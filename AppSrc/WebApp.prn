Compiling Program: Z:\VmShare\Projects\WebQuery18-0\AppSrc\WebApp.src
Memory Available: 2147483647
1>Use AllWebAppClasses.pkg
Using pre-compiled package ALLWEBAPPCLASSES.PKG
Including file: AllWebAppClasses.pkd    (E:\Program Files\DataFlex 18.0\Pkg\AllWebAppClasses.pkd)
25170>Use cWebMenuItemLoadView.pkg
25170>Use cWqWebApp.pkg
Including file: cWqWebApp.pkg    (Z:\VmShare\Projects\WebQuery18-0\AppSrc\cWqWebApp.pkg)
25170>>>Use cWebApp.pkg
25170>>>
25170>>>Define C_nwMenuBar    for "menubar"
25170>>>Define C_nwScrollBars for "scrollbars"
25170>>>Define C_nwStatusBar  for "status"
25170>>>Define C_nwTitleBar   for "titlebar"
25170>>>Define C_nwToolBar    for "toolbar"
25170>>>Define C_nwResizable  for "resizable"
25170>>>
25170>>>Class cWqWebApp is a cWebApp
25171>>>    
25171>>>    Procedure Construct_Object
25173>>>        Forward Send Construct_Object
25175>>>        
25175>>>        Property String[] pasNewWindowOptions
25176>>>    End_Procedure
25177>>>    
25177>>>    Procedure Set NewWindowOption String sOption Boolean bOn
25179>>>        String[] asOpts
25180>>>        Integer  i iPos
25180>>>        
25180>>>        Get pasNewWindowOptions to asOpts
25181>>>        Move (SizeOfArray(asOpts)) to iPos
25182>>>        
25182>>>        For i from 0 to (SizeOfArray(asOpts) - 1)
25188>>>>
25188>>>            If (Left(asOpts[i], (Pos("=", asOpts[i]) - 1)) = sOption) Move i to iPos
25191>>>        Loop
25192>>>>
25192>>>        
25192>>>        Move (sOption + "=" + If(bOn, "yes", "no")) to asOpts[iPos]
25193>>>        Set pasNewWindowOptions to asOpts
25194>>>    End_Procedure
25195>>>    
25195>>>    Procedure ClearWindowOptions
25197>>>        String[] asEmpty
25198>>>        
25198>>>        Set pasNewWindowOptions to asEmpty
25199>>>    End_Procedure
25200>>>    
25200>>>    Procedure NavigateNewWindow String sUrl Integer iWidth Integer iHeight
25202>>>        String[] aParams asOpts
25204>>>        String   sOpts
25204>>>        Integer  i
25204>>>        
25204>>>        Move sURL               to aParams[0]
25205>>>        Move iWidth             to aParams[1]
25206>>>        Move iHeight            to aParams[2]
25207>>>        
25207>>>        Get pasNewWindowOptions to asOpts
25208>>>        
25208>>>        For i from 0 to (SizeOfArray(asOpts) - 1)
25214>>>>
25214>>>            Move (sOpts + ", " + asOpts[i]) to sOpts
25215>>>        Loop
25216>>>>
25216>>>        
25216>>>        Move sOpts              to aParams[3]
25217>>>        
25217>>>        Send ClientAction "navigateNewWindow" aParams
25218>>>    End_Procedure
25219>>>    
25219>>>End_Class
25220>Use cWebQueryMenuItem.pkg
Including file: cWebQueryMenuItem.pkg    (Z:\VmShare\Projects\WebQuery18-0\AppSrc\cWebQueryMenuItem.pkg)
25220>>>// Class: cWebMenuItem
25220>>>//
25220>>>// It just causes a "Wait" dialog to appear when the item is clicked to avoid
25220>>>// having to create a trivial OnLoad procedure on every menu item that is going
25220>>>// to run a report.
25220>>>//
25220>>>// Can be used for things other than WebQuery reports.
25220>>>
25220>>>Use cWebMenuItem.pkg
25220>>>
25220>>>Class cWebQueryMenuItem is a cWebMenuItem
25221>>>    
25221>>>    Procedure OnLoad
25223>>>        Forward Send OnLoad
25225>>>        
25225>>>        Send SetActionMode (RefProc(OnClick)) scModeProgress "Processing report - please wait...."
25226>>>    End_Procedure
25227>>>
25227>>>End_Class
25228>
25228>Register_Function PublicPath   Returns String
25228>Register_Function piUserRights Returns Integer
25228>
25228>Object oApplication is a cApplication
25230>End_Object
25231>
25231>Object oWebApp is a cWqWebApp
25233>    Set psTheme to "Df_Web_Creme"
25234>    Set peLoginMode to lmLoginSupported
25235>    Set psDateFormat to "dd/mm/yyyy"
25236>    
25236>    Object oCommandbar is a cWebCommandBar
25238>        
25238>        Procedure OnLoad
25241>            Broadcast Recursive Send OnChangeRights
25243>        End_Procedure
25244>                        
25244>        Object oMenuBar is a cWebMenuBar
25246>            Object oFileMenu is a cWebMenuItem
25248>                Set psCaption to C_$File
25249>                
25249>                Object oClearMenuItem is a cWebMenuClear
25251>                End_Object  
25252>                             
25252>                Object oClearAllMenuItem is a cWebMenuClearAll
25254>                End_Object  
25255>                
25255>                Object oPromptMenuItem is a cWebMenuPrompt
25257>                    Set pbBeginGroup to True
25258>                End_Object  
25259>                               
25259>                Object oFindMenuItem is a cWebMenuFind
25261>                End_Object  
25262>
25262>                Object oNextMenuItem is a cWebMenuFindNext
25264>                End_Object  
25265>
25265>                Object oPreviousMenuItem is a cWebMenuFindPrevious
25267>                End_Object  
25268>                
25268>                Object oLastMenuItem is a cWebMenuFindLast
25270>                End_Object                
25271>                                
25271>                Object oFirstMenuItem is a cWebMenuFindFirst
25273>                End_Object  
25274>                
25274>                Object oSaveMenuItem is a cWebMenuSave
25276>                    Set pbBeginGroup to True
25277>                End_Object  
25278>                
25278>                Object oDeleteMenuItem is a cWebMenuDelete
25280>                End_Object  
25281>                
25281>                Object oLoginMenuItem is a cWebMenuItem
25283>                    Set psCaption to C_$LogIn
25284>                    Set pbBeginGroup to True
25285>                    Set psCSSClass to "WebLoginMenuItem"
25286>
25286>                    Procedure OnClick
25289>                        Send RequestLogin to ghoWebSessionManager
25290>                    End_Procedure
25291>                    
25291>                    Procedure OnLoad
25294>                        Integer eLoginMode
25294>                        Handle hoLogin
25294>                        Get phoLoginView to hoLogin
25295>                        Get peLoginMode to eLoginMode
25296>                        WebSet pbRender to  (hoLogin and eLoginMode<>lmLoginNone)
25297>                    End_Procedure  // OnLoad
25298>                    
25298>                End_Object  
25299>
25299>                Object oLogoutMenuItem is a cWebMenuItem
25301>                    Set psCaption to C_$LogOut
25302>                    Set psCSSClass to "WebLogoutMenuItem"
25303>
25303>                    Procedure OnClick
25306>                        Send RequestLogOut of ghoWebSessionManager
25307>                    End_Procedure
25308>
25308>                    Procedure OnLoad
25311>                        Integer eLoginMode
25311>                        Handle hoLogin
25311>                        Get phoLoginView to hoLogin
25312>                        Get peLoginMode to eLoginMode
25313>                        WebSet pbRender to  (hoLogin and eLoginMode<>lmLoginNone)
25314>                    End_Procedure
25315>                End_Object  
25316>            End_Object  
25317>    
25317>            Object oViewMenu is a cWebMenuItem
25319>                Set psCaption to C_$View
25320>
25320>                Object oIntroviewMenuItem1 is a cWebMenuItemLoadView
25322>                    Set psCaption to "Introduction"
25323>                    Set psLoadViewOnClick to "oIntroduction"
25324>                    Set psImage to "Images/Information.png"
25325>                End_Object
25326>                
25326>                Object oWebQueryDefinitionMenuItem1 is a cWebMenuItemLoadView
25328>                    Set psCaption to "WebQuery Definition"
25329>                    Set psLoadViewOnClick to "oWebQuery"
25330>                    Set psImage to "Custom/report.png"
25331>                    
25331>                    Procedure OnChangeRights
25334>                        WebSet pbEnabled to (IsLoggedIn(ghoWebSessionManager))
25335>                    End_Procedure
25336>                    
25336>                End_Object
25337>
25337>            End_Object  
25338>            
25338>            Object oReportMenu is a cWebMenuItem
25340>                Set psCaption to "Reports"
25341>                
25341>                Object oUsersListReport is a cWebQueryMenuItem
25343>                    Set psCaption to "Users List (new tab)"
25344>                    Set psImage to "Custom/report.png"
25345>                    
25345>                    Procedure OnClick
25348>                        Send LoadAndRun of oWebQuery (PublicPath(oWebQuery(Self)) + "\Users List.wqr")
25349>                    End_Procedure
25350>                    
25350>                End_Object
25351>                
25351>                Object oCustomerListReport is a cWebQueryMenuItem
25353>                    Set psCaption to "Customer List (download)"
25354>                    Set psImage to "Custom/report.png"
25355>                    
25355>                    Procedure OnClick
25358>                        Send LoadAndRun of oWebQuery (PublicPath(oWebQuery(Self)) + "\Customer List.wqr")
25359>                    End_Procedure
25360>                    
25360>                End_Object
25361>                
25361>                Object oSalesPListReport is a cWebQueryMenuItem
25363>                    Set psCaption to "Sales Person List (popup)"
25364>                    Set psImage to "Custom/report.png"
25365>                    
25365>                    Procedure OnClick
25368>                        Send LoadAndRun of oWebQuery (PublicPath(oWebQuery(Self)) + "\Sales People.wqr")
25369>                    End_Procedure
25370>                    
25370>                    Procedure OnChangeRights
25373>                        WebSet pbRender to (IsLoggedIn(ghoWebSessionManager) and ;                                            (piUserRights(ghoWebSessionManager) > 1))
25374>                    End_Procedure
25375>                    
25375>                End_Object
25376>                
25376>                Object oSalesPPictures is a cWebQueryMenuItem
25378>                    Set psCaption to "Sales Person Pictures"
25379>                    Set psImage to "Custom/report.png"
25380>                    
25380>                    Procedure OnClick
25383>                        Send LoadAndRun of oWebQuery (PublicPath(oWebQuery(Self)) + "\Sales People Pictures.wqr")
25384>                    End_Procedure
25385>                    
25385>                    Procedure OnChangeRights
25388>                        WebSet pbRender to (IsLoggedIn(ghoWebSessionManager))
25389>                    End_Procedure
25390>                    
25390>                End_Object
25391>                
25391>                Object oOrderDetsRep is a cWebQueryMenuItem
25393>                    Set psCaption to "Order Details 2012 (slow)"
25394>                    Set psImage to "Custom/report.png"
25395>                    
25395>                    Procedure OnClick
25398>                        Send LoadAndRun of oWebQuery (PublicPath(oWebQuery(Self)) + "\Order Details Report (2012).wqr")
25399>                    End_Procedure
25400>                    
25400>                    Procedure OnChangeRights
25403>                        WebSet pbRender to (IsLoggedIn(ghoWebSessionManager) and ;                                            (piUserRights(ghoWebSessionManager) > 2))
25404>                    End_Procedure
25405>                                        
25405>                End_Object
25406>                
25406>                Object oVendorList is a cWebQueryMenuItem
25408>                    Set psCaption  to "Vendor list with image"
25409>                    Set psImage to "Custom/report.png"
25410>                    
25410>                    Procedure OnClick
25413>                        Send LoadAndRun of oWebQuery (PublicPath(oWebQuery(Self)) + "\Vendor List with Image.wqr")
25414>                    End_Procedure
25415>                    
25415>                    Procedure OnChangeRights
25418>                        WebSet pbRender to (IsLoggedIn(ghoWebSessionManager))
25419>                    End_Procedure
25420>                    
25420>                End_Object
25421>                
25421>                Object oSalesReports is a cWebMenuItem
25423>                    Set pbBeginGroup to True
25424>                    Set psCaption to "Sales Reports"
25425>
25425>                    Procedure OnChangeRights
25428>                        WebSet pbRender to (IsLoggedIn(ghoWebSessionManager) and ;                                            (piUserRights(ghoWebSessionManager) > 2))
25429>                    End_Procedure
25430>                    
25430>                    Object oSalesTotals is a cWebQueryMenuItem
25432>                        Set psCaption to "Sales Totals"
25433>                        Set psImage to "Custom/report.png"
25434>                        
25434>                        Procedure OnClick
25437>                            Send LoadAndRun of oWebQuery (PublicPath(oWebQuery(Self)) + "\Sales Totals.wqr")
25438>                        End_Procedure
25439>                        
25439>                    End_Object
25440>                    
25440>                    Object oSales2012 is a cWebQueryMenuItem
25442>                        Set psCaption to "Sales in 2012"
25443>                        Set psImage to "Custom/report.png"
25444>                        
25444>                        Procedure OnClick
25447>                            Send LoadAndRun of oWebQuery (PublicPath(oWebQuery(Self)) + "\Sales in 2012.wqr")
25448>                        End_Procedure
25449>                        
25449>                    End_Object
25450>                    
25450>                End_Object
25451>
25451>                Object oStockReports is a cWebMenuItem
25453>                    Set psCaption to "Stock Reports"
25454>                    
25454>                    Procedure OnChangeRights
25457>                        WebSet pbRender to (IsLoggedIn(ghoWebSessionManager))
25458>                    End_Procedure
25459>                    
25459>                    Object oStockList is a cWebQueryMenuItem
25461>                        Set psCaption to "Stock List (text)"
25462>                        Set psImage to "Custom/report.png"
25463>                        
25463>                        Procedure OnClick
25466>                            Send LoadAndRun of oWebQuery (PublicPath(oWebQuery(Self)) + "\Stock List.wqr")
25467>                        End_Procedure
25468>                        
25468>                    End_Object
25469>                    
25469>                    Object oReorderListV is a cWebQueryMenuItem
25471>                        Set psCaption to "Reorder List (view)"
25472>                        Set psImage to "Custom/report.png"
25473>                        
25473>                        Procedure OnClick
25476>                            Send LoadAndRun of oWebQuery (PublicPath(oWebQuery(Self)) + "\Reorder List (view).wqr")
25477>                        End_Procedure
25478>                        
25478>                    End_Object
25479>                    
25479>                    Object oReorderListT is a cWebQueryMenuItem
25481>                        Set psCaption to "Reorder List (text)"
25482>                        Set psImage to "Custom/report.png"
25483>                        
25483>                        Procedure OnClick
25486>                            Send LoadAndRun of oWebQuery (PublicPath(oWebQuery(Self)) + "\Reorder List (text).wqr")
25487>                        End_Procedure
25488>                        
25488>                    End_Object
25489>                    
25489>                    Object oReorderListX is a cWebQueryMenuItem
25491>                        Set psCaption to "Reorder List (XML)"
25492>                        Set psImage to "Custom/report.png"
25493>                        
25493>                        Procedure OnClick
25496>                            Send LoadAndRun of oWebQuery (PublicPath(oWebQuery(Self)) + "\Reorder List (XML).wqr")
25497>                        End_Procedure
25498>                        
25498>                    End_Object
25499>                    
25499>                End_Object
25500>                
25500>                Object oAccoutReports is a cWebMenuItem
25502>                    Set psCaption to "Account Reports"
25503>
25503>                    Procedure OnChangeRights
25506>                        WebSet pbRender to (IsLoggedIn(ghoWebSessionManager) and ;                                            (piUserRights(ghoWebSessionManager) > 3))
25507>                    End_Procedure
25508>                    
25508>                    Object oLargeBalances is a cWebQueryMenuItem
25510>                        Set psCaption to "Large Balances"
25511>                        Set psImage to "Custom/report.png"
25512>                        
25512>                        Procedure OnClick
25515>                            Send LoadAndRun of oWebQuery (PublicPath(oWebQuery(Self)) + "\Large Balances.wqr")
25516>                        End_Procedure
25517>                        
25517>                    End_Object
25518>                    
25518>                    Object oOverCredit is a cWebQueryMenuItem
25520>                        Set psCaption to "Over Credit Limit (hidden!)"
25521>                        Set psImage to "Custom/report.png"
25522>                        
25522>                        Procedure OnClick
25525>                            Send LoadAndRun of oWebQuery (PublicPath(oWebQuery(Self)) + "\..\Over Credit Limit.wqr")
25526>                        End_Procedure
25527>                        
25527>                        Procedure OnChangeRights
25530>                            WebSet pbRender to (IsLoggedIn(ghoWebSessionManager) and ;                                                (piUserRights(ghoWebSessionManager) > 4))
25531>                        End_Procedure
25532>                    
25532>                    End_Object
25533>                    
25533>                    Object oBestCustomers is a cWebQueryMenuItem
25535>                        Set psCaption to "Best Customers (new tab)"
25536>                        Set psImage to "Custom/report.png"
25537>                        
25537>                        Procedure OnClick
25540>                            Send LoadAndRun of oWebQuery (PublicPath(oWebQuery(Self)) + "\Best Customers.wqr")
25541>                        End_Procedure
25542>                        
25542>                    End_Object
25543>                    
25543>                    Object oBalancesCSV is a cWebQueryMenuItem
25545>                        Set psCaption to "Balances CSV Download"
25546>                        Set psImage to "Custom/report.png"
25547>                        
25547>                        Procedure OnClick
25550>                            Send LoadAndRun of oWebQuery (PublicPath(oWebQuery(Self)) + "\Balances CSV Download.wqr")
25551>                        End_Procedure
25552>                        
25552>                    End_Object
25553>                    
25553>                End_Object
25554>                
25554>            End_Object            
25555>            
25555>            Object oThemesMenu is a cWebMenuItem
25557>                Set psCaption to "Themes"
25558>
25558>                Object oModernSky is a cWebMenuItem
25560>                    Set psCaption to "Modern Sky"
25561>                    
25561>                    Procedure OnClick 
25564>                        //  Change the theme at runtime
25564>                        WebSet psTheme of oWebApp to "Df_Modern_Sky"
25565>                        
25565>                        //  Update menu
25565>                        Send UpdateSelectedTheme
25566>                    End_Procedure
25567>                End_Object
25568>                                    
25568>                Object oWindowsLike is a cWebMenuItem
25570>                    Set psCaption to "Windows Like"
25571>                    
25571>                    Procedure OnClick 
25574>                        //  Change the theme at runtime
25574>                        WebSet psTheme of oWebApp to "Df_Windows_Like"
25575>                        
25575>                        //  Update menu
25575>                        Send UpdateSelectedTheme
25576>                    End_Procedure
25577>                End_Object
25578>                                                
25578>                Object oHighContrast is a cWebMenuItem
25580>                    Set psCaption to "High Contrast"
25581>                    
25581>                    Procedure OnClick 
25584>                        //  Change the theme at runtime
25584>                        WebSet psTheme of oWebApp to "Df_High_Contrast"
25585>                        
25585>                        //  Update menu
25585>                        Send UpdateSelectedTheme
25586>                    End_Procedure
25587>                End_Object
25588>                
25588>                Object oWebCremeItem is a cWebMenuItem
25590>                    Set psCaption to "Web Creme"
25591>                    Set pbEnabled to False
25592>                    
25592>                    Procedure OnClick
25595>                        //   Change the theme at runtime
25595>                        WebSet psTheme of oWebApp to "Df_Web_Creme"
25596>                        
25596>                        //  Update menu
25596>                        Send UpdateSelectedTheme
25597>                    End_Procedure
25598>                End_Object
25599>                
25599>                Procedure UpdateSelectedTheme
25602>                    String sTheme
25602>                    
25602>                    //  Determine theme
25602>                    WebGet psTheme of oWebApp to sTheme
25603>
25603>                    //  Set enabled state
25603>                    WebSet pbEnabled of (oModernSky)    to (sTheme <> "Df_Modern_Sky")
25604>                    WebSet pbEnabled of (oWindowsLike)  to (sTheme <> "Df_Windows_Like")
25605>                    WebSet pbEnabled of (oHighContrast) to (sTheme <> "Df_High_Contrast")
25606>                    WebSet pbEnabled of (oWebCremeItem) to (sTheme <> "Df_Web_Creme")
25607>                End_Procedure
25608>                
25608>                Procedure OnLoad
25611>                    Send UpdateSelectedTheme
25612>                End_Procedure
25613>                
25613>            End_Object
25614>            
25614>        End_Object  
25615>        
25615>        Object oFindToolBar is a cWebToolBar
25617>            Object oFirstMenuItem is a cWebMenuFindFirst
25619>            End_Object  
25620>    
25620>            Object oPreviousMenuItem is a cWebMenuFindPrevious
25622>            End_Object  
25623>
25623>            Object oFindMenuItem is a cWebMenuFind
25625>            End_Object  
25626>
25626>            Object oNextMenuItem is a cWebMenuFindNext
25628>            End_Object  
25629>            
25629>            Object oLastMenuItem is a cWebMenuFindLast
25631>            End_Object
25632>                           
25632>            Object oPromptMenuItem is a cWebMenuPrompt
25634>            End_Object 
25635>        End_Object
25636>        
25636>        Object oFileToolBar is a cWebToolBar
25638>            Set pbShowCaption to True
25639>            
25639>            Object oClearMenuItem is a cWebMenuClear
25641>            End_Object              
25642>             
25642>            Object oClearAllMenuItem is a cWebMenuClearAll
25644>            End_Object   
25645>                        
25645>            Object oSaveMenuItem is a cWebMenuSave
25647>            End_Object  
25648>            
25648>            Object oDeleteMenuItem is a cWebMenuDelete
25650>            End_Object 
25651>        End_Object
25652>    End_Object
25653>
25653>    Use SessionManager.wo
Including file: SessionManager.wo    (Z:\VmShare\Projects\WebQuery18-0\AppSrc\SessionManager.wo)
25653>>>Use cWebSessionManagerStandard.pkg
Including file: cWebSessionManagerStandard.pkg    (E:\Program Files\DataFlex 18.0\Pkg\cWebSessionManagerStandard.pkg)
25653>>>>>Use cWebSessionManager.pkg
25653>>>>>Use cWebAppSessionDataDictionary.dd
Including file: cWebAppSessionDataDictionary.dd    (E:\Program Files\DataFlex 18.0\Pkg\cWebAppSessionDataDictionary.dd)
25653>>>>>>>Use DataDict.pkg
25653>>>>>>>
25653>>>>>>>Open WebAppSession
Including file: WebAppSession.fd    (Z:\VmShare\Projects\WebQuery18-0\DDSrc\WebAppSession.fd)
25655>>>>>>>Open WebAppUser
Including file: WebAppUser.fd    (Z:\VmShare\Projects\WebQuery18-0\DDSrc\WebAppUser.fd)
25657>>>>>>>
25657>>>>>>>Class cWebAppSessionDataDictionary is a DataDictionary
25658>>>>>>>    
25658>>>>>>>    Procedure Construct_Object
25660>>>>>>>        Forward Send Construct_Object
25662>>>>>>>        Set Main_File to WebAppSession.File_Number
25663>>>>>>>
25663>>>>>>>        Set Add_Server_File to WebAppUser.File_Number
25664>>>>>>>
25664>>>>>>>        Set ParentNullAllowed WebAppUser.File_Number to True
25665>>>>>>>
25665>>>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_NOPUT to True
25666>>>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
25667>>>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
25668>>>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
25669>>>>>>>
25669>>>>>>>        Set Field_Option Field WebAppSession.Active DD_RETAIN to True
25670>>>>>>>        Set Field_Checkbox_Values Field WebAppSession.Active to "Y" "N"
25671>>>>>>>        Set Field_Error Field WebAppSession.Active to 500 "Invalid WebAppSession Active State"
25672>>>>>>>
25672>>>>>>>    End_Procedure
25673>>>>>>>
25673>>>>>>>    Procedure Creating
25675>>>>>>>        DateTime dtCurrentDateTime
25675>>>>>>>        
25675>>>>>>>        Forward Send Creating
25677>>>>>>>        
25677>>>>>>>        //  Init usecounter
25677>>>>>>>        Move 0 to WebAppSession.UseCount
25678>>>>>>>        
25678>>>>>>>        //  Set the creation and access time to the current time
25678>>>>>>>        Move (CurrentDateTime()) to dtCurrentDateTime
25679>>>>>>>    
25679>>>>>>>        Get TimeToString dtCurrentDateTime to WebAppSession.CreateTime
25680>>>>>>>        Get TimeToString dtCurrentDateTime to WebAppSession.LastAccessTime
25681>>>>>>>        
25681>>>>>>>        Move dtCurrentDateTime to WebAppSession.CreateDate
25682>>>>>>>        Move dtCurrentDateTime to WebAppSession.LastAccessDate
25683>>>>>>>    End_Procedure
25684>>>>>>>    
25684>>>>>>>    
25684>>>>>>>    
25684>>>>>>>    //
25684>>>>>>>    //  Converts the given time to an string that can be saved in the database.
25684>>>>>>>    //
25684>>>>>>>    //  Params:
25684>>>>>>>    //      dtTime  Time to convert
25684>>>>>>>    //  Returns:
25684>>>>>>>    //      String with "HH:MM:SS" format
25684>>>>>>>    //
25684>>>>>>>    Function TimeToString DateTime dtTime Returns String
25686>>>>>>>        String sHours sMinutes sSeconds
25686>>>>>>>        
25686>>>>>>>        //  Extract parts
25686>>>>>>>        Move (String(DateGetHour(dtTime))) to sHours
25687>>>>>>>        Move (String(DateGetMinute(dtTime))) to sMinutes
25688>>>>>>>        Move (String(DateGetSecond(dtTime))) to sSeconds
25689>>>>>>>        
25689>>>>>>>        //  Fill out with 0
25689>>>>>>>        If (Length(sHours) = 1) Move ("0" + sHours) to sHours
25692>>>>>>>        If (Length(sMinutes) = 1) Move ("0" + sMinutes) to sMinutes
25695>>>>>>>        If (Length(sSeconds) = 1) Move ("0" + sSeconds) to sSeconds
25698>>>>>>>        
25698>>>>>>>        Function_Return (sHours + ":" + sMinutes + ":" + sSeconds)
25699>>>>>>>    End_Function
25700>>>>>>>    
25700>>>>>>>    //
25700>>>>>>>    //  Sets the time of the datetime variable to the time in the string.
25700>>>>>>>    //
25700>>>>>>>    //  Params:
25700>>>>>>>    //      dtTime  Datetime variable to add time to
25700>>>>>>>    //      sTimeString String with time in the format "HH:MM:SS"
25700>>>>>>>    //  Returns:
25700>>>>>>>    //      dtDateTime with the loaded time
25700>>>>>>>    //
25700>>>>>>>    Function StringToTime DateTime dtTime String sTimeString Returns DateTime
25702>>>>>>>        String sHours sMinutes sSeconds
25702>>>>>>>        
25702>>>>>>>        //  Extract parts
25702>>>>>>>        Move (Mid(sTimeString, 2, 1)) to sHours
25703>>>>>>>        Move (Mid(sTimeString, 2, 4)) to sMinutes
25704>>>>>>>        Move (Mid(sTimeString, 2, 7)) to sSeconds
25705>>>>>>>        
25705>>>>>>>        //  Set to DateTime
25705>>>>>>>        Move (DateSetHour(dtTime, (Integer(sHours)))) to dtTime
25706>>>>>>>        Move (DateSetMinute(dtTime, (Integer(sMinutes)))) to dtTime
25707>>>>>>>        Move (DateSetSecond(dtTime, (Integer(sSeconds)))) to dtTime
25708>>>>>>>        
25708>>>>>>>        Function_Return dtTime
25709>>>>>>>    End_Function
25710>>>>>>>
25710>>>>>>>End_Class
25711>>>>>Use cWebAppUserDataDictionary.dd
Including file: cWebAppUserDataDictionary.dd    (E:\Program Files\DataFlex 18.0\Pkg\cWebAppUserDataDictionary.dd)
25711>>>>>>>Use DataDict.pkg
25711>>>>>>>Open WebAppUser
25713>>>>>>>Open WebAppSession
25715>>>>>>>
25715>>>>>>>Class cWebAppUserDataDictionary is a DataDictionary
25716>>>>>>>    
25716>>>>>>>    Procedure Construct_Object
25718>>>>>>>        Forward Send Construct_Object
25720>>>>>>>        Set Main_File to WebAppUser.File_Number
25721>>>>>>>
25721>>>>>>>        Set Add_Client_File to WebAppSession.File_Number
25722>>>>>>>
25722>>>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_NOPUT to True
25723>>>>>>>        Set Foreign_Field_Option DD_KEYFIELD DD_FINDREQ to True
25724>>>>>>>        Set Foreign_Field_Option DD_INDEXFIELD DD_NOPUT to True
25725>>>>>>>        Set Foreign_Field_Option DD_DEFAULT DD_DISPLAYONLY to True
25726>>>>>>>    End_Procedure
25727>>>>>>>
25727>>>>>>>End_Class
25728>>>>>
25728>>>>>Class cWebSessionManagerStandard is a cWebSessionManager
25729>>>>>    
25729>>>>>    Procedure Construct_Object
25731>>>>>        Handle hoUserDD hoSessionDD
25731>>>>>        
25731>>>>>        Forward Send Construct_Object
25733>>>>>        
25733>>>>>        Property Handle phoUserDD 0      // Handle to the WebAppUser DDO
25734>>>>>        Property Handle phoSessionDD 0   // Handle to the WebAppSession DDO        
25735>>>>>        
25735>>>>>        Get Create (RefClass(cWebAppUserDataDictionary)) to hoUserDD
25736>>>>>        Get Create (RefClass(cWebAppSessionDataDictionary)) to hoSessionDD
25737>>>>>        Set DDO_Server of hoSessionDD to hoUserDD
25738>>>>>
25738>>>>>        Set phoUserDD to hoUserDD
25739>>>>>        Set phoSessionDD to hoSessionDD
25740>>>>>        Property Boolean pbCreatingNewSession False
25741>>>>>        Property Integer piSessionTimeout 480        
25742>>>>>        Property String psLoginName
25743>>>>>        Property String psUserName ""
25744>>>>>        Property Integer piUserRights 0
25745>>>>>    End_Procedure
25746>>>>>    
25746>>>>>    Function CreateSession String sRemoteAddress Returns String
25748>>>>>        String sSessionKey
25748>>>>>        Integer iErr
25748>>>>>        Boolean bLogWebSession
25748>>>>>        Handle hoSessionDD       
25748>>>>>        Get phoSessionDD to hoSessionDD
25749>>>>>        
25749>>>>>        //  Get session key
25749>>>>>        Forward Get CreateSession sRemoteAddress to sSessionKey
25751>>>>>        
25751>>>>>        Get pbLogWebSession to bLogWebSession
25752>>>>>        If not bLogWebSession Begin
25754>>>>>            Function_Return sSessionKey        
25755>>>>>        End
25755>>>>>>
25755>>>>>
25755>>>>>        //  Store session
25755>>>>>        Send Clear of hoSessionDD
25756>>>>>        Set Field_Changed_Value of hoSessionDD Field WebAppSession.SessionKey to sSessionKey
25757>>>>>        Set Field_Changed_Value of hoSessionDD Field WebAppSession.RemoteAddress to sRemoteAddress
25758>>>>>        Set Field_Changed_Value of hoSessionDD Field WebAppSession.Active to "Y"
25759>>>>>        Get Request_Validate of hoSessionDD to iErr
25760>>>>>        If (iErr) Begin
25762>>>>>            // this should not happen. If it does its a programming error
25762>>>>>            Error DFERR_PROGRAM C_$WebAppSesionValidateFailed
25763>>>>>>
25763>>>>>            Function_Return ""
25764>>>>>        End
25764>>>>>>
25764>>>>>        Send Request_Save of hoSessionDD
25765>>>>>       
25765>>>>>        Function_Return sSessionKey        
25766>>>>>    End_Function
25767>>>>>    
25767>>>>>    
25767>>>>>    Function ValidateSession String sSessionKey Returns Boolean
25769>>>>>        DateTime dtLastAccess dtCurrent
25769>>>>>        TimeSpan tsDiff
25769>>>>>        Integer iErr iSessionTimeout iSpanMinutes
25769>>>>>        Boolean bResult bCreatingNewSession
25769>>>>>        Boolean bLogWebSession 
25769>>>>>        Integer eLoginMode
25769>>>>>        String sTime
25769>>>>>        Handle hoSessionDD hoUserDD       
25769>>>>>        
25769>>>>>        Get phoSessionDD to hoSessionDD
25770>>>>>        Get phoUserDD to hoUserDD
25771>>>>>        
25771>>>>>        Get pbLogWebSession to bLogWebSession
25772>>>>>        Get peLoginMode to eLoginMode
25773>>>>>        
25773>>>>>        // for this object, you can only disable logging if login completely is disabled
25773>>>>>        If (not(bLogWebSession) and (eLoginMode<>lmLoginNone)) Begin
25775>>>>>            Error DFERR_PROGRAM C_$WebSessionLoggingMustBeEnabled
25776>>>>>>
25776>>>>>            Function_Return False
25777>>>>>        End
25777>>>>>>
25777>>>>>
25777>>>>>        //  Clear session properties
25777>>>>>        Set psUsername to ""
25778>>>>>        Set psLoginName to ""
25779>>>>>        Set piUserrights to 0
25780>>>>>        
25780>>>>>        If not bLogWebSession Begin
25782>>>>>            Forward Get ValidateSession sSessionKey to bResult
25784>>>>>            Function_Return bResult
25785>>>>>        End        
25785>>>>>>
25785>>>>>        
25785>>>>>        Move False to bResult
25786>>>>>        Get piSessionTimeout to iSessionTimeout 
25787>>>>>        
25787>>>>>        //  Check if session exists
25787>>>>>        Send Clear of hoSessionDD
25788>>>>>        Move sSessionKey to WebAppSession.SessionKey
25789>>>>>        Send Find of hoSessionDD EQ Index.1
25790>>>>>            
25790>>>>>        If (Found) Begin
25792>>>>>            //  Calculate timespan between now and last access time
25792>>>>>            Move (CurrentDateTime()) to dtCurrent
25793>>>>>            Move WebAppSession.LastAccessDate to dtLastAccess
25794>>>>>            Get StringToTime of hoSessionDD dtLastAccess WebAppSession.LastAccessTime to dtLastAccess
25795>>>>>            Move (dtCurrent - dtLastAccess) to tsDiff
25796>>>>>            Move (SpanTotalMinutes(tsDiff)) to iSpanMinutes
25797>>>>>            
25797>>>>>            //  Check if session didn't time out
25797>>>>>            If ((iSessionTimeout <= 0 or (iSpanMinutes < iSessionTimeout)) and WebAppSession.Active = "Y") Begin
25799>>>>>                Forward Get ValidateSession sSessionKey to bResult
25801>>>>>                   
25801>>>>>                If (bResult) Begin
25803>>>>>                    //  Update session record
25803>>>>>                    Get TimeToString of hoSessionDD dtCurrent to sTime 
25804>>>>>                    Set Field_Changed_Value of hoSessionDD Field WebAppSession.LastAccessDate to dtCurrent
25805>>>>>                    Set Field_Changed_Value of hoSessionDD Field WebAppSession.LastAccessTime to sTime
25806>>>>>                    Set Field_Changed_Value of hoSessionDD Field WebAppSession.UseCount to (WebAppSession.UseCount + 1)
25807>>>>>                    Get Request_Validate of hoSessionDD to iErr
25808>>>>>                    If (iErr) Begin
25810>>>>>                        // this should not happen. If it does its a programming error
25810>>>>>                        Error DFERR_PROGRAM C_$WebAppSesionValidateFailed
25811>>>>>>
25811>>>>>                        Function_Return False
25812>>>>>                    End
25812>>>>>>
25812>>>>>                    Send Request_Save of hoSessionDD
25813>>>>>                    
25813>>>>>                    //  Update user properties
25813>>>>>                    If (HasRecord(hoUserDD)) Begin
25815>>>>>                        Set psUsername to WebAppUser.FullName
25816>>>>>                        Set psLoginName to WebAppUser.LoginName
25817>>>>>                        Set piUserRights to WebAppUser.Rights
25818>>>>>                    End
25818>>>>>>
25818>>>>>                End
25818>>>>>>
25818>>>>>            End
25818>>>>>>
25818>>>>>            Else Begin
25819>>>>>                // Test the Creating New Session Flag to protect against infinite recursion....
25819>>>>>                Get pbCreatingNewSession to bCreatingNewSession
25820>>>>>                
25820>>>>>                If (not(bCreatingNewSession)) Begin
25822>>>>>                    Set pbCreatingNewSession to True                    
25823>>>>>                    Send RecreateSession to ghoWebApp
25824>>>>>                    Error 950 "Your application session has timed out or is inactive, please login again."
25825>>>>>>
25825>>>>>                    Send NavigateRefresh of ghoWebApp          // refresh the WebApp at the client (triggers a login)
25826>>>>>                    Set pbCreatingNewSession to False
25827>>>>>                End
25827>>>>>>
25827>>>>>            End
25827>>>>>>
25827>>>>>        End
25827>>>>>>
25827>>>>>        Else Begin
25828>>>>>            Error 951 "Session key not known (reload page to recreate session)"
25829>>>>>>
25829>>>>>        End
25829>>>>>>
25829>>>>>        
25829>>>>>        Function_Return bResult
25830>>>>>    End_Function
25831>>>>>    
25831>>>>>    Function UserLogin String sLoginName String sPassword Returns Boolean
25833>>>>>        String sSessionKey sUserPassword
25833>>>>>        Handle hoSessionDD hoUserDD       
25833>>>>>        
25833>>>>>        Get phoSessionDD to hoSessionDD
25834>>>>>        Get phoUserDD to hoUserDD
25835>>>>>        Integer iErr eLoginMode
25835>>>>>        
25835>>>>>        // Refind session record
25835>>>>>        Get psSessionKey to sSessionKey
25836>>>>>        Send Clear of hoSessionDD
25837>>>>>        Move sSessionKey to WebAppSession.SessionKey
25838>>>>>        Send Find of hoSessionDD EQ Index.1
25839>>>>>        
25839>>>>>        If (Found and WebAppSession.SessionKey = sSessionKey) Begin
25841>>>>>            Get peLoginMode to eLoginMode
25842>>>>>            
25842>>>>>            // if login is not required, we will allow for a blank name and password, which gives you access to whatever
25842>>>>>            // your have access to with not being logged in. We consider this to be a success, even if you are not logged in.
25842>>>>>            If (eLoginMode <> lmLoginRequired and Trim(sLoginName) = "" and Trim(sPassword) = "") Begin
25844>>>>>                Set psUsername to ""
25845>>>>>                Set psLoginName to ""
25846>>>>>                Set piUserrights to 0
25847>>>>>                Send NotifyChangeRights
25848>>>>>                Function_Return True
25849>>>>>            End
25849>>>>>>
25849>>>>>            
25849>>>>>            //  Find the user
25849>>>>>            Move sLoginName to WebAppUser.LoginName
25850>>>>>            Send Find of hoUserDD EQ Index.1
25851>>>>>            
25851>>>>>            // Check username and password
25851>>>>>            Get Field_Current_Value of hoUserDD Field WebAppUser.Password to sUserPassword
25852>>>>>            
25852>>>>>            If (Found and (Lowercase(sLoginName) = Lowercase(Trim(WebAppUser.LoginName))) and Trim(sUserPassword) = Trim(sPassword)) Begin
25854>>>>>                // Store the login
25854>>>>>                Set Field_Changed_Value of hoUserDD Field WebAppUser.LastLogin to (CurrentDateTime())
25855>>>>>                Get Request_Validate of hoSessionDD to iErr
25856>>>>>                If (iErr) Begin
25858>>>>>                    // this should not happen. If it does its a programming error
25858>>>>>                    Error DFERR_PROGRAM C_$WebAppSesionValidateFailed
25859>>>>>>
25859>>>>>                    Function_Return False
25860>>>>>                End
25860>>>>>>
25860>>>>>                
25860>>>>>                Send Request_Save of hoSessionDD
25861>>>>>                
25861>>>>>                // Update session properties
25861>>>>>                Set psUsername to WebAppUser.FullName
25862>>>>>                Set psLoginName to WebAppUser.LoginName
25863>>>>>                Set piUserrights to WebAppUser.Rights
25864>>>>>                Send NotifyChangeRights
25865>>>>>                Function_Return True
25866>>>>>            End
25866>>>>>>
25866>>>>>        End
25866>>>>>>
25866>>>>>          
25866>>>>>        Function_Return False
25867>>>>>    End_Function
25868>>>>>    
25868>>>>>    Function IsLoggedIn Returns Boolean
25870>>>>>        String sLoginName
25870>>>>>        Boolean bLogWebSession bLoggedIn
25870>>>>>        
25870>>>>>        Get pbLogWebSession to bLogWebSession
25871>>>>>        If not bLogWebSession Begin
25873>>>>>            Forward Get IsLoggedIn to bLoggedIn
25875>>>>>            Function_Return bLoggedIn
25876>>>>>        End
25876>>>>>>
25876>>>>>        
25876>>>>>        Get psLoginName to sLoginName
25877>>>>>        
25877>>>>>        Function_Return (sLoginName <> "")
25878>>>>>    End_Function
25879>>>>>    
25879>>>>>    
25879>>>>>    Procedure EndSession
25881>>>>>        Integer iErr
25881>>>>>        Boolean bLogWebSession
25881>>>>>        Handle hoSessionDD       
25881>>>>>        
25881>>>>>        Get phoSessionDD to hoSessionDD
25882>>>>>        Get pbLogWebSession to bLogWebSession
25883>>>>>        If not bLogWebSession Begin
25885>>>>>            Forward Send EndSession
25887>>>>>            Procedure_Return
25888>>>>>        End
25888>>>>>>
25888>>>>>            
25888>>>>>        //  Check if session exists
25888>>>>>        Send Clear of hoSessionDD
25889>>>>>        Get psSessionKey to WebAppSession.SessionKey
25890>>>>>        
25890>>>>>        Send Find of hoSessionDD EQ Index.1
25891>>>>>        If (Found) Begin
25893>>>>>            Set Field_Changed_Value of hoSessionDD Field WebAppSession.Active to "N"
25894>>>>>            Get Request_Validate of hoSessionDD to iErr
25895>>>>>            If (iErr) Begin
25897>>>>>                // this should not happen. If it does its a programming error
25897>>>>>                Error DFERR_PROGRAM C_$WebAppSesionValidateFailed
25898>>>>>>
25898>>>>>                Procedure_Return
25899>>>>>            End
25899>>>>>>
25899>>>>>            Send Request_Save of hoSessionDD
25900>>>>>        End
25900>>>>>>
25900>>>>>    End_Procedure
25901>>>>>
25901>>>>>End_Class
25902>>>>>
25902>>>
25902>>>Object oSessionManager is a cWebSessionManagerStandard
25904>>>End_Object
25905>>>
25905>    Use LoginDialog.wo
Including file: LoginDialog.wo    (Z:\VmShare\Projects\WebQuery18-0\AppSrc\LoginDialog.wo)
25905>>>Use cWebModalDialog.pkg
25905>>>Use cWebForm.pkg
25905>>>Use cWebButton.pkg
25905>>>Use cWebPanel.pkg
25905>>>Use cWebLabel.pkg
25905>>>
25905>>>Object oLoginDialog is a cWebModalDialog
25907>>>    Set piMinWidth to 370
25908>>>    Set piMinHeight to 220
25909>>>    Set psCaption to "Login"
25910>>>    Set pbShowClose to (peLoginMode(oWebApp) <> lmLoginRequired)
25911>>>    
25911>>>    Delegate Set phoLoginView to Self
25913>>>    
25913>>>    Object oTopPanel is a cWebPanel
25915>>>        Set peRegion to prTop
25916>>>        Set piHeight to 55       
25917>>>        
25917>>>        Object oDescription is a cWebLabel
25919>>>            Set psCaption to "Please enter your username and password to login."
25920>>>            Set peAlign to alignCenter
25921>>>        End_Object
25922>>>    End_Object
25923>>>    
25923>>>    Object oRightPanel is a cWebPanel
25925>>>        Set peRegion to prRight
25926>>>        Set piWidth to 20       
25927>>>    End_Object
25928>>>    
25928>>>    Object oMainPanel is a cWebPanel
25930>>>        Set peRegion to prCenter
25931>>>        
25931>>>        Object oLoginName is a cWebForm
25933>>>            Set psLabel to "Login Name:"
25934>>>            Set peLabelPosition to C_WebDefault
25935>>>            Set peLabelAlign to alignRight
25936>>>            Set piMaxLength to 20
25937>>>        End_Object
25938>>>        
25938>>>        Object oPassword is a cWebForm
25940>>>            Set psLabel to "Password:"
25941>>>            Set pbPassword to True
25942>>>            Set peLabelAlign to alignRight
25943>>>            Set piMaxLength to 20
25944>>>        End_Object   
25945>>>        
25945>>>        Object oWarning is a cWebLabel
25947>>>            Set pbVisible to False
25948>>>            Set psCaption to "Invalid loginname or password."
25949>>>            Set psCSSClass to "Warning"
25950>>>            Set peAlign to alignCenter
25951>>>        End_Object
25952>>>    End_Object
25953>>>    
25953>>>    Object oButtonPanel is a cWebPanel
25955>>>        Set peRegion to prBottom
25956>>>        Set piColumnCount to 3
25957>>>        Set piMinHeight to 40
25958>>>
25958>>>        Object oLoginButton is a cWebButton
25960>>>            Set pbShowLabel to False
25961>>>            Set piColumnIndex to 2
25962>>>            Set psCaption to "Login"
25963>>>            Set pbServerOnClick to True
25964>>>                        
25964>>>            Procedure OnClick
25967>>>                Send DoLogin
25968>>>            End_Procedure
25969>>>            
25969>>>        End_Object
25970>>>        
25970>>>    End_Object
25971>>>    
25971>>>    Procedure DoLogin
25974>>>        String sLoginName sPassword
25974>>>        Boolean bResult
25974>>>        Handle hoDefaultView
25974>>>        
25974>>>        WebGet psValue of oLoginName to sLoginName
25975>>>        WebGet psValue of oPassword to sPassword
25976>>>        
25976>>>        Get UserLogin of ghoWebSessionManager sLoginName sPassword to bResult
25977>>>        
25977>>>        If (bResult) Begin
25979>>>            Send Hide of oLoginDialog
25980>>>            Get phoDefaultView to hoDefaultView
25981>>>            If (hoDefaultView > 0) Begin
25983>>>                Send Show of hoDefaultView
25984>>>            End
25984>>>>
25984>>>            
25984>>>            // clear the login values. we don't want to return the login id & password as synchronized properties....
25984>>>            WebSet psValue of oLoginName to ""
25985>>>            WebSet psValue of oPassword  to ""
25986>>>            WebSet pbVisible of oWarning to False
25987>>>        End
25987>>>>
25987>>>        Else Begin
25988>>>            WebSet pbVisible of oWarning to True
25989>>>        End
25989>>>>
25989>>>    End_Procedure
25990>>>    
25990>>>    
25990>>>    Set pbServerOnSubmit to True
25991>>>    Procedure OnSubmit
25994>>>         Send DoLogin
25995>>>    End_Procedure
25996>>>End_Object
25997>    Use WebResourceManager.wo
Including file: WebResourceManager.wo    (Z:\VmShare\Projects\WebQuery18-0\AppSrc\WebResourceManager.wo)
25997>>>Use cWebResourceManager.pkg
25997>>>
25997>>>Object oWebResourceManager is a cWebResourceManager
25999>>>End_Object
26000>    Use Introduction.wo
Including file: Introduction.wo    (Z:\VmShare\Projects\WebQuery18-0\AppSrc\Introduction.wo)
26000>>>Use cWebView.pkg
26000>>>Use cWebPanel.pkg
26000>>>Use cWebForm.pkg 
26000>>>Use cWebHtmlBox.pkg
26000>>>Use cWebTabContainer.pkg
26000>>>Use cWebTabPage.pkg
26000>>>
26000>>>Register_Object oWebQuery
26000>>>
26000>>>Object oIntroduction is a cWebView
26002>>>    Set piWidth             to 800
26003>>>    Set psCaption           to "Introduction to WebQuery"
26004>>>    Set pbLoginModeEnforced to False
26005>>>    
26005>>>    Delegate Set phoDefaultView to Self
26007>>>
26007>>>    Object oWebMainPanel is a cWebPanel
26009>>>        Set pbFillHeight to True
26010>>>        
26010>>>        Object oWebTabContainer1 is a cWebTabContainer
26012>>>            
26012>>>            Object oIntroPage is a cWebTabPage
26014>>>                Set psCaption to "Introduction"
26015>>>                Set pbFillHeight to True
26016>>>                
26016>>>                Object oIntro is a cWebIFrame
26018>>>                    Set pbFillHeight to True
26019>>>                    Set psUrl to "WebQueryIntro.html"
26020>>>                End_Object
26021>>>                
26021>>>            End_Object
26022>>>            
26022>>>            Object oFeaturePage is a cWebTabPage
26024>>>                Set psCaption to "Features"
26025>>>                Set pbFillHeight to True
26026>>>                
26026>>>                Object oFeatures is a cWebIFrame
26028>>>                    Set pbFillHeight to True
26029>>>                    Set psUrl to "WebQueryfeatures.html"
26030>>>                End_Object
26031>>>                
26031>>>            End_Object
26032>>>            
26032>>>            Object oUsagePage is a cWebTabPage
26034>>>                Set psCaption to "Usage"
26035>>>                
26035>>>                Object oUsage is a cWebIFrame
26037>>>                    Set psUrl        to "WebQueryUsage.html"
26038>>>                    Set pbFillHeight to True
26039>>>                End_Object                
26040>>>                
26040>>>            End_Object
26041>>>            
26041>>>            Object oAPIPage is a cWebTabPage
26043>>>                Set psCaption    to "API"
26044>>>                Set pbFillHeight to True
26045>>>                
26045>>>                Object oAPI is a cWebIFrame
26047>>>                    Set psUrl        to "WebQueryAPI.html"
26048>>>                    Set pbFillHeight to True
26049>>>                End_Object
26050>>>        
26050>>>            End_Object
26051>>>                    
26051>>>            Object oHelpPage is a cWebTabPage
26053>>>                Set psCaption to "Help"
26054>>>                
26054>>>                Object oHelp is a cWebIFrame
26056>>>                    Set pbFillHeight to True
26057>>>                    Set psUrl        to "WebQueryHelp.html"
26058>>>                End_Object
26059>>>                
26059>>>            End_Object
26060>>>            
26060>>>            Object oOtherPage is a cWebTabPage
26062>>>                Set psCaption to "Other"
26063>>>                
26063>>>                Object oOther is a cWebIFrame
26065>>>                    Set pbFillHeight to True
26066>>>                    Set psUrl        to "WebQueryOther.html"
26067>>>                End_Object
26068>>>                
26068>>>            End_Object
26069>>>            
26069>>>            Object oBugsPage is a cWebTabPage
26071>>>                Set psCaption to "Bug List"
26072>>>                
26072>>>                Object oBugList is a cWebIFrame
26074>>>                    Set psUrl        to "http://ec2-54-200-89-112.us-west-2.compute.amazonaws.com/WebQueryBugList.html"
26075>>>                    Set pbFillHeight to True
26076>>>                End_Object
26077>>>                
26077>>>            End_Object
26078>>>            
26078>>>            Object oReadMePage is a cWebTabPage
26080>>>                Set psCaption to "Read Me"
26081>>>                
26081>>>                Object oReadMe is a cWebIFrame
26083>>>                    Set psUrl        to "ReadMe.html"
26084>>>                    Set pbFillHeight to True
26085>>>                End_Object
26086>>>                
26086>>>            End_Object
26087>>>            
26087>>>            Object oReleasePage is a cWebTabPage
26089>>>                Set psCaption to "History"
26090>>>                
26090>>>                Object oRelHist is a cWebIFrame
26092>>>                    Set psUrl        to "WebQueryReleaseHistory.html"
26093>>>                    Set pbFillHeight to True
26094>>>                End_Object
26095>>>                
26095>>>            End_Object
26096>>>            
26096>>>            Object oLicencePage is a cWebTabPage
26098>>>                Set psCaption to "Licence"
26099>>>                
26099>>>                Object oRelHist is a cWebIFrame
26101>>>                    Set psUrl        to "WebQueryLicence.html"
26102>>>                    Set pbFillHeight to True
26103>>>                End_Object
26104>>>                
26104>>>            End_Object
26105>>>            
26105>>>        End_Object
26106>>>
26106>>>    End_Object 
26107>>>
26107>>>End_Object
26108>    Use WebQuery.wo
Including file: WebQuery.wo    (Z:\VmShare\Projects\WebQuery18-0\AppSrc\WebQuery.wo)
26108>>>//==============================================================================
26108>>>// WebQuery: An ad-hoc query tool designed tio be built into applications
26108>>>//           (most probably as a "Report" option).
26108>>>//
26108>>>//           It REQUIRES Sture Andersen's "StureApsPublicLib" (20131023 or
26108>>>//           later) - you can find it at:
26108>>>//              ftp://ftp.stureaps.dk/software/visualdataflex/stureapspubliclib/
26108>>>//
26108>>>// See the ReadMe.txt file in AppHTML for usage details.
26108>>>//
26108>>>// Author: Mike Peat; copyright (c) Unicorn InterGlobal, 2013
26108>>>//
26108>>>//==============================================================================
26108>>>
26108>>>//==============================================================================
26108>>>// Use statements
26108>>>//==============================================================================
26108>>>
26108>>>// Framework packages
26108>>>Use cWebView.pkg
26108>>>Use cWebPanel.pkg
26108>>>Use cWebForm.pkg 
26108>>>Use cWebCombo.pkg
26108>>>Use cWebButton.pkg
26108>>>Use cWebTabContainer.pkg
26108>>>Use cWebTabPage.pkg
26108>>>Use cWebGrid.pkg
26108>>>Use cWebColumn.pkg
26108>>>Use cWebList.pkg
26108>>>Use cWebHtmlBox.pkg
26108>>>Use cWebLabel.pkg
26108>>>Use cWebEdit.pkg
26108>>>Use cWebSpacer.pkg
26108>>>Use cWebColumnCheckbox.pkg
26108>>>Use cWebCheckBox.pkg
26108>>>Use cWebRadio.pkg
26108>>>
26108>>>// Web Query packages
26108>>>Use cWebQueryFunctions.pkg
Including file: cWebQueryFunctions.pkg    (Z:\VmShare\Projects\WebQuery18-0\AppSrc\cWebQueryFunctions.pkg)
26108>>>>>Use UI
26108>>>>>Use seq_chnl.pkg
26108>>>>>
26108>>>>>// Strure's packages:
26108>>>>>Use StringFunctions.pkg
Including file: StringFunctions.pkg    (Z:\VmShare\Projects\WebQuery18-0\StureApsPublicLib\AppSrc\StringFunctions.pkg)
26108>>>>>>>// String functions encapsulated in oStringFunctions (SturesPublicLibrary)
26108>>>>>>>
26108>>>>>>>//> The oStringFunctions.pkg package defines an object called oStringFunctions that encapsulates a number of
26108>>>>>>>//> general purpose string functions.
26108>>>>>>>//>
26108>>>>>>>//> For example, to call the function NumberToString the syntax is therefore
26108>>>>>>>//>
26108>>>>>>>//>     get NumberToString of oStringFunctions 3.1415926 3 to sResult
26108>>>>>>>//>
26108>>>>>>>//> or on expressional form
26108>>>>>>>//>
26108>>>>>>>//>     move (NumberToString(oStringFunctions,3.1415926,3)) to sResult
26108>>>>>>>//>
26108>>>>>>>//> (both of the above examples places the result "3.142" in string variable sResult)
26108>>>>>>>//>
26108>>>>>>>//> Since quite a number of functions in this package are concerned with formatting numbers
26108>>>>>>>//> a general note is in its place. Converting numbers to strings was never very difficult
26108>>>>>>>//> in VDF. Simply move a number to a string, end of conversion. However, that type of conversion
26108>>>>>>>//> leaves you no control over the number of decimals in the resulting string.
26108>>>>>>>//>
26108>>>>>>>//>     String sValue
26108>>>>>>>//>     Move 2.500 to sValue
26108>>>>>>>//>
26108>>>>>>>//> places the value "2.5" in the string variable because a number moved to a string variable
26108>>>>>>>//> gets truncated at the least significant digit that is non-zero (after the decimal point). The
26108>>>>>>>//> NumberToString function mentioned just above, or one of its cousins, helps you overcome this.
26108>>>>>>>//>
26108>>>>>>>//> pkg.doc.end
26108>>>>>>>
26108>>>>>>>Use VdfBase.pkg // DAW package. Provides low level support expected of all VDF applications (windows and webapp)
26108>>>>>>>
26108>>>>>>>// Internally for use with wildcard* functions
26108>>>>>>>Enum_List
26108>>>>>>>    Define _WILDC_THE_HARD_WAY         //>
26108>>>>>>>    Define _WILDC_ALWAYS_TRUE          //> *
26108>>>>>>>    Define _WILDC_EQUAL                //> Sture
26108>>>>>>>    Define _WILDC_LEFT_MATCH           //> Sture*
26108>>>>>>>    Define _WILDC_RIGHT_MATCH          //> *Andersen
26108>>>>>>>    Define _WILDC_LEFT_AND_RIGHT_MATCH //> Sture*Andersen
26108>>>>>>>    Define _WILDC_CONTAINS             //> *B*
26108>>>>>>>    Define _WILDC_CONTAINS_WORDONLY
26108>>>>>>>End_Enum_List
26108>>>>>>>
26108>>>>>>>Enum_List
26108>>>>>>>    Define _WILDC_CONSTANT
26108>>>>>>>    Define _WILDC_QUESTIONMARK
26108>>>>>>>    Define _WILDC_ASTERISK
26108>>>>>>>End_Enum_List
26108>>>>>>>
26108>>>>>>>Struct tWildCardEvalSequenceItem
26108>>>>>>>    Integer iType // 0=constant 1=? 2=*
26108>>>>>>>    String sValue // Only relevant when iType is 0
26108>>>>>>>End_Struct
26108>>>>>>>
26108>>>>>>>//> A value of this type describes a series of string comparisons to perform
26108>>>>>>>//> in order to validate a string against a particular mask. The WildCard* functions
26108>>>>>>>//> defined in the cStringFunctions class uses this.
26108>>>>>>>Struct tWildCardEvalSequence
26108>>>>>>>    // The properties defined here are used only to try to optimize
26108>>>>>>>    // the evaluation sequence.
26108>>>>>>>    Integer iAltStrategy
26108>>>>>>>    // If an alternative strategy is active, can we use it to accept a
26108>>>>>>>    // value (bAltStrategyRejectOnly=TRUE) or must we run it the hard
26108>>>>>>>    // way afterwards (bAltStrategyRejectOnly=FALSE)?
26108>>>>>>>    Boolean bAltStrategyRejectOnly
26108>>>>>>>    String  sAltStrategyLeftValue
26108>>>>>>>    String  sAltStrategyRightValue
26108>>>>>>>    tWildCardEvalSequenceItem[] aSequence
26108>>>>>>>    tWildCardEvalSequenceItem[] aSequence
26108>>>>>>>End_Struct
26108>>>>>>>
26108>>>>>>>String gStr$ReversedCollateString 255
26108>>>>>>>
26108>>>>>>>Struct _tsfMaxArgSize
26108>>>>>>>    Integer iSize
26108>>>>>>>    Boolean bSet
26108>>>>>>>End_Struct
26108>>>>>>>
26108>>>>>>>Global_Variable _tsfMaxArgSize[] _gasfMAS
26108>>>>>>>
26108>>>>>>>//> The oStringFunctions object is based on the cStringFunctions class.
26108>>>>>>>Class cStringFunctions is a cObject
26109>>>>>>>    
26109>>>>>>>    Procedure Construct_Object
26111>>>>>>>        Integer iAscii
26111>>>>>>>        Forward Send Construct_Object
26113>>>>>>>        //> The coolest little property
26113>>>>>>>        Property String psDecimalSeparator
26114>>>>>>>        Property Boolean _pbInsertThousandsSeparators False
26115>>>>>>>
26115>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iAscii
26118>>>>>>>        Set psDecimalSeparator to (Character(iAscii))
26119>>>>>>>        
26119>>>>>>>        Property String psWildCardWordCharacters "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_#0123456789"
26120>>>>>>>        
26120>>>>>>>        Property String _psCurrentCollateString ""
26121>>>>>>>    End_Procedure
26122>>>>>>>
26122>>>>>>>    //> 
26122>>>>>>>    Procedure MaxArgumentSizeAdjust Integer iSize Boolean bDownsizeIfPossible
26124>>>>>>>        Integer iCurrentSize iIndex
26124>>>>>>>        Boolean bSet
26124>>>>>>>        Move (SizeOfArray(_gasfMAS)) to iIndex
26125>>>>>>>        Get_Argument_Size to iCurrentSize
26126>>>>>>>        Move (iSize>iCurrentSize or bDownsizeIfPossible) to bSet
26127>>>>>>>        If (bSet) Begin
26129>>>>>>>            Set_Argument_Size iSize
26130>>>>>>>>
26130>>>>>>>            Move iCurrentSize to _gasfMAS[iIndex].iSize
26131>>>>>>>        End
26131>>>>>>>>
26131>>>>>>>        Move bSet to _gasfMAS[iIndex].bSet
26132>>>>>>>    End_Procedure
26133>>>>>>>    
26133>>>>>>>    //> See: Class:cStringFunctions,Procedure:MaxArgumentSizeAdjust
26133>>>>>>>    Procedure MaxArgumentSizeRestore
26135>>>>>>>        Integer iIndex iSize
26135>>>>>>>        Move (SizeOfArray(_gasfMAS)-1) to iIndex
26136>>>>>>>        If (iIndex>=0) Begin
26138>>>>>>>            If (_gasfMAS[iIndex].bSet) Begin
26140>>>>>>>                Move _gasfMAS[iIndex].iSize to iSize
26141>>>>>>>                Set_Argument_Size iSize
26142>>>>>>>>
26142>>>>>>>            End
26142>>>>>>>>
26142>>>>>>>            Move (ResizeArray(_gasfMAS,iIndex)) to _gasfMAS
26143>>>>>>>        End
26143>>>>>>>>
26143>>>>>>>        Else Begin
26144>>>>>>>            Error 666 "Unbalanced argument size push/pop (StringFunctions.pkg)"
26145>>>>>>>>
26145>>>>>>>        End
26145>>>>>>>>
26145>>>>>>>    End_Procedure
26146>>>>>>>    
26146>>>>>>>    Function MaxArgumentSize Returns Integer
26148>>>>>>>        Integer iCurrentSize
26148>>>>>>>        Get_Argument_Size to iCurrentSize
26149>>>>>>>        Function_Return iCurrentSize
26150>>>>>>>    End_Function
26151>>>>>>>
26151>>>>>>>    Function CurrentCollateString Returns String
26153>>>>>>>        Integer iChar iItem iMax hArr
26153>>>>>>>        String sValue
26153>>>>>>>        If (_psCurrentCollateString(Self)="") Begin
26155>>>>>>>            Get Create U_Array to hArr
26156>>>>>>>            Send Delete_Data of hArr
26157>>>>>>>            For iChar from 32 to 255
26163>>>>>>>>
26163>>>>>>>                Set Value of hArr (iChar-32) to (Character(iChar))
26164>>>>>>>            Loop
26165>>>>>>>>
26165>>>>>>>            Send Sort_Items of hArr Ascending // This reveals the true sorting of the current runtime.
26166>>>>>>>            Get Item_Count of hArr to iMax
26167>>>>>>>            Decrement iMax
26168>>>>>>>            Move "" to sValue
26169>>>>>>>            For iItem from 0 to iMax
26175>>>>>>>>
26175>>>>>>>                Move (sValue+Value(hArr,iItem)) to sValue
26176>>>>>>>            Loop
26177>>>>>>>>
26177>>>>>>>            Send Destroy of hArr
26178>>>>>>>            Set _psCurrentCollateString to sValue
26179>>>>>>>        End
26179>>>>>>>>
26179>>>>>>>        Function_Return (_psCurrentCollateString(Self))
26180>>>>>>>    End_Function
26181>>>>>>>    
26181>>>>>>>    //> Flip string
26181>>>>>>>    Function ReverseString String sValue Returns String
26183>>>>>>>        Integer iLen iPos
26183>>>>>>>        String sRval sChar
26183>>>>>>>        Move "" to sRval
26184>>>>>>>        Move (Length(sValue)) to iLen
26185>>>>>>>        For iPos from 1 to iLen 
26191>>>>>>>>
26191>>>>>>>            Move (Mid(sValue,1,iPos)+sRval) to sRval
26192>>>>>>>        Loop
26193>>>>>>>>
26193>>>>>>>        Function_Return sRval
26194>>>>>>>    End_Function
26195>>>>>>>    
26195>>>>>>>    //> Negate value so that sorting it as a string will reverse the direction of the original value
26195>>>>>>>    Function NegateString String sValue Returns String
26197>>>>>>>        Integer iPos iLen
26197>>>>>>>        String sRval sChar
26197>>>>>>>        Move (length(sValue)) to iLen
26198>>>>>>>        Move "" to sRval
26199>>>>>>>        For iPos from 1 to iLen
26205>>>>>>>>
26205>>>>>>>            Move (Mid(sValue,1,iPos)) to sChar
26206>>>>>>>            Move (sRval+Mid(gStr$ReversedCollateString,1,Ascii(sChar))) to sRval
26207>>>>>>>        Loop
26208>>>>>>>>
26208>>>>>>>        Function_Return sRval
26209>>>>>>>    End_Function
26210>>>>>>>    
26210>>>>>>>        Function _CurrentCollateStringReversed Returns String
26212>>>>>>>            Function_Return (ReverseString(Self,CurrentCollateString(Self)))
26213>>>>>>>        End_Function
26214>>>>>>>        
26214>>>>>>>    //> Function rPos returns the position of the last occurance of sSubString in sHostString. If
26214>>>>>>>    //> there are no occurances, 0 will be returned.
26214>>>>>>>    //>
26214>>>>>>>    //> Parameters:
26214>>>>>>>    //>     sSubString: The sequence of characters to be searched for.
26214>>>>>>>    //>     sHostString: The string in which to search for the 'sub string'.
26214>>>>>>>    //>
26214>>>>>>>    //>     returns: The highest position at which the 'sub string' was found. 0 if it wasn't.
26214>>>>>>>    //>
26214>>>>>>>    //> Examples:
26214>>>>>>>    //>
26214>>>>>>>    //>     get rPos of oStringFunctions "be" "tobeornottobe" to iPos // returns 12 to iPos
26214>>>>>>>    //>
26214>>>>>>>    Function rPos String sSubString String sHostString Returns Integer
26216>>>>>>>        Integer iPos iSubLen
26216>>>>>>>        If (Length(sSubString)=0) Function_Return 0
26219>>>>>>>        Move (Length(sHostString)-Length(sSubString)+1) to iPos
26220>>>>>>>        Move (Length(sSubString)) to iSubLen
26221>>>>>>>        While (iPos>0)
26225>>>>>>>            If (Mid(sHostString,iSubLen,iPos)=sSubString) Function_Return iPos
26228>>>>>>>            Decrement iPos
26229>>>>>>>        End
26230>>>>>>>>
26230>>>>>>>        Function_Return 0 // not found
26231>>>>>>>    End_Function
26232>>>>>>>
26232>>>>>>>    //> Function rRemove removes iNumChars characters from the right end of sValue.
26232>>>>>>>    Function rRemove String sValue Integer iNumChars Returns String
26234>>>>>>>        Function_Return (Left(sValue,Length(sValue)-iNumChars))
26235>>>>>>>    End_Function
26236>>>>>>>
26236>>>>>>>//  //> Function RightFromPos returns the right part of the string starting at position iPos.
26236>>>>>>>//  Function RightFromPos String sValue Integer iPos Returns String
26236>>>>>>>//      Function_Return (remove(sValue,1,iPos-1))
26236>>>>>>>//  End_Function
26236>>>>>>>
26236>>>>>>>    Function BeginsWith String sHostString String sLeadInCharacters Returns Boolean
26238>>>>>>>        If (Length(sLeadInCharacters)>Length(sHostString)) Function_Return False
26241>>>>>>>        Function_Return (Left(sHostString,Length(sLeadInCharacters))=sLeadInCharacters)
26242>>>>>>>    End_Function
26243>>>>>>>
26243>>>>>>>    Function EndsWith String sHostString String sTrailingCharacters Returns Boolean
26245>>>>>>>        If (Length(sTrailingCharacters)>Length(sHostString)) Function_Return False
26248>>>>>>>        Function_Return (Right(sHostString,Length(sTrailingCharacters))=sTrailingCharacters)
26249>>>>>>>    End_Function
26250>>>>>>>
26250>>>>>>>    Function SearchPos String sSubString String sHostString Integer iStartPos Returns Integer
26252>>>>>>>        Integer iRval
26252>>>>>>>        Move (Pos(sSubString,Remove(sHostString,1,iStartPos-1))) to iRval
26253>>>>>>>        If (iRval) Move (iRval+iStartPos-1) to iRval
26256>>>>>>>        Function_Return iRval
26257>>>>>>>    End_Function
26258>>>>>>>
26258>>>>>>>    Function psThousandsSeparator Returns String
26260>>>>>>>        If (psDecimalSeparator(Self)=",") Function_Return "." // Dot
26263>>>>>>>        Function_Return "," // Comma
26264>>>>>>>    End_Function
26265>>>>>>>
26265>>>>>>>    //> The string sValue is returned right justified in a string of length iLen
26265>>>>>>>    Function RightAdjust String sValue Integer iLen Returns String
26267>>>>>>>        Move (Trim(sValue)) to sValue
26268>>>>>>>        Move (Repeat(" ", 0 max (iLen-length(sValue)))+sValue) to sValue
26269>>>>>>>        Function_Return sValue
26270>>>>>>>    End_Function
26271>>>>>>>
26271>>>>>>>    //> Inserts thousands separators into the number passed.
26271>>>>>>>    Function InsertThousandsSeparators String sValue Returns String
26273>>>>>>>        Integer iPos
26273>>>>>>>        Boolean bNegative
26273>>>>>>>        String sDecimalSeparator sThousandsSeparator
26273>>>>>>>
26273>>>>>>>        Move (Trim(sValue)) to sValue
26274>>>>>>>        Move (Left(sValue,1)="-") to bNegative
26275>>>>>>>
26275>>>>>>>        If (bNegative) Move (Remove(sValue,1,1)) to sValue // if (lbNegative) get StringRightBut sValue 1 to sValue
26278>>>>>>>
26278>>>>>>>        Get psDecimalSeparator to sDecimalSeparator
26279>>>>>>>        Move (Pos(sDecimalSeparator,sValue)) to iPos
26280>>>>>>>        If (iPos=0) Move (Length(sValue)+1) to iPos
26283>>>>>>> 
26283>>>>>>>        Get psThousandsSeparator to sThousandsSeparator
26284>>>>>>>
26284>>>>>>>        While (iPos>4)
26288>>>>>>>            Move (iPos-3) to iPos
26289>>>>>>>            Move (Insert(sThousandsSeparator,sValue,iPos)) to sValue
26290>>>>>>>        Loop
26291>>>>>>>>
26291>>>>>>>        If (bNegative) Move ("-"+sValue) to sValue
26294>>>>>>>        Function_Return sValue
26295>>>>>>>    End_Function
26296>>>>>>>
26296>>>>>>>    //> Removes thousands separators from the string passed and dares comvert it into a number.
26296>>>>>>>    Function RemoveThousandsSeparators String sValue Returns Number
26298>>>>>>>        Move (Replaces(psThousandsSeparator(Self),sValue,"")) to sValue
26299>>>>>>>        Function_Return (Number(sValue))
26300>>>>>>>    End_Function
26301>>>>>>>
26301>>>>>>>    //> Calling the function below will convert the number passed in nNumber to a
26301>>>>>>>    //> string containing iDecimals decimals rounding excess decimals. Parameter iDecimals
26301>>>>>>>    //> may be negative. The expression (NumberToString(oStringFunctions,1789,-3)) will evaluate to "2000".
26301>>>>>>>    //> The function handles a maximum of 8 decimals.
26301>>>>>>>    Function NumberToString Number nValue Integer iDecimals Returns String
26303>>>>>>>        Integer iPos iAscii
26303>>>>>>>        Number nCorr
26303>>>>>>>        String sRval sDecimalSeparator
26303>>>>>>>        If (iDecimals<0) Function_Return (NumberToString(Self,nValue*(10^iDecimals),0)+left("00000000",-iDecimals))
26306>>>>>>>        Move (0.5/(10^iDecimals)) to nCorr
26307>>>>>>>        If (nValue>=0) Move (nCorr+nValue) to nValue
26310>>>>>>>        Else Move (nValue-nCorr) to nValue
26312>>>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iAscii
26315>>>>>>>        Move (Character(iAscii)) to sDecimalSeparator
26316>>>>>>>        Move nValue to sRval
26317>>>>>>>        If (not(Pos(sDecimalSeparator,sRval))) Move (sRval+sDecimalSeparator) to sRval
26320>>>>>>>        Move (sRval+"00000000") to sRval
26321>>>>>>>        Move (Pos(sDecimalSeparator,sRval)) to iPos
26322>>>>>>>        If (iDecimals=0) Decrement iPos
26325>>>>>>>        Move (Left(sRval,iPos+iDecimals)) to sRval
26326>>>>>>>        If (_pbInsertThousandsSeparators(Self)) Get InsertThousandsSeparators sRval to sRval
26329>>>>>>>        Function_Return sRval
26330>>>>>>>    End_Function
26331>>>>>>>
26331>>>>>>>    //> This function is the same as NumberToString except that you have to specify
26331>>>>>>>    //> the length of the return value (iLen). The number will be right
26331>>>>>>>    //> justified accordingly. Post-fix `R' means right adjust.
26331>>>>>>>    Function NumberToStringR Number nValue Integer iDecimals Integer iLen Returns String
26333>>>>>>>        Function_Return (RightAdjust(Self,NumberToString(Self,nValue,iDecimals),iLen))
26334>>>>>>>    End_Function
26335>>>>>>>
26335>>>>>>>    //> Function NumberToStringTS is the same as NumberToString except that thousands
26335>>>>>>>    //> separators are inserted. (TS=Thousands Separator)
26335>>>>>>>    Function NumberToStringTS Number nValue Integer iDecimals Returns String
26337>>>>>>>        String sRval
26337>>>>>>>        Set _pbInsertThousandsSeparators to True
26338>>>>>>>        Get NumberToString nValue iDecimals to sRval
26339>>>>>>>        Set _pbInsertThousandsSeparators to False
26340>>>>>>>        Function_Return sRval
26341>>>>>>>    End_Function
26342>>>>>>>
26342>>>>>>>    //> This function is identical to NumberToStringTS except that you have to specify
26342>>>>>>>    //> the length of the return value (iLen). The return value will be right
26342>>>>>>>    //> justified accordingly.
26342>>>>>>>    Function NumberToStringRTS Number nValue Integer iDecimals Integer iLen Returns String
26344>>>>>>>        String sRval
26344>>>>>>>        Get NumberToStringTS nValue iDecimals to sRval
26345>>>>>>>        Get RightAdjust sRval iLen to sRval
26346>>>>>>>        Function_Return sRval
26347>>>>>>>    End_Function
26348>>>>>>>
26348>>>>>>>    //> The number nValue is rounded to 0 decimals and returned right justified in a string of
26348>>>>>>>    //> length iLen. Lead in blanks are substituted for zeros (zf=zero fill).
26348>>>>>>>    Function IntegerToStringRzf Number nValue Integer iLen Returns String
26350>>>>>>>        String sRval
26350>>>>>>>        Get NumberToStringR nValue 0 iLen to sRval
26351>>>>>>>        Function_Return (replaces(" ",sRval,"0"))
26352>>>>>>>    End_Function
26353>>>>>>>    
26353>>>>>>>    Function StringToNumber String sValue Returns Number
26355>>>>>>>        String sDec sNotDec
26355>>>>>>>        Number nValue
26355>>>>>>>        Get psDecimalSeparator to sDec
26356>>>>>>>        Get psThousandsSeparator to sNotDec
26357>>>>>>>        Move (Replace(sNotDec,sValue,sDec)) to sValue
26358>>>>>>>        Move sValue to nValue
26359>>>>>>>        Function_Return nValue
26360>>>>>>>    End_Function
26361>>>>>>>
26361>>>>>>>    //> Use this function to obtain the number of the least significant "non zero
26361>>>>>>>    //> decimal in nValue. 0.702 will return 3 while 100 will return -2.
26361>>>>>>>    Function NumberOfDecimals Number nValue Returns Integer
26363>>>>>>>        Integer iCount
26363>>>>>>>        String sNumber sDecimalSeparator
26363>>>>>>>
26363>>>>>>>        If (nValue=0) Function_Return 0 // Special case
26366>>>>>>>        Move nValue to sNumber // This removes superflous decimals
26367>>>>>>>
26367>>>>>>>        Get psDecimalSeparator to sDecimalSeparator
26368>>>>>>>        If (pos(sDecimalSeparator,sNumber)) Function_Return (length(sNumber)-pos(sDecimalSeparator,sNumber))
26371>>>>>>>
26371>>>>>>>        Move 0 to iCount
26372>>>>>>>        While (right(sNumber,1)="0")
26376>>>>>>>            Move (left(sNumber,length(sNumber)-1)) to sNumber
26377>>>>>>>            Decrement iCount
26378>>>>>>>        End
26379>>>>>>>>
26379>>>>>>>        Function_Return iCount
26380>>>>>>>    End_Function
26381>>>>>>>
26381>>>>>>>    //> IsInteger returns True if the value held by the sValue parameter is an integer (the function does not handle thousand seps).
26381>>>>>>>    //> Note that even if this function returns True it may still not be possible to 'Move' the value to an integer variable. This will
26381>>>>>>>    //> be the case if the value falls outside of the integer value range (-2147483648 to 2147483647)
26381>>>>>>>    Function IsInteger String sValue Returns Boolean
26383>>>>>>>        Integer iPos iLen
26383>>>>>>>        Move (Trim(sValue)) to sValue
26384>>>>>>>        If (Left(sValue,1)="-") Move (Replace("-",sValue,"")) to sValue
26387>>>>>>>        Move (Length(sValue)) to iLen
26388>>>>>>>        For iPos from 1 to iLen
26394>>>>>>>>
26394>>>>>>>            If (not(Pos(Mid(sValue,1,iPos),"0123456789"))) begin
26396>>>>>>>                Function_Return False
26397>>>>>>>            End
26397>>>>>>>>
26397>>>>>>>        Loop
26398>>>>>>>>
26398>>>>>>>        Function_Return True
26399>>>>>>>    End_Function
26400>>>>>>>
26400>>>>>>>    //> This function returns True if sValue is a number or an integer (the function does not handle thousand seps)
26400>>>>>>>    //> Note that even if this function returns True it may still not be possible to 'Move' the value to a number variable. This will
26400>>>>>>>    //> be the case if the value falls outside of the number value range (+/-99999999999999.99999999)
26400>>>>>>>    Function IsNumber String sValue String sDecimalSeparator Returns Boolean
26402>>>>>>>        Integer iLen iPos iAscii
26402>>>>>>>        Boolean bDecSepFound
26402>>>>>>>        String sChar sSep
26402>>>>>>>        Move False to bDecSepFound
26403>>>>>>>        Move (Trim(sValue)) to sValue
26404>>>>>>>        If (Left(sValue,1)="-") Begin
26406>>>>>>>            Move (Replace("-",sValue,"")) to sValue
26407>>>>>>>        End
26407>>>>>>>>
26407>>>>>>>        If (num_arguments>1) Begin
26409>>>>>>>            Move sDecimalSeparator to sSep
26410>>>>>>>            If (not(",." contains sSep)) Begin // This error check may be removed in january 1st 2013
26412>>>>>>>                Error 666 "Decimal separator must be ',' or '.'"
26413>>>>>>>>
26413>>>>>>>            End
26413>>>>>>>>
26413>>>>>>>        End
26413>>>>>>>>
26413>>>>>>>        Else Begin
26414>>>>>>>            Get_Attribute DF_DECIMAL_SEPARATOR to iAscii
26417>>>>>>>            Move (Character(iAscii)) to sSep
26418>>>>>>>        End
26418>>>>>>>>
26418>>>>>>>        Move (Length(sValue)) to iLen
26419>>>>>>>        For iPos from 1 to iLen
26425>>>>>>>>
26425>>>>>>>            Move (Mid(sValue,1,iPos)) to sChar
26426>>>>>>>            If (sChar=sSep) Begin
26428>>>>>>>                If bDecSepFound Function_Return False
26431>>>>>>>                Move True to bDecSepFound
26432>>>>>>>            End
26432>>>>>>>>
26432>>>>>>>            Else If (not("0123456789" contains sChar)) Begin 
26435>>>>>>>                Function_Return False
26436>>>>>>>            End
26436>>>>>>>>
26436>>>>>>>        Loop
26437>>>>>>>>
26437>>>>>>>        Function_Return True
26438>>>>>>>    End_Function
26439>>>>>>>    
26439>>>>>>>    //> Convert a byte value (0-255) to its hex equivalent. Passing for example 27 makes it return "1B".
26439>>>>>>>    Function ByteToHex Integer iByte Returns String
26441>>>>>>>        Function_Return (Mid("0123456789ABCDEF",1,iByte/16+1)+Mid("0123456789ABCDEF",1,(iByte iand 15)+1))
26442>>>>>>>    End_Function
26443>>>>>>>
26443>>>>>>>    //> Convert a hexadecimal value to its byte equivalent: Passing "FF" for example makes it return 255.
26443>>>>>>>    Function HexToByte String sHex Returns Integer
26445>>>>>>>        Move (Uppercase(sHex)) to sHex
26446>>>>>>>        Function_Return (Pos(Left(sHex,1),"0123456789ABCDEF")-1*16+Pos(Right(sHex,1),"0123456789ABCDEF")-1)
26447>>>>>>>    End_Function
26448>>>>>>>    
26448>>>>>>>    Function IsHex String sHex Returns Boolean
26450>>>>>>>        Integer iLen iPos
26450>>>>>>>        String sChar
26450>>>>>>>        Move (Length(sHex)) to iLen
26451>>>>>>>        If (((iLen/2)*2)<>iLen) Function_Return False // Must be an equal number of characters
26454>>>>>>>        Move (Uppercase(sHex)) to sHex
26455>>>>>>>        For iPos from 1 to iLen
26461>>>>>>>>
26461>>>>>>>            Move (Mid(sHex,1,iPos)) to sChar
26462>>>>>>>            If not ("0123456789ABCDEF" contains sChar) Function_Return False
26465>>>>>>>        Loop
26466>>>>>>>>
26466>>>>>>>        Function_Return True
26467>>>>>>>    End_Function
26468>>>>>>>
26468>>>>>>>    //> Convert a string of characters to a string of hexadecimal values.
26468>>>>>>>    Function StringToHex String sValue Returns String
26470>>>>>>>        Integer iLen iPos
26470>>>>>>>        String sRval
26470>>>>>>>        Move (Length(sValue)) to iLen
26471>>>>>>>        Move "" to sRval
26472>>>>>>>        For iPos from 1 to iLen
26478>>>>>>>>
26478>>>>>>>            Move (String(sRval)+String(ByteToHex(Self,Ascii(Mid(sValue,1,iPos))))) to sRval
26479>>>>>>>        Loop
26480>>>>>>>>
26480>>>>>>>        Function_Return sRval
26481>>>>>>>    End_Function
26482>>>>>>>
26482>>>>>>>    //> Convert a string of hexadecimal values to a string of characters.
26482>>>>>>>    Function HexToString String sValue Returns String
26484>>>>>>>        Integer iLen iPos
26484>>>>>>>        String sRval
26484>>>>>>>        Move (Length(sValue)/2) to iLen
26485>>>>>>>        Move "" to sRval
26486>>>>>>>        For iPos from 1 to iLen
26492>>>>>>>>
26492>>>>>>>            Move (String(sRval)+Character(HexToByte(Self,Mid(sValue,2,iPos*2-1)))) to sRval
26493>>>>>>>        Loop
26494>>>>>>>>
26494>>>>>>>        Function_Return sRval
26495>>>>>>>    End_Function
26496>>>>>>>
26496>>>>>>>                    Function _iEncryptXor.iii Integer iXval Integer iYval Integer iBitCount Returns Integer // Private
26498>>>>>>>                        Integer iRval iBit iXbit iYbit iBitExp
26498>>>>>>>                        Move 0 to iRval
26499>>>>>>>                        For iBit from 0 to (iBitCount-1)
26505>>>>>>>>
26505>>>>>>>                            Move (2^iBit) to iBitExp
26506>>>>>>>                            Move ((iXval/iBitExp)-(((iXval/iBitExp)/2)*2)) to iXbit
26507>>>>>>>                            Move ((iYval/iBitExp)-(((iYval/iBitExp)/2)*2)) to iYbit
26508>>>>>>>                            If (iXbit<>iYbit) Move (iRval+iBitExp) to iRval
26511>>>>>>>                        Loop
26512>>>>>>>>
26512>>>>>>>                        Function_Return iRval
26513>>>>>>>                    End_Function
26514>>>>>>>
26514>>>>>>>    // The same function (Encrypt) is used to encrypt and decrypt a string:
26514>>>>>>>    //
26514>>>>>>>    //          Encrypt(string,code)
26514>>>>>>>    //                  |  Encrypt(encrypted_string,key)
26514>>>>>>>    //                  |                      |
26514>>>>>>>    //                  v                      v
26514>>>>>>>    //        <string> --> <encrypted string> --> <string>
26514>>>>>>>    //
26514>>>>>>>    // The code used to encrypt a string may be any integer value and must
26514>>>>>>>    // be the same when decrypting.
26514>>>>>>>    //
26514>>>>>>>    // Note that this is a very very weak encryption that can be decoded 
26514>>>>>>>    // easily. It only obscures the content from poeple that do not want
26514>>>>>>>    // to know.
26514>>>>>>>
26514>>>>>>>    Function Encrypt String sInput Integer iKey Integer iLen Returns String
26516>>>>>>>        Integer iPos
26516>>>>>>>        String sRval
26516>>>>>>>        Move "" to sRval
26517>>>>>>>        For iPos from 1 to iLen
26523>>>>>>>>
26523>>>>>>>            Move (sRval+character(_iEncryptXor.iii(Self,ascii(mid(pad(sInput,iLen),1,iPos)),((iKey+(iPos*7)) iand 31),8))) to sRval
26524>>>>>>>        Loop
26525>>>>>>>>
26525>>>>>>>        Function_Return sRval
26526>>>>>>>    End_Function
26527>>>>>>>
26527>>>>>>>    //> The SplitString procedure splits the value in sValue into a number of items based on the character in the sSeparatorChar
26527>>>>>>>    //> parameter. These items are returned (by reference) in the aValues parameter.
26527>>>>>>>    //>
26527>>>>>>>    //> Parameters:
26527>>>>>>>    //>     sValue: The string to be divided into items.
26527>>>>>>>    //>
26527>>>>>>>    //>     sSeparatorChar:  determines which character(s) is considered a "dividing" character.
26527>>>>>>>    //>     bIgnoreDoubleSeparators: if two or more separater characters are encountered in immediate
26527>>>>>>>    //>                      succession, this parameter decides whether they should be considered
26527>>>>>>>    //>                      as one divider or as a number of separate dividers.
26527>>>>>>>    //>     bProtectQuotes:  if this is true, strings in quotes (single or double) will not be
26527>>>>>>>    //>                      scanned for separating characters.
26527>>>>>>>    //>     aValues:         The result. Any values present at the time of calling are removed as
26527>>>>>>>    //>                      part of the procedure initialization.
26527>>>>>>>    //>
26527>>>>>>>    Procedure SplitString String sValue String sSeparatorChar Boolean bIgnoreDoubleSeparators Boolean bProtectQuotes String[] ByRef aValues
26529>>>>>>>        Integer iLen       // Length of the string we are parsing
26529>>>>>>>        Integer iItem      // Pointer to the next available index in the target array (aValues)
26529>>>>>>>        Integer iStartItem // Number of items originally in the target array
26529>>>>>>>        Integer iPos       // The current position in the string (sValue) we are parsing
26529>>>>>>>
26529>>>>>>>        String  sChar      // The character currently being examined by the loop
26529>>>>>>>        String  sItem      // The value of the next item as it is being built
26529>>>>>>>        String  sQuoteChar // If " or ', we are currently in a quoted section of the string
26529>>>>>>>        String  sQuotes    // Quotation characters: "'
26529>>>>>>>
26529>>>>>>>        Move "" to sQuoteChar
26530>>>>>>>
26530>>>>>>>        Move (ResizeArray(aValues,0)) to aValues
26531>>>>>>>        Move 0 to iStartItem
26532>>>>>>>
26532>>>>>>>        Move iStartItem to iItem
26533>>>>>>>        Move (length(sValue)) to iLen
26534>>>>>>>        Move "" to sItem
26535>>>>>>>        Move ("'"+'"') to sQuotes
26536>>>>>>>
26536>>>>>>>        Move 1 to iPos
26537>>>>>>>        If (bIgnoreDoubleSeparators) Begin // Leadin separating characters are to be disregarded, we advance the position accordingly
26539>>>>>>>            While (iPos<=iLen and sSeparatorChar contains mid(sValue,1,iPos))
26543>>>>>>>              Increment iPos
26544>>>>>>>            End
26545>>>>>>>>
26545>>>>>>>        End
26545>>>>>>>>
26545>>>>>>>        While (iPos<=iLen)
26549>>>>>>>            Move (mid(sValue,1,iPos)) to sChar
26550>>>>>>>            Increment iPos
26551>>>>>>>
26551>>>>>>>            If (sQuoteChar<>"") Begin
26553>>>>>>>                If (sChar=sQuoteChar) Begin
26555>>>>>>>                    Move "" to sQuoteChar
26556>>>>>>>                End
26556>>>>>>>>
26556>>>>>>>                Move (sItem+sChar) to sItem
26557>>>>>>>            End
26557>>>>>>>>
26557>>>>>>>            Else Begin // We're not in a quote
26558>>>>>>>                If (sSeparatorChar contains sChar) Begin
26560>>>>>>>                    Move sItem to aValues[iItem]
26561>>>>>>>                    Increment iItem
26562>>>>>>>                    Move "" to sItem
26563>>>>>>>
26563>>>>>>>                    If (bIgnoreDoubleSeparators) Begin // succeeding separating characters are to be considered as one, we advance the position accordingly
26565>>>>>>>                        While (iPos<=iLen and sSeparatorChar contains mid(sValue,1,iPos))
26569>>>>>>>                          Increment iPos
26570>>>>>>>                        End
26571>>>>>>>>
26571>>>>>>>                    End
26571>>>>>>>>
26571>>>>>>>                End
26571>>>>>>>>
26571>>>>>>>                Else If (bProtectQuotes<>0 and sQuotes contains sChar and Trim(sItem)="") Begin
26574>>>>>>>                    Move sChar to sQuoteChar
26575>>>>>>>                    Move (sItem+sChar) to sItem
26576>>>>>>>                End
26576>>>>>>>>
26576>>>>>>>                Else Begin
26577>>>>>>>                    Move (sItem+sChar) to sItem
26578>>>>>>>                End
26578>>>>>>>>
26578>>>>>>>            End
26578>>>>>>>>
26578>>>>>>>        End
26579>>>>>>>>
26579>>>>>>>
26579>>>>>>>        // Added "or not(bIgnoreDoubleSeparators)" to the below statement to add the last item, even if it's blank
26579>>>>>>>        If (sItem<>"" or not(bIgnoreDoubleSeparators)) Begin
26581>>>>>>>            Move sItem to aValues[iItem]
26582>>>>>>>            Increment iItem
26583>>>>>>>        End
26583>>>>>>>>
26583>>>>>>>    End_Procedure // SplitString
26584>>>>>>>    
26584>>>>>>>            Function _SplitStringReverse String[] aValues String sSeparator Integer iMinIndex Integer iMaxIndex Returns String
26586>>>>>>>                Integer iIndex
26586>>>>>>>                String sRval
26586>>>>>>>                String sValue
26586>>>>>>>                         
26586>>>>>>>                Move (iMaxIndex min (SizeOfArray(aValues)-1)) to iMaxIndex
26587>>>>>>>                Move (iMinIndex max 0) to iMinIndex
26588>>>>>>>                
26588>>>>>>>                Move "" to sRval
26589>>>>>>>                For iIndex from iMinIndex to iMaxIndex
26595>>>>>>>>
26595>>>>>>>                    Move aValues[iIndex] to sValue
26596>>>>>>>                    Move (sRval+sValue) to sRval
26597>>>>>>>                    If (iIndex<>iMaxIndex) Begin
26599>>>>>>>                        Move (sRval+sSeparator) to sRval
26600>>>>>>>                    End
26600>>>>>>>>
26600>>>>>>>                Loop
26601>>>>>>>>
26601>>>>>>>                Function_Return sRval
26602>>>>>>>            End_Function
26603>>>>>>>    
26603>>>>>>>    Function JoinString String[] aValues String sSeparator Integer iSkipHead Integer iSkipTail Returns String 
26605>>>>>>>        Integer iMax
26605>>>>>>>        Move (SizeOfArray(aValues)-1) to iMax
26606>>>>>>>        Function_Return (_SplitStringReverse(Self,aValues,sSeparator,iSkipHead,iMax-iSkipTail))
26607>>>>>>>    End_Function
26608>>>>>>>    
26608>>>>>>>//    Function SplitStringHead String sValue String sSeparatorChar Integer bIgnoreDoubleSeparators Integer bProtectQuotes Returns String
26608>>>>>>>//        String[] aValues
26608>>>>>>>//        Send SplitString sValue sSeparatorChar bIgnoreDoubleSeparators bProtectQuotes (&aValues)
26608>>>>>>>//        If (SizeOfArray(aValues)) Function_Return aValues[0]
26608>>>>>>>//        Function_Return ""
26608>>>>>>>//    End_Function
26608>>>>>>>//    
26608>>>>>>>//    Procedure SplitStringTail String sValue String sSeparatorChar Integer bIgnoreDoubleSeparators Integer bProtectQuotes String[] ByRef aValues
26608>>>>>>>//        Integer iSize
26608>>>>>>>//        Send SplitString sValue sSeparatorChar bIgnoreDoubleSeparators bProtectQuotes (&aValues)
26608>>>>>>>//        Move (SizeOfArray(aValues)) to iSize
26608>>>>>>>//        If (iSize>1) Move (CopyArray(aValues,1,iSize-1)) to aValues
26608>>>>>>>//        Else Move (ResizeArray(aValues,0)) to aValues
26608>>>>>>>//    End_Procedure
26608>>>>>>>    
26608>>>>>>>            Procedure _WildCardAddItem tWildCardEvalSequence ByRef sSequence Integer iType String sValue // Private
26610>>>>>>>                Integer iSize
26610>>>>>>>                Move (SizeOfArray(sSequence.aSequence)) to iSize
26611>>>>>>>                Move iType to sSequence.aSequence[iSize].iType
26612>>>>>>>                Move sValue to sSequence.aSequence[iSize].sValue
26613>>>>>>>            End_Procedure
26614>>>>>>>
26614>>>>>>>            Procedure _WildCardOptimizeSequence tWildCardEvalSequence ByRef sSequence // Private
26616>>>>>>>                Integer iSize
26616>>>>>>>
26616>>>>>>>                Move (SizeOfArray(sSequence.aSequence)) to iSize
26617>>>>>>>                Move _WILDC_THE_HARD_WAY to sSequence.iAltStrategy
26618>>>>>>>                Move False to sSequence.bAltStrategyRejectOnly
26619>>>>>>>                If (iSize=1) Begin
26621>>>>>>>                    If (sSequence.aSequence[0].iType=_WILDC_ASTERISK) Move _WILDC_ALWAYS_TRUE to sSequence.iAltStrategy
26624>>>>>>>                    If (sSequence.aSequence[0].iType=_WILDC_CONSTANT) Begin
26626>>>>>>>                        Move _WILDC_EQUAL to sSequence.iAltStrategy
26627>>>>>>>                        Move sSequence.aSequence[0].sValue to sSequence.sAltStrategyLeftValue
26628>>>>>>>                    End
26628>>>>>>>>
26628>>>>>>>                End
26628>>>>>>>>
26628>>>>>>>                Else if (iSize>0) Begin
26631>>>>>>>                    If (sSequence.aSequence[0].iType=_WILDC_CONSTANT) Begin // If leftmost is a constant
26633>>>>>>>                        If (sSequence.aSequence[iSize-1].iType=_WILDC_CONSTANT) Begin // if rightmost is also a constant
26635>>>>>>>                            If (iSize=3 and sSequence.aSequence[1].iType=_WILDC_ASTERISK) Begin
26637>>>>>>>                                Move _WILDC_LEFT_AND_RIGHT_MATCH to sSequence.iAltStrategy
26638>>>>>>>                                Move sSequence.aSequence[0].sValue to sSequence.sAltStrategyLeftValue
26639>>>>>>>                                Move sSequence.aSequence[iSize-1].sValue to sSequence.sAltStrategyRightValue
26640>>>>>>>                            End
26640>>>>>>>>
26640>>>>>>>                            Else Begin
26641>>>>>>>                                Move _WILDC_LEFT_AND_RIGHT_MATCH to sSequence.iAltStrategy
26642>>>>>>>                                Move sSequence.aSequence[0].sValue to sSequence.sAltStrategyLeftValue
26643>>>>>>>                                Move sSequence.aSequence[iSize-1].sValue to sSequence.sAltStrategyRightValue
26644>>>>>>>                                Move True to sSequence.bAltStrategyRejectOnly
26645>>>>>>>                            End
26645>>>>>>>>
26645>>>>>>>                        End
26645>>>>>>>>
26645>>>>>>>                        Else Begin
26646>>>>>>>                            If (iSize=2 and sSequence.aSequence[1].iType=_WILDC_ASTERISK) Begin
26648>>>>>>>                                Move _WILDC_LEFT_MATCH to sSequence.iAltStrategy
26649>>>>>>>                                Move sSequence.aSequence[0].sValue to sSequence.sAltStrategyLeftValue
26650>>>>>>>                            End
26650>>>>>>>>
26650>>>>>>>                            Else Begin
26651>>>>>>>                                Move _WILDC_LEFT_MATCH to sSequence.iAltStrategy
26652>>>>>>>                                Move sSequence.aSequence[0].sValue to sSequence.sAltStrategyLeftValue
26653>>>>>>>                                Move True to sSequence.bAltStrategyRejectOnly
26654>>>>>>>                            End
26654>>>>>>>>
26654>>>>>>>                        End
26654>>>>>>>>
26654>>>>>>>                    End
26654>>>>>>>>
26654>>>>>>>                    Else Begin
26655>>>>>>>                        If (sSequence.aSequence[iSize-1].iType=_WILDC_CONSTANT) Begin // If rightmost is a constant
26657>>>>>>>                            If (iSize=2 and sSequence.aSequence[0].iType=_WILDC_ASTERISK) Begin
26659>>>>>>>                                Move _WILDC_RIGHT_MATCH to sSequence.iAltStrategy
26660>>>>>>>                                Move sSequence.aSequence[iSize-1].sValue to sSequence.sAltStrategyRightValue
26661>>>>>>>                            End
26661>>>>>>>>
26661>>>>>>>                            Else Begin
26662>>>>>>>                                Move _WILDC_RIGHT_MATCH to sSequence.iAltStrategy
26663>>>>>>>                                Move sSequence.aSequence[iSize-1].sValue to sSequence.sAltStrategyRightValue
26664>>>>>>>                                Move True to sSequence.bAltStrategyRejectOnly
26665>>>>>>>                            End
26665>>>>>>>>
26665>>>>>>>                        End
26665>>>>>>>>
26665>>>>>>>                        Else Begin // Now we check if first and last are asterisks
26666>>>>>>>                            If (iSize=3 and sSequence.aSequence[0].iType=_WILDC_ASTERISK and sSequence.aSequence[1].iType=_WILDC_CONSTANT and sSequence.aSequence[2].iType=_WILDC_ASTERISK) Begin
26668>>>>>>>                                Move _WILDC_CONTAINS to sSequence.iAltStrategy
26669>>>>>>>                                Move sSequence.aSequence[1].sValue to sSequence.sAltStrategyLeftValue
26670>>>>>>>                            End
26670>>>>>>>>
26670>>>>>>>                        End
26670>>>>>>>>
26670>>>>>>>                    End
26670>>>>>>>>
26670>>>>>>>                End
26670>>>>>>>>
26670>>>>>>>            End_Procedure
26671>>>>>>>
26671>>>>>>>    Function WildCardEvalSequence String sMask Returns tWildCardEvalSequence
26673>>>>>>>        Integer iLen iPos
26673>>>>>>>        String sItem sChar
26673>>>>>>>        tWildCardEvalSequence sSequence
26673>>>>>>>        tWildCardEvalSequence sSequence
26673>>>>>>>        Move _WILDC_THE_HARD_WAY to sSequence.iAltStrategy
26674>>>>>>>        Move (Replaces("**",sMask,"*")) to sMask // Simple reduction
26675>>>>>>>        Move (Length(sMask)) to iLen
26676>>>>>>>        Move "" to sItem
26677>>>>>>>        For iPos from 1 to iLen
26683>>>>>>>>
26683>>>>>>>            Move (Mid(sMask,1,iPos)) to sChar
26684>>>>>>>            If (sChar="*") Begin
26686>>>>>>>                If (sItem<>"") Begin
26688>>>>>>>                    Send _WildCardAddItem (&sSequence) _WILDC_CONSTANT sItem
26689>>>>>>>                    Move "" to sItem
26690>>>>>>>                End
26690>>>>>>>>
26690>>>>>>>                Send _WildCardAddItem (&sSequence) _WILDC_ASTERISK ""
26691>>>>>>>            End
26691>>>>>>>>
26691>>>>>>>            Else If (sChar="?") Begin
26694>>>>>>>                If (sItem<>"") Begin
26696>>>>>>>                    Send _WildCardAddItem (&sSequence) _WILDC_CONSTANT sItem
26697>>>>>>>                    Move "" to sItem
26698>>>>>>>                End
26698>>>>>>>>
26698>>>>>>>                Send _WildCardAddItem (&sSequence) _WILDC_QUESTIONMARK ""
26699>>>>>>>            End
26699>>>>>>>>
26699>>>>>>>            Else Move (sItem+sChar) to sItem
26701>>>>>>>        Loop
26702>>>>>>>>
26702>>>>>>>        If (sItem<>"") Send _WildCardAddItem (&sSequence) _WILDC_CONSTANT sItem
26705>>>>>>>        Send _WildCardOptimizeSequence (&sSequence)
26706>>>>>>>        Function_Return sSequence
26707>>>>>>>    End_Function
26708>>>>>>>    
26708>>>>>>>    Function WildCardEvalSequences String[] aMasks Returns tWildCardEvalSequence[]
26710>>>>>>>        Integer iItem iMax
26710>>>>>>>        tWildCardEvalSequence[] aSeq
26710>>>>>>>        tWildCardEvalSequence[] aSeq
26711>>>>>>>        Move (SizeOfArray(aMasks)-1) to iMax
26712>>>>>>>        For iItem from 0 to iMax
26718>>>>>>>>
26718>>>>>>>            Get WildCardEvalSequence aMasks[iItem] to aSeq[iItem]
26719>>>>>>>        Loop
26720>>>>>>>>
26720>>>>>>>        Function_Return aSeq
26721>>>>>>>    End_Function
26722>>>>>>>    
26722>>>>>>>    Procedure AddWildCardEvalSequence String sMask tWildCardEvalSequence[] ByRef aEvalSequences
26724>>>>>>>        Integer iIndex
26724>>>>>>>        Move (SizeOfArray(aEvalSequences)) to iIndex
26725>>>>>>>        Get WildCardEvalSequence sMask to aEvalSequences[iIndex]
26726>>>>>>>    End_Procedure
26727>>>>>>>
26727>>>>>>>    Procedure AddWildCardEvalSequences String[] aMasks tWildCardEvalSequence[] ByRef aEvalSequences
26729>>>>>>>        Integer iIndex iMax
26729>>>>>>>        Move (SizeOfArray(aMasks)-1) to iMax
26730>>>>>>>        For iIndex from 0 to iMax
26736>>>>>>>>
26736>>>>>>>            Send AddWildCardEvalSequence aMasks[iIndex] (&aEvalSequences)
26737>>>>>>>        Loop
26738>>>>>>>>
26738>>>>>>>    End_Procedure
26739>>>>>>>
26739>>>>>>>            Function _WildCardMatchRecursive Integer iItem String sValue tWildCardEvalSequence ByRef sSequence Returns Boolean // Private
26741>>>>>>>                Integer iMax iType iLen iPos
26741>>>>>>>                String sItem
26741>>>>>>>                Move (SizeOfArray(sSequence.aSequence)) to iMax
26742>>>>>>>                If (iItem>=iMax) Begin
26744>>>>>>>                    If (sValue="") Function_Return True
26747>>>>>>>                    Function_Return False
26748>>>>>>>                End
26748>>>>>>>>
26748>>>>>>>                Move sSequence.aSequence[iItem].iType to iType
26749>>>>>>>                If (iType=_WILDC_CONSTANT) Begin // constant
26751>>>>>>>                    If (length(sValue)=0) Function_Return False
26754>>>>>>>                    Move sSequence.aSequence[iItem].sValue to sItem
26755>>>>>>>                    Move (length(sItem)) to iLen
26756>>>>>>>                  //If (sItem=left(sValue,iLen)) Function_Return (_WildCardMatchRecursive(Self,iItem+1,RightFromPos(Self,sValue,iLen+1),&sSequence))
26756>>>>>>>                    If (sItem=left(sValue,iLen)) Function_Return (_WildCardMatchRecursive(Self,iItem+1,Remove(sValue,1,iLen),&sSequence))
26759>>>>>>>                    Function_Return 0
26760>>>>>>>                End
26760>>>>>>>>
26760>>>>>>>                If (iType=_WILDC_QUESTIONMARK) Begin // ?
26762>>>>>>>                    If (length(sValue)=0) Function_Return False
26765>>>>>>>                  //Function_Return (_WildCardMatchRecursive(Self,iItem+1,RightFromPos(Self,sValue,2),&sSequence))
26765>>>>>>>                    Function_Return (_WildCardMatchRecursive(Self,iItem+1,Remove(sValue,1,1),&sSequence))
26766>>>>>>>                End
26766>>>>>>>>
26766>>>>>>>                If (iType=_WILDC_ASTERISK) Begin // *
26768>>>>>>>                    If (iItem=(iMax-1)) Function_Return True
26771>>>>>>>                    Move (length(sValue)) to iLen
26772>>>>>>>                    For iPos from 0 to iLen
26778>>>>>>>>
26778>>>>>>>                      //If (_WildCardMatchRecursive(Self,iItem+1,RightFromPos(Self,sValue,iPos+1),&sSequence)) Function_Return True
26778>>>>>>>                        If (_WildCardMatchRecursive(Self,iItem+1,Remove(sValue,1,iPos),&sSequence)) Function_Return True
26781>>>>>>>                    Loop
26782>>>>>>>>
26782>>>>>>>                End
26782>>>>>>>>
26782>>>>>>>                Function_Return False
26783>>>>>>>            End_Function
26784>>>>>>>            
26784>>>>>>>    Function WildCardMatch String sValue tWildCardEvalSequence sSequence Returns Boolean
26786>>>>>>>        Integer iPos iPosEnd
26786>>>>>>>        String sWordCharacters
26786>>>>>>>        If (sSequence.iAltStrategy=_WILDC_ALWAYS_TRUE) Function_Return True
26789>>>>>>>        If (sSequence.iAltStrategy=_WILDC_EQUAL) Function_Return (sValue=sSequence.sAltStrategyLeftValue)
26792>>>>>>>        If (sSequence.iAltStrategy=_WILDC_LEFT_MATCH) Begin
26794>>>>>>>            If (sSequence.bAltStrategyRejectOnly) Begin
26796>>>>>>>                If (not(BeginsWith(Self,sValue,sSequence.sAltStrategyLeftValue))) Begin
26798>>>>>>>                    Function_Return False
26799>>>>>>>                End
26799>>>>>>>>
26799>>>>>>>            End
26799>>>>>>>>
26799>>>>>>>            Else Function_Return (BeginsWith(Self,sValue,sSequence.sAltStrategyLeftValue))
26801>>>>>>>        End
26801>>>>>>>>
26801>>>>>>>        If (sSequence.iAltStrategy=_WILDC_RIGHT_MATCH) Begin
26803>>>>>>>            If (sSequence.bAltStrategyRejectOnly) Begin
26805>>>>>>>                If (not(EndsWith(Self,sValue,sSequence.sAltStrategyRightValue))) Begin
26807>>>>>>>                    Function_Return False
26808>>>>>>>                End
26808>>>>>>>>
26808>>>>>>>            End
26808>>>>>>>>
26808>>>>>>>            Else Function_Return (EndsWith(Self,sValue,sSequence.sAltStrategyRightValue))
26810>>>>>>>        End
26810>>>>>>>>
26810>>>>>>>        If (sSequence.iAltStrategy=_WILDC_LEFT_AND_RIGHT_MATCH) Begin
26812>>>>>>>            If (sSequence.bAltStrategyRejectOnly) Begin
26814>>>>>>>                If (not(BeginsWith(Self,sValue,sSequence.sAltStrategyLeftValue) and EndsWith(Self,sValue,sSequence.sAltStrategyRightValue))) Begin
26816>>>>>>>                    Function_Return False
26817>>>>>>>                End
26817>>>>>>>>
26817>>>>>>>            End
26817>>>>>>>>
26817>>>>>>>            Else Function_Return (BeginsWith(Self,sValue,sSequence.sAltStrategyLeftValue) and EndsWith(Self,sValue,sSequence.sAltStrategyRightValue))
26819>>>>>>>        End
26819>>>>>>>>
26819>>>>>>>        If (sSequence.iAltStrategy=_WILDC_CONTAINS) Begin
26821>>>>>>>            Function_Return (sValue contains sSequence.sAltStrategyLeftValue)
26822>>>>>>>        End
26822>>>>>>>>
26822>>>>>>>        If (sSequence.iAltStrategy=_WILDC_CONTAINS_WORDONLY) Begin
26824>>>>>>>            Move 1 to iPos
26825>>>>>>>            Get psWildCardWordCharacters to sWordCharacters
26826>>>>>>>            While (iPos>0)
26830>>>>>>>                Move (Pos(sSequence.sAltStrategyLeftValue,sValue,iPos)) to iPos
26831>>>>>>>                If (iPos>0) Begin
26833>>>>>>>                    If (iPos=1 or not(sWordCharacters contains Mid(sValue,1,iPos-1))) Begin
26835>>>>>>>                        Move (iPos+Length(sSequence.sAltStrategyLeftValue)) to iPosEnd
26836>>>>>>>                        If (iPosEnd>Length(sValue) or not(sWordCharacters contains Mid(sValue,1,iPosEnd))) Begin
26838>>>>>>>                            Function_Return True
26839>>>>>>>                        End
26839>>>>>>>>
26839>>>>>>>                    End
26839>>>>>>>>
26839>>>>>>>                    Increment iPos
26840>>>>>>>                End
26840>>>>>>>>
26840>>>>>>>            Loop
26841>>>>>>>>
26841>>>>>>>            Function_Return False
26842>>>>>>>        End
26842>>>>>>>>
26842>>>>>>>        Function_Return (_WildCardMatchRecursive(Self,0,sValue,&sSequence))
26843>>>>>>>    End_Function
26844>>>>>>>
26844>>>>>>>    Function WildCardMatchAny String sValue tWildCardEvalSequence[] aSequences Returns Boolean
26846>>>>>>>        Integer iItm iMax
26846>>>>>>>        Move (SizeOfArray(aSequences)) to iMax
26847>>>>>>>        Decrement iMax
26848>>>>>>>        For iItm from 0 to iMax
26854>>>>>>>>
26854>>>>>>>            If (WildCardMatch(Self,sValue,aSequences[iItm])) Function_Return True
26857>>>>>>>        Loop
26858>>>>>>>>
26858>>>>>>>        Function_Return False
26859>>>>>>>    End_Function
26860>>>>>>>
26860>>>>>>>    Function WildCardMatchAll String sValue tWildCardEvalSequence[] aSequences Returns Boolean
26862>>>>>>>        Integer iItm iMax
26862>>>>>>>        Move (SizeOfArray(aSequences)) to iMax
26863>>>>>>>        Decrement iMax
26864>>>>>>>        For iItm from 0 to iMax
26870>>>>>>>>
26870>>>>>>>            If not (WildCardMatch(Self,sValue,aSequences[iItm])) Function_Return False
26873>>>>>>>        Loop
26874>>>>>>>>
26874>>>>>>>        Function_Return True
26875>>>>>>>    End_Function
26876>>>>>>>
26876>>>>>>>    Function UppercaseFirstLetters String sValue Returns String
26878>>>>>>>        Boolean bInWord
26878>>>>>>>        Integer iLen iPos
26878>>>>>>>        String sRval sChar
26878>>>>>>>        Move (Lowercase(sValue)) to sValue
26879>>>>>>>        Move (Length(sValue)) to iLen
26880>>>>>>>        Move 0 to bInWord
26881>>>>>>>        For iPos from 1 to iLen
26887>>>>>>>>
26887>>>>>>>            Move (Mid(sValue,1,iPos)) to sChar
26888>>>>>>>            If (sChar="") Move False to bInWord
26891>>>>>>>            Else Begin
26892>>>>>>>                If (not(bInWord)) Begin
26894>>>>>>>                    Move (Uppercase(sChar)) to sChar
26895>>>>>>>                    Move True to bInWord
26896>>>>>>>                End
26896>>>>>>>>
26896>>>>>>>            End
26896>>>>>>>>
26896>>>>>>>            Move (sRval+sChar) to sRval
26897>>>>>>>        Loop
26898>>>>>>>>
26898>>>>>>>        Function_Return sRval
26899>>>>>>>    End_Function
26900>>>>>>>
26900>>>>>>>    // Knut Sparhell pointed to this address for a thorough explanation: http://www.merriampark.com/ld.htm
26900>>>>>>>    Function LongestCommonSequence String sWord1 String sWord2 Returns Integer
26902>>>>>>>        Integer iLen1 iLen2
26902>>>>>>>        Integer iPos1 iPos2
26902>>>>>>>        Integer[][] aArray
26903>>>>>>>        Move (length(sWord1)) to iLen1
26904>>>>>>>        Move (length(sWord2)) to iLen2
26905>>>>>>>        If (iLen1=0 or iLen2=0) Function_Return 0
26908>>>>>>>        For iPos1 from 1 to iLen1
26914>>>>>>>>
26914>>>>>>>            Move 0 to aArray[iPos1][0]
26915>>>>>>>            For iPos2 from 1 to iLen2
26921>>>>>>>>
26921>>>>>>>                If (iPos1=1) Move 0 to aArray[0][iPos2]
26924>>>>>>>                If (mid(sWord1,1,iPos1)=mid(sWord2,1,iPos2)) Begin
26926>>>>>>>                    Move (aArray[iPos1-1][iPos2-1]+1) to aArray[iPos1][iPos2]
26927>>>>>>>                End
26927>>>>>>>>
26927>>>>>>>                Else If (aArray[iPos1-1][iPos2]>=aArray[iPos1][iPos2-1]) Begin
26930>>>>>>>                    Move aArray[iPos1-1][iPos2] to aArray[iPos1][iPos2]
26931>>>>>>>                End
26931>>>>>>>>
26931>>>>>>>                Else Begin
26932>>>>>>>                    Move aArray[iPos1][iPos2-1] to aArray[iPos1][iPos2]
26933>>>>>>>                End
26933>>>>>>>>
26933>>>>>>>            Loop
26934>>>>>>>>
26934>>>>>>>        Loop
26935>>>>>>>>
26935>>>>>>>        Function_Return aArray[iLen1][iLen2]
26936>>>>>>>    End_Function
26937>>>>>>>
26937>>>>>>>    //> Returns the number of faulty keystrokes needed for sWord1 to accidentally become sWord2 (called the "Levenshtein distance")
26937>>>>>>>    Function SpellingDistance String sWord1 String sWord2 Returns Integer
26939>>>>>>>        Integer iLCS iMaxLen
26939>>>>>>>        Move (length(sWord1) max length(sWord2)) to iMaxLen
26940>>>>>>>        Get LongestCommonSequence sWord1 sWord2 to iLCS
26941>>>>>>>        Function_Return (iMaxLen-iLCS)
26942>>>>>>>        Function_Return (Length(sWord1)+Length(sWord2)-iLCS-iLCS)
26943>>>>>>>    End_Function
26944>>>>>>>
26944>>>>>>>    Define GPW_VOCALS     for "aeiouy"
26944>>>>>>>    Define GPW_CONSONANTS for "bcdfghjklmnpqrstvwxz"
26944>>>>>>>
26944>>>>>>>    //> This function generates a password composed from a number of random syllables (consonant+vocal). The iLen
26944>>>>>>>    //> parameter specifues the number of syllables (and therefore half the length of the return value measured in characters)
26944>>>>>>>    Function GenerateRandomPassword Integer iLen Returns String
26946>>>>>>>        Integer iPos iPosV iPosC iLenV iLenC
26946>>>>>>>        String sRval
26946>>>>>>>        Move (Length(GPW_CONSONANTS)) to iLenC
26947>>>>>>>        Move (Length(GPW_VOCALS)) to iLenV
26948>>>>>>>        For iPos from 1 to iLen
26954>>>>>>>>
26954>>>>>>>            Move (Random(iLenC)) to iPosC
26955>>>>>>>            Move (Random(iLenV)) to iPosV
26956>>>>>>>            Move (sRval+Mid(GPW_CONSONANTS,1,iPosC+1)+Mid(GPW_VOCALS,1,iPosV+1)) to sRval
26957>>>>>>>        Loop
26958>>>>>>>>
26958>>>>>>>        Function_Return sRval
26959>>>>>>>    End_Function
26960>>>>>>>
26960>>>>>>>    Function QuickHtmlEncode String sValue Returns String
26962>>>>>>>        Integer iLen iPos
26962>>>>>>>        String sRval sChar
26962>>>>>>>        Move (Length(sValue)) to iLen
26963>>>>>>>        For iPos from 1 to iLen
26969>>>>>>>>
26969>>>>>>>            Move (Mid(sValue,1,iPos)) to sChar
26970>>>>>>>            If (sChar='"') Move (sRval+"&quot;") to sRval
26973>>>>>>>            Else If (sChar="&") Move (sRval+"&amp;") to sRval
26977>>>>>>>            Else If (sChar="<") Move (sRval+"&lt;") to sRval
26981>>>>>>>            Else If (sChar=">") Move (sRval+"&gt;") to sRval
26985>>>>>>>            Else Move (sRval+sChar) to sRval
26987>>>>>>>        Loop
26988>>>>>>>>
26988>>>>>>>        Function_Return sRval
26989>>>>>>>    End_Function
26990>>>>>>>    
26990>>>>>>>    Function MakeColumnNameNice String sLabel Returns String
26992>>>>>>>        Integer iPos iLen
26992>>>>>>>        String sRval sChar
26992>>>>>>>        If (sLabel=Uppercase(sLabel)) Begin
26994>>>>>>>            Move (Lowercase(sLabel)) to sLabel
26995>>>>>>>        End
26995>>>>>>>>
26995>>>>>>>        Move (Replaces("_",sLabel," ")) to sLabel
26996>>>>>>>        Move (Length(sLabel)) to iLen
26997>>>>>>>        Move (Left(sLabel,1)) to sRval
26998>>>>>>>        For iPos from 2 to iLen
27004>>>>>>>>
27004>>>>>>>            Move (Mid(sLabel,1,iPos)) to sChar
27005>>>>>>>            If (sChar=Uppercase(sChar)) Begin
27007>>>>>>>                Move (sRval+" ") to sRval
27008>>>>>>>            End
27008>>>>>>>>
27008>>>>>>>            Move (sRval+sChar) to sRval
27009>>>>>>>        Loop
27010>>>>>>>>
27010>>>>>>>        Move (Replaces("  ",sRval," ")) to sRval
27011>>>>>>>        Function_Return (UppercaseFirstLetters(Self,sRval))
27012>>>>>>>    End_Function
27013>>>>>>>    
27013>>>>>>>    Procedure StripQuotes String ByRef sValue
27015>>>>>>>        Integer iLen
27015>>>>>>>        String sFirst sLast
27015>>>>>>>        Move (Length(sValue)) to iLen
27016>>>>>>>        If (iLen>1) Begin
27018>>>>>>>            Move (Left(sValue,1)) to sFirst
27019>>>>>>>            Move (Right(sValue,1)) to sLast
27020>>>>>>>            If (("'"+'"') contains sFirst and sFirst=sLast) Begin
27022>>>>>>>                Move (Mid(sValue,iLen-2,2)) to sValue
27023>>>>>>>            End
27023>>>>>>>>
27023>>>>>>>        End
27023>>>>>>>>
27023>>>>>>>    End_Procedure
27024>>>>>>>    
27024>>>>>>>    Function AddQuotes String ByRef sValue String sQuoteToCharacterPreferred Returns Boolean
27026>>>>>>>        If (sQuoteToCharacterPreferred="") Begin
27028>>>>>>>            Move '"' to sQuoteToCharacterPreferred
27029>>>>>>>        End                           
27029>>>>>>>>
27029>>>>>>>        
27029>>>>>>>        If (Pos(sQuoteToCharacterPreferred,sValue)>0) Begin
27031>>>>>>>            Move (If(sQuoteToCharacterPreferred="'",'"',"'")) to sQuoteToCharacterPreferred
27032>>>>>>>        End
27032>>>>>>>>
27032>>>>>>>        If (Pos(sQuoteToCharacterPreferred,sValue)=0) Begin
27034>>>>>>>            Move (sQuoteToCharacterPreferred+sValue+sQuoteToCharacterPreferred) to sValue
27035>>>>>>>            Function_Return True
27036>>>>>>>        End
27036>>>>>>>>
27036>>>>>>>        Function_Return False
27037>>>>>>>    End_Function
27038>>>>>>>    
27038>>>>>>>End_Class
27039>>>>>>>
27039>>>>>>>Global_Variable Integer oStringFunctions
27039>>>>>>>
27039>>>>>>>Object _oStringFunctions is a cStringFunctions 
27041>>>>>>>    Move Self to oStringFunctions
27042>>>>>>>    // This only needs to be done once in the lifetime of the app. 
27042>>>>>>>    Get _CurrentCollateStringReversed to gStr$ReversedCollateString
27043>>>>>>>    Move (Repeat(" ",31)+gStr$ReversedCollateString) to gStr$ReversedCollateString
27044>>>>>>>End_Object
27045>>>>>Use StructFunctions.pkg
Including file: StructFunctions.pkg    (Z:\VmShare\Projects\WebQuery18-0\StureApsPublicLib\AppSrc\StructFunctions.pkg)
27045>>>>>>>//> StructFunction.pkg can be used to serialize structs into strings:
27045>>>>>>>//>
27045>>>>>>>//>    Function TableQueryToString tTableQuery strQ Returns String
27045>>>>>>>//>        String sTQ
27045>>>>>>>//>        Get VariantToString of oStructFunctions strQ to sTQ
27045>>>>>>>//>        Function_Return sTQ
27045>>>>>>>//>    End_Function
27045>>>>>>>//>
27045>>>>>>>//> Deserializing takes one extra step:
27045>>>>>>>//>
27045>>>>>>>//>    Function StringToTableQuery String sTQ Returns tTableQuery
27045>>>>>>>//>        tTableQuery strQ
27045>>>>>>>//>        tValueTree strValueTree
27045>>>>>>>//>        Get StringToValueTree of oStructFunctions sTQ to strValueTree
27045>>>>>>>//>        ValueTreeDeserializeParameter strValueTree to strQ
27045>>>>>>>//>        Function_Return strQ
27045>>>>>>>//>    End_Function
27045>>>>>>>//>
27045>>>>>>>//> If your purpose is to read and write structs to sequential files you
27045>>>>>>>//> may do it like this:
27045>>>>>>>//>
27045>>>>>>>//>    Send WriteVariant of oStructFunctions iChannel strQ
27045>>>>>>>//>
27045>>>>>>>//> And again, on the way back there is one extra step:
27045>>>>>>>//>
27045>>>>>>>//>    Function ReadTableQuery Integer iChannel Returns tTableQuery
27045>>>>>>>//>        tValueTree strValueTree
27045>>>>>>>//>        tTableQuery strQ
27045>>>>>>>//>        Send ReadValueTree of oStructFunctions iChannel (&strValueTree)
27045>>>>>>>//>        ValueTreeDeserializeParameter strValueTree to strQ
27045>>>>>>>//>        Function_Return strQ
27045>>>>>>>//>    End_Function
27045>>>>>>>//>
27045>>>>>>>//>
27045>>>>>>>//> NOTE:
27045>>>>>>>//>   1. these functions perform no checking on the string input. Things will go
27045>>>>>>>//>      wrong if values are deserialized into non-conformant structs.
27045>>>>>>>//>   2. not all simple member types can be handled this way. RowID for example
27045>>>>>>>//>      will not serialize.
27045>>>>>>>//>   3. when serializing to/from string max_argument_size must be taken into 
27045>>>>>>>//>      account. The read/write version does not have that issue.
27045>>>>>>>//>
27045>>>>>>>
27045>>>>>>>// Temporary mod to deal with changes in DF 18.0 until Sture does a proper version
27045>>>>>>>//Use cClientWebService.pkg // Struct tValueTree is defined in here
27045>>>>>>>
27045>>>>>>>    Struct tValueTree
27045>>>>>>>        String sValue
27045>>>>>>>        tValueTree[] children
27045>>>>>>>        tValueTree[] children
27045>>>>>>>    End_Struct
27045>>>>>>>
27045>>>>>>>Global_Variable Integer oStructFunctions
27045>>>>>>>
27045>>>>>>>Object _oStructFunctions is a cObject
27047>>>>>>>    Move Self to oStructFunctions
27048>>>>>>>
27048>>>>>>>    Procedure WriteValueTree Integer iChannel tValueTree strValueTree
27051>>>>>>>        Integer iLen iIndex iMax
27051>>>>>>>        Move (Length(strValueTree.sValue)) to iLen
27052>>>>>>>        Writeln channel iChannel iLen
27055>>>>>>>        Write strValueTree.sValue
27056>>>>>>>        Move (SizeOfArray(strValueTree.children)-1) to iMax
27057>>>>>>>        Writeln iMax
27059>>>>>>>        For iIndex from 0 to iMax
27065>>>>>>>>
27065>>>>>>>            Send WriteValueTree iChannel strValueTree.children[iIndex]
27066>>>>>>>        Loop
27067>>>>>>>>
27067>>>>>>>    End_Procedure
27068>>>>>>>
27068>>>>>>>    Procedure WriteVariant Integer iChannel Variant vValue
27071>>>>>>>        tValueTree strValueTree
27071>>>>>>>        tValueTree strValueTree
27071>>>>>>>        ValueTreeSerializeParameter vValue to strValueTree
27072>>>>>>>        Send WriteValueTree iChannel strValueTree
27073>>>>>>>    End_Procedure
27074>>>>>>>
27074>>>>>>>    Procedure ReadValueTree Integer iChannel tValueTree ByRef strValueTree
27077>>>>>>>        Integer iLen iIndex iMax
27077>>>>>>>        tValueTree strEmpty
27077>>>>>>>        tValueTree strEmpty
27077>>>>>>>        Readln channel iChannel iLen
27079>>>>>>>        Read_Block strValueTree.sValue iLen
27080>>>>>>>        Readln iMax
27081>>>>>>>        For iIndex from 0 to iMax
27087>>>>>>>>
27087>>>>>>>            Move strEmpty to strValueTree.children[iIndex]
27088>>>>>>>            Send ReadValueTree iChannel (&strValueTree.children[iIndex])
27089>>>>>>>        Loop
27090>>>>>>>>
27090>>>>>>>    End_Procedure
27091>>>>>>>
27091>>>>>>>            Procedure _VTTS_AppendValue String ByRef sCurrentString String sNewValue
27094>>>>>>>                Integer iLen
27094>>>>>>>                Move (Length(sNewValue)) to iLen
27095>>>>>>>                Move (sCurrentString+String(iLen)+","+sNewValue) to sCurrentString
27096>>>>>>>            End_Procedure
27097>>>>>>>
27097>>>>>>>            Procedure _VTTS_AppendValueTree String ByRef sCurrentString tValueTree strValueTree
27100>>>>>>>                Integer iIndex iMax
27100>>>>>>>                Send _VTTS_AppendValue (&sCurrentString) strValueTree.sValue
27101>>>>>>>                Move (SizeOfArray(strValueTree.children)-1) to iMax
27102>>>>>>>                Send _VTTS_AppendValue (&sCurrentString) iMax
27103>>>>>>>                For iIndex from 0 to iMax
27109>>>>>>>>
27109>>>>>>>                    Send _VTTS_AppendValueTree (&sCurrentString) strValueTree.children[iIndex]
27110>>>>>>>                Loop
27111>>>>>>>>
27111>>>>>>>            End_Procedure
27112>>>>>>>
27112>>>>>>>    //> Use this only for "small" to "moderate" size values of strValueTree. It is not too efficient.
27112>>>>>>>    Function ValueTreeToString tValueTree strValueTree Returns String
27115>>>>>>>        String sValue
27115>>>>>>>        Move "" to sValue
27116>>>>>>>        Send _VTTS_AppendValueTree (&sValue) strValueTree
27117>>>>>>>        Function_Return sValue
27118>>>>>>>    End_Function
27119>>>>>>>
27119>>>>>>>            Function _STVT_ReadValue String sCurrentString Integer ByRef iPos Returns String
27122>>>>>>>                Integer iIndex iMax iCommaPos iLen
27122>>>>>>>                Move (Pos(",",sCurrentString,iPos,10)) to iCommaPos
27123>>>>>>>                Move (Integer(Mid(sCurrentString,iCommaPos-iPos,iPos))) to iLen
27124>>>>>>>                Move (iCommaPos+1) to iPos
27125>>>>>>>                Move (iPos+iLen) to iPos
27126>>>>>>>                Function_Return (Mid(sCurrentString,iLen,iPos-iLen))
27127>>>>>>>            End_Function
27128>>>>>>>
27128>>>>>>>
27128>>>>>>>            Procedure _STVT_ReadValueTree tValueTree ByRef strValueTree String sCurrentString Integer ByRef iPos
27131>>>>>>>                Integer iIndex iMax
27131>>>>>>>                tValueTree strValueTreeEmpty
27131>>>>>>>                tValueTree strValueTreeEmpty
27131>>>>>>>                Get _STVT_ReadValue sCurrentString (&iPos) to strValueTree.sValue
27132>>>>>>>                Get _STVT_ReadValue sCurrentString (&iPos) to iMax
27133>>>>>>>                For iIndex from 0 to iMax
27139>>>>>>>>
27139>>>>>>>                    Move strValueTreeEmpty to strValueTree.children[iIndex]
27140>>>>>>>                    Send _STVT_ReadValueTree (&strValueTree.children[iIndex]) sCurrentString (&iPos)
27141>>>>>>>                Loop
27142>>>>>>>>
27142>>>>>>>            End_Procedure
27143>>>>>>>
27143>>>>>>>    //> Use this only for "small" to "moderate" size values of strValueTree. It is not too efficient.
27143>>>>>>>    Function StringToValueTree String sValue Returns tValueTree
27146>>>>>>>        Integer iPos
27146>>>>>>>        tValueTree strValueTree
27146>>>>>>>        tValueTree strValueTree
27146>>>>>>>        Move 1 to iPos
27147>>>>>>>        Send _STVT_ReadValueTree (&strValueTree) sValue (&iPos)
27148>>>>>>>        Function_Return strValueTree
27149>>>>>>>    End_Function
27150>>>>>>>
27150>>>>>>>    Function VariantToString Variant vValue Returns String
27153>>>>>>>        String sValue
27153>>>>>>>        tValueTree strValueTree
27153>>>>>>>        tValueTree strValueTree
27153>>>>>>>
27153>>>>>>>        ValueTreeSerializeParameter vValue to strValueTree
27154>>>>>>>        Get ValueTreeToString strValueTree to sValue
27155>>>>>>>
27155>>>>>>>        Function_Return sValue
27156>>>>>>>    End_Function
27157>>>>>>>
27157>>>>>>>//    Procedure StringToVariant String sValue Variant ByRef vValue
27157>>>>>>>//        Variant vLocalValue
27157>>>>>>>//        tValueTree strValueTree
27157>>>>>>>//
27157>>>>>>>//        Move vValue to vLocalValue // We'll work on a local copy
27157>>>>>>>//        
27157>>>>>>>//        Get StringToValueTree sValue to strValueTree
27157>>>>>>>//
27157>>>>>>>//        ValueTreeDeserializeParameter strValueTree to vLocalValue // Does not work
27157>>>>>>>//        Move vLocalValue to vValue
27157>>>>>>>//    End_Procedure
27157>>>>>>>
27157>>>>>>>//    Function ReadVariant Variant ByRef vValue Returns Boolean
27157>>>>>>>//        Integer iChannel
27157>>>>>>>//        Boolean bOk
27157>>>>>>>//        tValueTree strValueTree
27157>>>>>>>//
27157>>>>>>>//        Move False to bOk
27157>>>>>>>//        Get DirectInput of oFileFunctions ("binary:"+_FileName(Self)) to iChannel
27157>>>>>>>//        If (iChannel>=0) Begin
27157>>>>>>>//            Move True to bOk
27157>>>>>>>//            Send ReadValueTree iChannel (&strValueTree)
27157>>>>>>>//            Send CloseInput of oFileFunctions iChannel
27157>>>>>>>//            ValueTreeDeserializeParameter strValueTree to vValue // Does not work
27157>>>>>>>//        End
27157>>>>>>>//        Function_Return bOk
27157>>>>>>>//    End_Function
27157>>>>>>>
27157>>>>>>>        Function _IsIdenticalStructValue tValueTree strValueTree1 tValueTree strValueTree2 Returns Boolean
27160>>>>>>>            Integer iMax iIndex
27160>>>>>>>            If (strValueTree1.sValue<>strValueTree2.sValue) Begin
27162>>>>>>>                Function_Return False
27163>>>>>>>            End
27163>>>>>>>>
27163>>>>>>>            Move (SizeOfArray(strValueTree1.children)) to iMax
27164>>>>>>>            If (iMax<>SizeOfArray(strValueTree2.children)) Begin
27166>>>>>>>                Function_Return False
27167>>>>>>>            End
27167>>>>>>>>
27167>>>>>>>            Else Begin
27168>>>>>>>                Decrement iMax
27169>>>>>>>                For iIndex from 0 to iMax
27175>>>>>>>>
27175>>>>>>>                    If (not(_IsIdenticalStructValue(Self,strValueTree1.children[iIndex],strValueTree2.children[iIndex]))) Begin
27177>>>>>>>                        Function_Return False
27178>>>>>>>                    End
27178>>>>>>>>
27178>>>>>>>                Loop
27179>>>>>>>>
27179>>>>>>>            End
27179>>>>>>>>
27179>>>>>>>            Function_Return True
27180>>>>>>>        End_Function
27181>>>>>>>    
27181>>>>>>>    Function IsIdenticalStructValue Variant vValue1 Variant vValue2 Returns Boolean
27184>>>>>>>        tValueTree strValueTree1 strValueTree2
27184>>>>>>>        tValueTree strValueTree1 strValueTree2
27184>>>>>>>        ValueTreeSerializeParameter vValue1 to strValueTree1
27185>>>>>>>        ValueTreeSerializeParameter vValue2 to strValueTree2
27186>>>>>>>        Function_Return (_IsIdenticalStructValue(Self,strValueTree1,strValueTree2))
27187>>>>>>>    End_Function
27188>>>>>>>End_Object
27189>>>>>>>
27189>>>>>>>
27189>>>>>>>// Test:
27189>>>>>>>//
27189>>>>>>>//Struct tTest
27189>>>>>>>//    Integer iDirection
27189>>>>>>>//    String  sLabel
27189>>>>>>>//End_Struct
27189>>>>>>>//
27189>>>>>>>//Procedure test
27189>>>>>>>//    tTest strTest strTest2
27189>>>>>>>//    String sValue
27189>>>>>>>//    Move 3 to strTest.iDirection
27189>>>>>>>//    Move "west" to strTest.sLabel
27189>>>>>>>//    Get VariantToString of oStructFunctions strTest to sValue
27189>>>>>>>//    Move 2 to strTest.iDirection
27189>>>>>>>//    Move "north" to strTest.sLabel
27189>>>>>>>//    Move strTest to strTest2
27189>>>>>>>//    Send StringToVariant of oStructFunctions sValue (&strTest2) << - That can't work
27189>>>>>>>//End_Procedure
27189>>>>>>>//
27189>>>>>>>//Send test
27189>>>>>Use cExpressionParser.pkg
Including file: cExpressionParser.pkg    (Z:\VmShare\Projects\WebQuery18-0\StureApsPublicLib\AppSrc\cExpressionParser.pkg)
27189>>>>>>>//> The cExpressionParser implements Dijkstras Shunting-yard algorithm as described 
27189>>>>>>>//> here: http://en.wikipedia.org/wiki/Shunting-yard_algorithm.
27189>>>>>>>//>
27189>>>>>>>//><code> 
27189>>>>>>>//> Object oExpressionParser is a cExpressionParser
27189>>>>>>>//>     Procedure Demo
27189>>>>>>>//>         tXPGrammar strGrammar
27189>>>>>>>//>         tXPToken[] aSymbols
27189>>>>>>>//>         tXPError strError
27189>>>>>>>//>         tXPValue strResult
27189>>>>>>>//>     
27189>>>>>>>//>         // Get a grammer with operators and functions:
27189>>>>>>>//>         Get NewGrammar to strGrammar                  
27189>>>>>>>//> 
27189>>>>>>>//>         // Parse an expression into an array of symbols:
27189>>>>>>>//>         Get TokenizeString strGrammar '3+4*2/(1-5)^2^3' (&strError) to aSymbols
27189>>>>>>>//>
27189>>>>>>>//>         // Convert into "reverse polish notation" that can be used for evaluating the expression:
27189>>>>>>>//>         Get ReversePolishNotation strGrammar aSymbols (&strError) to aSymbols
27189>>>>>>>//>
27189>>>>>>>//>         // Evaluate the expression:
27189>>>>>>>//>         Get Evaluate strGrammar aSymbols (&strError) to strResult
27189>>>>>>>//> 
27189>>>>>>>//>         Send Info_Box (strResult.sValue+", type: "+String(strResult.iValueType))
27189>>>>>>>//>     End_Procedure
27189>>>>>>>//> End_Object
27189>>>>>>>//>
27189>>>>>>>//> Send Demo of oExpressionParser
27189>>>>>>>//></code>
27189>>>>>>>//>
27189>>>>>>>//> Extending the grammar
27189>>>>>>>//> ---------------------
27189>>>>>>>//>
27189>>>>>>>//>     real soon
27189>>>>>>>//>     
27189>>>>>>>//>     
27189>>>>>>>//> Class cMyExpressionParser is a cExpressionParser
27189>>>>>>>//> End_Class
27189>>>>>>>//>
27189>>>>>>>//>
27189>>>>>>>//>
27189>>>>>>>//> pkg.doc.end
27189>>>>>>>
27189>>>>>>>Use StackFunctions.pkg
Including file: StackFunctions.pkg    (Z:\VmShare\Projects\WebQuery18-0\StureApsPublicLib\AppSrc\StackFunctions.pkg)
27189>>>>>>>>>// Use StackFunctions.pkg // Define oStackFunctions object
27189>>>>>>>>>
27189>>>>>>>>>Use VdfBase.pkg // DAW package. Provides low level support expected of all VDF applications (windows and webapp)
27189>>>>>>>>>
27189>>>>>>>>>Global_Variable Integer oStackFunctions
27189>>>>>>>>>
27189>>>>>>>>>Object _oStackFunctions is a cObject
27191>>>>>>>>>    Move Self to oStackFunctions
27192>>>>>>>>>
27192>>>>>>>>>    // Boolean interface:
27192>>>>>>>>>    Procedure BooleanPush Boolean bValue Boolean[] ByRef aValues
27195>>>>>>>>>        Move bValue to aValues[SizeOfArray(aValues)]
27196>>>>>>>>>    End_Procedure
27197>>>>>>>>>    Function BooleanPop Boolean[] ByRef aValues Returns Boolean
27200>>>>>>>>>        Boolean bRval
27200>>>>>>>>>        Integer iSize
27200>>>>>>>>>        Move (SizeOfArray(aValues)) to iSize
27201>>>>>>>>>        Move aValues[iSize-1] to bRval
27202>>>>>>>>>        Move (ResizeArray(aValues,iSize-1)) to aValues
27203>>>>>>>>>        Function_Return bRval
27204>>>>>>>>>    End_Function
27205>>>>>>>>>    Function BooleanCopy Boolean[] aValues Returns Boolean
27208>>>>>>>>>        Function_Return aValues[SizeOfArray(aValues)-1]
27209>>>>>>>>>    End_Function
27210>>>>>>>>>    Function BooleanIsEmpty Boolean[] aValues Returns Boolean
27213>>>>>>>>>        Function_Return (SizeOfArray(aValues)=0)
27214>>>>>>>>>    End_Function
27215>>>>>>>>>    Function BooleanIsOnStack Boolean bValue Boolean[] aValues Returns Boolean
27218>>>>>>>>>        Integer iSearchItem
27218>>>>>>>>>        Move (SearchArray(bValue,aValues)) to iSearchItem
27219>>>>>>>>>        Function_Return (iSearchItem<>-1)
27220>>>>>>>>>    End_Function
27221>>>>>>>>>    Procedure BooleanDrop Boolean[] ByRef aValues
27224>>>>>>>>>        Integer iSize
27224>>>>>>>>>        Move (SizeOfArray(aValues)) to iSize
27225>>>>>>>>>        Move (ResizeArray(aValues,iSize-1)) to aValues
27226>>>>>>>>>    End_Procedure
27227>>>>>>>>>
27227>>>>>>>>>    // Integer interface:
27227>>>>>>>>>    Procedure IntegerPush Integer iValue Integer[] ByRef aValues
27230>>>>>>>>>        Move iValue to aValues[SizeOfArray(aValues)]
27231>>>>>>>>>    End_Procedure
27232>>>>>>>>>    Function IntegerPop Integer[] ByRef aValues Returns Integer
27235>>>>>>>>>        Integer iRval iSize
27235>>>>>>>>>        Move (SizeOfArray(aValues)) to iSize
27236>>>>>>>>>        Move aValues[iSize-1] to iRval
27237>>>>>>>>>        Move (ResizeArray(aValues,iSize-1)) to aValues
27238>>>>>>>>>        Function_Return iRval
27239>>>>>>>>>    End_Function
27240>>>>>>>>>    Function IntegerCopy Integer[] aValues Returns Integer
27243>>>>>>>>>        Function_Return aValues[SizeOfArray(aValues)-1]
27244>>>>>>>>>    End_Function
27245>>>>>>>>>    Function IntegerIsEmpty Integer[] aValues Returns Boolean
27248>>>>>>>>>        Function_Return (SizeOfArray(aValues)=0)
27249>>>>>>>>>    End_Function
27250>>>>>>>>>    Function IntegerIsOnStack Integer iValue Integer[] aValues Returns Boolean
27253>>>>>>>>>        Integer iSearchItem
27253>>>>>>>>>        Move (SearchArray(iValue,aValues)) to iSearchItem
27254>>>>>>>>>        Function_Return (iSearchItem<>-1)
27255>>>>>>>>>    End_Function
27256>>>>>>>>>    Procedure IntegerDrop Integer[] ByRef aValues
27259>>>>>>>>>        Integer iSize
27259>>>>>>>>>        Move (SizeOfArray(aValues)) to iSize
27260>>>>>>>>>        Move (ResizeArray(aValues,iSize-1)) to aValues
27261>>>>>>>>>    End_Procedure
27262>>>>>>>>>
27262>>>>>>>>>
27262>>>>>>>>>    Procedure IntegerRemoveDoublettes Integer[] ByRef aValues //> aValues must be sorted!
27265>>>>>>>>>        Integer iLengthMinusOne iPos
27265>>>>>>>>>        Move (SizeOfArray(aValues)-2) to iLengthMinusOne
27266>>>>>>>>>        Move 0 to iPos
27267>>>>>>>>>        While (iPos<iLengthMinusOne)
27271>>>>>>>>>            If (aValues[iPos]=aValues[iPos+1]) Begin
27273>>>>>>>>>                Move (RemoveFromArray(aValues,iPos+1)) to aValues
27274>>>>>>>>>            End
27274>>>>>>>>>>
27274>>>>>>>>>            Else Begin
27275>>>>>>>>>                Increment iPos
27276>>>>>>>>>            End
27276>>>>>>>>>>
27276>>>>>>>>>        Loop
27277>>>>>>>>>>
27277>>>>>>>>>    End_Procedure
27278>>>>>>>>>
27278>>>>>>>>>//    Procedure IntegerTopDrop Integer[] ByRef aValues
27278>>>>>>>>>//        Move (RemoveFromArray(aValues,SizeOfArray(aValues)-1)) to aValues
27278>>>>>>>>>//    End_Procedure
27278>>>>>>>>>//    Function IntegerTopDrop Integer[] aValues Returns Integer[]
27278>>>>>>>>>//        Function_Return (RemoveFromArray(aValues,SizeOfArray(aValues)-1))
27278>>>>>>>>>//    End_Function
27278>>>>>>>>>
27278>>>>>>>>>    // WHAT HAVE WE HERE? That's not a stack function!
27278>>>>>>>>>    // iOpCode=0: Logical AND,   1:Logical OR,   2: In Set1 but NOT in Set2
27278>>>>>>>>>    Function IntegerLogicalOperationSets Integer iOpCode Integer[] aValue1 Integer[] aValue2 Returns Integer[]
27281>>>>>>>>>        Integer iMax1 iMax2 iIndex1 iIndex2 iResultItem
27281>>>>>>>>>        Integer[] aResult
27282>>>>>>>>>
27282>>>>>>>>>        Move 0 to iIndex1
27283>>>>>>>>>        Move 0 to iIndex2
27284>>>>>>>>>        Move 0 to iResultItem
27285>>>>>>>>>        Move (SortArray(aValue1)) to aValue1
27286>>>>>>>>>        Move (SortArray(aValue2)) to aValue2
27287>>>>>>>>>        Move (SizeOfArray(aValue1)) to iMax1
27288>>>>>>>>>        Move (SizeOfArray(aValue2)) to iMax2
27289>>>>>>>>>
27289>>>>>>>>>        While (iIndex1<iMax1 or iIndex2<iMax2)
27293>>>>>>>>>            If (iIndex1<iMax1 and iIndex2<iMax2 and aValue1[iIndex1]=aValue2[iIndex2]) Begin // It occurs in both
27295>>>>>>>>>                If (iOpCode<>2) Begin
27297>>>>>>>>>                    Move aValue1[iIndex1] to aResult[iResultItem]
27298>>>>>>>>>                    Increment iResultItem
27299>>>>>>>>>                End
27299>>>>>>>>>>
27299>>>>>>>>>                Increment iIndex1
27300>>>>>>>>>                Increment iIndex2
27301>>>>>>>>>            End
27301>>>>>>>>>>
27301>>>>>>>>>            Else If (iIndex2=iMax2 or (iIndex1<iMax1 and aValue1[iIndex1]<aValue2[iIndex2])) Begin // It's only in array 1.
27304>>>>>>>>>                If (iOpCode<>0) Begin
27306>>>>>>>>>                    Move aValue1[iIndex1] to aResult[iResultItem]
27307>>>>>>>>>                    Increment iResultItem
27308>>>>>>>>>                End
27308>>>>>>>>>>
27308>>>>>>>>>                Increment iIndex1
27309>>>>>>>>>            End
27309>>>>>>>>>>
27309>>>>>>>>>            Else Begin // It's only in array 2.
27310>>>>>>>>>                If (iOpCode=1) Begin
27312>>>>>>>>>                    Move aValue2[iIndex2] to aResult[iResultItem]
27313>>>>>>>>>                    Increment iResultItem
27314>>>>>>>>>                End
27314>>>>>>>>>>
27314>>>>>>>>>                Increment iIndex2
27315>>>>>>>>>            End
27315>>>>>>>>>>
27315>>>>>>>>>        Loop
27316>>>>>>>>>>
27316>>>>>>>>>
27316>>>>>>>>>        Function_Return aResult
27317>>>>>>>>>    End_Function
27318>>>>>>>>>
27318>>>>>>>>>    Function IntegerAddToSet Integer[] ByRef aSet Integer iMember Returns Boolean
27321>>>>>>>>>        Integer iMax iIndex
27321>>>>>>>>>        Move (SizeOfArray(aSet)-1) to iMax
27322>>>>>>>>>        For iIndex from 0 to iMax
27328>>>>>>>>>>
27328>>>>>>>>>            If (iMember=aSet[iIndex]) Begin
27330>>>>>>>>>                Function_Return False
27331>>>>>>>>>            End
27331>>>>>>>>>>
27331>>>>>>>>>        Loop
27332>>>>>>>>>>
27332>>>>>>>>>        Move iMember to aSet[SizeOfArray(aSet)]
27333>>>>>>>>>        Function_Return True
27334>>>>>>>>>    End_Function
27335>>>>>>>>>
27335>>>>>>>>>    Function IntegerIsMember Integer[] aSet Integer iValue Returns Boolean
27338>>>>>>>>>        Integer iMax iIndex
27338>>>>>>>>>        Move (SizeOfArray(aSet)-1) to iMax
27339>>>>>>>>>        For iIndex from 0 to iMax
27345>>>>>>>>>>
27345>>>>>>>>>            If (iValue=aSet[iIndex]) Begin
27347>>>>>>>>>                Function_Return True
27348>>>>>>>>>            End
27348>>>>>>>>>>
27348>>>>>>>>>        Loop
27349>>>>>>>>>>
27349>>>>>>>>>        Function_Return False
27350>>>>>>>>>    End_Function
27351>>>>>>>>>
27351>>>>>>>>>    Procedure IntegerIncrement Integer[] ByRef aArray Integer iIndex
27354>>>>>>>>>        If (iIndex>=SizeOfArray(aArray)) Begin
27356>>>>>>>>>            Move (ResizeArray(aArray,iIndex+1)) to aArray
27357>>>>>>>>>        End
27357>>>>>>>>>>
27357>>>>>>>>>        Increment aArray[iIndex]
27358>>>>>>>>>    End_Procedure
27359>>>>>>>>>
27359>>>>>>>>>
27359>>>>>>>>>    // Number interface:
27359>>>>>>>>>    Procedure NumberPush Number nValue Number[] ByRef aValues
27362>>>>>>>>>        Move nValue to aValues[SizeOfArray(aValues)]
27363>>>>>>>>>    End_Procedure
27364>>>>>>>>>    Function NumberPop Number[] ByRef aValues Returns Number
27367>>>>>>>>>        Integer iSize
27367>>>>>>>>>        Number nRval 
27367>>>>>>>>>        Move (SizeOfArray(aValues)) to iSize
27368>>>>>>>>>        Move aValues[iSize-1] to nRval
27369>>>>>>>>>        Move (ResizeArray(aValues,iSize-1)) to aValues
27370>>>>>>>>>        Function_Return nRval
27371>>>>>>>>>    End_Function
27372>>>>>>>>>    Function NumberCopy Number[] aValues Returns Number
27375>>>>>>>>>        Function_Return aValues[SizeOfArray(aValues)-1]
27376>>>>>>>>>    End_Function
27377>>>>>>>>>    Function NumberIsEmpty Number[] aValues Returns Boolean
27380>>>>>>>>>        Function_Return (SizeOfArray(aValues)=0)
27381>>>>>>>>>    End_Function
27382>>>>>>>>>
27382>>>>>>>>>    Function NumberIsOnStack Number nValue Number[] aValues Returns Boolean
27385>>>>>>>>>        Integer iSearchItem
27385>>>>>>>>>        Move (SearchArray(nValue,aValues)) to iSearchItem
27386>>>>>>>>>        Function_Return (iSearchItem<>-1)
27387>>>>>>>>>    End_Function
27388>>>>>>>>>
27388>>>>>>>>>    Function NumberAddToSet Number[] ByRef aSet Number nMember Returns Boolean
27391>>>>>>>>>        Integer iMax iIndex
27391>>>>>>>>>        Move (SizeOfArray(aSet)-1) to iMax
27392>>>>>>>>>        For iIndex from 0 to iMax
27398>>>>>>>>>>
27398>>>>>>>>>            If (nMember=aSet[iIndex]) Begin
27400>>>>>>>>>                Function_Return False
27401>>>>>>>>>            End
27401>>>>>>>>>>
27401>>>>>>>>>        Loop
27402>>>>>>>>>>
27402>>>>>>>>>        Move nMember to aSet[SizeOfArray(aSet)]
27403>>>>>>>>>        Function_Return True
27404>>>>>>>>>    End_Function
27405>>>>>>>>>
27405>>>>>>>>>    Procedure NumberDrop Number[] ByRef aValues
27408>>>>>>>>>        Integer iSize
27408>>>>>>>>>        Move (SizeOfArray(aValues)) to iSize
27409>>>>>>>>>        Move (ResizeArray(aValues,iSize-1)) to aValues
27410>>>>>>>>>    End_Procedure
27411>>>>>>>>>
27411>>>>>>>>>
27411>>>>>>>>>    Procedure NumberRemoveDoublettes Number[] ByRef aValues //> aValues must be sorted!
27414>>>>>>>>>        Integer iLengthMinusOne iPos
27414>>>>>>>>>        Move (SizeOfArray(aValues)-2) to iLengthMinusOne
27415>>>>>>>>>        Move 0 to iPos
27416>>>>>>>>>        While (iPos<iLengthMinusOne)
27420>>>>>>>>>            If (aValues[iPos]=aValues[iPos+1]) Begin
27422>>>>>>>>>                Move (RemoveFromArray(aValues,iPos+1)) to aValues
27423>>>>>>>>>            End
27423>>>>>>>>>>
27423>>>>>>>>>            Else Begin
27424>>>>>>>>>                Increment iPos
27425>>>>>>>>>            End
27425>>>>>>>>>>
27425>>>>>>>>>        Loop
27426>>>>>>>>>>
27426>>>>>>>>>    End_Procedure
27427>>>>>>>>>
27427>>>>>>>>>//    Procedure NumberTopDrop Number[] ByRef aValues
27427>>>>>>>>>//        Move (RemoveFromArray(aValues,SizeOfArray(aValues)-1)) to aValues
27427>>>>>>>>>//    End_Procedure
27427>>>>>>>>>//    Function NumberTopDrop Number[] aValues Returns Number[]
27427>>>>>>>>>//        Function_Return (RemoveFromArray(aValues,SizeOfArray(aValues)-1))
27427>>>>>>>>>//    End_Function
27427>>>>>>>>>
27427>>>>>>>>>    // WHAT HAVE WE HERE? That's not a stack function!
27427>>>>>>>>>    // iOpCode=0: Logical AND,   1:Logical OR,   2: In Set1 but NOT in Set2
27427>>>>>>>>>    Function NumberLogicalOperationSets Integer iOpCode Number[] aValue1 Number[] aValue2 Returns Number[]
27430>>>>>>>>>        Integer iMax1 iMax2 iIndex1 iIndex2 iResultItem
27430>>>>>>>>>        Number[] aResult
27431>>>>>>>>>
27431>>>>>>>>>        Move 0 to iIndex1
27432>>>>>>>>>        Move 0 to iIndex2
27433>>>>>>>>>        Move 0 to iResultItem
27434>>>>>>>>>        Move (SortArray(aValue1)) to aValue1
27435>>>>>>>>>        Move (SortArray(aValue2)) to aValue2
27436>>>>>>>>>        Move (SizeOfArray(aValue1)) to iMax1
27437>>>>>>>>>        Move (SizeOfArray(aValue2)) to iMax2
27438>>>>>>>>>
27438>>>>>>>>>        While (iIndex1<iMax1 or iIndex2<iMax2)
27442>>>>>>>>>            If (iIndex1<iMax1 and iIndex2<iMax2 and aValue1[iIndex1]=aValue2[iIndex2]) Begin // It occurs in both
27444>>>>>>>>>                If (iOpCode<>2) Begin
27446>>>>>>>>>                    Move aValue1[iIndex1] to aResult[iResultItem]
27447>>>>>>>>>                    Increment iResultItem
27448>>>>>>>>>                End
27448>>>>>>>>>>
27448>>>>>>>>>                Increment iIndex1
27449>>>>>>>>>                Increment iIndex2
27450>>>>>>>>>            End
27450>>>>>>>>>>
27450>>>>>>>>>            Else If (iIndex2=iMax2 or (iIndex1<iMax1 and aValue1[iIndex1]<aValue2[iIndex2])) Begin // It's only in array 1.
27453>>>>>>>>>                If (iOpCode<>0) Begin
27455>>>>>>>>>                    Move aValue1[iIndex1] to aResult[iResultItem]
27456>>>>>>>>>                    Increment iResultItem
27457>>>>>>>>>                End
27457>>>>>>>>>>
27457>>>>>>>>>                Increment iIndex1
27458>>>>>>>>>            End
27458>>>>>>>>>>
27458>>>>>>>>>            Else Begin // It's only in array 2.
27459>>>>>>>>>                If (iOpCode=1) Begin
27461>>>>>>>>>                    Move aValue2[iIndex2] to aResult[iResultItem]
27462>>>>>>>>>                    Increment iResultItem
27463>>>>>>>>>                End
27463>>>>>>>>>>
27463>>>>>>>>>                Increment iIndex2
27464>>>>>>>>>            End
27464>>>>>>>>>>
27464>>>>>>>>>        Loop
27465>>>>>>>>>>
27465>>>>>>>>>
27465>>>>>>>>>        Function_Return aResult
27466>>>>>>>>>    End_Function
27467>>>>>>>>>
27467>>>>>>>>>    Function NumberAddToSet Number[] ByRef aSet Number nValue Returns Boolean
27470>>>>>>>>>        Integer iMax iIndex
27470>>>>>>>>>        Move (SizeOfArray(aSet)-1) to iMax
27471>>>>>>>>>        For iIndex from 0 to iMax
27477>>>>>>>>>>
27477>>>>>>>>>            If (nValue=aSet[iIndex]) Begin
27479>>>>>>>>>                Function_Return False
27480>>>>>>>>>            End
27480>>>>>>>>>>
27480>>>>>>>>>        Loop
27481>>>>>>>>>>
27481>>>>>>>>>        Move nValue to aSet[SizeOfArray(aSet)]
27482>>>>>>>>>        Function_Return True
27483>>>>>>>>>    End_Function
27484>>>>>>>>>
27484>>>>>>>>>    Function NumberIsMember Number[] aSet Number nValue Returns Boolean
27487>>>>>>>>>        Integer iMax iIndex
27487>>>>>>>>>        Move (SizeOfArray(aSet)-1) to iMax
27488>>>>>>>>>        For iIndex from 0 to iMax
27494>>>>>>>>>>
27494>>>>>>>>>            If (nValue=aSet[iIndex]) Begin
27496>>>>>>>>>                Function_Return True
27497>>>>>>>>>            End
27497>>>>>>>>>>
27497>>>>>>>>>        Loop
27498>>>>>>>>>>
27498>>>>>>>>>        Function_Return False
27499>>>>>>>>>    End_Function
27500>>>>>>>>>
27500>>>>>>>>>
27500>>>>>>>>>    Function StringAddToSet String[] ByRef aSet String sMember Returns Boolean
27503>>>>>>>>>        Integer iMax iIndex
27503>>>>>>>>>        Move (SizeOfArray(aSet)-1) to iMax
27504>>>>>>>>>        For iIndex from 0 to iMax
27510>>>>>>>>>>
27510>>>>>>>>>            If (sMember=aSet[iIndex]) Begin
27512>>>>>>>>>                Function_Return False
27513>>>>>>>>>            End
27513>>>>>>>>>>
27513>>>>>>>>>        Loop
27514>>>>>>>>>>
27514>>>>>>>>>        Move sMember to aSet[SizeOfArray(aSet)]
27515>>>>>>>>>        Function_Return True
27516>>>>>>>>>    End_Function
27517>>>>>>>>>    
27517>>>>>>>>>    Function StringRemoveFromSet String[] ByRef aSet String sMember Returns Boolean
27520>>>>>>>>>        Integer iMax iIndex
27520>>>>>>>>>        Move (SizeOfArray(aSet)-1) to iMax
27521>>>>>>>>>        For iIndex from 0 to iMax
27527>>>>>>>>>>
27527>>>>>>>>>            If (sMember=aSet[iIndex]) Begin
27529>>>>>>>>>                Move (RemoveFromArray(aSet,iIndex)) to aSet
27530>>>>>>>>>                Function_Return True
27531>>>>>>>>>            End
27531>>>>>>>>>>
27531>>>>>>>>>        Loop
27532>>>>>>>>>>
27532>>>>>>>>>        Function_Return False
27533>>>>>>>>>    End_Function
27534>>>>>>>>>
27534>>>>>>>>>
27534>>>>>>>>>    // String interface
27534>>>>>>>>>    Procedure StringPush String sValue String[] ByRef aValues
27537>>>>>>>>>        Move sValue to aValues[SizeOfArray(aValues)]
27538>>>>>>>>>    End_Procedure
27539>>>>>>>>>    Function StringPop String[] ByRef aValues Returns String
27542>>>>>>>>>        Integer iSize
27542>>>>>>>>>        String sRval
27542>>>>>>>>>        Move (SizeOfArray(aValues)) to iSize
27543>>>>>>>>>        Move aValues[iSize-1] to sRval
27544>>>>>>>>>        Move (ResizeArray(aValues,iSize-1)) to aValues
27545>>>>>>>>>        Function_Return sRval
27546>>>>>>>>>    End_Function
27547>>>>>>>>>    Function StringCopy String[] aValues Returns String
27550>>>>>>>>>        Function_Return aValues[SizeOfArray(aValues)-1]
27551>>>>>>>>>    End_Function
27552>>>>>>>>>    Function StringIsEmpty String[] aValues Returns Boolean
27555>>>>>>>>>        Function_Return (SizeOfArray(aValues)=0)
27556>>>>>>>>>    End_Function
27557>>>>>>>>>    Function StringIsOnStack String sValue String[] aValues Returns Boolean
27560>>>>>>>>>        Integer iSearchItem
27560>>>>>>>>>        Move (SearchArray(sValue,aValues)) to iSearchItem
27561>>>>>>>>>        Function_Return (iSearchItem<>-1)
27562>>>>>>>>>    End_Function
27563>>>>>>>>>    Procedure StringDrop String[] ByRef aValues
27566>>>>>>>>>        Integer iSize
27566>>>>>>>>>        Move (SizeOfArray(aValues)) to iSize
27567>>>>>>>>>        Move (ResizeArray(aValues,iSize-1)) to aValues
27568>>>>>>>>>    End_Procedure
27569>>>>>>>>>    
27569>>>>>>>>>
27569>>>>>>>>>    Procedure StringRemoveDoublettes String[] ByRef aValues //> aValues must be sorted!
27572>>>>>>>>>        Integer iLengthMinusOne iPos
27572>>>>>>>>>        Move (SizeOfArray(aValues)-2) to iLengthMinusOne
27573>>>>>>>>>        Move 0 to iPos
27574>>>>>>>>>        While (iPos<iLengthMinusOne)
27578>>>>>>>>>            If (aValues[iPos]=aValues[iPos+1]) Begin
27580>>>>>>>>>                Move (RemoveFromArray(aValues,iPos+1)) to aValues
27581>>>>>>>>>            End
27581>>>>>>>>>>
27581>>>>>>>>>            Else Begin
27582>>>>>>>>>                Increment iPos
27583>>>>>>>>>            End
27583>>>>>>>>>>
27583>>>>>>>>>        Loop
27584>>>>>>>>>>
27584>>>>>>>>>    End_Procedure
27585>>>>>>>>>
27585>>>>>>>>>    
27585>>>>>>>>>//    Procedure StringTopDrop String[] ByRef aValues
27585>>>>>>>>>//        Move (RemoveFromArray(aValues,SizeOfArray(aValues)-1)) to aValues
27585>>>>>>>>>//    End_Procedure
27585>>>>>>>>>//    Function StringTopDrop String[] aValues Returns String[]
27585>>>>>>>>>//        Function_Return (RemoveFromArray(aValues,SizeOfArray(aValues)-1))
27585>>>>>>>>>//    End_Function
27585>>>>>>>>>
27585>>>>>>>>>    // Handle interface
27585>>>>>>>>>    Procedure HandlePush Handle hValue Handle[] ByRef aValues
27588>>>>>>>>>        Move hValue to aValues[SizeOfArray(aValues)]
27589>>>>>>>>>    End_Procedure
27590>>>>>>>>>    Function HandlePop Handle[] ByRef aValues Returns Handle
27593>>>>>>>>>        Integer iSize
27593>>>>>>>>>        Handle hRval
27593>>>>>>>>>        Move (SizeOfArray(aValues)) to iSize
27594>>>>>>>>>        Move aValues[iSize-1] to hRval
27595>>>>>>>>>        Move (ResizeArray(aValues,iSize-1)) to aValues
27596>>>>>>>>>        Function_Return hRval
27597>>>>>>>>>    End_Function
27598>>>>>>>>>    Function HandleCopy Handle[] aValues Returns Handle
27601>>>>>>>>>        Function_Return aValues[SizeOfArray(aValues)-1]
27602>>>>>>>>>    End_Function
27603>>>>>>>>>    Function HandleIsEmpty Handle[] aValues Returns Boolean
27606>>>>>>>>>        Function_Return (SizeOfArray(aValues)=0)
27607>>>>>>>>>    End_Function
27608>>>>>>>>>    Function HandleIsOnStack Handle hValue Handle[] aValues Returns Boolean
27611>>>>>>>>>        Integer iSearchItem
27611>>>>>>>>>        Move (SearchArray(hValue,aValues)) to iSearchItem
27612>>>>>>>>>        Function_Return (iSearchItem<>-1)
27613>>>>>>>>>    End_Function
27614>>>>>>>>>    Procedure HandleDrop Handle[] ByRef aValues
27617>>>>>>>>>        Integer iSize
27617>>>>>>>>>        Move (SizeOfArray(aValues)) to iSize
27618>>>>>>>>>        Move (ResizeArray(aValues,iSize-1)) to aValues
27619>>>>>>>>>    End_Procedure
27620>>>>>>>>>End_Object
27621>>>>>>>Use DateFunctions.pkg
Including file: DateFunctions.pkg    (Z:\VmShare\Projects\WebQuery18-0\StureApsPublicLib\AppSrc\DateFunctions.pkg)
27621>>>>>>>>>// Use DateFunctions.pkg // Define oDateFunctions object
27621>>>>>>>>>
27621>>>>>>>>>Use VdfBase.pkg // DAW package. Provides low level support expected of all VDF applications (windows and webapp)
27621>>>>>>>>>
27621>>>>>>>>>Use StringFunctions.pkg // Define oStringFunctions object
27621>>>>>>>>>
27621>>>>>>>>>Use DatesLD.pkg // Language dictionary for day and month names
Including file: DatesLD.pkg    (Z:\VmShare\Projects\WebQuery18-0\StureApsPublicLib\AppSrc\DatesLD.pkg)
27621>>>>>>>>>>>Use LanguageDictionary.pkg
Including file: LanguageDictionary.pkg    (Z:\VmShare\Projects\WebQuery18-0\StureApsPublicLib\AppSrc\LanguageDictionary.pkg)
27621>>>>>>>>>>>>>// Use LanguageDictionary.pkg // cLanguageDictionary class and oLanguageFunctions object
27621>>>>>>>>>>>>>
27621>>>>>>>>>>>>>Use VdfBase.pkg // DAW package. Provides low level support expected of all VDF applications (windows and webapp)
27621>>>>>>>>>>>>>
27621>>>>>>>>>>>>>Use Language.pkg
Including file: Language.pkg    (Z:\VmShare\Projects\WebQuery18-0\StureApsPublicLib\AppSrc\Language.pkg)
27621>>>>>>>>>>>>>>>// Use Language     // Default language setup
27621>>>>>>>>>>>>>>>// Sets default languange
27621>>>>>>>>>>>>>>>
27621>>>>>>>>>>>>>>>Use LangSymb.pkg // Language symbols
Including file: LangSymb.pkg    (Z:\VmShare\Projects\WebQuery18-0\StureApsPublicLib\AppSrc\LangSymb.pkg)
27621>>>>>>>>>>>>>>>>>// Use LangSymb.pkg // Language symbols
27621>>>>>>>>>>>>>>>>>//
27621>>>>>>>>>>>>>>>>>// This package file is part of FreeLib.
27621>>>>>>>>>>>>>>>>>
27621>>>>>>>>>>>>>>>>>define LNG_DUTCH       for  0  // 131
27621>>>>>>>>>>>>>>>>>define LNG_FRENCH      for  1  // 133
27621>>>>>>>>>>>>>>>>>define LNG_SPANISH     for  2  // 134
27621>>>>>>>>>>>>>>>>>define LNG_ITALIAN     for  3  // 139 // NOT TRANSLATED. DO NOT SELECT!
27621>>>>>>>>>>>>>>>>>define LNG_ENGLISH     for  4  // 144
27621>>>>>>>>>>>>>>>>>define LNG_DANISH      for  5  // 145
27621>>>>>>>>>>>>>>>>>define LNG_SWEDISH     for  6  // 146
27621>>>>>>>>>>>>>>>>>define LNG_NORWEGIAN   for  7  // 147
27621>>>>>>>>>>>>>>>>>define LNG_GERMAN      for  8  // 149
27621>>>>>>>>>>>>>>>>>define LNG_PORTUGUESE  for  9  // 155
27621>>>>>>>>>>>>>>>>>define LNG_PAPIAMENTU  for 10  // 199 // NOT TRANSLATED. DO NOT SELECT!
27621>>>>>>>>>>>>>>>>>define LNG_MAX         for 11  // Points one higher than the highest language
27621>>>>>>>>>>>>>>>
27621>>>>>>>>>>>>>>> define LNG_DEFAULT for LNG_ENGLISH // <-- Change default language here
27621>>>>>>>>>>>>>>>
27621>>>>>>>>>>>>>>>  define _LANGUAGE_ for $ENGLISH$
27621>>>>>>>>>>>>>>>
#REM LANGUAGE SET BY LANGUAGE.PKG: $ENGLISH$
27621>>>>>>>>>>>>>>>
27621>>>>>>>>>>>>>>>
27621>>>>>>>>>>>>>>>Integer giLanguage
27621>>>>>>>>>>>>>>>Move LNG_DEFAULT to giLanguage
27622>>>>>>>>>>>>>>>
27622>>>>>>>>>>>>>
27622>>>>>>>>>>>>>Struct tTranslateResult // The return type of a symbol translation
27622>>>>>>>>>>>>>    String  sResult          // The translated value to print or display
27622>>>>>>>>>>>>>    Boolean bOptimize        // TRUE if symbol should be updated
27622>>>>>>>>>>>>>    String  sOptimizedLookup // An optimized symbol (faster to translate)
27622>>>>>>>>>>>>>End_Struct
27622>>>>>>>>>>>>>
27622>>>>>>>>>>>>>Struct tSupLng // Supported language. Which language is determined by its position in an array
27622>>>>>>>>>>>>>    Boolean bActive // TRUE if the language is supported by the application
27622>>>>>>>>>>>>>    Integer iIndex  // Index value to use in language dictionaries for retrieving translated value
27622>>>>>>>>>>>>>End_Struct
27622>>>>>>>>>>>>>
27622>>>>>>>>>>>>>Struct tLngDictListItem // An array of elements of this type holds a list of all language dictionaries in the application.
27622>>>>>>>>>>>>>    Integer hDictionary    // A handle for a alnguage dictionary object
27622>>>>>>>>>>>>>    String  sDictionaryId  // A copy of the unique id that identifies the language dictionary object.
27622>>>>>>>>>>>>>End_Struct
27622>>>>>>>>>>>>>
27622>>>>>>>>>>>>>Struct tLngDictSymbol // Type of a symbol in a language dictionary object
27622>>>>>>>>>>>>>    String sSymbol             // Symbol to be translated ("save")
27622>>>>>>>>>>>>>    String sDefaultTranslation // Default translation if LNG_DEFAULT is not part of the compressed array defined by oSupportedLanguages
27622>>>>>>>>>>>>>    String[] sTranslations     // Array of translations.
27622>>>>>>>>>>>>>End_Struct
27622>>>>>>>>>>>>>
27622>>>>>>>>>>>>>//> Language.pkg defines a global integer called giLanguage that identifies the language currently
27622>>>>>>>>>>>>>//> "spoken" by the application. The cLanguageDictionary class defined in this package internally needs to
27622>>>>>>>>>>>>>//> translate the value of giLanguage into a "compressed index" value (it is compressed because it can only
27622>>>>>>>>>>>>>//> point to the languages supported by this particular application). This compressed value is stored in the
27622>>>>>>>>>>>>>//> global integer gi$CmprLngIdx
27622>>>>>>>>>>>>>  Global_Variable Integer gi$CmprLngIdx
27622>>>>>>>>>>>>>
27622>>>>>>>>>>>>>Class _cLanguageFunctions is a cObject
27623>>>>>>>>>>>>>    Procedure construct_object
27625>>>>>>>>>>>>>        Forward Send Construct_Object
27627>>>>>>>>>>>>>
27627>>>>>>>>>>>>>        // After the first cLanguageDictionary object has been declared, it is no longer
27627>>>>>>>>>>>>>        // possible to add languages that should be supported (via DoAddLanguage).
27627>>>>>>>>>>>>>        Property Boolean _StopForAddingLanguages False
27628>>>>>>>>>>>>>
27628>>>>>>>>>>>>>        // The paLanguages property determines what languages are supported in the
27628>>>>>>>>>>>>>        // application at hand. The purpose of this is to compress the arrays that holds
27628>>>>>>>>>>>>>        // language dependant values and to make sure that un-needed values aren't loaded.
27628>>>>>>>>>>>>>        Property tSupLng[] paLanguages
27629>>>>>>>>>>>>>
27629>>>>>>>>>>>>>        Property Integer _piCounter 0
27630>>>>>>>>>>>>>
27630>>>>>>>>>>>>>        // This property holds references to all cLanguageDictionary objects
27630>>>>>>>>>>>>>        // declared in the application. It is because of this property that the function
27630>>>>>>>>>>>>>        // translate_value is able to find the correct dictionary to handle a given translation.
27630>>>>>>>>>>>>>        Property tLngDictListItem[] _paLngDictList
27631>>>>>>>>>>>>>
27631>>>>>>>>>>>>>        Send _OnInitializeObject
27632>>>>>>>>>>>>>    End_Procedure
27633>>>>>>>>>>>>>
27633>>>>>>>>>>>>>            Procedure _OnInitializeObject
27635>>>>>>>>>>>>>                Integer iLng
27635>>>>>>>>>>>>>                tSupLng sLanguage
27635>>>>>>>>>>>>>                tSupLng sLanguage
27635>>>>>>>>>>>>>                tSupLng[] aLanguages
27635>>>>>>>>>>>>>                tSupLng[] aLanguages
27636>>>>>>>>>>>>>                Move False to sLanguage.bActive
27637>>>>>>>>>>>>>                Move -1 to sLanguage.iIndex
27638>>>>>>>>>>>>>                Move (ResizeArray(aLanguages,LNG_MAX,sLanguage)) to aLanguages
27639>>>>>>>>>>>>>                Set paLanguages to aLanguages
27640>>>>>>>>>>>>>                Send DoAddLanguage LNG_DEFAULT
27641>>>>>>>>>>>>>                Set CurrentLanguage to LNG_DEFAULT
27642>>>>>>>>>>>>>            End_Procedure
27643>>>>>>>>>>>>>
27643>>>>>>>>>>>>>    //> All languages that must be supported by the application at hand msut be added by this method. And this must be done before
27643>>>>>>>>>>>>>    //> the first translation is done. The reason is that only the languages supposed to be supported by the application are read
27643>>>>>>>>>>>>>    //> into memory on calling OnDefineSymbols.
27643>>>>>>>>>>>>>    Procedure DoAddLanguage Integer iLng
27645>>>>>>>>>>>>>        Integer iCount iSize
27645>>>>>>>>>>>>>        tSupLng[] aLanguages
27645>>>>>>>>>>>>>        tSupLng[] aLanguages
27646>>>>>>>>>>>>>        If (_StopForAddingLanguages(Self)) Error 783 "Languages cannot be added after cLanguageDictionary objects has been added"
27649>>>>>>>>>>>>>        Else Begin
27650>>>>>>>>>>>>>            Get paLanguages to aLanguages
27651>>>>>>>>>>>>>            Move (SizeOfArray(aLanguages)) to iSize
27652>>>>>>>>>>>>>            If (iLng>=iSize or aLanguages[iLng].bActive=False) Begin
27654>>>>>>>>>>>>>                 Get _piCounter to iCount
27655>>>>>>>>>>>>>                 Move iCount to aLanguages[iLng].iIndex
27656>>>>>>>>>>>>>                 Move True to aLanguages[iLng].bActive
27657>>>>>>>>>>>>>                 Set _piCounter to (iCount+1)
27658>>>>>>>>>>>>>                 Set paLanguages to aLanguages
27659>>>>>>>>>>>>>             End
27659>>>>>>>>>>>>>>
27659>>>>>>>>>>>>>         End
27659>>>>>>>>>>>>>>
27659>>>>>>>>>>>>>    End_Procedure
27660>>>>>>>>>>>>>
27660>>>>>>>>>>>>>    //
27660>>>>>>>>>>>>>    Procedure Set CurrentLanguage Integer iLng
27662>>>>>>>>>>>>>        Move iLng to giLanguage
27663>>>>>>>>>>>>>        Get _IndexToCompressedIndex iLng to gi$CmprLngIdx
27664>>>>>>>>>>>>>    End_Procedure
27665>>>>>>>>>>>>>
27665>>>>>>>>>>>>>    Function CurrentLanguage Returns Integer
27667>>>>>>>>>>>>>        Integer iMax iIndex
27667>>>>>>>>>>>>>        tSupLng[] aLanguages
27667>>>>>>>>>>>>>        tSupLng[] aLanguages
27668>>>>>>>>>>>>>        Get paLanguages to aLanguages
27669>>>>>>>>>>>>>        Move (SizeOfArray(aLanguages)-1) to iMax
27670>>>>>>>>>>>>>        For iIndex from 0 to iMax
27676>>>>>>>>>>>>>>
27676>>>>>>>>>>>>>            If (aLanguages[iIndex].iIndex=gi$CmprLngIdx) Function_Return iIndex
27679>>>>>>>>>>>>>        Loop
27680>>>>>>>>>>>>>>
27680>>>>>>>>>>>>>        Function_Return -1
27681>>>>>>>>>>>>>    End_Function
27682>>>>>>>>>>>>>
27682>>>>>>>>>>>>>    // This may be used by a language selector or by a page where it's possible
27682>>>>>>>>>>>>>    // to edit the values in a database.
27682>>>>>>>>>>>>>    Procedure CallbackSupportedLanguages Integer hMsg Integer hObj
27684>>>>>>>>>>>>>        Integer iMax iLng
27684>>>>>>>>>>>>>        tSupLng[] aLanguages
27684>>>>>>>>>>>>>        tSupLng[] aLanguages
27685>>>>>>>>>>>>>        Get paLanguages to aLanguages
27686>>>>>>>>>>>>>        Move (SizeOfArray(aLanguages)-1) to iMax
27687>>>>>>>>>>>>>        For iLng from 0 to iMax
27693>>>>>>>>>>>>>>
27693>>>>>>>>>>>>>            If (aLanguages[iLng].bActive) Send hMsg of hObj iLng
27696>>>>>>>>>>>>>        Loop
27697>>>>>>>>>>>>>>
27697>>>>>>>>>>>>>    End_Procedure
27698>>>>>>>>>>>>>
27698>>>>>>>>>>>>>    Procedure CallbackDictionaries Integer hMsg Integer hObj
27700>>>>>>>>>>>>>        Integer iMax iIndex
27700>>>>>>>>>>>>>        tLngDictListItem[] aLngDictList
27700>>>>>>>>>>>>>        tLngDictListItem[] aLngDictList
27701>>>>>>>>>>>>>        Get _paLngDictList to aLngDictList
27702>>>>>>>>>>>>>        Move (SizeOfArray(aLngDictList)-1) to iMax
27703>>>>>>>>>>>>>        For iIndex from 0 to iMax
27709>>>>>>>>>>>>>>
27709>>>>>>>>>>>>>            Send hMsg of hObj aLngDictList[iIndex].sDictionaryId aLngDictList[iIndex].hDictionary
27710>>>>>>>>>>>>>        Loop
27711>>>>>>>>>>>>>>
27711>>>>>>>>>>>>>    End_Procedure
27712>>>>>>>>>>>>>
27712>>>>>>>>>>>>>            Function _IndexToCompressedIndex Integer iLng Returns Integer
27714>>>>>>>>>>>>>                tSupLng[] aLanguages
27714>>>>>>>>>>>>>                tSupLng[] aLanguages
27715>>>>>>>>>>>>>                Get paLanguages to aLanguages
27716>>>>>>>>>>>>>                if (SizeOfArray(aLanguages)>iLng) Function_Return aLanguages[iLng].iIndex
27719>>>>>>>>>>>>>                Function_Return 0
27720>>>>>>>>>>>>>            End_Function
27721>>>>>>>>>>>>>
27721>>>>>>>>>>>>>                     Function _Compare_LngDictListItem tLngDictListItem sVal1 tLngDictListItem sVal2 Returns Integer
27723>>>>>>>>>>>>>                         If (sVal1.sDictionaryId>sVal2.sDictionaryId) Function_Return (GT)
27726>>>>>>>>>>>>>                         If (sVal1.sDictionaryId=sVal2.sDictionaryId) Function_Return (EQ)
27729>>>>>>>>>>>>>                         Function_Return (LT)
27730>>>>>>>>>>>>>                     End_Function
27731>>>>>>>>>>>>>
27731>>>>>>>>>>>>>            Function _Search_LngDictListItem_Array tLngDictListItem[] aLngDictList String sDictionaryId Returns Integer
27733>>>>>>>>>>>>>                tLngDictListItem sVal
27733>>>>>>>>>>>>>                tLngDictListItem sVal
27733>>>>>>>>>>>>>                Move sDictionaryId to sVal.sDictionaryId
27734>>>>>>>>>>>>>                Function_Return (SearchArray(sVal,aLngDictList,Self,GET__Compare_LngDictListItem))
27735>>>>>>>>>>>>>            End_Function
27736>>>>>>>>>>>>>
27736>>>>>>>>>>>>>                     Function _Compare_LngDictSymbols tLngDictSymbol sVal1 tLngDictSymbol sVal2 Returns Integer
27738>>>>>>>>>>>>>                         If (sVal1.sSymbol>sVal2.sSymbol) Function_Return (GT)
27741>>>>>>>>>>>>>                         If (sVal1.sSymbol=sVal2.sSymbol) Function_Return (EQ)
27744>>>>>>>>>>>>>                         Function_Return (LT)
27745>>>>>>>>>>>>>                     End_Function
27746>>>>>>>>>>>>>
27746>>>>>>>>>>>>>            Function _Search_LngDictSymbol_Array tLngDictSymbol[] aLngDictSymbols String sSymbol Returns Integer
27748>>>>>>>>>>>>>                tLngDictSymbol sVal
27748>>>>>>>>>>>>>                tLngDictSymbol sVal
27748>>>>>>>>>>>>>                Move sSymbol to sVal.sSymbol
27749>>>>>>>>>>>>>                Function_Return (BinarySearchArray(sVal,aLngDictSymbols,Self,GET__Compare_LngDictSymbols))
27750>>>>>>>>>>>>>            End_Function
27751>>>>>>>>>>>>>
27751>>>>>>>>>>>>>            Procedure _Sort_LngDictSymbols tLngDictSymbol[] ByRef aLngDictSymbols
27753>>>>>>>>>>>>>                Move (SortArray(aLngDictSymbols,Self,GET__Compare_LngDictSymbols)) to aLngDictSymbols
27754>>>>>>>>>>>>>            End_Procedure
27755>>>>>>>>>>>>>
27755>>>>>>>>>>>>>            // Called automatically when defining cLaguageDictionaryObjects
27755>>>>>>>>>>>>>            Procedure _Add_Dictionary_Object Integer hDictionary
27757>>>>>>>>>>>>>                Integer iRow
27757>>>>>>>>>>>>>                String sDictionaryId
27757>>>>>>>>>>>>>                tLngDictListItem[] aLngDics
27757>>>>>>>>>>>>>                tLngDictListItem[] aLngDics
27758>>>>>>>>>>>>>                Get _paLngDictList to aLngDics
27759>>>>>>>>>>>>>                Get psDictionaryId of hDictionary to sDictionaryId
27760>>>>>>>>>>>>>                If (sDictionaryId<>"") Begin
27762>>>>>>>>>>>>>                    Move (SizeOfArray(aLngDics)) to iRow
27763>>>>>>>>>>>>>                    Move (lowercase(sDictionaryId)) to aLngDics[iRow].sDictionaryId
27764>>>>>>>>>>>>>                    Move hDictionary to aLngDics[iRow].hDictionary
27765>>>>>>>>>>>>>                    Set _paLngDictList to aLngDics
27766>>>>>>>>>>>>>                End
27766>>>>>>>>>>>>>>
27766>>>>>>>>>>>>>            End_Procedure
27767>>>>>>>>>>>>>
27767>>>>>>>>>>>>>    // Examples:
27767>>>>>>>>>>>>>    // "ls.button.save"    ->  "Save", TRUE, "lv.23.3"    (not so fast)
27767>>>>>>>>>>>>>    // "lv.23.3"           ->  "Save", FALSE, ""          (fast)
27767>>>>>>>>>>>>>    // "Save"              ->  "Save", FALSE, ""          (fastest, but no point)
27767>>>>>>>>>>>>>    Function TranslateValue String sValue Returns tTranslateResult
27769>>>>>>>>>>>>>        Integer iRow hDictionary iSymbolId
27769>>>>>>>>>>>>>        String sDictionaryId sSymbol
27769>>>>>>>>>>>>>        tTranslateResult sRval
27769>>>>>>>>>>>>>        tTranslateResult sRval
27769>>>>>>>>>>>>>        tLngDictListItem[] aLngDics
27769>>>>>>>>>>>>>        tLngDictListItem[] aLngDics
27770>>>>>>>>>>>>>
27770>>>>>>>>>>>>>        Get _paLngDictList to aLngDics
27771>>>>>>>>>>>>>
27771>>>>>>>>>>>>>        Move False to sRval.bOptimize
27772>>>>>>>>>>>>>
27772>>>>>>>>>>>>>        If (left(sValue,3)="ls.") Begin // Value could be: "ls.buttons.save"
27774>>>>>>>>>>>>>            // It's a "language symbol" and we must translate it into a language value
27774>>>>>>>>>>>>>            Move (replace("ls.",sValue,"")) to sValue // "buttons.save"
27775>>>>>>>>>>>>>            Move (left(sValue,pos(".",sValue)-1)) to sDictionaryId // "buttons"
27776>>>>>>>>>>>>>            //get iFindRow.s sDictionaryId to iRow
27776>>>>>>>>>>>>>            Get _Search_LngDictListItem_Array aLngDics sDictionaryId to iRow
27777>>>>>>>>>>>>>            If (iRow>=0) Begin
27779>>>>>>>>>>>>>                Move aLngDics[iRow].hDictionary to hDictionary
27780>>>>>>>>>>>>>                Move (Replace(sDictionaryId+".",sValue,"")) to sSymbol // "save"
27781>>>>>>>>>>>>>                Get _SymbolToId of hDictionary sSymbol to iSymbolId // The number we're going to use when asking for this value in the future
27782>>>>>>>>>>>>>                Move True to sRval.bOptimize
27783>>>>>>>>>>>>>                Move ("lv."+String(iRow)+"."+String(iSymbolId)) to sRval.sOptimizedLookup
27784>>>>>>>>>>>>>                Get _TranslateItem of hDictionary iSymbolId to sValue // Get actual return value
27785>>>>>>>>>>>>>            End
27785>>>>>>>>>>>>>>
27785>>>>>>>>>>>>>        End
27785>>>>>>>>>>>>>>
27785>>>>>>>>>>>>>        Else Begin
27786>>>>>>>>>>>>>            If (left(sValue,3)="lv.") Begin // Value is: "lv.23.3" (23rd dictionary, 3rd item)
27788>>>>>>>>>>>>>                Move (replace("lv.",sValue,"")) to sValue // "23.3"
27789>>>>>>>>>>>>>                Move (left(sValue,pos(".",sValue)-1)) to iRow // "23"
27790>>>>>>>>>>>>>                Move aLngDics[iRow].hDictionary to hDictionary
27791>>>>>>>>>>>>>                Move (replace(String(iRow)+".",sValue,"")) to iSymbolId // "3"
27792>>>>>>>>>>>>>                Get _TranslateItem of hDictionary iSymbolId to sValue // Get actual return value
27793>>>>>>>>>>>>>            End
27793>>>>>>>>>>>>>>
27793>>>>>>>>>>>>>        End
27793>>>>>>>>>>>>>>
27793>>>>>>>>>>>>>        Move sValue to sRval.sResult
27794>>>>>>>>>>>>>        Function_Return sRval
27795>>>>>>>>>>>>>    End_Function
27796>>>>>>>>>>>>>
27796>>>>>>>>>>>>>    Function Translate String sSymbol Returns String
27798>>>>>>>>>>>>>        tTranslateResult stResult
27798>>>>>>>>>>>>>        tTranslateResult stResult
27798>>>>>>>>>>>>>        Get TranslateValue sSymbol to stResult
27799>>>>>>>>>>>>>        Function_Return stResult.sResult
27800>>>>>>>>>>>>>    End_Function
27801>>>>>>>>>>>>>
27801>>>>>>>>>>>>>    Function DictionaryHandle String sDictionaryId Returns Integer
27803>>>>>>>>>>>>>        Integer iIndex
27803>>>>>>>>>>>>>        tLngDictListItem[] aLngDics
27803>>>>>>>>>>>>>        tLngDictListItem[] aLngDics
27804>>>>>>>>>>>>>
27804>>>>>>>>>>>>>        Get _paLngDictList to aLngDics
27805>>>>>>>>>>>>>        Get _Search_LngDictListItem_Array aLngDics sDictionaryId to iIndex
27806>>>>>>>>>>>>>        If (iIndex>=0) Function_Return aLngDics[iIndex].hDictionary
27809>>>>>>>>>>>>>        Function_Return 0
27810>>>>>>>>>>>>>    End_Function
27811>>>>>>>>>>>>>
27811>>>>>>>>>>>>>End_Class // cLanguageFunctions
27812>>>>>>>>>>>>>
27812>>>>>>>>>>>>>Global_Variable Integer oLanguageFunctions
27812>>>>>>>>>>>>>
27812>>>>>>>>>>>>>Object _oLanguageFunctions is a _cLanguageFunctions
27814>>>>>>>>>>>>>    Move Self to oLanguageFunctions
27815>>>>>>>>>>>>>End_Object
27816>>>>>>>>>>>>>
27816>>>>>>>>>>>>>Class cLanguageDictionary is a cObject
27817>>>>>>>>>>>>>    Procedure construct_object
27819>>>>>>>>>>>>>        Forward Send construct_object
27821>>>>>>>>>>>>>
27821>>>>>>>>>>>>>        Property String  psDictionaryId "" // Name of the dictionary,
27822>>>>>>>>>>>>>
27822>>>>>>>>>>>>>        //> If a value returns blank, the default behavior is to try the default
27822>>>>>>>>>>>>>        //> language (LNG_DEFAULT).
27822>>>>>>>>>>>>>        Property Integer piDefaultLanguage LNG_DEFAULT // -1: No default languages (=blank values are OK)
27823>>>>>>>>>>>>>
27823>>>>>>>>>>>>>                 Property Boolean pbLoadData True
27824>>>>>>>>>>>>>
27824>>>>>>>>>>>>>                 // These are used internally to optimize the process of adding
27824>>>>>>>>>>>>>                 Property String  _PreviousSymbol ""
27825>>>>>>>>>>>>>                 Property Integer _PreviousIndex 0
27826>>>>>>>>>>>>>
27826>>>>>>>>>>>>>        Property tLngDictSymbol[] paSymbols
27827>>>>>>>>>>>>>    End_Procedure
27828>>>>>>>>>>>>>
27828>>>>>>>>>>>>>    Procedure OnDefineSymbols
27830>>>>>>>>>>>>>    End_Procedure
27831>>>>>>>>>>>>>
27831>>>>>>>>>>>>>    // Translate symbol into a unique item id (item no in array or other integer id)
27831>>>>>>>>>>>>>    Function _SymbolToId String sSymbol Returns Integer
27833>>>>>>>>>>>>>        Integer iItem
27833>>>>>>>>>>>>>        tLngDictSymbol[] aSymbols
27833>>>>>>>>>>>>>        tLngDictSymbol[] aSymbols
27834>>>>>>>>>>>>>        Get paSymbols to aSymbols
27835>>>>>>>>>>>>>        If (pbLoadData(Self)) Begin // If array is empty
27837>>>>>>>>>>>>>            Set pbLoadData to False
27838>>>>>>>>>>>>>            Set _StopForAddingLanguages of oLanguageFunctions to True
27839>>>>>>>>>>>>>            Send OnDefineSymbols // Fill array
27840>>>>>>>>>>>>>            Get paSymbols to aSymbols
27841>>>>>>>>>>>>>            Send _Sort_LngDictSymbols of oLanguageFunctions (&aSymbols) // Prepare for BinarySearchArray
27842>>>>>>>>>>>>>            Set paSymbols to aSymbols
27843>>>>>>>>>>>>>        End
27843>>>>>>>>>>>>>>
27843>>>>>>>>>>>>>        Get _Search_LngDictSymbol_Array of oLanguageFunctions aSymbols sSymbol to iItem
27844>>>>>>>>>>>>>        Function_Return iItem
27845>>>>>>>>>>>>>    End_Function
27846>>>>>>>>>>>>>
27846>>>>>>>>>>>>>    Function _TranslateItem Integer iSymbolId Returns String
27848>>>>>>>>>>>>>        Integer iCmprLngIdx iMaxIndex
27848>>>>>>>>>>>>>        String sValue
27848>>>>>>>>>>>>>        tLngDictSymbol[] aSymbols
27848>>>>>>>>>>>>>        tLngDictSymbol[] aSymbols
27849>>>>>>>>>>>>>        Get paSymbols to aSymbols
27850>>>>>>>>>>>>>
27850>>>>>>>>>>>>>        Move (SizeOfArray(aSymbols[iSymbolId].sTranslations)-1) to iMaxIndex
27851>>>>>>>>>>>>>
27851>>>>>>>>>>>>>        // First we try the straight way:
27851>>>>>>>>>>>>>        If (gi$CmprLngIdx<=iMaxIndex) Move aSymbols[iSymbolId].sTranslations[gi$CmprLngIdx] to sValue
27854>>>>>>>>>>>>>        Else Move "" to sValue
27856>>>>>>>>>>>>>
27856>>>>>>>>>>>>>        If (sValue="") Begin // This didn't give us a value to return
27858>>>>>>>>>>>>>            // We'll therefore try to get a value using the default language of the application:
27858>>>>>>>>>>>>>            Get _IndexToCompressedIndex of oLanguageFunctions LNG_DEFAULT to iCmprLngIdx
27859>>>>>>>>>>>>>            If (iCmprLngIdx>=0) Begin
27861>>>>>>>>>>>>>                If (iCmprLngIdx<=iMaxIndex) Move aSymbols[iSymbolId].sTranslations[iCmprLngIdx] to sValue
27864>>>>>>>>>>>>>                Else Move "" to sValue
27866>>>>>>>>>>>>>            End
27866>>>>>>>>>>>>>>
27866>>>>>>>>>>>>>
27866>>>>>>>>>>>>>            If (sValue="") Begin // This didn't give us a value either.
27868>>>>>>>>>>>>>                  // We will therefore now try to get the value of default language of the dictionary:
27868>>>>>>>>>>>>>                  If (piDefaultLanguage(Self)>=0) Begin
27870>>>>>>>>>>>>>                      Get _IndexToCompressedIndex of oLanguageFunctions (piDefaultLanguage(Self)) to iCmprLngIdx
27871>>>>>>>>>>>>>                      If (iCmprLngIdx>=0) begin
27873>>>>>>>>>>>>>                          If (iCmprLngIdx<=iMaxIndex) Move aSymbols[iSymbolId].sTranslations[iCmprLngIdx] to sValue
27876>>>>>>>>>>>>>                          Else Move "" to sValue
27878>>>>>>>>>>>>>                      End
27878>>>>>>>>>>>>>>
27878>>>>>>>>>>>>>                  End
27878>>>>>>>>>>>>>>
27878>>>>>>>>>>>>>
27878>>>>>>>>>>>>>                  If (sValue="") Begin // The default language of this LanguageDictionary is not part of the supported languages
27880>>>>>>>>>>>>>                      // As a last resort we will therefore try to get the value from the default column of the object
27880>>>>>>>>>>>>>                      Move aSymbols[iSymbolId].sDefaultTranslation to sValue
27881>>>>>>>>>>>>>                  End
27881>>>>>>>>>>>>>>
27881>>>>>>>>>>>>>            End
27881>>>>>>>>>>>>>>
27881>>>>>>>>>>>>>        End
27881>>>>>>>>>>>>>>
27881>>>>>>>>>>>>>
27881>>>>>>>>>>>>>        Function_Return sValue
27882>>>>>>>>>>>>>    End_Function
27883>>>>>>>>>>>>>
27883>>>>>>>>>>>>>            Function _SymbolToIdOrCreate String sSymbol Returns Integer // Private
27885>>>>>>>>>>>>>                Integer iSymbolId iItem
27885>>>>>>>>>>>>>                tLngDictSymbol[] aSymbols
27885>>>>>>>>>>>>>                tLngDictSymbol[] aSymbols
27886>>>>>>>>>>>>>
27886>>>>>>>>>>>>>                Get _SymbolToId sSymbol to iSymbolId
27887>>>>>>>>>>>>>                If (iSymbolId=-1) Begin
27889>>>>>>>>>>>>>                    Get paSymbols to aSymbols
27890>>>>>>>>>>>>>                    Move (SizeOfArray(aSymbols)) to iSymbolId
27891>>>>>>>>>>>>>                    Move sSymbol to aSymbols[iSymbolId].sSymbol
27892>>>>>>>>>>>>>                    Set paSymbols to aSymbols
27893>>>>>>>>>>>>>                End
27893>>>>>>>>>>>>>>
27893>>>>>>>>>>>>>                Function_Return iSymbolId
27894>>>>>>>>>>>>>            End_Function
27895>>>>>>>>>>>>>
27895>>>>>>>>>>>>>    Procedure Set Language_Value String sSymbol Integer iLng String sValue
27897>>>>>>>>>>>>>        Integer iCmprLngIdx iSymbolId
27897>>>>>>>>>>>>>        tLngDictSymbol[] aSymbols
27897>>>>>>>>>>>>>        tLngDictSymbol[] aSymbols
27898>>>>>>>>>>>>>        Get paSymbols to aSymbols
27899>>>>>>>>>>>>>
27899>>>>>>>>>>>>>        Get _IndexToCompressedIndex of oLanguageFunctions iLng to iCmprLngIdx
27900>>>>>>>>>>>>>        If (iCmprLngIdx>=0) Begin // If language is supported by this application
27902>>>>>>>>>>>>>            Move (lowercase(sSymbol)) to sSymbol
27903>>>>>>>>>>>>>            If (sSymbol=_PreviousSymbol(Self)) Begin // It's the same symbol => we reuse its position
27905>>>>>>>>>>>>>                Get _PreviousIndex to iSymbolId
27906>>>>>>>>>>>>>            End
27906>>>>>>>>>>>>>>
27906>>>>>>>>>>>>>            Else Begin
27907>>>>>>>>>>>>>                Get _SymbolToIdOrCreate sSymbol to iSymbolId
27908>>>>>>>>>>>>>                Move sSymbol to aSymbols[iSymbolId].sSymbol
27909>>>>>>>>>>>>>                Set _PreviousIndex to iSymbolId
27910>>>>>>>>>>>>>                Set _PreviousSymbol to sSymbol
27911>>>>>>>>>>>>>            End
27911>>>>>>>>>>>>>>
27911>>>>>>>>>>>>>            Move sValue to aSymbols[iSymbolId].sTranslations[iCmprLngIdx]
27912>>>>>>>>>>>>>        End
27912>>>>>>>>>>>>>>
27912>>>>>>>>>>>>>        Else Begin // The language is not supported by the application.
27913>>>>>>>>>>>>>            // However, if the language passed is the default language of the
27913>>>>>>>>>>>>>            // language dictionary, we'll put the value in the default column.
27913>>>>>>>>>>>>>            If (iLng=piDefaultLanguage(Self)) begin
27915>>>>>>>>>>>>>                Move sSymbol to aSymbols[iSymbolId].sSymbol
27916>>>>>>>>>>>>>                Move sValue to aSymbols[iSymbolId].sDefaultTranslation
27917>>>>>>>>>>>>>            End
27917>>>>>>>>>>>>>>
27917>>>>>>>>>>>>>        End
27917>>>>>>>>>>>>>>
27917>>>>>>>>>>>>>        Set paSymbols to aSymbols
27918>>>>>>>>>>>>>    End_Procedure
27919>>>>>>>>>>>>>
27919>>>>>>>>>>>>>    Procedure CallbackSymbols Integer hMsg Integer hObj
27921>>>>>>>>>>>>>        Integer iMax iIndex
27921>>>>>>>>>>>>>        String sSymbol sValue
27921>>>>>>>>>>>>>        tLngDictSymbol[] aSymbols
27921>>>>>>>>>>>>>        tLngDictSymbol[] aSymbols
27922>>>>>>>>>>>>>
27922>>>>>>>>>>>>>        If (pbLoadData(Self)) Get _SymbolToId "dummy" to iIndex // Load symbols if not already loaded
27925>>>>>>>>>>>>>
27925>>>>>>>>>>>>>        Get paSymbols to aSymbols
27926>>>>>>>>>>>>>        Move (SizeOfArray(aSymbols)-1) to iMax
27927>>>>>>>>>>>>>        For iIndex from 0 to iMax
27933>>>>>>>>>>>>>>
27933>>>>>>>>>>>>>            Move ("ls."+psDictionaryId(Self)+"."+aSymbols[iIndex].sSymbol) to sSymbol
27934>>>>>>>>>>>>>            Get Translate of oLanguageFunctions sSymbol to sValue
27935>>>>>>>>>>>>>            Send hMsg of hObj sSymbol sValue
27936>>>>>>>>>>>>>        Loop
27937>>>>>>>>>>>>>>
27937>>>>>>>>>>>>>    End_Procedure
27938>>>>>>>>>>>>>
27938>>>>>>>>>>>>>    Procedure end_construct_object
27940>>>>>>>>>>>>>        Forward Send end_construct_object
27942>>>>>>>>>>>>>        Send _Add_Dictionary_Object of oLanguageFunctions Self // Register with global list of language dictionaries
27943>>>>>>>>>>>>>    End_Procedure
27944>>>>>>>>>>>>>End_Class // cLanguageDictionary
27945>>>>>>>>>>>>>
27945>>>>>>>>>>>>>Global_Variable Integer oLanguageLD
27945>>>>>>>>>>>>>
27945>>>>>>>>>>>>>Object _oLanguageLD is a cLanguageDictionary
27947>>>>>>>>>>>>>    Move Self to oLanguageLD
27948>>>>>>>>>>>>>    Set psDictionaryId to "lng"
27949>>>>>>>>>>>>>    Set piDefaultLanguage to LNG_ENGLISH
27950>>>>>>>>>>>>>
27950>>>>>>>>>>>>>    Procedure OnDefineSymbols
27953>>>>>>>>>>>>>        Set Language_Value "language"   LNG_DUTCH      to "Taal"
27954>>>>>>>>>>>>>      //Set Language_Value "language"   LNG_ITALIAN    to
27954>>>>>>>>>>>>>      //Set Language_Value "language"   LNG_SPANISH    to
27954>>>>>>>>>>>>>        Set Language_Value "language"   LNG_ENGLISH    to "Language"
27955>>>>>>>>>>>>>        Set Language_Value "language"   LNG_DANISH     to "Sprog"
27956>>>>>>>>>>>>>        Set Language_Value "language"   LNG_SWEDISH    to "Sprk"
27957>>>>>>>>>>>>>        Set Language_Value "language"   LNG_NORWEGIAN  to "Sprog"
27958>>>>>>>>>>>>>        Set Language_Value "language"   LNG_GERMAN     to "Sprache"
27959>>>>>>>>>>>>>      //Set Language_Value "language"   LNG_PORTUGUESE to
27959>>>>>>>>>>>>>      //Set Language_Value "language"   LNG_FRENCH     to
27959>>>>>>>>>>>>>
27959>>>>>>>>>>>>>        Set Language_Value "dutch"      LNG_DUTCH      to "Nederlands"
27960>>>>>>>>>>>>>      //Set Language_Value "dutch"      LNG_ITALIAN    to
27960>>>>>>>>>>>>>      //Set Language_Value "dutch"      LNG_SPANISH    to
27960>>>>>>>>>>>>>        Set Language_Value "dutch"      LNG_ENGLISH    to "Dutch"
27961>>>>>>>>>>>>>        Set Language_Value "dutch"      LNG_DANISH     to "Hollandsk"
27962>>>>>>>>>>>>>        Set Language_Value "dutch"      LNG_SWEDISH    to "Hollandska"
27963>>>>>>>>>>>>>      //Set Language_Value "dutch"      LNG_NORWEGIAN  to ""
27963>>>>>>>>>>>>>      //Set Language_Value "dutch"      LNG_GERMAN     to ""
27963>>>>>>>>>>>>>      //Set Language_Value "dutch"      LNG_PORTUGUESE to ""
27963>>>>>>>>>>>>>      //Set Language_Value "dutch"      LNG_FRENCH     to ""
27963>>>>>>>>>>>>>
27963>>>>>>>>>>>>>      //Set Language_Value "danish"     LNG_DUTCH      to ""
27963>>>>>>>>>>>>>      //Set Language_Value "danish"     LNG_ITALIAN    to
27963>>>>>>>>>>>>>      //Set Language_Value "danish"     LNG_SPANISH    to
27963>>>>>>>>>>>>>        Set Language_Value "danish"     LNG_ENGLISH    to "Danish"
27964>>>>>>>>>>>>>        Set Language_Value "danish"     LNG_DANISH     to "Dansk"
27965>>>>>>>>>>>>>        Set Language_Value "danish"     LNG_SWEDISH    to "Danska"
27966>>>>>>>>>>>>>      //Set Language_Value "danish"     LNG_NORWEGIAN  to ""
27966>>>>>>>>>>>>>      //Set Language_Value "danish"     LNG_GERMAN     to ""
27966>>>>>>>>>>>>>      //Set Language_Value "danish"     LNG_PORTUGUESE to ""
27966>>>>>>>>>>>>>      //Set Language_Value "danish"     LNG_FRENCH     to ""
27966>>>>>>>>>>>>>
27966>>>>>>>>>>>>>      //Set Language_Value "english"    LNG_DUTCH      to ""
27966>>>>>>>>>>>>>      //Set Language_Value "english"    LNG_ITALIAN    to
27966>>>>>>>>>>>>>      //Set Language_Value "english"    LNG_SPANISH    to
27966>>>>>>>>>>>>>        Set Language_Value "english"    LNG_ENGLISH    to "English"
27967>>>>>>>>>>>>>        Set Language_Value "english"    LNG_DANISH     to "Engelsk"
27968>>>>>>>>>>>>>        Set Language_Value "english"    LNG_SWEDISH    to "Engelska"
27969>>>>>>>>>>>>>      //Set Language_Value "english"    LNG_NORWEGIAN  to ""
27969>>>>>>>>>>>>>      //Set Language_Value "english"    LNG_GERMAN     to ""
27969>>>>>>>>>>>>>      //Set Language_Value "english"    LNG_PORTUGUESE to ""
27969>>>>>>>>>>>>>      //Set Language_Value "english"    LNG_FRENCH     to ""
27969>>>>>>>>>>>>>
27969>>>>>>>>>>>>>      //Set Language_Value "french"     LNG_DUTCH      to ""
27969>>>>>>>>>>>>>      //Set Language_Value "french"     LNG_ITALIAN    to
27969>>>>>>>>>>>>>      //Set Language_Value "french"     LNG_SPANISH    to
27969>>>>>>>>>>>>>        Set Language_Value "french"     LNG_ENGLISH    to "French"
27970>>>>>>>>>>>>>        Set Language_Value "french"     LNG_DANISH     to "Fransk"
27971>>>>>>>>>>>>>        Set Language_Value "french"     LNG_SWEDISH    to "Franska"
27972>>>>>>>>>>>>>      //Set Language_Value "french"     LNG_NORWEGIAN  to ""
27972>>>>>>>>>>>>>      //Set Language_Value "french"     LNG_GERMAN     to ""
27972>>>>>>>>>>>>>      //Set Language_Value "french"     LNG_PORTUGUESE to ""
27972>>>>>>>>>>>>>      //Set Language_Value "french"     LNG_FRENCH     to ""
27972>>>>>>>>>>>>>
27972>>>>>>>>>>>>>      //Set Language_Value "german"     LNG_DUTCH      to ""
27972>>>>>>>>>>>>>      //Set Language_Value "german"     LNG_ITALIAN    to
27972>>>>>>>>>>>>>      //Set Language_Value "german"     LNG_SPANISH    to
27972>>>>>>>>>>>>>        Set Language_Value "german"     LNG_ENGLISH    to "German"
27973>>>>>>>>>>>>>        Set Language_Value "german"     LNG_DANISH     to "Tysk"
27974>>>>>>>>>>>>>        Set Language_Value "german"     LNG_SWEDISH    to "Tyska"
27975>>>>>>>>>>>>>      //Set Language_Value "german"     LNG_NORWEGIAN  to ""
27975>>>>>>>>>>>>>      //Set Language_Value "german"     LNG_GERMAN     to ""
27975>>>>>>>>>>>>>      //Set Language_Value "german"     LNG_PORTUGUESE to ""
27975>>>>>>>>>>>>>      //Set Language_Value "german"     LNG_FRENCH     to ""
27975>>>>>>>>>>>>>
27975>>>>>>>>>>>>>      //Set Language_Value "italian"    LNG_DUTCH      to ""
27975>>>>>>>>>>>>>      //Set Language_Value "italian"    LNG_ITALIAN    to
27975>>>>>>>>>>>>>      //Set Language_Value "italian"    LNG_SPANISH    to
27975>>>>>>>>>>>>>        Set Language_Value "italian"    LNG_ENGLISH    to "Italian"
27976>>>>>>>>>>>>>        Set Language_Value "italian"    LNG_DANISH     to "Italiensk"
27977>>>>>>>>>>>>>        Set Language_Value "italian"    LNG_SWEDISH    to "Italienska"
27978>>>>>>>>>>>>>      //Set Language_Value "italian"    LNG_NORWEGIAN  to ""
27978>>>>>>>>>>>>>      //Set Language_Value "italian"    LNG_GERMAN     to ""
27978>>>>>>>>>>>>>      //Set Language_Value "italian"    LNG_PORTUGUESE to ""
27978>>>>>>>>>>>>>      //Set Language_Value "italian"    LNG_FRENCH     to ""
27978>>>>>>>>>>>>>
27978>>>>>>>>>>>>>      //Set Language_Value "norwegian"  LNG_DUTCH      to ""
27978>>>>>>>>>>>>>      //Set Language_Value "norwegian"  LNG_ITALIAN    to
27978>>>>>>>>>>>>>      //Set Language_Value "norwegian"  LNG_SPANISH    to
27978>>>>>>>>>>>>>        Set Language_Value "norwegian"  LNG_ENGLISH    to "Norwegian"
27979>>>>>>>>>>>>>        Set Language_Value "norwegian"  LNG_DANISH     to "Norsk"
27980>>>>>>>>>>>>>        Set Language_Value "norwegian"  LNG_SWEDISH    to "Norska"
27981>>>>>>>>>>>>>      //Set Language_Value "norwegian"  LNG_NORWEGIAN  to ""
27981>>>>>>>>>>>>>      //Set Language_Value "norwegian"  LNG_GERMAN     to ""
27981>>>>>>>>>>>>>      //Set Language_Value "norwegian"  LNG_PORTUGUESE to ""
27981>>>>>>>>>>>>>      //Set Language_Value "norwegian"  LNG_FRENCH     to ""
27981>>>>>>>>>>>>>
27981>>>>>>>>>>>>>      //Set Language_Value "portuguese" LNG_DUTCH      to ""
27981>>>>>>>>>>>>>      //Set Language_Value "portuguese" LNG_ITALIAN    to
27981>>>>>>>>>>>>>      //Set Language_Value "portuguese" LNG_SPANISH    to
27981>>>>>>>>>>>>>        Set Language_Value "portuguese" LNG_ENGLISH    to "Portuguese"
27982>>>>>>>>>>>>>        Set Language_Value "portuguese" LNG_DANISH     to "Portugisisk"
27983>>>>>>>>>>>>>        Set Language_Value "portuguese" LNG_SWEDISH    to "Portugisiska"
27984>>>>>>>>>>>>>      //Set Language_Value "portuguese" LNG_NORWEGIAN  to ""
27984>>>>>>>>>>>>>      //Set Language_Value "portuguese" LNG_GERMAN     to ""
27984>>>>>>>>>>>>>      //Set Language_Value "portuguese" LNG_PORTUGUESE to ""
27984>>>>>>>>>>>>>      //Set Language_Value "portuguese" LNG_FRENCH     to ""
27984>>>>>>>>>>>>>
27984>>>>>>>>>>>>>      //Set Language_Value "spanish"    LNG_DUTCH      to ""
27984>>>>>>>>>>>>>      //Set Language_Value "spanish"    LNG_ITALIAN    to
27984>>>>>>>>>>>>>      //Set Language_Value "spanish"    LNG_SPANISH    to
27984>>>>>>>>>>>>>        Set Language_Value "spanish"    LNG_ENGLISH    to "Spanish"
27985>>>>>>>>>>>>>        Set Language_Value "spanish"    LNG_DANISH     to "Spansk"
27986>>>>>>>>>>>>>        Set Language_Value "spanish"    LNG_SWEDISH    to "Spanska"
27987>>>>>>>>>>>>>      //Set Language_Value "spanish"    LNG_NORWEGIAN  to ""
27987>>>>>>>>>>>>>      //Set Language_Value "spanish"    LNG_GERMAN     to ""
27987>>>>>>>>>>>>>      //Set Language_Value "spanish"    LNG_PORTUGUESE to ""
27987>>>>>>>>>>>>>      //Set Language_Value "spanish"    LNG_FRENCH     to ""
27987>>>>>>>>>>>>>
27987>>>>>>>>>>>>>      //Set Language_Value "swedish"    LNG_DUTCH      to ""
27987>>>>>>>>>>>>>      //Set Language_Value "swedish"    LNG_ITALIAN    to
27987>>>>>>>>>>>>>      //Set Language_Value "swedish"    LNG_SPANISH    to
27987>>>>>>>>>>>>>        Set Language_Value "swedish"    LNG_ENGLISH    to "Swedish"
27988>>>>>>>>>>>>>        Set Language_Value "swedish"    LNG_DANISH     to "Svensk"
27989>>>>>>>>>>>>>        Set Language_Value "swedish"    LNG_SWEDISH    to "Svenska"
27990>>>>>>>>>>>>>      //Set Language_Value "swedish"    LNG_NORWEGIAN  to ""
27990>>>>>>>>>>>>>      //Set Language_Value "swedish"    LNG_GERMAN     to ""
27990>>>>>>>>>>>>>      //Set Language_Value "swedish"    LNG_PORTUGUESE to ""
27990>>>>>>>>>>>>>      //Set Language_Value "swedish"    LNG_FRENCH     to ""
27990>>>>>>>>>>>>>    End_Procedure
27991>>>>>>>>>>>>>
27991>>>>>>>>>>>>>    Function LanguageSymbolId Integer iLng Returns String
27994>>>>>>>>>>>>>        If (iLng=LNG_DUTCH)      Function_Return "ls.lng.dutch"
27997>>>>>>>>>>>>>        If (iLng=LNG_FRENCH)     Function_Return "ls.lng.french"
28000>>>>>>>>>>>>>        If (iLng=LNG_SPANISH)    Function_Return "ls.lng.spanish"
28003>>>>>>>>>>>>>        If (iLng=LNG_ITALIAN)    Function_Return "ls.lng.italian"
28006>>>>>>>>>>>>>        If (iLng=LNG_ENGLISH)    Function_Return "ls.lng.english"
28009>>>>>>>>>>>>>        If (iLng=LNG_DANISH)     Function_Return "ls.lng.danish"
28012>>>>>>>>>>>>>        If (iLng=LNG_SWEDISH)    Function_Return "ls.lng.swedish"
28015>>>>>>>>>>>>>        If (iLng=LNG_NORWEGIAN)  Function_Return "ls.lng.norwegian"
28018>>>>>>>>>>>>>        If (iLng=LNG_GERMAN)     Function_Return "ls.lng.german"
28021>>>>>>>>>>>>>        If (iLng=LNG_PORTUGUESE) Function_Return "ls.lng.portuguese"
28024>>>>>>>>>>>>>    End_Function
28025>>>>>>>>>>>>>End_Object // oLanguageLD
28026>>>>>>>>>>>>>
28026>>>>>>>>>>>>>Class cStringConstantsArray is an Array
28027>>>>>>>>>>>>>    Procedure Construct_Object
28029>>>>>>>>>>>>>        Forward Send Construct_Object
28031>>>>>>>>>>>>>        Set Delegation_Mode to Delegate_To_Parent
28032>>>>>>>>>>>>>    End_Procedure
28033>>>>>>>>>>>>>    Function Value Integer iItem Returns String
28035>>>>>>>>>>>>>        String sValue
28035>>>>>>>>>>>>>        tTranslateResult stTranslateResult
28035>>>>>>>>>>>>>        tTranslateResult stTranslateResult
28035>>>>>>>>>>>>>
28035>>>>>>>>>>>>>        Forward Get value iItem to sValue
28037>>>>>>>>>>>>>
28037>>>>>>>>>>>>>        Get TranslateValue of oLanguageFunctions sValue to stTranslateResult
28038>>>>>>>>>>>>>
28038>>>>>>>>>>>>>        If (stTranslateResult.bOptimize) Set Value iItem to stTranslateResult.sOptimizedLookup
28041>>>>>>>>>>>>>        Function_Return stTranslateResult.sResult
28042>>>>>>>>>>>>>    End_Function
28043>>>>>>>>>>>>>End_Class
28044>>>>>>>>>>>
28044>>>>>>>>>>>Object oDatesLD is a cLanguageDictionary
28046>>>>>>>>>>>    Set psDictionaryId to "date"
28047>>>>>>>>>>>    Set piDefaultLanguage to LNG_DEFAULT // Not necessary. But now we know that there is such a thing.
28048>>>>>>>>>>>
28048>>>>>>>>>>>    Procedure OnDefineSymbols
28051>>>>>>>>>>>        Set Language_Value "calendar"  LNG_DUTCH      to "Kalender"
28052>>>>>>>>>>>        Set Language_Value "calendar"  LNG_ITALIAN    to "Calendario"
28053>>>>>>>>>>>        Set Language_Value "calendar"  LNG_SPANISH    to "Calendario"
28054>>>>>>>>>>>        Set Language_Value "calendar"  LNG_ENGLISH    to "Calendar"
28055>>>>>>>>>>>        Set Language_Value "calendar"  LNG_DANISH     to "Kalender"
28056>>>>>>>>>>>        Set Language_Value "calendar"  LNG_SWEDISH    to "Kalender"
28057>>>>>>>>>>>        Set Language_Value "calendar"  LNG_NORWEGIAN  to "Kalender"
28058>>>>>>>>>>>        Set Language_Value "calendar"  LNG_GERMAN     to "Kalender"
28059>>>>>>>>>>>        Set Language_Value "calendar"  LNG_PORTUGUESE to "Calendrio"
28060>>>>>>>>>>>        Set Language_Value "calendar"  LNG_FRENCH     to "Calendrier"
28061>>>>>>>>>>>        
28061>>>>>>>>>>>        Set Language_Value "day"       LNG_DUTCH      to "Dag"
28062>>>>>>>>>>>        Set Language_Value "day"       LNG_ITALIAN    to "Giorno"
28063>>>>>>>>>>>        Set Language_Value "day"       LNG_SPANISH    to "Da"
28064>>>>>>>>>>>        Set Language_Value "day"       LNG_ENGLISH    to "Day"
28065>>>>>>>>>>>        Set Language_Value "day"       LNG_DANISH     to "Dag"
28066>>>>>>>>>>>        Set Language_Value "day"       LNG_SWEDISH    to "Dag"
28067>>>>>>>>>>>        Set Language_Value "day"       LNG_NORWEGIAN  to "Dag"
28068>>>>>>>>>>>        Set Language_Value "day"       LNG_GERMAN     to "Tag"
28069>>>>>>>>>>>        Set Language_Value "day"       LNG_PORTUGUESE to "Day"
28070>>>>>>>>>>>        Set Language_Value "day"       LNG_FRENCH     to "Jour"
28071>>>>>>>>>>>        
28071>>>>>>>>>>>        Set Language_Value "month"     LNG_DUTCH      to "Maand"
28072>>>>>>>>>>>        Set Language_Value "month"     LNG_ITALIAN    to "Mese"
28073>>>>>>>>>>>        Set Language_Value "month"     LNG_SPANISH    to "Mes"
28074>>>>>>>>>>>        Set Language_Value "month"     LNG_ENGLISH    to "Month"
28075>>>>>>>>>>>        Set Language_Value "month"     LNG_DANISH     to "Mned"
28076>>>>>>>>>>>        Set Language_Value "month"     LNG_SWEDISH    to "Mnad"
28077>>>>>>>>>>>        Set Language_Value "month"     LNG_NORWEGIAN  to "Mned"
28078>>>>>>>>>>>        Set Language_Value "month"     LNG_GERMAN     to "Monat"
28079>>>>>>>>>>>        Set Language_Value "month"     LNG_PORTUGUESE to "Ms"
28080>>>>>>>>>>>        Set Language_Value "month"     LNG_FRENCH     to "Mois"
28081>>>>>>>>>>>        
28081>>>>>>>>>>>        Set Language_Value "week"      LNG_DUTCH      to "Wk."
28082>>>>>>>>>>>        Set Language_Value "week"      LNG_ITALIAN    to "Set."
28083>>>>>>>>>>>        Set Language_Value "week"      LNG_SPANISH    to "Sem"
28084>>>>>>>>>>>        Set Language_Value "week"      LNG_ENGLISH    to "Wk."
28085>>>>>>>>>>>        Set Language_Value "week"      LNG_DANISH     to "Uge"
28086>>>>>>>>>>>        Set Language_Value "week"      LNG_SWEDISH    to "Vck"
28087>>>>>>>>>>>        Set Language_Value "week"      LNG_NORWEGIAN  to "Uke"
28088>>>>>>>>>>>        Set Language_Value "week"      LNG_GERMAN     to "Wo."
28089>>>>>>>>>>>        Set Language_Value "week"      LNG_PORTUGUESE to "Sem."
28090>>>>>>>>>>>        Set Language_Value "week"      LNG_FRENCH     to "Sem."
28091>>>>>>>>>>>
28091>>>>>>>>>>>        Set Language_Value "year"      LNG_DUTCH      to "Jaar"
28092>>>>>>>>>>>        Set Language_Value "year"      LNG_ITALIAN    to "Anno"
28093>>>>>>>>>>>        Set Language_Value "year"      LNG_SPANISH    to "Ao"
28094>>>>>>>>>>>        Set Language_Value "year"      LNG_ENGLISH    to "Year"
28095>>>>>>>>>>>        Set Language_Value "year"      LNG_DANISH     to "r"
28096>>>>>>>>>>>        Set Language_Value "year"      LNG_SWEDISH    to "r"
28097>>>>>>>>>>>        Set Language_Value "year"      LNG_NORWEGIAN  to "r"
28098>>>>>>>>>>>        Set Language_Value "year"      LNG_GERMAN     to "Jahr"
28099>>>>>>>>>>>        Set Language_Value "year"      LNG_PORTUGUESE to "Ano"
28100>>>>>>>>>>>        Set Language_Value "year"      LNG_FRENCH     to "Anne"
28101>>>>>>>>>>>        
28101>>>>>>>>>>>        Set Language_Value "january"   LNG_DUTCH      to "Januari"
28102>>>>>>>>>>>        Set Language_Value "january"   LNG_ITALIAN    to "Gennaio"
28103>>>>>>>>>>>        Set Language_Value "january"   LNG_SPANISH    to "Enero"
28104>>>>>>>>>>>        Set Language_Value "january"   LNG_ENGLISH    to "January"
28105>>>>>>>>>>>        Set Language_Value "january"   LNG_DANISH     to "Januar"
28106>>>>>>>>>>>        Set Language_Value "january"   LNG_SWEDISH    to "Januari"
28107>>>>>>>>>>>        Set Language_Value "january"   LNG_NORWEGIAN  to "Januar"
28108>>>>>>>>>>>        Set Language_Value "january"   LNG_GERMAN     to "Januar"
28109>>>>>>>>>>>        Set Language_Value "january"   LNG_PORTUGUESE to "Janeiro"
28110>>>>>>>>>>>        Set Language_Value "january"   LNG_FRENCH     to "Janvier"
28111>>>>>>>>>>>        
28111>>>>>>>>>>>        Set Language_Value "february"  LNG_DUTCH      to "Februari"
28112>>>>>>>>>>>        Set Language_Value "february"  LNG_ITALIAN    to "Febbraio"
28113>>>>>>>>>>>        Set Language_Value "february"  LNG_SPANISH    to "Febrero"
28114>>>>>>>>>>>        Set Language_Value "february"  LNG_ENGLISH    to "February"
28115>>>>>>>>>>>        Set Language_Value "february"  LNG_DANISH     to "Februar"
28116>>>>>>>>>>>        Set Language_Value "february"  LNG_SWEDISH    to "Februari"
28117>>>>>>>>>>>        Set Language_Value "february"  LNG_NORWEGIAN  to "Februar"
28118>>>>>>>>>>>        Set Language_Value "february"  LNG_GERMAN     to "Februar"
28119>>>>>>>>>>>        Set Language_Value "february"  LNG_PORTUGUESE to "Fevereiro"
28120>>>>>>>>>>>        Set Language_Value "february"  LNG_FRENCH     to "Fvrier"
28121>>>>>>>>>>>        
28121>>>>>>>>>>>        Set Language_Value "march"     LNG_DUTCH      to "Maart"
28122>>>>>>>>>>>        Set Language_Value "march"     LNG_ITALIAN    to "Marzo"
28123>>>>>>>>>>>        Set Language_Value "march"     LNG_SPANISH    to "Marzo"
28124>>>>>>>>>>>        Set Language_Value "march"     LNG_ENGLISH    to "March"
28125>>>>>>>>>>>        Set Language_Value "march"     LNG_DANISH     to "Marts"
28126>>>>>>>>>>>        Set Language_Value "march"     LNG_SWEDISH    to "Mars"
28127>>>>>>>>>>>        Set Language_Value "march"     LNG_NORWEGIAN  to "Mars"
28128>>>>>>>>>>>        Set Language_Value "march"     LNG_GERMAN     to "Mrz"
28129>>>>>>>>>>>        Set Language_Value "march"     LNG_PORTUGUESE to "Maro"
28130>>>>>>>>>>>        Set Language_Value "march"     LNG_FRENCH     to "Mars"
28131>>>>>>>>>>>        
28131>>>>>>>>>>>        Set Language_Value "april"     LNG_DUTCH      to "April"
28132>>>>>>>>>>>        Set Language_Value "april"     LNG_ITALIAN    to "Aprile"
28133>>>>>>>>>>>        Set Language_Value "april"     LNG_SPANISH    to "Abril"
28134>>>>>>>>>>>        Set Language_Value "april"     LNG_ENGLISH    to "April"
28135>>>>>>>>>>>        Set Language_Value "april"     LNG_DANISH     to "April"
28136>>>>>>>>>>>        Set Language_Value "april"     LNG_SWEDISH    to "April"
28137>>>>>>>>>>>        Set Language_Value "april"     LNG_NORWEGIAN  to "April"
28138>>>>>>>>>>>        Set Language_Value "april"     LNG_GERMAN     to "April"
28139>>>>>>>>>>>        Set Language_Value "april"     LNG_PORTUGUESE to "Abril"
28140>>>>>>>>>>>        Set Language_Value "april"     LNG_FRENCH     to "Avril"
28141>>>>>>>>>>>        
28141>>>>>>>>>>>        Set Language_Value "may"       LNG_DUTCH      to "Mei"
28142>>>>>>>>>>>        Set Language_Value "may"       LNG_ITALIAN    to "Maggio"
28143>>>>>>>>>>>        Set Language_Value "may"       LNG_SPANISH    to "Mayo"
28144>>>>>>>>>>>        Set Language_Value "may"       LNG_ENGLISH    to "May"
28145>>>>>>>>>>>        Set Language_Value "may"       LNG_DANISH     to "Maj"
28146>>>>>>>>>>>        Set Language_Value "may"       LNG_SWEDISH    to "Maj"
28147>>>>>>>>>>>        Set Language_Value "may"       LNG_NORWEGIAN  to "Mai"
28148>>>>>>>>>>>        Set Language_Value "may"       LNG_GERMAN     to "Mai"
28149>>>>>>>>>>>        Set Language_Value "may"       LNG_PORTUGUESE to "Maio"
28150>>>>>>>>>>>        Set Language_Value "may"       LNG_FRENCH     to "Mai"
28151>>>>>>>>>>>        
28151>>>>>>>>>>>        Set Language_Value "june"      LNG_DUTCH      to "Juni"
28152>>>>>>>>>>>        Set Language_Value "june"      LNG_ITALIAN    to "Giugno"
28153>>>>>>>>>>>        Set Language_Value "june"      LNG_SPANISH    to "Junio"
28154>>>>>>>>>>>        Set Language_Value "june"      LNG_ENGLISH    to "June"
28155>>>>>>>>>>>        Set Language_Value "june"      LNG_DANISH     to "Juni"
28156>>>>>>>>>>>        Set Language_Value "june"      LNG_SWEDISH    to "Juni"
28157>>>>>>>>>>>        Set Language_Value "june"      LNG_NORWEGIAN  to "Juni"
28158>>>>>>>>>>>        Set Language_Value "june"      LNG_GERMAN     to "Juni"
28159>>>>>>>>>>>        Set Language_Value "june"      LNG_PORTUGUESE to "Junho"
28160>>>>>>>>>>>        Set Language_Value "june"      LNG_FRENCH     to "Juin"
28161>>>>>>>>>>>        
28161>>>>>>>>>>>        Set Language_Value "july"      LNG_DUTCH      to "Juli"
28162>>>>>>>>>>>        Set Language_Value "july"      LNG_ITALIAN    to "Luglio"
28163>>>>>>>>>>>        Set Language_Value "july"      LNG_SPANISH    to "Julio"
28164>>>>>>>>>>>        Set Language_Value "july"      LNG_ENGLISH    to "July"
28165>>>>>>>>>>>        Set Language_Value "july"      LNG_DANISH     to "Juli"
28166>>>>>>>>>>>        Set Language_Value "july"      LNG_SWEDISH    to "Juli"
28167>>>>>>>>>>>        Set Language_Value "july"      LNG_NORWEGIAN  to "Juli"
28168>>>>>>>>>>>        Set Language_Value "july"      LNG_GERMAN     to "Juli"
28169>>>>>>>>>>>        Set Language_Value "july"      LNG_PORTUGUESE to "Julho"
28170>>>>>>>>>>>        Set Language_Value "july"      LNG_FRENCH     to "Juillet"
28171>>>>>>>>>>>
28171>>>>>>>>>>>        Set Language_Value "august"    LNG_DUTCH      to "Augustus"
28172>>>>>>>>>>>        Set Language_Value "august"    LNG_ITALIAN    to "Agosto"
28173>>>>>>>>>>>        Set Language_Value "august"    LNG_SPANISH    to "Agosto"
28174>>>>>>>>>>>        Set Language_Value "august"    LNG_ENGLISH    to "August"
28175>>>>>>>>>>>        Set Language_Value "august"    LNG_DANISH     to "August"
28176>>>>>>>>>>>        Set Language_Value "august"    LNG_SWEDISH    to "Augusti"
28177>>>>>>>>>>>        Set Language_Value "august"    LNG_NORWEGIAN  to "August"
28178>>>>>>>>>>>        Set Language_Value "august"    LNG_GERMAN     to "August"
28179>>>>>>>>>>>        Set Language_Value "august"    LNG_PORTUGUESE to "Agosto"
28180>>>>>>>>>>>        Set Language_Value "august"    LNG_FRENCH     to "Aot"
28181>>>>>>>>>>>        
28181>>>>>>>>>>>        Set Language_Value "september" LNG_DUTCH      to "September"
28182>>>>>>>>>>>        Set Language_Value "september" LNG_ITALIAN    to "Settembre"
28183>>>>>>>>>>>        Set Language_Value "september" LNG_SPANISH    to "Septiembre"
28184>>>>>>>>>>>        Set Language_Value "september" LNG_ENGLISH    to "September"
28185>>>>>>>>>>>        Set Language_Value "september" LNG_DANISH     to "September"
28186>>>>>>>>>>>        Set Language_Value "september" LNG_SWEDISH    to "September"
28187>>>>>>>>>>>        Set Language_Value "september" LNG_NORWEGIAN  to "September"
28188>>>>>>>>>>>        Set Language_Value "september" LNG_GERMAN     to "September"
28189>>>>>>>>>>>        Set Language_Value "september" LNG_PORTUGUESE to "Setembro"
28190>>>>>>>>>>>        Set Language_Value "september" LNG_FRENCH     to "Septembre"
28191>>>>>>>>>>>        
28191>>>>>>>>>>>        Set Language_Value "october"   LNG_DUTCH      to "Oktober"
28192>>>>>>>>>>>        Set Language_Value "october"   LNG_ITALIAN    to "Ottobre"
28193>>>>>>>>>>>        Set Language_Value "october"   LNG_SPANISH    to "Octubre"
28194>>>>>>>>>>>        Set Language_Value "october"   LNG_ENGLISH    to "October"
28195>>>>>>>>>>>        Set Language_Value "october"   LNG_DANISH     to "Oktober"
28196>>>>>>>>>>>        Set Language_Value "october"   LNG_SWEDISH    to "Oktober"
28197>>>>>>>>>>>        Set Language_Value "october"   LNG_NORWEGIAN  to "Oktober"
28198>>>>>>>>>>>        Set Language_Value "october"   LNG_GERMAN     to "Oktober"
28199>>>>>>>>>>>        Set Language_Value "october"   LNG_PORTUGUESE to "Outubro"
28200>>>>>>>>>>>        Set Language_Value "october"   LNG_FRENCH     to "Octobre"
28201>>>>>>>>>>>        
28201>>>>>>>>>>>        Set Language_Value "november"  LNG_DUTCH      to "November"
28202>>>>>>>>>>>        Set Language_Value "november"  LNG_ITALIAN    to "Novembre"
28203>>>>>>>>>>>        Set Language_Value "november"  LNG_SPANISH    to "Noviembre"
28204>>>>>>>>>>>        Set Language_Value "november"  LNG_ENGLISH    to "November"
28205>>>>>>>>>>>        Set Language_Value "november"  LNG_DANISH     to "November"
28206>>>>>>>>>>>        Set Language_Value "november"  LNG_SWEDISH    to "November"
28207>>>>>>>>>>>        Set Language_Value "november"  LNG_NORWEGIAN  to "November"
28208>>>>>>>>>>>        Set Language_Value "november"  LNG_GERMAN     to "November"
28209>>>>>>>>>>>        Set Language_Value "november"  LNG_PORTUGUESE to "Novembro"
28210>>>>>>>>>>>        Set Language_Value "november"  LNG_FRENCH     to "Novembre"
28211>>>>>>>>>>>        
28211>>>>>>>>>>>        Set Language_Value "december"  LNG_DUTCH      to "December"
28212>>>>>>>>>>>        Set Language_Value "december"  LNG_ITALIAN    to "Dicembre"
28213>>>>>>>>>>>        Set Language_Value "december"  LNG_SPANISH    to "Diciembre"
28214>>>>>>>>>>>        Set Language_Value "december"  LNG_ENGLISH    to "December"
28215>>>>>>>>>>>        Set Language_Value "december"  LNG_DANISH     to "December"
28216>>>>>>>>>>>        Set Language_Value "december"  LNG_SWEDISH    to "December"
28217>>>>>>>>>>>        Set Language_Value "december"  LNG_NORWEGIAN  to "Desember"
28218>>>>>>>>>>>        Set Language_Value "december"  LNG_GERMAN     to "Dezember"
28219>>>>>>>>>>>        Set Language_Value "december"  LNG_PORTUGUESE to "Dezembro"
28220>>>>>>>>>>>        Set Language_Value "december"  LNG_FRENCH     to "Dcembre"
28221>>>>>>>>>>>        
28221>>>>>>>>>>>        Set Language_Value "monday"    LNG_DUTCH      to "Maandag"
28222>>>>>>>>>>>        Set Language_Value "monday"    LNG_ITALIAN    to "Luned"
28223>>>>>>>>>>>        Set Language_Value "monday"    LNG_SPANISH    to "Lunes"
28224>>>>>>>>>>>        Set Language_Value "monday"    LNG_ENGLISH    to "Monday"
28225>>>>>>>>>>>        Set Language_Value "monday"    LNG_DANISH     to "Mandag"
28226>>>>>>>>>>>        Set Language_Value "monday"    LNG_SWEDISH    to "Mndag"
28227>>>>>>>>>>>        Set Language_Value "monday"    LNG_NORWEGIAN  to "Mandag"
28228>>>>>>>>>>>        Set Language_Value "monday"    LNG_GERMAN     to "Montag"
28229>>>>>>>>>>>        Set Language_Value "monday"    LNG_PORTUGUESE to "Segunda"
28230>>>>>>>>>>>        Set Language_Value "monday"    LNG_FRENCH     to "Lundi"
28231>>>>>>>>>>>        
28231>>>>>>>>>>>        Set Language_Value "tuesday"   LNG_DUTCH      to "Dinsdag"
28232>>>>>>>>>>>        Set Language_Value "tuesday"   LNG_ITALIAN    to "Marted"
28233>>>>>>>>>>>        Set Language_Value "tuesday"   LNG_SPANISH    to "Martes"
28234>>>>>>>>>>>        Set Language_Value "tuesday"   LNG_ENGLISH    to "Tuesday"
28235>>>>>>>>>>>        Set Language_Value "tuesday"   LNG_DANISH     to "Tirsdag"
28236>>>>>>>>>>>        Set Language_Value "tuesday"   LNG_SWEDISH    to "Tisdag"
28237>>>>>>>>>>>        Set Language_Value "tuesday"   LNG_NORWEGIAN  to "Tirsdag"
28238>>>>>>>>>>>        Set Language_Value "tuesday"   LNG_GERMAN     to "Dienstag"
28239>>>>>>>>>>>        Set Language_Value "tuesday"   LNG_PORTUGUESE to "Tera"
28240>>>>>>>>>>>        Set Language_Value "tuesday"   LNG_FRENCH     to "Mardi"
28241>>>>>>>>>>>        
28241>>>>>>>>>>>        Set Language_Value "wednesday" LNG_DUTCH      to "Woensdag"
28242>>>>>>>>>>>        Set Language_Value "wednesday" LNG_ITALIAN    to "Mercoled"
28243>>>>>>>>>>>        Set Language_Value "wednesday" LNG_SPANISH    to "Mircoles"
28244>>>>>>>>>>>        Set Language_Value "wednesday" LNG_ENGLISH    to "Wednesday"
28245>>>>>>>>>>>        Set Language_Value "wednesday" LNG_DANISH     to "Onsdag"
28246>>>>>>>>>>>        Set Language_Value "wednesday" LNG_SWEDISH    to "Onsdag"
28247>>>>>>>>>>>        Set Language_Value "wednesday" LNG_NORWEGIAN  to "Onsdag"
28248>>>>>>>>>>>        Set Language_Value "wednesday" LNG_GERMAN     to "Mittwoch"
28249>>>>>>>>>>>        Set Language_Value "wednesday" LNG_PORTUGUESE to "Quarta"
28250>>>>>>>>>>>        Set Language_Value "wednesday" LNG_FRENCH     to "Mercredi"
28251>>>>>>>>>>>        
28251>>>>>>>>>>>        Set Language_Value "thursday"  LNG_DUTCH      to "Donderdag"
28252>>>>>>>>>>>        Set Language_Value "thursday"  LNG_ITALIAN    to "Gioved"
28253>>>>>>>>>>>        Set Language_Value "thursday"  LNG_SPANISH    to "Jueves"
28254>>>>>>>>>>>        Set Language_Value "thursday"  LNG_ENGLISH    to "Thursday"
28255>>>>>>>>>>>        Set Language_Value "thursday"  LNG_DANISH     to "Torsdag"
28256>>>>>>>>>>>        Set Language_Value "thursday"  LNG_SWEDISH    to "Torsdag"
28257>>>>>>>>>>>        Set Language_Value "thursday"  LNG_NORWEGIAN  to "Torsdag"
28258>>>>>>>>>>>        Set Language_Value "thursday"  LNG_GERMAN     to "Donnerstag"
28259>>>>>>>>>>>        Set Language_Value "thursday"  LNG_PORTUGUESE to "Quinta"
28260>>>>>>>>>>>        Set Language_Value "thursday"  LNG_FRENCH     to "Jeudi"
28261>>>>>>>>>>>        
28261>>>>>>>>>>>        Set Language_Value "friday"    LNG_DUTCH      to "Vrijdag"
28262>>>>>>>>>>>        Set Language_Value "friday"    LNG_ITALIAN    to "Venerd"
28263>>>>>>>>>>>        Set Language_Value "friday"    LNG_SPANISH    to "Viernes"
28264>>>>>>>>>>>        Set Language_Value "friday"    LNG_ENGLISH    to "Friday"
28265>>>>>>>>>>>        Set Language_Value "friday"    LNG_DANISH     to "Fredag"
28266>>>>>>>>>>>        Set Language_Value "friday"    LNG_SWEDISH    to "Fredag"
28267>>>>>>>>>>>        Set Language_Value "friday"    LNG_NORWEGIAN  to "Fredag"
28268>>>>>>>>>>>        Set Language_Value "friday"    LNG_GERMAN     to "Freitag"
28269>>>>>>>>>>>        Set Language_Value "friday"    LNG_PORTUGUESE to "Sexta"
28270>>>>>>>>>>>        Set Language_Value "friday"    LNG_FRENCH     to "Vendredi"
28271>>>>>>>>>>>
28271>>>>>>>>>>>        Set Language_Value "saturday"  LNG_DUTCH      to "Zaterdag"
28272>>>>>>>>>>>        Set Language_Value "saturday"  LNG_ITALIAN    to "Sabato"
28273>>>>>>>>>>>        Set Language_Value "saturday"  LNG_SPANISH    to "Sbado"
28274>>>>>>>>>>>        Set Language_Value "saturday"  LNG_ENGLISH    to "Saturday"
28275>>>>>>>>>>>        Set Language_Value "saturday"  LNG_DANISH     to "Lrdag"
28276>>>>>>>>>>>        Set Language_Value "saturday"  LNG_SWEDISH    to "Lrdag"
28277>>>>>>>>>>>        Set Language_Value "saturday"  LNG_NORWEGIAN  to "Lrdag"
28278>>>>>>>>>>>        Set Language_Value "saturday"  LNG_GERMAN     to "Samstag"
28279>>>>>>>>>>>        Set Language_Value "saturday"  LNG_PORTUGUESE to "Sbado"
28280>>>>>>>>>>>        Set Language_Value "saturday"  LNG_FRENCH     to "Samedi"
28281>>>>>>>>>>>
28281>>>>>>>>>>>        Set Language_Value "sunday"    LNG_DUTCH      to "Zondag"
28282>>>>>>>>>>>        Set Language_Value "sunday"    LNG_ITALIAN    to "Domenica"
28283>>>>>>>>>>>        Set Language_Value "sunday"    LNG_SPANISH    to "Domingo"
28284>>>>>>>>>>>        Set Language_Value "sunday"    LNG_ENGLISH    to "Sunday"
28285>>>>>>>>>>>        Set Language_Value "sunday"    LNG_DANISH     to "Sndag"
28286>>>>>>>>>>>        Set Language_Value "sunday"    LNG_SWEDISH    to "Sndag"
28287>>>>>>>>>>>        Set Language_Value "sunday"    LNG_NORWEGIAN  to "Sndag"
28288>>>>>>>>>>>        Set Language_Value "sunday"    LNG_GERMAN     to "Sonntag"
28289>>>>>>>>>>>        Set Language_Value "sunday"    LNG_PORTUGUESE to "Domingo"
28290>>>>>>>>>>>        Set Language_Value "sunday"    LNG_FRENCH     to "Dimanche"
28291>>>>>>>>>>>
28291>>>>>>>>>>>        Set Language_Value "int_userentry"   LNG_ENGLISH to "Explicit"
28292>>>>>>>>>>>        Set Language_Value "int_userentry"   LNG_DANISH  to "Tast selv"
28293>>>>>>>>>>>  
28293>>>>>>>>>>>        Set Language_Value "int_nolimit"     LNG_ENGLISH to "No limits"
28294>>>>>>>>>>>        Set Language_Value "int_nolimit"     LNG_DANISH  to "Ingen begr."
28295>>>>>>>>>>>        
28295>>>>>>>>>>>        Set Language_Value "int_lastweek"    LNG_ENGLISH to "Last week"
28296>>>>>>>>>>>        Set Language_Value "int_lastweek"    LNG_DANISH  to "Sidste uge"
28297>>>>>>>>>>>        
28297>>>>>>>>>>>        Set Language_Value "int_lastmonth"   LNG_ENGLISH to "Last month"
28298>>>>>>>>>>>        Set Language_Value "int_lastmonth"   LNG_DANISH  to "Sidste mned"
28299>>>>>>>>>>>        
28299>>>>>>>>>>>        Set Language_Value "int_lastyear"    LNG_ENGLISH to "Last year"
28300>>>>>>>>>>>        Set Language_Value "int_lastyear"    LNG_DANISH  to "Sidste r"
28301>>>>>>>>>>>        
28301>>>>>>>>>>>        Set Language_Value "int_weektodate"  LNG_ENGLISH to "Week to date"
28302>>>>>>>>>>>        Set Language_Value "int_weektodate"  LNG_DANISH  to "Uge til dato"
28303>>>>>>>>>>>        
28303>>>>>>>>>>>        Set Language_Value "int_monthtodate" LNG_ENGLISH to "Month to date"
28304>>>>>>>>>>>        Set Language_Value "int_monthtodate" LNG_DANISH  to "Mned til dato"
28305>>>>>>>>>>>        
28305>>>>>>>>>>>        Set Language_Value "int_yeartodate"  LNG_ENGLISH to "Year to date"
28306>>>>>>>>>>>        Set Language_Value "int_yeartodate"  LNG_DANISH  to "r til dato"
28307>>>>>>>>>>>
28307>>>>>>>>>>>    End_Procedure
28308>>>>>>>>>>>
28308>>>>>>>>>>>End_Object // oDatesLD
28309>>>>>>>>>Use Windows.pkg
28309>>>>>>>>>Use DfLine.pkg
Including file: Dfline.pkg    (E:\Program Files\DataFlex 18.0\Pkg\Dfline.pkg)
28309>>>>>>>>>>>//************************************************************************
28309>>>>>>>>>>>//--- DFLine.pkg   Line-Drawing
28309>>>>>>>>>>>//
28309>>>>>>>>>>>// Copyright (c) 1983-1997 Data Access Corporation, Miami Florida,
28309>>>>>>>>>>>// All rights reserved.
28309>>>>>>>>>>>// DataFlex is a registered trademark of Data Access Corporation.
28309>>>>>>>>>>>//
28309>>>>>>>>>>>//************************************************************************
28309>>>>>>>>>>>//  Description:
28309>>>>>>>>>>>//      A class designed to draw lines.
28309>>>>>>>>>>>//************************************************************************
28309>>>>>>>>>>>
28309>>>>>>>>>>>use windows.pkg
28309>>>>>>>>>>>
28309>>>>>>>>>>>//
28309>>>>>>>>>>>// Line Styles
28309>>>>>>>>>>>//
28309>>>>>>>>>>>Enumeration_list
28309>>>>>>>>>>>  define lnDIP        // grey (Shadow) top line, light bottom (highlight)
28309>>>>>>>>>>>  define lnBUMP       // light top (highlight), grey (Shadow) bottom
28309>>>>>>>>>>>  define lnSINGLE     // Single dark line
28309>>>>>>>>>>>  define lnCUSTOM     // create your own with line_color1 & 2.
28309>>>>>>>>>>>End_Enumeration_list
28309>>>>>>>>>>>
28309>>>>>>>>>>>// Interface:
28309>>>>>>>>>>>//
28309>>>>>>>>>>>//  Set Size             to Height Width
28309>>>>>>>>>>>//  Set Location         to col row
28309>>>>>>>>>>>//  Set Horizontal_State to TRUE|FALSE
28309>>>>>>>>>>>//  Set Line_Style       to lnDIP | lnBUMP | lnSINGLE | LnCUSTOM
28309>>>>>>>>>>>//  Set Line_Thickness   to pixel-thickness
28309>>>>>>>>>>>//  Set Line_Margin      to pixel-border
28309>>>>>>>>>>>//
28309>>>>>>>>>>>//  If LnCustom you must define both of these colors
28309>>>>>>>>>>>//     Set Line_Color1 to Windows_Color
28309>>>>>>>>>>>//     Set Line_Color2 to Windows_Color  (if 0, single line)
28309>>>>>>>>>>>//
28309>>>>>>>>>>>
28309>>>>>>>>>>>Class LineControl is a DFBaseLineControl
28310>>>>>>>>>>>
28310>>>>>>>>>>>    Procedure Construct_Object
28312>>>>>>>>>>>        Forward Send Construct_Object
28314>>>>>>>>>>>        Property integer Line_Color1  COLOR_BTNSHADOW
28315>>>>>>>>>>>        Property integer Line_Color2  COLOR_BTNHIGHLIGHT
28316>>>>>>>>>>>        // we do not want control to participate in forward backwards object navigation
28316>>>>>>>>>>>        set Skip_State to True
28317>>>>>>>>>>>    End_Procedure
28318>>>>>>>>>>>
28318>>>>>>>>>>>    Procedure Notify Integer wParam Integer lParam
28320>>>>>>>>>>>    End_Procedure
28321>>>>>>>>>>>
28321>>>>>>>>>>>    Procedure set Line_Color1 integer theColor
28323>>>>>>>>>>>        set top_line_color to theColor
28324>>>>>>>>>>>    End_Procedure
28325>>>>>>>>>>>
28325>>>>>>>>>>>    Procedure set Line_Color2 integer theColor
28327>>>>>>>>>>>        set bottom_line_color to theColor
28328>>>>>>>>>>>    End_Procedure
28329>>>>>>>>>>>
28329>>>>>>>>>>>    Function Line_Color1 returns integer
28331>>>>>>>>>>>        Function_Return (top_line_color(self))
28332>>>>>>>>>>>    End_Function
28333>>>>>>>>>>>
28333>>>>>>>>>>>    Function Line_Color2 returns integer
28335>>>>>>>>>>>        Function_Return (bottom_line_color(self))
28336>>>>>>>>>>>    End_Function
28337>>>>>>>>>>>End_Class
28338>>>>>>>>>Use RgbFunctions.pkg
Including file: RgbFunctions.pkg    (Z:\VmShare\Projects\WebQuery18-0\StureApsPublicLib\AppSrc\RgbFunctions.pkg)
28338>>>>>>>>>>>
28338>>>>>>>>>>>//> This package contains functions to manipulate RGB colors.
28338>>>>>>>>>>>//> The RGB color model is an additive color model in which red, green, and blue light are combined in various ways
28338>>>>>>>>>>>//> to create other colors. The very idea for the model itself and the abbreviation "RGB" come from the three primary
28338>>>>>>>>>>>//> colors in additive light models (http://www.wordiq.com/definition/RGB).
28338>>>>>>>>>>>//> pkg.doc.end
28338>>>>>>>>>>>
28338>>>>>>>>>>>Use VdfBase.pkg // DAW package. Provides low level support expected of all VDF applications (windows and web)
28338>>>>>>>>>>>
28338>>>>>>>>>>>Use StringFunctions.pkg // Define oStringFunctions object
28338>>>>>>>>>>>
28338>>>>>>>>>>>Class cRgbFunctions is a cObject
28339>>>>>>>>>>>    Procedure Construct_Object
28341>>>>>>>>>>>        Integer[] aColors
28342>>>>>>>>>>>        Forward Send Construct_Object
28344>>>>>>>>>>>        Property Integer[] paBrightColors
28345>>>>>>>>>>>        Get Brighten clRed 80 to aColors[0]
28346>>>>>>>>>>>        Get Brighten clGreen 80 to aColors[1]
28347>>>>>>>>>>>        Get Brighten clBlue 80 to aColors[2]
28348>>>>>>>>>>>        Get Brighten clYellow 80 to aColors[3]
28349>>>>>>>>>>>        Get Brighten clGray 80 to aColors[4]
28350>>>>>>>>>>>        Set paBrightColors to aColors
28351>>>>>>>>>>>    End_Procedure
28352>>>>>>>>>>>
28352>>>>>>>>>>>    Function BrightColor Integer iColor Returns Integer
28354>>>>>>>>>>>        Integer[] aColors
28355>>>>>>>>>>>        get paBrightColors to aColors
28356>>>>>>>>>>>        If (iColor=clRed) Function_Return aColors[0]
28359>>>>>>>>>>>        If (iColor=clGreen) Function_Return aColors[1]
28362>>>>>>>>>>>        If (iColor=clBlue) Function_Return aColors[2]
28365>>>>>>>>>>>        If (iColor=clYellow) Function_Return aColors[3]
28368>>>>>>>>>>>        If (iColor=clGray) Function_Return aColors[4]
28371>>>>>>>>>>>    End_Function
28372>>>>>>>>>>>
28372>>>>>>>>>>>    //> Return a RGB color composed from red, green and blue components (each of a value between 0 and 255)
28372>>>>>>>>>>>    Function Compose Integer iRed Integer iGreen Integer iBlue Returns Integer
28374>>>>>>>>>>>        Function_Return (iBlue*256+iGreen*256+iRed)
28375>>>>>>>>>>>    End_Function
28376>>>>>>>>>>>
28376>>>>>>>>>>>    //> Brighten a RGB color by a percentage.
28376>>>>>>>>>>>    Function Brighten Integer iColor Integer iPercent Returns Integer
28378>>>>>>>>>>>        Integer iRed iGreen iBlue
28378>>>>>>>>>>>        Move (iColor iand $0000FF) to iRed
28379>>>>>>>>>>>        Move (iColor iand $00FF00/256) to iGreen
28380>>>>>>>>>>>        Move (iColor iand $FF0000/65536) to iBlue
28381>>>>>>>>>>>        Move (255-iRed*iPercent/100+iRed) to iRed
28382>>>>>>>>>>>        Move (255-iGreen*iPercent/100+iGreen) to iGreen
28383>>>>>>>>>>>        Move (255-iBlue*iPercent/100+iBlue) to iBlue
28384>>>>>>>>>>>        Function_Return (iBlue*256+iGreen*256+iRed)
28385>>>>>>>>>>>    End_Function
28386>>>>>>>>>>>
28386>>>>>>>>>>>    //> Darken a RGB color by a percentage.
28386>>>>>>>>>>>    Function Darken Integer iColor Integer iPercent Returns Integer
28388>>>>>>>>>>>        Integer iRed iGreen iBlue
28388>>>>>>>>>>>        Move (iColor iand $0000FF) to iRed
28389>>>>>>>>>>>        Move (iColor iand $00FF00/256) to iGreen
28390>>>>>>>>>>>        Move (iColor iand $FF0000/65536) to iBlue
28391>>>>>>>>>>>        Move (-iRed*iPercent/100+iRed) to iRed
28392>>>>>>>>>>>        Move (-iGreen*iPercent/100+iGreen) to iGreen
28393>>>>>>>>>>>        Move (-iBlue*iPercent/100+iBlue) to iBlue
28394>>>>>>>>>>>        Function_Return (iBlue*256+iGreen*256+iRed)
28395>>>>>>>>>>>    End_Function
28396>>>>>>>>>>>
28396>>>>>>>>>>>    //> Blend two RGB colors weighing color1 by a percentage.
28396>>>>>>>>>>>    Function Blend Integer iColor1 Integer iColor2 Integer iPercent1 Returns Integer
28398>>>>>>>>>>>        Integer iRed1 iGreen1 iBlue1
28398>>>>>>>>>>>        Integer iRed2 iGreen2 iBlue2
28398>>>>>>>>>>>        Move (iColor1 iand $0000FF) to iRed1
28399>>>>>>>>>>>        Move (iColor1 iand $00FF00/256) to iGreen1
28400>>>>>>>>>>>        Move (iColor1 iand $FF0000/65536) to iBlue1
28401>>>>>>>>>>>        Move (iColor2 iand $0000FF) to iRed2
28402>>>>>>>>>>>        Move (iColor2 iand $00FF00/256) to iGreen2
28403>>>>>>>>>>>        Move (iColor2 iand $FF0000/65536) to iBlue2
28404>>>>>>>>>>>        Move (iRed1*iPercent1+(100-iPercent1*iRed2)/100) to iRed1
28405>>>>>>>>>>>        Move (iGreen1*iPercent1+(100-iPercent1*iGreen2)/100) to iGreen1
28406>>>>>>>>>>>        Move (iBlue1*iPercent1+(100-iPercent1*iBlue2)/100) to iBlue1
28407>>>>>>>>>>>        Function_Return (iBlue1*256+iGreen1*256+iRed1)
28408>>>>>>>>>>>    End_Function
28409>>>>>>>>>>>
28409>>>>>>>>>>>    //> Negate a RGB color
28409>>>>>>>>>>>    Function Negate Integer iColor Returns Integer
28411>>>>>>>>>>>        Integer iRed iGreen iBlue
28411>>>>>>>>>>>        Move (iColor iand $0000FF) to iRed
28412>>>>>>>>>>>        Move (iColor iand $00FF00/256) to iGreen
28413>>>>>>>>>>>        Move (iColor iand $FF0000/65536) to iBlue
28414>>>>>>>>>>>        Move (255-iRed) to iRed
28415>>>>>>>>>>>        Move (255-iGreen) to iGreen
28416>>>>>>>>>>>        Move (255-iBlue) to iBlue
28417>>>>>>>>>>>        Function_Return (iBlue*256+iGreen*256+iRed)
28418>>>>>>>>>>>    End_Function
28419>>>>>>>>>>>
28419>>>>>>>>>>>    //> Translate a RGB color to HTML syntax.
28419>>>>>>>>>>>    Function ToHTML Integer iColor Returns String
28421>>>>>>>>>>>        Integer iRed iGreen iBlue
28421>>>>>>>>>>>        Move (iColor iand $0000FF) to iRed
28422>>>>>>>>>>>        Move (iColor iand $00FF00/256) to iGreen
28423>>>>>>>>>>>        Move (iColor iand $FF0000/65536) to iBlue
28424>>>>>>>>>>>        Function_Return ("#"+ByteToHex(oStringFunctions,iRed)+ByteToHex(oStringFunctions,iGreen)+ByteToHex(oStringFunctions,iBlue))
28425>>>>>>>>>>>    End_Function
28426>>>>>>>>>>>
28426>>>>>>>>>>>    Function HTMLToRgb String sColor Returns Integer
28428>>>>>>>>>>>        Integer iRed iGreen iBlue
28428>>>>>>>>>>>        Move (Uppercase(Replace("#",sColor,""))) to sColor
28429>>>>>>>>>>>        Get HexToByte of oStringFunctions (Mid(sColor,2,1)) to iRed
28430>>>>>>>>>>>        Get HexToByte of oStringFunctions (Mid(sColor,2,3)) to iGreen
28431>>>>>>>>>>>        Get HexToByte of oStringFunctions (Mid(sColor,2,5)) to iBlue
28432>>>>>>>>>>>        Function_Return (Compose(Self,iRed,iGreen,iBlue))
28433>>>>>>>>>>>    End_Function
28434>>>>>>>>>>>    
28434>>>>>>>>>>>End_Class // cRgbFunctions
28435>>>>>>>>>>>
28435>>>>>>>>>>>Global_Variable Integer oRgbFunctions
28435>>>>>>>>>>>
28435>>>>>>>>>>>Object _oRgbFunctions is a cRgbFunctions
28437>>>>>>>>>>>    Move Self to oRgbFunctions
28438>>>>>>>>>>>End_Object
28439>>>>>>>>>
28439>>>>>>>>>
28439>>>>>>>>>Define LargestPossibleDate for 913490 // December 31st 2500
28439>>>>>>>>>Define Jan1st1900          for 693975
28439>>>>>>>>>Define Jan1st2000          for 730500
28439>>>>>>>>>Define Jan1st1930          for 704933
28439>>>>>>>>>Define Jan1st1000          for 365250
28439>>>>>>>>>Define Jan1st105           for 38352
28439>>>>>>>>>Define Jan1st100           for 36525
28439>>>>>>>>>
28439>>>>>>>>>Enumeration_List // Date Segments. Sequence of definitions determined granularity
28439>>>>>>>>>    Define DS_SECOND
28439>>>>>>>>>    Define DS_MINUTE
28439>>>>>>>>>    Define DS_HOUR
28439>>>>>>>>>    Define DS_DAY
28439>>>>>>>>>    Define DS_WEEK
28439>>>>>>>>>    Define DS_MONTH
28439>>>>>>>>>    Define DS_QUARTER
28439>>>>>>>>>    Define DS_YEAR
28439>>>>>>>>>End_Enumeration_List
28439>>>>>>>>>
28439>>>>>>>>>//#IFNDEF TS_HOUR
28439>>>>>>>>>//    Enumeration_List // Time Segments. Sequence of definitions determined granularity
28439>>>>>>>>>//        Define TS_SECOND
28439>>>>>>>>>//        Define TS_MINUTE
28439>>>>>>>>>//        Define TS_HOUR
28439>>>>>>>>>//    End_Enumeration_List
28439>>>>>>>>>//#ENDIF
28439>>>>>>>>>
28439>>>>>>>>>Enumeration_List // Codes for date interval presets
28439>>>>>>>>>  Define DI_EXPLICIT
28439>>>>>>>>>  Define DI_NO_LIMIT
28439>>>>>>>>>  Define DI_LAST_WEEK
28439>>>>>>>>>  Define DI_LAST_MONTH
28439>>>>>>>>>  Define DI_LAST_YEAR
28439>>>>>>>>>  Define DI_WEEK_TO_DATE
28439>>>>>>>>>  Define DI_MONTH_TO_DATE
28439>>>>>>>>>  Define DI_YEAR_TO_DATE
28439>>>>>>>>>End_Enumeration_List
28439>>>>>>>>>
28439>>>>>>>>>
28439>>>>>>>>>External_Function do_GetSystemTime "GetSystemTime" kernel32.dll Pointer lpGST Returns VOID_TYPE
28440>>>>>>>>>
28440>>>>>>>>>Struct tSystemTimeMS
28440>>>>>>>>>    Short iYear
28440>>>>>>>>>    Short iMonth
28440>>>>>>>>>    Short iDayOfWeek
28440>>>>>>>>>    Short iDay
28440>>>>>>>>>    Short iHour
28440>>>>>>>>>    Short iMinute
28440>>>>>>>>>    Short iSecond
28440>>>>>>>>>    Short iMilliSeconds
28440>>>>>>>>>End_Struct
28440>>>>>>>>>
28440>>>>>>>>>Global_Variable String _gsDate$ModuleStartTime
28440>>>>>>>>>
28440>>>>>>>>>Class cDateFunctions is a cObject
28441>>>>>>>>>    Procedure Construct_Object
28443>>>>>>>>>        Integer iValue
28443>>>>>>>>>        Forward Send Construct_Object  
28445>>>>>>>>>        Property String  psDateSeparator //
28446>>>>>>>>>        Property Integer piDateFormat    //
28447>>>>>>>>>        Get_Attribute DF_DATE_SEPARATOR to iValue  
28450>>>>>>>>>        Set psDateSeparator to (character(iValue)) 
28451>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iValue 
28454>>>>>>>>>        Set piDateFormat to iValue 
28455>>>>>>>>>        
28455>>>>>>>>>        // The next cryptic objects enables the language dependent functions of this package to change
28455>>>>>>>>>        // their language on the fly in an efficient manner.
28455>>>>>>>>>        
28455>>>>>>>>>        Object oDayNames is a cStringConstantsArray 
28457>>>>>>>>>            Set Value 1 to "ls.date.monday"
28458>>>>>>>>>            Set Value 2 to "ls.date.tuesday"
28459>>>>>>>>>            Set Value 3 to "ls.date.wednesday"
28460>>>>>>>>>            Set Value 4 to "ls.date.thursday"
28461>>>>>>>>>            Set Value 5 to "ls.date.friday"
28462>>>>>>>>>            Set Value 6 to "ls.date.saturday"
28463>>>>>>>>>            Set Value 7 to "ls.date.sunday"
28464>>>>>>>>>        End_Object
28465>>>>>>>>>
28465>>>>>>>>>        Object oMonthNames is a cStringConstantsArray
28467>>>>>>>>>            Set Value  1 to "ls.date.january"
28468>>>>>>>>>            Set Value  2 to "ls.date.february"
28469>>>>>>>>>            Set Value  3 to "ls.date.march"
28470>>>>>>>>>            Set Value  4 to "ls.date.april"
28471>>>>>>>>>            Set Value  5 to "ls.date.may"
28472>>>>>>>>>            Set Value  6 to "ls.date.june"
28473>>>>>>>>>            Set Value  7 to "ls.date.july"
28474>>>>>>>>>            Set Value  8 to "ls.date.august"
28475>>>>>>>>>            Set Value  9 to "ls.date.september"
28476>>>>>>>>>            Set Value 10 to "ls.date.october"
28477>>>>>>>>>            Set Value 11 to "ls.date.november"
28478>>>>>>>>>            Set Value 12 to "ls.date.december"
28479>>>>>>>>>        End_Object
28480>>>>>>>>>        
28480>>>>>>>>>        Object oIntervalLabels is a cStringConstantsArray
28482>>>>>>>>>            Set Value DI_EXPLICIT      to "ls.date.int_userentry"
28483>>>>>>>>>            Set Value DI_NO_LIMIT      to "ls.date.int_nolimit"
28484>>>>>>>>>            Set Value DI_LAST_WEEK     to "ls.date.int_lastweek"
28485>>>>>>>>>            Set Value DI_LAST_MONTH    to "ls.date.int_lastmonth"
28486>>>>>>>>>            Set Value DI_LAST_YEAR     to "ls.date.int_lastyear"
28487>>>>>>>>>            Set Value DI_WEEK_TO_DATE  to "ls.date.int_weektodate"
28488>>>>>>>>>            Set Value DI_MONTH_TO_DATE to "ls.date.int_monthtodate"
28489>>>>>>>>>            Set Value DI_YEAR_TO_DATE  to "ls.date.int_yeartodate"
28490>>>>>>>>>        End_Object
28491>>>>>>>>>    End_Procedure
28492>>>>>>>>>   
28492>>>>>>>>>    Procedure DecomposeDate Date dValue Integer ByRef iDay Integer ByRef iMonth Integer ByRef iYear
28494>>>>>>>>>        Integer iValue iFormat 
28494>>>>>>>>>        String sValue sSep 
28494>>>>>>>>>        Integer[] aNumbers
28495>>>>>>>>>   
28495>>>>>>>>>        Move (Date(dValue)) to dValue  
28496>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iFormat
28499>>>>>>>>>        Get_Attribute DF_DATE_SEPARATOR to iValue // overload  
28502>>>>>>>>>        Move (character(iValue)) to sSep          // end overload  
28503>>>>>>>>>        Move dValue to sValue  
28504>>>>>>>>>   
28504>>>>>>>>>        Send SplitString of oStringFunctions sValue sSep False False (&aNumbers)  
28505>>>>>>>>>        Move (SizeOfArray(aNumbers)) to iValue 
28506>>>>>>>>>        If (iValue=3) Begin
28508>>>>>>>>>            If (iFormat=DF_DATE_EUROPEAN) Begin
28510>>>>>>>>>                Move aNumbers[0] to iDay
28511>>>>>>>>>                Move aNumbers[1] to iMonth 
28512>>>>>>>>>                Move aNumbers[2] to iYear
28513>>>>>>>>>            End
28513>>>>>>>>>>
28513>>>>>>>>>            If (iFormat=DF_DATE_USA) Begin 
28515>>>>>>>>>                Move aNumbers[0] to iMonth 
28516>>>>>>>>>                Move aNumbers[1] to iDay   
28517>>>>>>>>>                Move aNumbers[2] to iYear  
28518>>>>>>>>>            End
28518>>>>>>>>>>
28518>>>>>>>>>            If (iFormat=DF_DATE_MILITARY) Begin
28520>>>>>>>>>                Move aNumbers[0] to iYear  
28521>>>>>>>>>                Move aNumbers[1] to iMonth 
28522>>>>>>>>>                Move aNumbers[2] to iDay   
28523>>>>>>>>>            End
28523>>>>>>>>>>
28523>>>>>>>>>        End
28523>>>>>>>>>>
28523>>>>>>>>>        Else Begin 
28524>>>>>>>>>            Move 0 to iDay 
28525>>>>>>>>>            Move 0 to iMonth   
28526>>>>>>>>>            Move 0 to iYear
28527>>>>>>>>>        End
28527>>>>>>>>>>
28527>>>>>>>>>    End_Procedure
28528>>>>>>>>>   
28528>>>>>>>>>    Function ComposeDate Integer iDay Integer iMonth Integer iYear Returns Date
28530>>>>>>>>>        Integer iFormat iDD iMM iYY
28530>>>>>>>>>        Date dValue
28530>>>>>>>>>        String sSep
28530>>>>>>>>>        ifnot (iDay*iMonth) Function_Return 0
28533>>>>>>>>>
28533>>>>>>>>>        Get_Attribute DF_DATE_SEPARATOR to iFormat // overload 
28536>>>>>>>>>        Move (character(iFormat)) to sSep          // end overload 
28537>>>>>>>>>   
28537>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iFormat
28540>>>>>>>>>        If (iDay>28) Begin 
28542>>>>>>>>>            If (iFormat=DF_DATE_EUROPEAN) Move (Date(String(iDay)+sSep+String(iMonth)+sSep+String(iYear))) to dValue // DMY
28545>>>>>>>>>            If (iFormat=DF_DATE_USA)      Move (Date(String(iMonth)+sSep+String(iDay)+sSep+String(iYear))) to dValue // MDY
28548>>>>>>>>>            If (iFormat=DF_DATE_MILITARY) Move (Date(String(iYear)+sSep+String(iMonth)+sSep+String(iDay))) to dValue // YMD
28551>>>>>>>>>            Send DecomposeDate dValue (&iDD) (&iMM) (&iYY)
28552>>>>>>>>>            If (iMM<>iMonth) Move (iDay-IDD) to iDay   
28555>>>>>>>>>        End
28555>>>>>>>>>>
28555>>>>>>>>>        If (iFormat=DF_DATE_EUROPEAN) Function_Return (Date(String(iDay)+sSep+String(iMonth)+sSep+String(iYear))) // DMY   
28558>>>>>>>>>        If (iFormat=DF_DATE_USA) Function_Return (Date(String(iMonth)+sSep+String(iDay)+sSep+String(iYear))) // MDY
28561>>>>>>>>>        Function_Return (Date(String(iYear)+sSep+String(iMonth)+sSep+String(iDay))) // YMD 
28562>>>>>>>>>    End_Function
28563>>>>>>>>>    
28563>>>>>>>>>    // DecomposeTimeString / TimeStringDecompose
28563>>>>>>>>>    Procedure DecomposeTimeString String sTime Integer ByRef iHour Integer ByRef iMin Integer ByRef iSec
28565>>>>>>>>>        String[] aValues
28566>>>>>>>>>        Send SplitString of oStringFunctions (trim(sTime)) ":" False False (&aValues)
28567>>>>>>>>>        If (SizeOfArray(aValues)=2) Begin
28569>>>>>>>>>            Move aValues[0] to iHour
28570>>>>>>>>>            Move aValues[1] to iMin
28571>>>>>>>>>            Move 0 to iSec
28572>>>>>>>>>        End
28572>>>>>>>>>>
28572>>>>>>>>>        Else If (SizeOfArray(aValues)=3) Begin
28575>>>>>>>>>            Move aValues[0] to iHour
28576>>>>>>>>>            Move aValues[1] to iMin
28577>>>>>>>>>            Move aValues[2] to iSec
28578>>>>>>>>>        End
28578>>>>>>>>>>
28578>>>>>>>>>        Else If (length(sTime)=4) Begin
28581>>>>>>>>>            Move (Mid(sTime,2,1)) to iHour
28582>>>>>>>>>            Move (Mid(sTime,2,3)) to iMin
28583>>>>>>>>>            Move 0 to iSec
28584>>>>>>>>>        End
28584>>>>>>>>>>
28584>>>>>>>>>        Else If (length(sTime)=6) Begin
28587>>>>>>>>>            Move (Mid(sTime,2,1)) to iHour
28588>>>>>>>>>            Move (Mid(sTime,2,3)) to iMin
28589>>>>>>>>>            Move (Mid(sTime,2,5)) to iSec            
28590>>>>>>>>>        End
28590>>>>>>>>>>
28590>>>>>>>>>        Else Begin
28591>>>>>>>>>            Move 0 to iHour
28592>>>>>>>>>            Move 0 to iMin 
28593>>>>>>>>>            Move 0 to iSec 
28594>>>>>>>>>        End
28594>>>>>>>>>>
28594>>>>>>>>>    End_Procedure
28595>>>>>>>>>    
28595>>>>>>>>>    // ComposeTimeString / TimeStringCompose
28595>>>>>>>>>    Function ComposeTimeString Integer iHour Integer iMin Integer iSec Returns String
28597>>>>>>>>>        Function_Return (If(iHour<10,"0","")+String(iHour)+":"+If(iMin<10,"0","")+String(iMin)+":"+If(iSec<10,"0","")+String(iSec))
28598>>>>>>>>>    End_Function
28599>>>>>>>>>    
28599>>>>>>>>>    // DecomposeTime / TimeDecompose
28599>>>>>>>>>    Procedure DecomposeTime Time tmTime Integer ByRef iHour Integer ByRef iMin Integer ByRef iSec
28601>>>>>>>>>        Move (DateGetHour(tmTime)) to iHour
28602>>>>>>>>>        Move (DateGetMinute(tmTime)) to iMin
28603>>>>>>>>>        Move (DateGetSecond(tmTime)) to iSec
28604>>>>>>>>>    End_Procedure
28605>>>>>>>>>    
28605>>>>>>>>>    // ComposeTime / TimeCompose
28605>>>>>>>>>    Function ComposeTime Integer iHour Integer iMin Integer iSec Returns Time
28607>>>>>>>>>        Time tRval
28607>>>>>>>>>        Move (DateSetHour(tRval,iHour)) to tRval
28608>>>>>>>>>        Move (DateSetMinute(tRval,iMin)) to tRval
28609>>>>>>>>>        Move (DateSetSecond(tRval,iSec)) to tRval
28610>>>>>>>>>        Function_Return tRval
28611>>>>>>>>>    End_Function
28612>>>>>>>>>        
28612>>>>>>>>>    // DecomposeDateTime / DateTimeDecompose
28612>>>>>>>>>    Procedure DecomposeDateTime DateTime dtValue Date ByRef dDate Time ByRef tmTime
28614>>>>>>>>>        Move (ComposeDate(Self,DateGetDay(dtValue),DateGetMonth(dtValue),DateGetYear(dtValue))) to dDate
28615>>>>>>>>>        Move (ComposeTime(Self,DateGetHour(dtValue),DateGetMinute(dtValue),DateGetSecond(dtValue))) to tmTime
28616>>>>>>>>>    End_Procedure
28617>>>>>>>>>    
28617>>>>>>>>>    // ComposeDateTime / DateTimeCompose
28617>>>>>>>>>    Function ComposeDateTime Date dDate Time tmTime Returns DateTime
28619>>>>>>>>>        Integer iHour iMin iSec
28619>>>>>>>>>        DateTime dtRval
28619>>>>>>>>>        Move dDate to dtRval
28620>>>>>>>>>        Move (DateGetHour(tmTime)) to iHour
28621>>>>>>>>>        Move (DateGetMinute(tmTime)) to iMin
28622>>>>>>>>>        Move (DateGetSecond(tmTime)) to iSec
28623>>>>>>>>>        If (iHour<>0) Move (DateSetHour(dtRval,iHour)) to dtRval
28626>>>>>>>>>        If (iMin<>0) Move (DateSetMinute(dtRval,iMin)) to dtRval
28629>>>>>>>>>        If (iSec<>0) Move (DateSetSecond(dtRval,iSec)) to dtRval
28632>>>>>>>>>        Function_Return dtRval
28633>>>>>>>>>    End_Function
28634>>>>>>>>>    
28634>>>>>>>>>    // DecomposeDateTimeString / DateTimeStringDecompose
28634>>>>>>>>>    Procedure DecomposeDateTimeString DateTime dtValue Date ByRef dDate String ByRef sTime
28636>>>>>>>>>        Move (ComposeDate(Self,DateGetDay(dtValue),DateGetMonth(dtValue),DateGetYear(dtValue))) to dDate
28637>>>>>>>>>        Move (ComposeTimeString(Self,DateGetHour(dtValue),DateGetMinute(dtValue),DateGetSecond(dtValue))) to sTime
28638>>>>>>>>>    End_Procedure
28639>>>>>>>>>    
28639>>>>>>>>>    // ComposeDateTimeString / DateTimeStringCompose
28639>>>>>>>>>    Function ComposeDateTimeString Date dDate String sTime Returns DateTime
28641>>>>>>>>>        Integer iHour iMin iSec
28641>>>>>>>>>        DateTime dtRval
28641>>>>>>>>>        Send DecomposeTimeString sTime (&iHour) (&iMin) (&iSec)
28642>>>>>>>>>        Move dDate to dtRval
28643>>>>>>>>>        Move (DateSetHour(dtRval,iHour)) to dtRval
28644>>>>>>>>>        Move (DateSetMinute(dtRval,iMin)) to dtRval
28645>>>>>>>>>        Move (DateSetSecond(dtRval,iSec)) to dtRval
28646>>>>>>>>>        Function_Return dtRval
28647>>>>>>>>>    End_Function
28648>>>>>>>>>    
28648>>>>>>>>>    Procedure DecomposeDateTimeAtoms DateTime dtValue Date ByRef dDate Integer ByRef iHour Integer ByRef iMin Integer ByRef iSec 
28650>>>>>>>>>        Time tmTime
28650>>>>>>>>>        Send DecomposeDateTime dtValue (&dDate) (&tmTime)
28651>>>>>>>>>        Send DecomposeTime tmTime (&iHour) (&iMin) (&iSec)
28652>>>>>>>>>    End_Procedure
28653>>>>>>>>>    
28653>>>>>>>>>    Function ComposeDateTimeAtoms Date dDate Integer iHour Integer iMin Integer iSec Returns DateTime
28655>>>>>>>>>        Time tmTime
28655>>>>>>>>>        DateTime dtValue
28655>>>>>>>>>        Get ComposeTime iHour iMin iSec to tmTime
28656>>>>>>>>>        Get ComposeDateTime dDate tmTime to dtValue
28657>>>>>>>>>        Function_Return dtValue
28658>>>>>>>>>    End_Function
28659>>>>>>>>>
28659>>>>>>>>>    Procedure DecomposeDateTimeQuarks DateTime dtValue Integer ByRef iYear Integer ByRef iMonth Integer ByRef iDay Integer ByRef iHour Integer ByRef iMin Integer ByRef iSec 
28661>>>>>>>>>        Date dDate
28661>>>>>>>>>        Time tmTime
28661>>>>>>>>>        Send DecomposeDateTime dtValue (&dDate) (&tmTime)
28662>>>>>>>>>        Send DecomposeDate dDate (&iDay) (&iMonth) (&iYear)
28663>>>>>>>>>        Send DecomposeTime tmTime (&iHour) (&iMin) (&iSec)
28664>>>>>>>>>    End_Procedure
28665>>>>>>>>>    
28665>>>>>>>>>    Function ComposeDateTimeQuarks Integer iYear Integer iMonth Integer iDay Integer iHour Integer iMin Integer iSec Returns DateTime
28667>>>>>>>>>        Time tmTime
28667>>>>>>>>>        Date dDate
28667>>>>>>>>>        DateTime dtValue
28667>>>>>>>>>        Get ComposeDate iDay iMonth iYear to dDate
28668>>>>>>>>>        Get ComposeTime iHour iMin iSec to tmTime
28669>>>>>>>>>        Get ComposeDateTime dDate tmTime to dtValue
28670>>>>>>>>>        Function_Return dtValue
28671>>>>>>>>>    End_Function
28672>>>>>>>>>
28672>>>>>>>>>    Function TimeToTimeString Time tmTime Returns String
28674>>>>>>>>>        Integer iHour iMin iSec
28674>>>>>>>>>        Send DecomposeTime tmTime (&iHour) (&iMin) (&iSec)
28675>>>>>>>>>        Function_Return (ComposeTimeString(Self,iHour,iMin,iSec))
28676>>>>>>>>>    End_Function
28677>>>>>>>>>    
28677>>>>>>>>>    Function TimeStringToTime String sTime Returns Time
28679>>>>>>>>>        Integer iHour iMin iSec
28679>>>>>>>>>        Send DecomposeTimeString sTime (&iHour) (&iMin) (&iSec)
28680>>>>>>>>>        Function_Return (ComposeTime(Self,iHour,iMin,iSec))
28681>>>>>>>>>    End_Function
28682>>>>>>>>>    
28682>>>>>>>>>    // The number returned is equivalent to the number of seconds between Jan 1st year 0 and the value of dtValue. This means that you may subtract two such values to get the number of seconds elapsed between the two.
28682>>>>>>>>>    Function DateTimeToNumber DateTime dtValue Returns Number
28684>>>>>>>>>        Date dValue
28684>>>>>>>>>        Move dtValue to dValue // Strip hours, minutes and seconds
28685>>>>>>>>>        Function_Return (Integer(dValue)*24.0+DateGetHour(dtValue)*60+DateGetMinute(dtValue)*60+DateGetSecond(dtValue))
28686>>>>>>>>>    End_Function
28687>>>>>>>>>
28687>>>>>>>>>    Function NumberToDateTime Number nValue Returns DateTime
28689>>>>>>>>>        Integer iSeconds iHours iMinutes
28689>>>>>>>>>        Date dValue
28689>>>>>>>>>        String sTime
28689>>>>>>>>>        Time tmTime
28689>>>>>>>>>        DateTime dtRval
28689>>>>>>>>>        Move (Date(Integer(nValue/86400))) to dValue
28690>>>>>>>>>        If (Integer(dValue)<>0) Begin
28692>>>>>>>>>            Move (nValue-(86400.0*Integer(dValue))) to iSeconds
28693>>>>>>>>>            Move (iSeconds/3600) to iHours
28694>>>>>>>>>            Move (iSeconds-(iHours*3600)) to iSeconds
28695>>>>>>>>>            Move (iSeconds/60) to iMinutes
28696>>>>>>>>>            Move (iSeconds-(iMinutes*60)) to iSeconds
28697>>>>>>>>>            Get ComposeTimeString iHours iMinutes iSeconds to sTime
28698>>>>>>>>>            Get TimeStringToTime sTime to tmTime
28699>>>>>>>>>            Get ComposeDateTime dValue tmTime to dtRval
28700>>>>>>>>>            
28700>>>>>>>>>            //Function_Return (DateTimeCompose(Self,dValue,TimeStringToTime(Self,sTime)))
28700>>>>>>>>>        End
28700>>>>>>>>>>
28700>>>>>>>>>        Function_Return dtRval
28701>>>>>>>>>    End_Function
28702>>>>>>>>>   
28702>>>>>>>>>    Function SystemDate Returns Date
28704>>>>>>>>>        Date dDate
28704>>>>>>>>>        Sysdate4 dDate
28705>>>>>>>>>        Function_Return dDate
28706>>>>>>>>>    End_Function
28707>>>>>>>>>
28707>>>>>>>>>    Function SystemTimeString Returns String
28709>>>>>>>>>        Integer iHour iMin iSec
28709>>>>>>>>>        Sysdate4 iHour iHour iMin iSec
28713>>>>>>>>>        Function_Return (ComposeTimeString(Self,iHour,iMin,iSec))
28714>>>>>>>>>    End_Function
28715>>>>>>>>>    
28715>>>>>>>>>    Function SystemTimeStringMS Returns String
28717>>>>>>>>>        tSystemTimeMS strTime
28717>>>>>>>>>        tSystemTimeMS strTime
28717>>>>>>>>>        String sValue
28717>>>>>>>>>        Get SystemTimeMilliSeconds to strTime
28718>>>>>>>>>        Get SystemTimeToString23 strTime to sValue
28719>>>>>>>>>        Function_Return (Right(sValue,12)) // Only the 'time' part
28720>>>>>>>>>    End_Function
28721>>>>>>>>>    
28721>>>>>>>>>    Function SystemDateTime Returns DateTime
28723>>>>>>>>>        Function_Return (CurrentDateTime())
28724>>>>>>>>>    End_Function
28725>>>>>>>>>    
28725>>>>>>>>>    Function SystemTime Returns Time // <-New
28727>>>>>>>>>        Date dValue
28727>>>>>>>>>        DateTime dtValue
28727>>>>>>>>>        Time tmResult
28727>>>>>>>>>        Move (CurrentDateTime()) to dtValue
28728>>>>>>>>>        Send DecomposeDateTime dtValue (&dValue) (&tmResult)
28729>>>>>>>>>        Function_Return tmResult
28730>>>>>>>>>    End_Function
28731>>>>>>>>>    
28731>>>>>>>>>    Function SystemTimeMilliSeconds Returns tSystemTimeMS
28733>>>>>>>>>        Integer iVoid
28733>>>>>>>>>        tSystemTimeMS stRval
28733>>>>>>>>>        tSystemTimeMS stRval
28733>>>>>>>>>        Move (do_GetSystemTime(AddressOf(stRval))) to iVoid
28734>>>>>>>>>        Function_Return stRval
28735>>>>>>>>>    End_Function 
28736>>>>>>>>>    
28736>>>>>>>>>    Function ModuleStartTime Returns String // YYYY-MM-DDTHH:MM:SS.mmm
28738>>>>>>>>>        Function_Return _gsDate$ModuleStartTime 
28739>>>>>>>>>    End_Function
28740>>>>>>>>>    
28740>>>>>>>>>    Function SystemTimeMilliSecondsElapsed tSystemTimeMS strStart tSystemTimeMS strStop Returns Number
28742>>>>>>>>>        Integer iDays
28742>>>>>>>>>        tSystemTimeMS strStopX
28742>>>>>>>>>        tSystemTimeMS strStopX
28742>>>>>>>>>        If (num_arguments>1) Begin
28744>>>>>>>>>            Move strStop to strStopX
28745>>>>>>>>>        End
28745>>>>>>>>>>
28745>>>>>>>>>        Else Begin
28746>>>>>>>>>            Get SystemTimeMilliSeconds to strStopX
28747>>>>>>>>>        End
28747>>>>>>>>>>
28747>>>>>>>>>        Move (Integer(ComposeDate(Self,strStopX.iDay,strStopX.iMonth,strStopX.iYear))-Integer(ComposeDate(Self,strStart.iDay,strStart.iMonth,strStart.iYear))) to iDays
28748>>>>>>>>>        Function_Return (iDays*24.0+(strStopX.iHour-strStart.iHour)*60+(strStopX.iMinute-strStart.iMinute)*60+(strStopX.iSecond-strStart.iSecond)*1000+strStopX.iMilliSeconds-strStart.iMilliSeconds)
28749>>>>>>>>>    End_Function
28750>>>>>>>>>
28750>>>>>>>>>    Function SystemTimeToString tSystemTimeMS stTime Returns String
28752>>>>>>>>>        String sValue
28752>>>>>>>>>
28752>>>>>>>>>        Move stTime.iYear to sValue
28753>>>>>>>>>        Move (sValue+IntegerToStringRzf(oStringFunctions,stTime.iMonth,2)) to sValue
28754>>>>>>>>>        Move (sValue+IntegerToStringRzf(oStringFunctions,stTime.iDay,2)) to sValue
28755>>>>>>>>>        Move (sValue+IntegerToStringRzf(oStringFunctions,stTime.iHour,2)) to sValue
28756>>>>>>>>>        Move (sValue+IntegerToStringRzf(oStringFunctions,stTime.iMinute,2)) to sValue
28757>>>>>>>>>        Move (sValue+IntegerToStringRzf(oStringFunctions,stTime.iSecond,2)) to sValue
28758>>>>>>>>>        Move (sValue+IntegerToStringRzf(oStringFunctions,stTime.iMilliSeconds,3)) to sValue
28759>>>>>>>>>        
28759>>>>>>>>>        Function_Return sValue // 19991231135959999 (=length:17)
28760>>>>>>>>>    End_Function
28761>>>>>>>>>    
28761>>>>>>>>>    Function SystemTimeToString23 tSystemTimeMS stTime Returns String
28763>>>>>>>>>        String sValue 
28763>>>>>>>>>
28763>>>>>>>>>        Move stTime.iYear to sValue
28764>>>>>>>>>        Move (sValue+"-"+IntegerToStringRzf(oStringFunctions,stTime.iMonth,2)) to sValue
28765>>>>>>>>>        Move (sValue+"-"+IntegerToStringRzf(oStringFunctions,stTime.iDay,2)) to sValue
28766>>>>>>>>>        Move (sValue+"T"+IntegerToStringRzf(oStringFunctions,stTime.iHour,2)) to sValue
28767>>>>>>>>>        Move (sValue+":"+IntegerToStringRzf(oStringFunctions,stTime.iMinute,2)) to sValue
28768>>>>>>>>>        Move (sValue+":"+IntegerToStringRzf(oStringFunctions,stTime.iSecond,2)) to sValue
28769>>>>>>>>>        Move (sValue+"."+IntegerToStringRzf(oStringFunctions,stTime.iMilliSeconds,3)) to sValue
28770>>>>>>>>>        
28770>>>>>>>>>        Function_Return sValue // 1999-12-31T13:59:59.999 (=length:23)
28771>>>>>>>>>    End_Function               // 1    6  9  2  5  8  1
28772>>>>>>>>>    
28772>>>>>>>>>    Function String23ToSystemTime String sValue Returns tSystemTimeMS 
28774>>>>>>>>>        tSystemTimeMS strTime
28774>>>>>>>>>        tSystemTimeMS strTime
28774>>>>>>>>>        Move (Integer(Mid(sValue,4,1))) to strTime.iYear
28775>>>>>>>>>        Move (Integer(Mid(sValue,2,6))) to strTime.iMonth
28776>>>>>>>>>        Move (Integer(Mid(sValue,2,9))) to strTime.iDay
28777>>>>>>>>>        Move (Integer(Mid(sValue,2,12))) to strTime.iHour
28778>>>>>>>>>        Move (Integer(Mid(sValue,2,15))) to strTime.iMinute
28779>>>>>>>>>        Move (Integer(Mid(sValue,2,18))) to strTime.iSecond
28780>>>>>>>>>        Move (Integer(Mid(sValue,3,21))) to strTime.iMilliSeconds
28781>>>>>>>>>        Function_Return strTime
28782>>>>>>>>>    End_Function
28783>>>>>>>>>    
28783>>>>>>>>>    Function SystemTimeString23 Returns String
28785>>>>>>>>>        Function_Return (SystemTimeToString23(Self,SystemTimeMilliSeconds(Self)))
28786>>>>>>>>>    End_Function
28787>>>>>>>>>
28787>>>>>>>>>    Function SystemTimeAsPathNameSegment Returns String
28789>>>>>>>>>        String sPathNameSegment
28789>>>>>>>>>        Get SystemTimeString23 to sPathNameSegment
28790>>>>>>>>>        Move (Replace(":",sPathNameSegment,"")) to sPathNameSegment
28791>>>>>>>>>        Move (Replace(":",sPathNameSegment,"")) to sPathNameSegment
28792>>>>>>>>>        Move (Replace(".",sPathNameSegment,"")) to sPathNameSegment
28793>>>>>>>>>        Function_Return sPathNameSegment
28794>>>>>>>>>    End_Function
28795>>>>>>>>>    
28795>>>>>>>>>
28795>>>>>>>>>    //> Use Increment to add or subtract a number of months, years, days or
28795>>>>>>>>>    //> weeks to/from a given date.
28795>>>>>>>>>    //>
28795>>>>>>>>>    //>  date dValue        is the date to which the time interval will be added or subtracted 
28795>>>>>>>>>    //>
28795>>>>>>>>>    //>  integer iSegment   may be one of these constants: DS_YEAR, DS_MONTH, DS_DAY or DS_WEEK
28795>>>>>>>>>    //>
28795>>>>>>>>>    //>  integer iAmount    is the (positive or negative) amount of units (indicated by iSegment) to be added.
28795>>>>>>>>>    Function DateIncrement Date dValue Integer iSegment Integer iAmount Returns Date   
28797>>>>>>>>>        Integer iDay iMonth iYear  
28797>>>>>>>>>        If (Integer(dValue)=0) Function_Return 0  
28800>>>>>>>>>        If (iSegment=DS_QUARTER) Function_Return (DateIncrement(Self,dValue,DS_MONTH,iAmount*3))   
28803>>>>>>>>>        If (iSegment=DS_WEEK) Function_Return (dValue+(iAmount*7)) //weeks 
28806>>>>>>>>>        If (iSegment<>DS_DAY) Begin // months or years 
28808>>>>>>>>>            Send DecomposeDate dValue (&iDay) (&iMonth) (&iYear)   
28809>>>>>>>>>            If (iSegment=DS_MONTH) Begin //months  
28811>>>>>>>>>                Move (iMonth+iAmount) to iMonth
28812>>>>>>>>>                If (iAmount>=0) Function_Return (ComposeDate(Self,iDay,iMonth-(((iMonth-1)/12)*12),iYear+((iMonth-1)/12))) 
28815>>>>>>>>>                Function_Return (ComposeDate(Self,iDay,iMonth-(((iMonth-12)/12)*12),iYear+((iMonth-12)/12)))   
28816>>>>>>>>>            End //years:   
28816>>>>>>>>>>
28816>>>>>>>>>            If (iSegment=DS_YEAR) Function_Return (ComposeDate(Self,iDay,iMonth,iYear+iAmount))
28819>>>>>>>>>        End
28819>>>>>>>>>>
28819>>>>>>>>>        Else Function_Return (dValue+iAmount) //days   
28821>>>>>>>>>    End_Function   
28822>>>>>>>>>   
28822>>>>>>>>>    Function DateSegment Date dValue Integer iSegment Returns Integer  
28824>>>>>>>>>        Integer iDay iMonth iYear iWeek
28824>>>>>>>>>        If (iSegment=DS_WEEK) Begin
28826>>>>>>>>>            Get WeekNumber dValue to iWeek
28827>>>>>>>>>            Function_Return iWeek
28828>>>>>>>>>        End
28828>>>>>>>>>>
28828>>>>>>>>>        Else Begin
28829>>>>>>>>>            Send DecomposeDate dValue (&iDay) (&iMonth) (&iYear)   
28830>>>>>>>>>            If (iSegment=DS_DAY)     Function_Return iDay  
28833>>>>>>>>>            If (iSegment=DS_MONTH)   Function_Return iMonth
28836>>>>>>>>>            If (iSegment=DS_YEAR)    Function_Return iYear 
28839>>>>>>>>>            If (iSegment=DS_QUARTER) Function_Return (iMonth+2/3)
28842>>>>>>>>>        End
28842>>>>>>>>>>
28842>>>>>>>>>        Function_Return 0 // Also covers DS_ETERNITY
28843>>>>>>>>>    End_Function
28844>>>>>>>>>    
28844>>>>>>>>>    Function TimeIncrement Time tmValue Integer iSegment Integer iAmount Integer ByRef iDays Returns Time
28846>>>>>>>>>        Integer iHour iMin iSec
28846>>>>>>>>>        Send DecomposeTime tmValue (&iHour) (&iMin) (&iSec)
28847>>>>>>>>>        If (iSegment=DS_HOUR) Begin
28849>>>>>>>>>            Move (iHour+iAmount) to iHour
28850>>>>>>>>>        End
28850>>>>>>>>>>
28850>>>>>>>>>        If (iSegment=DS_MINUTE) Begin
28852>>>>>>>>>            Move (iMin+iAmount) to iMin
28853>>>>>>>>>        End
28853>>>>>>>>>>
28853>>>>>>>>>        If (iSegment=DS_SECOND) Begin
28855>>>>>>>>>            Move (iSec+iAmount) to iSec
28856>>>>>>>>>        End
28856>>>>>>>>>>
28856>>>>>>>>>        Move (iHour*60+iMin*60+iSec) to iSec
28857>>>>>>>>>        If (iSec>=0) Begin
28859>>>>>>>>>            Move (iSec/86400) to iDays
28860>>>>>>>>>        End
28860>>>>>>>>>>
28860>>>>>>>>>        Else Begin
28861>>>>>>>>>            Move (iSec/86400) to iDays
28862>>>>>>>>>            Decrement iDays
28863>>>>>>>>>        End
28863>>>>>>>>>>
28863>>>>>>>>>        Move (iSec-(iDays*86400)) to iSec
28864>>>>>>>>>        Move (iSec/3600) to iHour
28865>>>>>>>>>        Move (iSec-(iHour*3600)) to iSec
28866>>>>>>>>>        Move (iSec/60) to iMin
28867>>>>>>>>>        Move (iSec-(iMin*60)) to iSec
28868>>>>>>>>>        Get ComposeTime iHour iMin iSec to tmValue
28869>>>>>>>>>        Function_Return tmValue
28870>>>>>>>>>    End_Function
28871>>>>>>>>>
28871>>>>>>>>>    Function DateTimeIncrement DateTime dtValue Integer iSegment Integer iAmount Returns DateTime
28873>>>>>>>>>        Integer iDays
28873>>>>>>>>>        Date dValue
28873>>>>>>>>>        Time tmValue
28873>>>>>>>>>        Send DecomposeDateTime dtValue (&dValue) (&tmValue)
28874>>>>>>>>>        If (iSegment>=DS_DAY) Begin
28876>>>>>>>>>            Get DateIncrement dValue iSegment iAmount to dValue
28877>>>>>>>>>        End
28877>>>>>>>>>>
28877>>>>>>>>>        Else Begin
28878>>>>>>>>>            Get TimeIncrement tmValue iSegment iAmount (&iDays) to tmValue
28879>>>>>>>>>            Move (dValue+iDays) to dValue
28880>>>>>>>>>        End
28880>>>>>>>>>>
28880>>>>>>>>>        Function_Return (ComposeDateTime(Self,dValue,tmValue))
28881>>>>>>>>>    End_Function
28882>>>>>>>>>    
28882>>>>>>>>>    Function FirstDateIn Integer iDateSegment Date dValue Returns Date
28884>>>>>>>>>        Integer iQuarter iYear iMonth iWeek
28884>>>>>>>>>        If (iDateSegment=DS_MONTH) Begin
28886>>>>>>>>>            Get DateSegment dValue DS_MONTH to iMonth
28887>>>>>>>>>            Get DateSegment dValue DS_YEAR to iYear
28888>>>>>>>>>            Function_Return (ComposeDate(Self,1,iMonth,iYear))
28889>>>>>>>>>        End
28889>>>>>>>>>>
28889>>>>>>>>>        If (iDateSegment=DS_QUARTER) Begin
28891>>>>>>>>>            Get DateSegment dValue DS_QUARTER to iQuarter
28892>>>>>>>>>            Get DateSegment dValue DS_YEAR to iYear
28893>>>>>>>>>            Function_Return (ComposeDate(Self,1,iQuarter-1*3+1,iYear))
28894>>>>>>>>>        End
28894>>>>>>>>>>
28894>>>>>>>>>        If (iDateSegment=DS_YEAR) Begin
28896>>>>>>>>>            Get DateSegment dValue DS_YEAR to iYear
28897>>>>>>>>>            Function_Return (ComposeDate(Self,1,1,iYear))
28898>>>>>>>>>        End
28898>>>>>>>>>>
28898>>>>>>>>>        If (iDateSegment=DS_WEEK) Begin
28900>>>>>>>>>            Get DateSegment dValue DS_WEEK to iWeek
28901>>>>>>>>>            Get DateSegment dValue DS_YEAR to iYear
28902>>>>>>>>>            Get MondayInWeek iYear iWeek to dValue
28903>>>>>>>>>            Function_Return dValue
28904>>>>>>>>>        End
28904>>>>>>>>>>
28904>>>>>>>>>        Error 123 "Illegal iDateSegment value (Function FirstDateIn)"
28905>>>>>>>>>>
28905>>>>>>>>>    End_Function
28906>>>>>>>>>
28906>>>>>>>>>    Function LastDateIn Integer iDateSegment Date dValue Returns Date
28908>>>>>>>>>        If (iDateSegment=DS_MONTH) Begin
28910>>>>>>>>>            Get DateIncrement dValue DS_MONTH 1 to dValue
28911>>>>>>>>>            Function_Return (FirstDateIn(Self,DS_MONTH,dValue)-1)
28912>>>>>>>>>        End
28912>>>>>>>>>>
28912>>>>>>>>>        If (iDateSegment=DS_QUARTER) Begin
28914>>>>>>>>>            Get FirstDateIn DS_QUARTER dValue to dValue
28915>>>>>>>>>            Get DateIncrement dValue DS_QUARTER 1 to dValue
28916>>>>>>>>>            Function_Return (DateIncrement(Self,dValue,DS_DAY,-1))
28917>>>>>>>>>        End
28917>>>>>>>>>>
28917>>>>>>>>>        If (iDateSegment=DS_YEAR) Begin
28919>>>>>>>>>            Get DateIncrement dValue DS_YEAR 1 to dValue   
28920>>>>>>>>>            Function_Return (FirstDateIn(Self,DS_YEAR,dValue)-1)
28921>>>>>>>>>        End
28921>>>>>>>>>>
28921>>>>>>>>>        If (iDateSegment=DS_WEEK) Begin
28923>>>>>>>>>            Get FirstDateIn DS_WEEK dValue to dValue
28924>>>>>>>>>            Get DateIncrement dValue DS_DAY 6 to dValue
28925>>>>>>>>>            Function_Return dValue
28926>>>>>>>>>        End
28926>>>>>>>>>>
28926>>>>>>>>>        Error 123 "Illegal iDateSegment value (Function LastDateIn)"
28927>>>>>>>>>>
28927>>>>>>>>>    End_Function
28928>>>>>>>>>   
28928>>>>>>>>>    // This procedure calculates the date interval including dAnchor in the last interval and the previous iIntervals-1 intervals.
28928>>>>>>>>>    Procedure CalculateStartStopDates Date dAnchor Integer iDateSegment Integer iIntervals Date ByRef dBegin Date ByRef dEnd
28930>>>>>>>>>        If (iDateSegment=DS_DAY) Begin
28932>>>>>>>>>            Get DateIncrement dAnchor DS_DAY (1-iIntervals) to dBegin
28933>>>>>>>>>            Move dAnchor to dEnd
28934>>>>>>>>>        End
28934>>>>>>>>>>
28934>>>>>>>>>        If (iDateSegment=DS_WEEK) Begin
28936>>>>>>>>>            Get MondayInWeek (DateSegment(Self,dAnchor,DS_YEAR)) (DateSegment(Self,dAnchor,DS_WEEK)) to dAnchor
28937>>>>>>>>>            Get DateIncrement dAnchor DS_DAY 6 to dEnd
28938>>>>>>>>>            Get DateIncrement dAnchor DS_WEEK (1-iIntervals) to dBegin
28939>>>>>>>>>        End
28939>>>>>>>>>>
28939>>>>>>>>>        If (iDateSegment=DS_MONTH) Begin
28941>>>>>>>>>            Get FirstDateIn DS_MONTH dAnchor to dAnchor
28942>>>>>>>>>            Get DateIncrement dAnchor DS_MONTH (1-iIntervals) to dBegin
28943>>>>>>>>>            Get LastDateIn DS_MONTH dAnchor to dEnd
28944>>>>>>>>>        End
28944>>>>>>>>>>
28944>>>>>>>>>        If (iDateSegment=DS_QUARTER) Begin
28946>>>>>>>>>            Get FirstDateIn DS_QUARTER dAnchor to dAnchor
28947>>>>>>>>>            Get DateIncrement dAnchor DS_QUARTER (1-iIntervals) to dBegin
28948>>>>>>>>>            Get LastDateIn DS_QUARTER dAnchor to dEnd
28949>>>>>>>>>        End
28949>>>>>>>>>>
28949>>>>>>>>>        If (iDateSegment=DS_YEAR) Begin
28951>>>>>>>>>            Get FirstDateIn DS_YEAR dAnchor to dAnchor
28952>>>>>>>>>            Get DateIncrement dAnchor DS_YEAR (1-iIntervals) to dBegin
28953>>>>>>>>>            Get LastDateIn DS_YEAR dAnchor to dEnd
28954>>>>>>>>>        End
28954>>>>>>>>>>
28954>>>>>>>>>    End_Procedure
28955>>>>>>>>>    
28955>>>>>>>>>    Function DatesDistance Date dValue1 Date dValue2 Integer iSegment Returns Integer   
28957>>>>>>>>>        Integer bNeg iDistance iDay iYear1 iYear2 iMonth1 iMonth2  
28957>>>>>>>>>        Date dTemp 
28957>>>>>>>>>        If (dValue1>dValue2) Begin 
28959>>>>>>>>>            Move dValue1 to dTemp  
28960>>>>>>>>>            Move dValue2 to dValue1
28961>>>>>>>>>            Move dTemp to dValue2  
28962>>>>>>>>>            Move True to bNeg  
28963>>>>>>>>>        End
28963>>>>>>>>>>
28963>>>>>>>>>        Else Move False to bNeg
28965>>>>>>>>>        If (iSegment=DS_DAY) Move (Integer(dValue2)-Integer(dValue1)) to iDistance 
28968>>>>>>>>>        If (iSegment=DS_WEEK) Begin
28970>>>>>>>>>            Get DayNumber dValue1 to iDay  
28971>>>>>>>>>            Move (Date(Integer(dValue1)-iDay+1)) to dValue1 // Now a monday
28972>>>>>>>>>            Get DayNumber dValue2 to iDay  
28973>>>>>>>>>            Move (Date(Integer(dValue2)-iDay+1)) to dValue2 // Now a monday
28974>>>>>>>>>            Move (Integer(dValue2)-Integer(dValue1)) to iDistance  
28975>>>>>>>>>            Move (iDistance/7) to iDistance
28976>>>>>>>>>        End
28976>>>>>>>>>>
28976>>>>>>>>>        If (iSegment=DS_MONTH) Begin   
28978>>>>>>>>>            Get DateSegment dValue1 DS_MONTH to iMonth1
28979>>>>>>>>>            Get DateSegment dValue1 DS_YEAR to iYear1
28980>>>>>>>>>            Get DateSegment dValue2 DS_MONTH to iMonth2
28981>>>>>>>>>            Get DateSegment dValue2 DS_YEAR to iYear2  
28982>>>>>>>>>            Move (iYear2-iYear1*12+iMonth2-iMonth1) to iDistance   
28983>>>>>>>>>        End
28983>>>>>>>>>>
28983>>>>>>>>>        If (iSegment=DS_QUARTER) Begin
28985>>>>>>>>>            Get DateSegment dValue1 DS_QUARTER to iMonth1 // Overload  
28986>>>>>>>>>            Get DateSegment dValue1 DS_YEAR to iYear1  
28987>>>>>>>>>            Get DateSegment dValue2 DS_QUARTER to iMonth2 // Overload  
28988>>>>>>>>>            Get DateSegment dValue2 DS_YEAR to iYear2  
28989>>>>>>>>>            Move (iYear2-iYear1*4+iMonth2-iMonth1) to iDistance
28990>>>>>>>>>        End
28990>>>>>>>>>>
28990>>>>>>>>>        If (iSegment=DS_YEAR) Begin
28992>>>>>>>>>            Get DateSegment dValue1 DS_YEAR to iYear1  
28993>>>>>>>>>            Get DateSegment dValue2 DS_YEAR to iYear2  
28994>>>>>>>>>            Move (iYear2-iYear1) to iDistance  
28995>>>>>>>>>        End
28995>>>>>>>>>>
28995>>>>>>>>>        If bNeg Move (0-iDistance) to iDistance
28998>>>>>>>>>        Function_Return iDistance  
28999>>>>>>>>>    End_Function
29000>>>>>>>>>
29000>>>>>>>>>    Function WeekNumber Date dValue Returns Integer
29002>>>>>>>>>        Integer iWeek iFirstWeekDay iDayOfYear iYear iWeekDay  
29002>>>>>>>>>        If not (Integer(dValue)) Function_Return 0  
29005>>>>>>>>>   
29005>>>>>>>>>        Get DayNumber dValue to iWeekDay   
29006>>>>>>>>>        Get DateSegment (dValue-iWeekDay+1) DS_YEAR to iYear   
29007>>>>>>>>>   
29007>>>>>>>>>        Get DayNumber (FirstDateIn(Self,DS_YEAR,dValue)) to iFirstWeekDay   
29008>>>>>>>>>        Move (dValue-FirstDateIn(Self,DS_YEAR,dValue)) to iDayOfYear
29009>>>>>>>>>        Move (iDayOfYear-1-7+iFirstWeekDay) to iDayOfYear  
29010>>>>>>>>>        If ((iDayOfYear/7.0)>=0) Move (iDayOfYear/7+1) to iWeek
29013>>>>>>>>>        Else Move 0 to iWeek   
29015>>>>>>>>>        If (iFirstWeekDay<=4) Increment iWeek  
29018>>>>>>>>>        If (iWeek>52) Begin
29020>>>>>>>>>            Move 1 to iWeek
29021>>>>>>>>>            If (iFirstWeekDay=4) Move 53 to iWeek  
29024>>>>>>>>>            If (iFirstWeekDay=3) If (((iYear/4)*4)=iYear) If (((iYear/100)*100)<>iYear) Move 53 to iWeek   
29031>>>>>>>>>        End
29031>>>>>>>>>>
29031>>>>>>>>>        If (iWeek=0) Begin 
29033>>>>>>>>>            // Week 52 or 53   
29033>>>>>>>>>            Get DayNumber (DateIncrement(Self,FirstDateIn(Self,DS_YEAR,dValue),DS_YEAR,-1)) to iFirstWeekDay 
29034>>>>>>>>>            Move 52 to iWeek   
29035>>>>>>>>>            If (iFirstWeekDay=4) Move 53 to iWeek  
29038>>>>>>>>>            If (iFirstWeekDay=3) If (((iYear/4)*4)=iYear) If (((iYear/100)*100)<>iYear) Move 53 to iWeek
29045>>>>>>>>>        End
29045>>>>>>>>>>
29045>>>>>>>>>        Function_Return iWeek  
29046>>>>>>>>>    End_Function   
29047>>>>>>>>>
29047>>>>>>>>>    Function DayNumber Date dValue Returns Integer 
29049>>>>>>>>>        Integer iRval // 1=Monday, ... , 7=Sunday  
29049>>>>>>>>>        //get Date2to4 dValue to dValue
29049>>>>>>>>>        Move dValue to iRval   
29050>>>>>>>>>        If iRval Begin
29052>>>>>>>>>            If (iRval>693975) Move (iRval-2) to iRval  
29055>>>>>>>>>            Move (iRval-((iRval/7)*7)) to iRval
29056>>>>>>>>>            If (iRval=0) Move 7 to iRval   
29059>>>>>>>>>        End
29059>>>>>>>>>>
29059>>>>>>>>>        Function_Return iRval  
29060>>>>>>>>>    End_Function   
29061>>>>>>>>>    
29061>>>>>>>>>    Function DayName Integer iDay Returns String
29063>>>>>>>>>        Function_Return (Value(oDayNames,iDay))
29064>>>>>>>>>    End_Function
29065>>>>>>>>>    
29065>>>>>>>>>    Function MonthName Integer iMonth Returns String
29067>>>>>>>>>        Function_Return (Value(oMonthNames,iMonth))
29068>>>>>>>>>    End_Function
29069>>>>>>>>>    
29069>>>>>>>>>    Function DateMonthName Date dValue Returns String
29071>>>>>>>>>        Integer iMonth
29071>>>>>>>>>        Get DateSegment dValue DS_MONTH to iMonth
29072>>>>>>>>>        Function_Return (MonthName(Self,iMonth))
29073>>>>>>>>>    End_Function
29074>>>>>>>>>    
29074>>>>>>>>>    Function DateDayName Date dValue Returns String
29076>>>>>>>>>        Integer iDay
29076>>>>>>>>>        Get DayNumber dValue to iDay
29077>>>>>>>>>        Function_Return (DayName(Self,iDay))
29078>>>>>>>>>    End_Function
29079>>>>>>>>>
29079>>>>>>>>>    Function WeekCountOfYear Integer iYear Returns Integer
29081>>>>>>>>>        Integer iWeek1 iWeek2  
29081>>>>>>>>>        Get WeekNumber (ComposeDate(Self,31,12,iYear)) to iWeek1   
29082>>>>>>>>>        Get WeekNumber (ComposeDate(Self,24,12,iYear)) to iWeek2   
29083>>>>>>>>>        Function_Return (iWeek1 max iWeek2)
29084>>>>>>>>>    End_Function   
29085>>>>>>>>>   
29085>>>>>>>>>    Function MondayInWeek Integer iYear Integer iWeek Returns Date
29087>>>>>>>>>        Date dVal
29087>>>>>>>>>        Get ComposeDate 1 1 iYear to dVal
29088>>>>>>>>>        If (WeekNumber(Self,dVal)<>1) Move (dVal+7) to dVal // week 52 or 53
29091>>>>>>>>>        Move (dVal-DayNumber(Self,dVal)+1) to dVal // Now it's a Monday
29092>>>>>>>>>        Function_Return (iWeek-1*7+dVal)
29093>>>>>>>>>    End_Function
29094>>>>>>>>>    
29094>>>>>>>>>    // May be used like this:
29094>>>>>>>>>    //  get DateToText of oDateFunctions 06/06/2008 "#D-#MN3-#Y4" to sValue
29094>>>>>>>>>    //  => sValue = 6-Jul-2008
29094>>>>>>>>>    Function DateToText Date dValue String sFormat Returns String
29096>>>>>>>>>        Integer iDay iMonth iYear iYearTmp
29096>>>>>>>>>        If (Integer(dValue)=0) Function_Return ""
29099>>>>>>>>>        Move (Replace("#DN3",sFormat,Left(DateDayName(Self,dValue),3)))   to sFormat
29100>>>>>>>>>        Move (Replace("#DN2",sFormat,Left(DateDayName(Self,dValue),2)))   to sFormat // Dutch request. 
29101>>>>>>>>>        Move (Replace("#MN3",sFormat,Left(DateMonthName(Self,dValue),3))) to sFormat
29102>>>>>>>>>        Move (Replace("#DN", sFormat,DateDayName(Self,dValue)))           to sFormat
29103>>>>>>>>>        Move (Replace("#MN", sFormat,DateMonthName(Self,dValue)))         to sFormat
29104>>>>>>>>>        Move (Replace("#WN", sFormat,WeekNumber(Self,dValue)))        to sFormat
29105>>>>>>>>>        Move (DateSegment(Self,dValue,DS_DAY))   to iDay
29106>>>>>>>>>        Move (DateSegment(Self,dValue,DS_MONTH)) to iMonth
29107>>>>>>>>>        Move (DateSegment(Self,dValue,DS_YEAR))  to iYear
29108>>>>>>>>>        Move (Replace("#D2", sFormat,If(iDay<10,"0"+String(iDay),String(iDay)))) to sFormat
29109>>>>>>>>>        Move (Replace("#D",  sFormat,String(iDay))) to sFormat
29110>>>>>>>>>                    
29110>>>>>>>>>        Move (Right(String(iYear),2)) to iYearTmp // Year 4 -> 2
29111>>>>>>>>>        Move (Replace("#Y2", sFormat,If(iYearTmp<10,"0"+String(iYearTmp),String(iYearTmp)))) to sFormat
29112>>>>>>>>>        
29112>>>>>>>>>//        Get Year2to4 iYear to iYearTmp
29112>>>>>>>>>        Move (Replace("#Y4", sFormat,String(iYear))) to sFormat
29113>>>>>>>>>
29113>>>>>>>>>        Move (Replace("#M2", sFormat,If(iMonth<10,"0"+String(iMonth),String(iMonth)))) to sFormat
29114>>>>>>>>>        Move (Replace("#M",  sFormat,String(iMonth))) to sFormat
29115>>>>>>>>>        Function_Return sFormat
29116>>>>>>>>>    End_Function
29117>>>>>>>>>
29117>>>>>>>>>    Function DateToString Date dValue Integer iFormat Boolean bLong String sSep Returns String
29119>>>>>>>>>        Integer iDay iMonth iYear
29119>>>>>>>>>        String sRval sDay sMonth sYear
29119>>>>>>>>>        If (Integer(dValue)) Begin
29121>>>>>>>>>            Send DecomposeDate dValue (&iDay) (&iMonth) (&iYear)
29122>>>>>>>>>            Get IntegerToStringRzf of oStringFunctions iDay 2 to sDay
29123>>>>>>>>>            Get IntegerToStringRzf of oStringFunctions iMonth 2 to sMonth
29124>>>>>>>>>            Move iYear to sYear
29125>>>>>>>>>            If (not(bLong)) Move (right(sYear,2)) to sYear
29128>>>>>>>>>            If (iFormat=DF_DATE_EUROPEAN) Move (sDay+sSep+sMonth+sSep+sYear) to sRval // DMY
29131>>>>>>>>>            If (iFormat=DF_DATE_USA)      Move (sMonth+sSep+sDay+sSep+sYear) to sRval // MDY
29134>>>>>>>>>            If (iFormat=DF_DATE_MILITARY) Move (sYear+sSep+sMonth+sSep+sDay) to sRval // YMD
29137>>>>>>>>>        End
29137>>>>>>>>>>
29137>>>>>>>>>        Else Move "" to sRval
29139>>>>>>>>>        Function_Return sRval
29140>>>>>>>>>    End_Function
29141>>>>>>>>>
29141>>>>>>>>>    Function StringToDate String sDate Integer iFormat Returns Date
29143>>>>>>>>>        Integer iLen iPos iValIdx
29143>>>>>>>>>        Integer[3] aValues
29144>>>>>>>>>        Date dRval
29144>>>>>>>>>        String sChar
29144>>>>>>>>>        Move (Trim(sDate)) to sDate
29145>>>>>>>>>        Move (Length(sDate)) to iLen
29146>>>>>>>>>        Move 0 to iValIdx
29147>>>>>>>>>
29147>>>>>>>>>        For iPos from 1 to iLen
29153>>>>>>>>>>
29153>>>>>>>>>            Move (mid(sDate,1,iPos)) to sChar
29154>>>>>>>>>            If ("0123456789" contains sChar) Move (aValues[iValIdx]*10+Integer(sChar)) to aValues[iValIdx]
29157>>>>>>>>>            Else Increment iValIdx
29159>>>>>>>>>        Loop
29160>>>>>>>>>>
29160>>>>>>>>>
29160>>>>>>>>>        If (iValIdx=2 or (iValIdx=0 and (iLen=6 or iLen=8))) Begin // 3 values or 1
29162>>>>>>>>>            If (iValIdx=0) Begin
29164>>>>>>>>>                If (iLen=6) Begin
29166>>>>>>>>>                    Move (Left(sDate,2)) to aValues[0]
29167>>>>>>>>>                    Move (Mid(sDate,2,3)) to aValues[1]
29168>>>>>>>>>                    Move (Right(sDate,2)) to aValues[2]
29169>>>>>>>>>                End
29169>>>>>>>>>>
29169>>>>>>>>>                Else Begin // iLen:8
29170>>>>>>>>>                    If (iFormat=DF_DATE_MILITARY) Begin // Year is first
29172>>>>>>>>>                        Move (Left(sDate,4)) to aValues[0]
29173>>>>>>>>>                        Move (Mid(sDate,2,5)) to aValues[1]
29174>>>>>>>>>                        Move (Right(sDate,2)) to aValues[2]
29175>>>>>>>>>                    End
29175>>>>>>>>>>
29175>>>>>>>>>                    Else Begin // Year is last
29176>>>>>>>>>                        Move (Left(sDate,2)) to aValues[0]
29177>>>>>>>>>                        Move (Mid(sDate,2,3)) to aValues[1]
29178>>>>>>>>>                        Move (Right(sDate,4)) to aValues[2]
29179>>>>>>>>>                    End
29179>>>>>>>>>>
29179>>>>>>>>>                End
29179>>>>>>>>>>
29179>>>>>>>>>            End
29179>>>>>>>>>>
29179>>>>>>>>>
29179>>>>>>>>>            // We have now done our utmost to produce 3 numbers. Make them into a date:
29179>>>>>>>>>            If (iFormat=DF_DATE_EUROPEAN) Get ComposeDate aValues[0] aValues[1] aValues[2] to dRval
29182>>>>>>>>>            If (iFormat=DF_DATE_USA)      Get ComposeDate aValues[1] aValues[0] aValues[2] to dRval
29185>>>>>>>>>            If (iFormat=DF_DATE_MILITARY) Get ComposeDate aValues[2] aValues[1] aValues[0] to dRval
29188>>>>>>>>>        End
29188>>>>>>>>>>
29188>>>>>>>>>        Else Move 0 to dRval
29190>>>>>>>>>
29190>>>>>>>>>        Function_Return dRval
29191>>>>>>>>>    End_Function
29192>>>>>>>>>
29192>>>>>>>>>    Function DateTimeToString23 DateTime dtValue Returns String
29194>>>>>>>>>        String sValue
29194>>>>>>>>>
29194>>>>>>>>>        Move (DateGetYear(dtValue)) to sValue
29195>>>>>>>>>        Move (sValue+"-"+IntegerToStringRzf(oStringFunctions,DateGetMonth(dtValue),2)) to sValue
29196>>>>>>>>>        Move (sValue+"-"+IntegerToStringRzf(oStringFunctions,DateGetDay(dtValue),2)) to sValue
29197>>>>>>>>>        Move (sValue+"T"+IntegerToStringRzf(oStringFunctions,DateGetHour(dtValue),2)) to sValue
29198>>>>>>>>>        Move (sValue+":"+IntegerToStringRzf(oStringFunctions,DateGetMinute(dtValue),2)) to sValue
29199>>>>>>>>>        Move (sValue+":"+IntegerToStringRzf(oStringFunctions,DateGetSecond(dtValue),2)) to sValue
29200>>>>>>>>>        Move (sValue+"."+IntegerToStringRzf(oStringFunctions,DateGetMillisecond(dtValue),3)) to sValue
29201>>>>>>>>>
29201>>>>>>>>>        Function_Return sValue // 1999-12-31T13:59:59.999 (=length:23)
29202>>>>>>>>>    End_Function
29203>>>>>>>>>
29203>>>>>>>>>    Function String23ToDateTime String sValue Returns DateTime
29205>>>>>>>>>        DateTime dtValue
29205>>>>>>>>>        Move (DateSetYear(dtValue,Integer(Mid(sValue,4,1)))) to dtValue
29206>>>>>>>>>        Move (DateSetMonth(dtValue,Integer(Mid(sValue,2,6)))) to dtValue
29207>>>>>>>>>        Move (DateSetDay(dtValue,Integer(Mid(sValue,2,9)))) to dtValue
29208>>>>>>>>>        Move (DateSetHour(dtValue,Integer(Mid(sValue,2,12)))) to dtValue
29209>>>>>>>>>        Move (DateSetMinute(dtValue,Integer(Mid(sValue,2,15)))) to dtValue
29210>>>>>>>>>        Move (DateSetSecond(dtValue,Integer(Mid(sValue,2,18)))) to dtValue
29211>>>>>>>>>        Move (DateSetMillisecond(dtValue,Integer(Mid(sValue,3,21)))) to dtValue
29212>>>>>>>>>        Function_Return dtValue
29213>>>>>>>>>    End_Function
29214>>>>>>>>>
29214>>>>>>>>>    Function DateTimeToString DateTime dtValue Integer iDateFormat Boolean bLong String sSep Returns String
29216>>>>>>>>>        Date dValue
29216>>>>>>>>>        Time tmTimeValue
29216>>>>>>>>>        Integer iHour iMin iSec
29216>>>>>>>>>        String sValue
29216>>>>>>>>>        Send DecomposeDateTime dtValue (&dValue) (&tmTimeValue)
29217>>>>>>>>>        Get DateToString dValue iDateFormat bLong sSep to sValue
29218>>>>>>>>>        Send DecomposeTime tmTimeValue (&iHour) (&iMin) (&iSec)
29219>>>>>>>>>        Function_Return (sValue*ComposeTimeString(Self,iHour,iMin,iSec))
29220>>>>>>>>>    End_Function
29221>>>>>>>>>
29221>>>>>>>>>    Function StringToDateTime String sDateTimeValue Integer iDateFormat Returns DateTime
29223>>>>>>>>>        Integer iSpacePos
29223>>>>>>>>>        String sDate sTime
29223>>>>>>>>>        DateTime dtResult
29223>>>>>>>>>        Date dValue
29223>>>>>>>>>        Time tmValue
29223>>>>>>>>>        Move (Trim(sDateTimeValue)) to sDateTimeValue
29224>>>>>>>>>        Move (Pos(" ",sDateTimeValue)) to iSpacePos
29225>>>>>>>>>        If (iSpacePos<>0) Begin
29227>>>>>>>>>            Move (Left(sDateTimeValue,iSpacePos-1)) to sDate
29228>>>>>>>>>            Move (Trim(Replace(sDate,sDateTimeValue,""))) to sTime
29229>>>>>>>>>            Get StringToDate sDate iDateFormat to dValue
29230>>>>>>>>>            Get TimeStringToTime sTime to tmValue
29231>>>>>>>>>            Get ComposeDateTime dValue tmValue to dtResult
29232>>>>>>>>>        End
29232>>>>>>>>>>
29232>>>>>>>>>        Function_Return dtResult
29233>>>>>>>>>    End_Function
29234>>>>>>>>>
29234>>>>>>>>>    Function DateIntervalLabel Integer iCode Returns String
29236>>>>>>>>>        Function_Return (Value(oIntervalLabels,iCode))
29237>>>>>>>>>    End_Function
29238>>>>>>>>>
29238>>>>>>>>>    Function DateIntervalEval Date dFrom Date dTo Date dTestValue Returns Boolean
29240>>>>>>>>>        If (Integer(dFrom)+Integer(dTo)) Begin
29242>>>>>>>>>            If (Integer(dTo)=0) Function_Return (dTestValue>=dFrom)
29245>>>>>>>>>            Function_Return (dTestValue>=dFrom and dTestValue<=dTo)
29246>>>>>>>>>        End
29246>>>>>>>>>>
29246>>>>>>>>>        Function_Return True
29247>>>>>>>>>    End_Function
29248>>>>>>>>>    
29248>>>>>>>>>    Procedure DateIntervalCalc Integer iCode Date ByRef dFrom Date ByRef dTo
29250>>>>>>>>>        Date dDate
29250>>>>>>>>>        If (iCode=DI_EXPLICIT) Begin
29252>>>>>>>>>            // Do nothing
29252>>>>>>>>>        End
29252>>>>>>>>>>
29252>>>>>>>>>        If (iCode=DI_NO_LIMIT) Begin
29254>>>>>>>>>            Move "" to dFrom
29255>>>>>>>>>            Move "" to dTo
29256>>>>>>>>>        End
29256>>>>>>>>>>
29256>>>>>>>>>        If (iCode=DI_LAST_WEEK) Begin
29258>>>>>>>>>            Get DateIncrement (SystemDate(Self)) DS_WEEK -1 to dDate
29259>>>>>>>>>            Move (Date(Integer(dDate)-DayNumber(Self,dDate)+1)) to dFrom
29260>>>>>>>>>            Move (Date(Integer(dDate)-DayNumber(Self,dDate)+7)) to dTo
29261>>>>>>>>>        End
29261>>>>>>>>>>
29261>>>>>>>>>        If (iCode=DI_LAST_MONTH) Begin
29263>>>>>>>>>            Get DateIncrement (SystemDate(Self)) DS_MONTH -1 to dDate
29264>>>>>>>>>            Get FirstDateIn DS_MONTH dDate to dFrom
29265>>>>>>>>>            Get LastDateIn DS_MONTH dDate to dTo
29266>>>>>>>>>        End
29266>>>>>>>>>>
29266>>>>>>>>>        If (iCode=DI_LAST_YEAR) Begin
29268>>>>>>>>>            Get DateIncrement (SystemDate(Self)) DS_YEAR -1 to dDate
29269>>>>>>>>>            Get FirstDateIn DS_YEAR dDate to dFrom
29270>>>>>>>>>            Get LastDateIn DS_YEAR dDate to dTo
29271>>>>>>>>>        End
29271>>>>>>>>>>
29271>>>>>>>>>        If (iCode=DI_WEEK_TO_DATE) Begin
29273>>>>>>>>>            Get SystemDate to dTo
29274>>>>>>>>>            Move (Date(Integer(dTo)-DayNumber(Self,dTo)+1)) to dFrom
29275>>>>>>>>>        End
29275>>>>>>>>>>
29275>>>>>>>>>        If (iCode=DI_MONTH_TO_DATE) Begin
29277>>>>>>>>>            Get SystemDate to dTo
29278>>>>>>>>>            Get FirstDateIn DS_MONTH dTo to dFrom
29279>>>>>>>>>        End
29279>>>>>>>>>>
29279>>>>>>>>>        If (iCode=DI_YEAR_TO_DATE) Begin
29281>>>>>>>>>            Get SystemDate to dTo
29282>>>>>>>>>            Get FirstDateIn DS_YEAR dTo to dFrom
29283>>>>>>>>>        End
29283>>>>>>>>>>
29283>>>>>>>>>    End_Procedure
29284>>>>>>>>>    
29284>>>>>>>>>    Function SecondsToTimeString Integer iSeconds Returns String
29286>>>>>>>>>        Integer iHour iMinute
29286>>>>>>>>>        If (iSeconds=0) Function_Return "00:00:00"
29289>>>>>>>>>        Move (iSeconds/3600) to iHour
29290>>>>>>>>>        Move (iSeconds-(iHour*3600)) to iSeconds
29291>>>>>>>>>        Move (iSeconds/60) to iMinute
29292>>>>>>>>>        Move (iSeconds-(iMinute*60)) to iSeconds
29293>>>>>>>>>        Function_Return (If(iHour<10,"0","")+String(iHour)+":"+If(iMinute<10,"0","")+String(iMinute)+":"+If(iSeconds<10,"0","")+String(iSeconds))
29294>>>>>>>>>    End_Function
29295>>>>>>>>>    
29295>>>>>>>>>    Function MilliSecondsToTimeString Number nMilliSeconds Returns String
29297>>>>>>>>>        String sTimeString
29297>>>>>>>>>        Integer iMilliSeconds
29297>>>>>>>>>        Get SecondsToTimeString (Integer(nMilliSeconds/1000)) to sTimeString
29298>>>>>>>>>        Move (Mod(nMilliSeconds,1000)) to iMilliSeconds
29299>>>>>>>>>        Function_Return (sTimeString+"."+IntegerToStringRzf(oStringFunctions,iMilliSeconds,3))
29300>>>>>>>>>    End_Function
29301>>>>>>>>>    
29301>>>>>>>>>//    Function TimeStringFormat String sValue Integer iPrioritizedSegment Returns String
29301>>>>>>>>>//        Integer iMax iPos iHours iMinutes iTmp
29301>>>>>>>>>//        String[] aSegments
29301>>>>>>>>>//        String sRval
29301>>>>>>>>>//        If (sValue="-" or lowercase(sValue)="now") begin
29301>>>>>>>>>//            Function_Return (Left(SystemTimeString(Self),5)) // Strip away seconds
29301>>>>>>>>>//        End
29301>>>>>>>>>//        If (sValue="") begin
29301>>>>>>>>>//            Function_Return ""
29301>>>>>>>>>//        End
29301>>>>>>>>>//        Move (Replaces(" ",sValue,":")) to sValue
29301>>>>>>>>>//        Move (Replaces(",",sValue,":")) to sValue
29301>>>>>>>>>//        Send SplitString of oStringFunctions sValue ":" True False (&aSegments)
29301>>>>>>>>>//        Move (SizeOfArray(aSegments)) to iMax // Get HowManyWords sValue ":" to iMax
29301>>>>>>>>>//        If (iMax=1) Begin
29301>>>>>>>>>//            If (iPrioritizedSegment=TS_MINUTE) Begin
29301>>>>>>>>>//                Move (ExtractInteger(ExtractWord(sValue,":",1),1)) to iMinutes
29301>>>>>>>>>//                Move 0 to iHours
29301>>>>>>>>>//            End
29301>>>>>>>>>//            Else Begin //So it is hour prioritized
29301>>>>>>>>>//                Move (ExtractInteger(ExtractWord(sValue,":",1),1)) to sValue
29301>>>>>>>>>//                If (Length(sValue)>2) Begin
29301>>>>>>>>>//                    If (Length(sValue)=3) Move (Append("0",sValue)) to sValue
29301>>>>>>>>>//                    If (Length(sValue)>4) Move (Left(sValue,4)) to sValue
29301>>>>>>>>>//                    Move (Left(sValue,2)) to iHours
29301>>>>>>>>>//                    Move (Right(sValue,2)) to iMinutes
29301>>>>>>>>>//                End
29301>>>>>>>>>//                Else Begin
29301>>>>>>>>>//                    Move 0 to iMinutes
29301>>>>>>>>>//                    Move sValue to iHours
29301>>>>>>>>>//                End
29301>>>>>>>>>//            End
29301>>>>>>>>>//        End
29301>>>>>>>>>//        Else Begin
29301>>>>>>>>>//            Move (ExtractInteger(ExtractWord(sValue,":",1),1)) to iHours
29301>>>>>>>>>//            Move (ExtractInteger(ExtractWord(sValue,":",2),1)) to iMinutes
29301>>>>>>>>>//        End
29301>>>>>>>>>//        Move (iMinutes/60) to iTmp
29301>>>>>>>>>//        Move (iMinutes-(iTmp*60)) to iMinutes
29301>>>>>>>>>//        Move (iHours+iTmp) to iHours
29301>>>>>>>>>//        Function_Return (IntegerToStringRzf(oStringFunctions,iHours,2)+":"+IntegerToStringRzf(oStringFunctions,iMinutes,2))
29301>>>>>>>>>//    End_Function
29301>>>>>>>>>//Function TimeStringToHours Global String lsTime Returns Number
29301>>>>>>>>>//  Integer liHours liMinutes liFraction
29301>>>>>>>>>//  Move (ExtractWord(lsTime,":",1)) to liHours
29301>>>>>>>>>//  Move (ExtractWord(lsTime,":",2)) to liMinutes
29301>>>>>>>>>//  Move (liMinutes*25/15) to liFraction
29301>>>>>>>>>//  Function_Return (liHours+(liFraction/100.0))
29301>>>>>>>>>//End_Function
29301>>>>>>>>>//
29301>>>>>>>>>//// Returns true if lsTime is a legal time of day ("hh:mm:ss" or "hh:mm")
29301>>>>>>>>>//Function IsTimeString Global String lsTime Returns Integer
29301>>>>>>>>>//  Integer liLen liNumber
29301>>>>>>>>>//  String lsNumber
29301>>>>>>>>>//  Move (trim(lsTime)) to lsTime
29301>>>>>>>>>//  Move (length(lsTime)) to liLen
29301>>>>>>>>>//  If (liLen<>5 and liLen<>8) Function_Return 0 // Wrong length, couldn't be a time
29301>>>>>>>>>//  If (mid(lsTime,1,3)<>":") Function_Return 0 // Missing ":"
29301>>>>>>>>>//
29301>>>>>>>>>//  Move (mid(lsTime,2,1)) to lsNumber
29301>>>>>>>>>//  If (StringIsInteger(lsNumber)) Begin
29301>>>>>>>>>//    Move (Integer(lsNumber)) to liNumber
29301>>>>>>>>>//    If (liNumber<0 or liNumber>23) Function_Return 0 // Wrong hours
29301>>>>>>>>>//  End
29301>>>>>>>>>//  Else Function_Return 0 // Not digits
29301>>>>>>>>>//
29301>>>>>>>>>//  Move (mid(lsTime,2,4)) to lsNumber
29301>>>>>>>>>//  If (StringIsInteger(lsNumber)) Begin
29301>>>>>>>>>//    Move (Integer(lsNumber)) to liNumber
29301>>>>>>>>>//    If (liNumber<0 or liNumber>59) Function_Return 0 // Wrong hours
29301>>>>>>>>>//  End
29301>>>>>>>>>//  Else Function_Return 0 // Not digits
29301>>>>>>>>>//
29301>>>>>>>>>//  If (liLen=8) Begin
29301>>>>>>>>>//    If (mid(lsTime,1,6)<>":") Function_Return 0 // Missing ":"
29301>>>>>>>>>//    Move (mid(lsTime,2,7)) to lsNumber
29301>>>>>>>>>//    If (StringIsInteger(lsNumber)) Begin
29301>>>>>>>>>//      Move (Integer(lsNumber)) to liNumber
29301>>>>>>>>>//      If (liNumber<0 or liNumber>59) Function_Return 0 // Wrong hours
29301>>>>>>>>>//    End
29301>>>>>>>>>//    Else Function_Return 0 // Not digits
29301>>>>>>>>>//  End
29301>>>>>>>>>//
29301>>>>>>>>>//  Function_Return 1 // It's a time
29301>>>>>>>>>//End_Function
29301>>>>>>>>>//
29301>>>>>>>>>//Function HoursBetweenTimeStrings Global String lsTimeFrom String lsTimeTo Returns Number
29301>>>>>>>>>//  Function_Return (Time_ToHours(lsTimeTo)-Time_ToHours(lsTimeFrom))
29301>>>>>>>>>//End_Function
29301>>>>>>>>>
29301>>>>>>>>>    Function DateIndex Date dBase Date dDate Integer iSegment Returns Integer
29303>>>>>>>>>        Integer iBase iDate
29303>>>>>>>>>        If (iSegment=DS_DAY) Begin
29305>>>>>>>>>            Move (Integer(dDate)) to iDate
29306>>>>>>>>>            Move (Integer(dBase)) to iBase
29307>>>>>>>>>        End
29307>>>>>>>>>>
29307>>>>>>>>>        If (iSegment=DS_WEEK) Begin
29309>>>>>>>>>            Get DayNumber dDate to iDate
29310>>>>>>>>>            Move (Integer(dDate)+1-iDate) to iDate // Back to Monday!
29311>>>>>>>>>            Get DayNumber dBase to iBase
29312>>>>>>>>>            Move (Integer(dBase)+1-iBase) to iBase // Back to Monday!
29313>>>>>>>>>            Move (iDate-iBase) to iDate
29314>>>>>>>>>            Move (iDate/7) to iDate
29315>>>>>>>>>            Move 0 to iBase
29316>>>>>>>>>        End
29316>>>>>>>>>>
29316>>>>>>>>>        If (iSegment=DS_MONTH) Begin
29318>>>>>>>>>            Move (DateSegment(Self,dDate,DS_YEAR)*12+DateSegment(Self,dDate,DS_MONTH)) to iDate
29319>>>>>>>>>            Move (DateSegment(Self,dBase,DS_YEAR)*12+DateSegment(Self,dBase,DS_MONTH)) to iBase
29320>>>>>>>>>        End
29320>>>>>>>>>>
29320>>>>>>>>>        If (iSegment=DS_QUARTER) Begin
29322>>>>>>>>>            Move (DateSegment(Self,dDate,DS_YEAR)*4+DateSegment(Self,dDate,DS_QUARTER)) to iDate
29323>>>>>>>>>            Move (DateSegment(Self,dBase,DS_YEAR)*4+DateSegment(Self,dBase,DS_QUARTER)) to iBase
29324>>>>>>>>>        End
29324>>>>>>>>>>
29324>>>>>>>>>        If (iSegment=DS_YEAR) Begin
29326>>>>>>>>>            Move (DateSegment(Self,dDate,DS_YEAR)) to iDate
29327>>>>>>>>>            Move (DateSegment(Self,dBase,DS_YEAR)) to iBase
29328>>>>>>>>>        End
29328>>>>>>>>>>
29328>>>>>>>>>        Function_Return (iDate-iBase)
29329>>>>>>>>>    End_Function
29330>>>>>>>>>    
29330>>>>>>>>>    Function DateIndexLabel Date dBase Integer iIndex Integer iSegment Returns String
29332>>>>>>>>>        Integer iBase iMonth
29332>>>>>>>>>        If (iSegment=DS_DAY) Begin
29334>>>>>>>>>            Function_Return (String(Date(Integer(dBase)+iIndex)))
29335>>>>>>>>>        End
29335>>>>>>>>>>
29335>>>>>>>>>        If (iSegment=DS_WEEK) Begin
29337>>>>>>>>>            Get DayNumber dBase to iBase
29338>>>>>>>>>            Move (Integer(dBase)+1-iBase) to iBase // Back to Monday!
29339>>>>>>>>>            Move (iIndex*7+iBase) to iBase // Now it's the julian value of the monday in the week we want to label
29340>>>>>>>>>            Move (Date(iBase)) to dBase
29341>>>>>>>>>            Function_Return (String(DateSegment(Self,dBase,DS_YEAR))+"-"+IntegerToStringRzf(oStringFunctions,DateSegment(Self,dBase,DS_WEEK),2))
29342>>>>>>>>>        End
29342>>>>>>>>>>
29342>>>>>>>>>        If (iSegment=DS_MONTH) Begin
29344>>>>>>>>>            Get DateIncrement dBase DS_MONTH iIndex to dBase
29345>>>>>>>>>            Get DateSegment dBase DS_MONTH to iMonth
29346>>>>>>>>>//            If (iMonth=1) Begin
29346>>>>>>>>>//                Function_Return (String(DateSegment(Self,dBase,DS_YEAR))+"-"+Left(MonthName(Self,DateSegment(Self,dBase,DS_MONTH)),3))
29346>>>>>>>>>//            End
29346>>>>>>>>>//            Else Begin
29346>>>>>>>>>//                Function_Return (MonthName(Self,iMonth))
29346>>>>>>>>>//            End
29346>>>>>>>>>            Function_Return (String(DateSegment(Self,dBase,DS_YEAR))+"-"+Left(MonthName(Self,DateSegment(Self,dBase,DS_MONTH)),3))
29347>>>>>>>>>//            Function_Return (String(DateSegment(Self,dBase,DS_YEAR))+"-"+IntegerToStringRzf(oStringFunctions,DateSegment(Self,dBase,DS_MONTH),2))
29347>>>>>>>>>        End
29347>>>>>>>>>>
29347>>>>>>>>>        If (iSegment=DS_QUARTER) Begin
29349>>>>>>>>>            Get DateIncrement dBase DS_QUARTER iIndex to dBase
29350>>>>>>>>>            Function_Return (String(DateSegment(Self,dBase,DS_YEAR))+"-"+IntegerToStringRzf(oStringFunctions,DateSegment(Self,dBase,DS_QUARTER),2))
29351>>>>>>>>>        End
29351>>>>>>>>>>
29351>>>>>>>>>        If (iSegment=DS_YEAR) Begin
29353>>>>>>>>>            Get DateIncrement dBase DS_YEAR iIndex to dBase
29354>>>>>>>>>            Function_Return (String(DateSegment(Self,dBase,DS_YEAR)))
29355>>>>>>>>>        End
29355>>>>>>>>>>
29355>>>>>>>>>    End_Function
29356>>>>>>>>>    
29356>>>>>>>>>    // Function DateIndexStartDate returns the lowest date in the interval time
29356>>>>>>>>>    // interval implicitly passed in the parameters
29356>>>>>>>>>    Function DateIndexStartDate Date dBase Integer iIndex Integer iSegment Returns Date
29358>>>>>>>>>        Integer iBase
29358>>>>>>>>>        If (iSegment=DS_DAY) Begin
29360>>>>>>>>>            Function_Return (Date(Integer(dBase)+iIndex))
29361>>>>>>>>>        End
29361>>>>>>>>>>
29361>>>>>>>>>        If (iSegment=DS_WEEK) Begin
29363>>>>>>>>>            Get DayNumber dBase to iBase
29364>>>>>>>>>            Move (Integer(dBase)+1-iBase) to iBase // Back to Monday!
29365>>>>>>>>>            Move (iIndex*7+iBase) to iBase // Now it's the julian value of the monday in the week we want to label
29366>>>>>>>>>            Move (Date(iBase)) to dBase
29367>>>>>>>>>            Function_Return dBase
29368>>>>>>>>>        End
29368>>>>>>>>>>
29368>>>>>>>>>        If (iSegment=DS_MONTH) Begin
29370>>>>>>>>>            Get DateIncrement dBase DS_MONTH iIndex to dBase
29371>>>>>>>>>            Function_Return dBase
29372>>>>>>>>>        End
29372>>>>>>>>>>
29372>>>>>>>>>        If (iSegment=DS_QUARTER) Begin
29374>>>>>>>>>            Get DateIncrement dBase DS_QUARTER iIndex to dBase
29375>>>>>>>>>            Function_Return dBase
29376>>>>>>>>>        End
29376>>>>>>>>>>
29376>>>>>>>>>        If (iSegment=DS_YEAR) Begin
29378>>>>>>>>>            Get DateIncrement dBase DS_YEAR iIndex to dBase
29379>>>>>>>>>            Function_Return dBase
29380>>>>>>>>>        End
29380>>>>>>>>>>
29380>>>>>>>>>    End_Function
29381>>>>>>>>>
29381>>>>>>>>>    Function DateIndexStopDate Date dBase Integer iIndex Integer iSegment Returns Date
29383>>>>>>>>>        Date dValue
29383>>>>>>>>>        Get DateIndexStartDate dBase iIndex iSegment to dValue
29384>>>>>>>>>        Get DateIncrement dValue iSegment 1 to dValue
29385>>>>>>>>>        Get DateIncrement dValue DS_DAY -1 to dValue
29386>>>>>>>>>        Function_Return dValue
29387>>>>>>>>>    End_Function
29388>>>>>>>>>    
29388>>>>>>>>>    Function CurrentDateFormat Returns Integer
29390>>>>>>>>>        Integer iFormat
29390>>>>>>>>>        Get_Attribute DF_DATE_FORMAT to iFormat
29393>>>>>>>>>        Function_Return iFormat
29394>>>>>>>>>    End_Function
29395>>>>>>>>>    
29395>>>>>>>>>End_Class
29396>>>>>>>>>
29396>>>>>>>>>Global_Variable Integer oDateFunctions
29396>>>>>>>>>
29396>>>>>>>>>Object _oDateFunctions is a cDateFunctions
29398>>>>>>>>>    Move Self to oDateFunctions
29399>>>>>>>>>    Get SystemTimeToString23 (SystemTimeMilliSeconds(Self)) to _gsDate$ModuleStartTime
29400>>>>>>>>>End_Object
29401>>>>>>>>>
29401>>>>>>>Use StringFunctions.pkg
29401>>>>>>>
29401>>>>>>>Define C_EPSymbolLegalFirstCharacters for "_ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
29401>>>>>>>Define C_EPSymbolLegalCharacters for "_ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.#"
29401>>>>>>>
29401>>>>>>>Enum_List
29401>>>>>>>    Define XP_Error // As a return type this means that a function or operator errored during eval
29401>>>>>>>    Define XP_String   
29401>>>>>>>    Define XP_Numeric  
29401>>>>>>>    Define XP_Date     
29401>>>>>>>    Define XP_Integer  
29401>>>>>>>    Define XP_Boolean
29401>>>>>>>    // this has not been tested. maybe not even implemented:  
29401>>>>>>>    // Functions may have return type Variant if it varies with the input
29401>>>>>>>    // (like the 'if' function for example)
29401>>>>>>>    Define XP_Variant
29401>>>>>>>End_Enum_List
29401>>>>>>>
29401>>>>>>>Use VdfBase.pkg
29401>>>>>>>
29401>>>>>>>Struct tXPValue
29401>>>>>>>    String sValue
29401>>>>>>>    Integer iValueType // XP_String, XP_Numeric, XP_Date, XP_Integer or XP_Boolean
29401>>>>>>>End_Struct
29401>>>>>>>
29401>>>>>>>Struct tXPConstant
29401>>>>>>>    String sSymbol
29401>>>>>>>    tXPValue strValue
29401>>>>>>>    tXPValue strValue
29401>>>>>>>End_Struct
29401>>>>>>>
29401>>>>>>>Struct _tXPFunctionPointer
29401>>>>>>>    Integer iObj
29401>>>>>>>    Integer iMsg
29401>>>>>>>End_Struct
29401>>>>>>>
29401>>>>>>>Struct tXPOperator
29401>>>>>>>    String sSymbol
29401>>>>>>>    Integer iArgumentCount
29401>>>>>>>    Integer iPrecedence
29401>>>>>>>    Integer iAssociativity // 0=left 1=right
29401>>>>>>>    _tXPFunctionPointer strDispatch
29401>>>>>>>    _tXPFunctionPointer strDispatch
29401>>>>>>>End_Struct
29401>>>>>>>
29401>>>>>>>Struct tXPFunction
29401>>>>>>>    String sFunction
29401>>>>>>>    Integer iArgumentCount
29401>>>>>>>    Integer iReturnType
29401>>>>>>>    _tXPFunctionPointer strDispatch
29401>>>>>>>    _tXPFunctionPointer strDispatch
29401>>>>>>>End_Struct
29401>>>>>>>
29401>>>>>>>Struct tXPGrammar
29401>>>>>>>    tXPOperator[] aOperators
29401>>>>>>>    tXPOperator[] aOperators
29401>>>>>>>    tXPFunction[] aFunctions
29401>>>>>>>    tXPFunction[] aFunctions
29401>>>>>>>    tXPConstant[] aConstants
29401>>>>>>>    tXPConstant[] aConstants
29401>>>>>>>    String _sOperatorTestString
29401>>>>>>>End_Struct
29401>>>>>>>
29401>>>>>>>Struct _tXPSymbolValueRetrievalHint
29401>>>>>>>    Integer iTable
29401>>>>>>>    Integer iColumn
29401>>>>>>>    Integer iValueType
29401>>>>>>>    Integer iConstantIndex
29401>>>>>>>End_Struct
29401>>>>>>>
29401>>>>>>>Struct tXPToken
29401>>>>>>>    Integer iType
29401>>>>>>>    Integer iOperatorIndex // If iType is XPTokenType_Operator then this holds the index of the operator passed
29401>>>>>>>                           // If iType is XPTokenType_FunctionCall then this holds the index of the function passed
29401>>>>>>>    String sValue //
29401>>>>>>>    Integer iStartPos
29401>>>>>>>    
29401>>>>>>>    _tXPSymbolValueRetrievalHint strValueHint // Only used when iType is XPTokenType_Symbol 
29401>>>>>>>    _tXPSymbolValueRetrievalHint strValueHint // Only used when iType is XPTokenType_Symbol 
29401>>>>>>>End_Struct
29401>>>>>>>
29401>>>>>>>Enum_List
29401>>>>>>>    Define XPTokenType_Error            // As a return value this is an error
29401>>>>>>>    Define XPTokenType_Operator         // Anything from the operator array
29401>>>>>>>    Define XPTokenType_Symbol           // Variables, Table columns, True and False,
29401>>>>>>>    Define XPTokenType_FunctionCall
29401>>>>>>>    Define XPTokenType_NewParameter
29401>>>>>>>    Define XPTokenType_EndFunctionCall
29401>>>>>>>    Define XPTokenType_StringConstant
29401>>>>>>>    Define XPTokenType_NumberConstant
29401>>>>>>>    Define XPTokenType_IntegerConstant
29401>>>>>>>    Define XPTokenType_LeftParenthesis
29401>>>>>>>    Define XPTokenType_RightParenthesis
29401>>>>>>>End_Enum_List
29401>>>>>>>
29401>>>>>>>Struct tXPError
29401>>>>>>>    Integer iPos
29401>>>>>>>    String  sErrorText
29401>>>>>>>End_Struct
29401>>>>>>>
29401>>>>>>>Class cExpressionParserBasic is a cObject
29402>>>>>>>    Procedure Construct_Object
29404>>>>>>>        Forward Send Construct_Object
29406>>>>>>>        Property tXPGrammar pstrDefaultGrammar
29407>>>>>>>    End_Procedure
29408>>>>>>>    
29408>>>>>>>    Procedure End_Construct_Object
29410>>>>>>>        Forward Send End_Construct_Object
29412>>>>>>>        Send ColdBoot
29413>>>>>>>    End_Procedure
29414>>>>>>>
29414>>>>>>>        Function _fTypeCastString tXPValue strValue Returns tXPValue // 1 param
29416>>>>>>>            If (strValue.iValueType=XP_Date) Begin
29418>>>>>>>                Move (Date(Integer(strValue.sValue))) to strValue.sValue
29419>>>>>>>            End
29419>>>>>>>>
29419>>>>>>>            Else If (strValue.iValueType=XP_Boolean) Begin
29422>>>>>>>                If (Integer(strValue.sValue)<>0) Begin
29424>>>>>>>                    Move "true" to strValue.sValue
29425>>>>>>>                End
29425>>>>>>>>
29425>>>>>>>                Else Begin
29426>>>>>>>                    Move "false" to strValue.sValue
29427>>>>>>>                End
29427>>>>>>>>
29427>>>>>>>            End
29427>>>>>>>>
29427>>>>>>>            Move XP_String to strValue.iValueType
29428>>>>>>>            Function_Return strValue
29429>>>>>>>        End_Function
29430>>>>>>>
29430>>>>>>>        Function _fTypeCastNumeric tXPValue strValue Returns tXPValue // 1 param
29432>>>>>>>            Number nValue
29432>>>>>>>            Get StringToNumber of oStringFunctions strValue.sValue to nValue
29433>>>>>>>            Move nValue to strValue.sValue
29434>>>>>>>            Move XP_Numeric to strValue.iValueType
29435>>>>>>>            Function_Return strValue
29436>>>>>>>        End_Function
29437>>>>>>>
29437>>>>>>>        Function _fTypeCastDate tXPValue strValue Returns tXPValue // 1 param
29439>>>>>>>            Date dValue
29439>>>>>>>            Move strValue.sValue to dValue
29440>>>>>>>            Move (Integer(dValue)) to strValue.sValue
29441>>>>>>>            Move XP_Date to strValue.iValueType
29442>>>>>>>            Function_Return strValue
29443>>>>>>>        End_Function
29444>>>>>>>
29444>>>>>>>        Function _fTypeCastInteger tXPValue strValue Returns tXPValue // 1 param
29446>>>>>>>            Integer iValue
29446>>>>>>>            Get StringToNumber of oStringFunctions strValue.sValue to iValue
29447>>>>>>>            Move iValue to strValue.sValue
29448>>>>>>>            Move XP_Integer to strValue.iValueType
29449>>>>>>>            Function_Return strValue
29450>>>>>>>        End_Function
29451>>>>>>>
29451>>>>>>>        Function _fTypeCastBoolean tXPValue strValue Returns tXPValue // 1 param
29453>>>>>>>            Number nValue
29453>>>>>>>            If (strValue.iValueType=XP_String) Begin
29455>>>>>>>                If (lowercase(strValue.sValue)="true") Begin
29457>>>>>>>                    Move "1" to strValue.sValue
29458>>>>>>>                End
29458>>>>>>>>
29458>>>>>>>                Else If (lowercase(strValue.sValue)="false") Begin
29461>>>>>>>                    Move "0" to strValue.sValue
29462>>>>>>>                End
29462>>>>>>>>
29462>>>>>>>            End
29462>>>>>>>>
29462>>>>>>>            Get StringToNumber of oStringFunctions strValue.sValue to nValue
29463>>>>>>>            Move (nValue<>0) to strValue.sValue
29464>>>>>>>            Move XP_Boolean to strValue.iValueType
29465>>>>>>>            Function_Return strValue
29466>>>>>>>        End_Function
29467>>>>>>>        
29467>>>>>>>        Function _CastValueAs tXPValue strValue Integer iXPType Returns tXPValue
29469>>>>>>>            If (iXPType=strValue.iValueType) Begin
29471>>>>>>>                // If type is already right do nothing
29471>>>>>>>            End
29471>>>>>>>>
29471>>>>>>>            Else If (iXPType=XP_String) Begin
29474>>>>>>>                Get _fTypeCastString strValue to strValue 
29475>>>>>>>            End
29475>>>>>>>>
29475>>>>>>>            Else If (iXPType=XP_Date) Begin
29478>>>>>>>                Get _fTypeCastDate strValue to strValue 
29479>>>>>>>            End
29479>>>>>>>>
29479>>>>>>>            Else If (iXPType=XP_Numeric) Begin
29482>>>>>>>                Get _fTypeCastNumeric strValue to strValue 
29483>>>>>>>            End
29483>>>>>>>>
29483>>>>>>>            Else If (iXPType=XP_Boolean) Begin
29486>>>>>>>                Get _fTypeCastBoolean strValue to strValue 
29487>>>>>>>            End
29487>>>>>>>>
29487>>>>>>>            Else If (iXPType=XP_Integer) Begin
29490>>>>>>>                Get _fTypeCastInteger strValue to strValue 
29491>>>>>>>            End
29491>>>>>>>>
29491>>>>>>>            Function_Return strValue
29492>>>>>>>        End_Function
29493>>>>>>>
29493>>>>>>>    Procedure DefineOperator tXPGrammar ByRef strGrammar String sSymbol Integer iArgs Integer iPrecedence Integer iAssociativity Integer hGet
29495>>>>>>>        Integer iIndex
29495>>>>>>>        Move (SizeOfArray(strGrammar.aOperators)) to iIndex
29496>>>>>>>        Move sSymbol to strGrammar.aOperators[iIndex].sSymbol
29497>>>>>>>        Move iArgs to strGrammar.aOperators[iIndex].iArgumentCount
29498>>>>>>>        Move iPrecedence to strGrammar.aOperators[iIndex].iPrecedence
29499>>>>>>>        Move iAssociativity to strGrammar.aOperators[iIndex].iAssociativity
29500>>>>>>>        Move hGet to strGrammar.aOperators[iIndex].strDispatch.iMsg
29501>>>>>>>        Move Self to strGrammar.aOperators[iIndex].strDispatch.iObj
29502>>>>>>>    End_Procedure
29503>>>>>>>
29503>>>>>>>    Procedure DefineFunction tXPGrammar ByRef strGrammar String sFunction Integer iArgCount Integer iValueType Integer hGet
29505>>>>>>>        Integer iIndex
29505>>>>>>>        Move (SizeOfArray(strGrammar.aFunctions)) to iIndex
29506>>>>>>>        Move sFunction to strGrammar.aFunctions[iIndex].sFunction
29507>>>>>>>        Move iArgCount to strGrammar.aFunctions[iIndex].iArgumentCount
29508>>>>>>>        Move iValueType to strGrammar.aFunctions[iIndex].iReturnType
29509>>>>>>>        Move hGet to strGrammar.aFunctions[iIndex].strDispatch.iMsg
29510>>>>>>>        Move Self to strGrammar.aFunctions[iIndex].strDispatch.iObj
29511>>>>>>>    End_Procedure
29512>>>>>>>
29512>>>>>>>    Procedure DefineConstant tXPGrammar ByRef strGrammar String sSymbol String sValue Integer iValueType
29514>>>>>>>        tXPConstant strConstant
29514>>>>>>>        tXPConstant strConstant
29514>>>>>>>        Move (Lowercase(sSymbol)) to strConstant.sSymbol
29515>>>>>>>        Move sValue to strConstant.strValue.sValue
29516>>>>>>>        Move iValueType to strConstant.strValue.iValueType
29517>>>>>>>        Move strConstant to strGrammar.aConstants[SizeOfArray(strGrammar.aConstants)]
29518>>>>>>>    End_Procedure
29519>>>>>>>    
29519>>>>>>>    Procedure OnDefineOperators tXPGrammar ByRef strGrammar
29521>>>>>>>    End_Procedure
29522>>>>>>>    
29522>>>>>>>    Procedure OnDefineFunctions tXPGrammar ByRef strGrammar
29524>>>>>>>    End_Procedure
29525>>>>>>>    
29525>>>>>>>    Procedure OnDefineConstants tXPGrammar ByRef strGrammar
29527>>>>>>>    End_Procedure
29528>>>>>>>    
29528>>>>>>>        Function _FindConstantIndex tXPGrammar strGrammar String sSymbol Returns Integer
29530>>>>>>>            Integer iItem iMax
29530>>>>>>>            Move (Lowercase(sSymbol)) to sSymbol
29531>>>>>>>            Move (SizeOfArray(strGrammar.aConstants)-1) to iMax
29532>>>>>>>            For iItem from 0 to iMax
29538>>>>>>>>
29538>>>>>>>                If (sSymbol=strGrammar.aConstants[iItem].sSymbol) Begin
29540>>>>>>>                    Function_Return iItem
29541>>>>>>>                End
29541>>>>>>>>
29541>>>>>>>            Loop
29542>>>>>>>>
29542>>>>>>>            Function_Return -1
29543>>>>>>>        End_Function
29544>>>>>>>
29544>>>>>>>        Function _OperatorTestString tXPGrammar strGrammar Returns String
29546>>>>>>>            // The return value of this can be used as a fast way to determine if a symbol is an operator.
29546>>>>>>>            Integer iItem iMax
29546>>>>>>>            String sValue
29546>>>>>>>            Move (SizeOfArray(strGrammar.aOperators)-1) to iMax
29547>>>>>>>            Move " " to sValue
29548>>>>>>>            For iItem from 0 to iMax
29554>>>>>>>>
29554>>>>>>>                Move (sValue+strGrammar.aOperators[iItem].sSymbol+" ") to sValue
29555>>>>>>>            Loop
29556>>>>>>>>
29556>>>>>>>            Function_Return (Uppercase(sValue))
29557>>>>>>>        End_Function
29558>>>>>>>
29558>>>>>>>    Procedure ColdBoot // Reset the default grammar returned by the NewGrammar function.
29560>>>>>>>        tXPGrammar strGrammar
29560>>>>>>>        tXPGrammar strGrammar
29560>>>>>>>        Send OnDefineOperators (&strGrammar)
29561>>>>>>>        Send OnDefineFunctions (&strGrammar)
29562>>>>>>>        Send OnDefineConstants (&strGrammar)
29563>>>>>>>        Get _OperatorTestString strGrammar to strGrammar._sOperatorTestString
29564>>>>>>>        Set pstrDefaultGrammar to strGrammar
29565>>>>>>>    End_Procedure
29566>>>>>>>
29566>>>>>>>    Function NewGrammar Returns tXPGrammar
29568>>>>>>>        Function_Return (pstrDefaultGrammar(Self))
29569>>>>>>>    End_Function
29570>>>>>>>
29570>>>>>>>            Function XPSymbolClassId2Text Integer iType Returns String
29572>>>>>>>                If (iType=XPTokenType_Operator       ) Function_Return "Operator"
29575>>>>>>>                If (iType=XPTokenType_Symbol         ) Function_Return "Symbol"
29578>>>>>>>                If (iType=XPTokenType_FunctionCall   ) Function_Return "FunctionCall"
29581>>>>>>>                If (iType=XPTokenType_NewParameter   ) Function_Return "NewParameter"
29584>>>>>>>                If (iType=XPTokenType_EndFunctionCall) Function_Return "EndFunctionCall"
29587>>>>>>>                If (iType=XPTokenType_StringConstant ) Function_Return "StringConstant"
29590>>>>>>>                If (iType=XPTokenType_NumberConstant ) Function_Return "NumberConstant"
29593>>>>>>>                If (iType=XPTokenType_IntegerConstant) Function_Return "IntegerConstant"
29596>>>>>>>                If (iType=XPTokenType_LeftParenthesis ) Function_Return "Operator ("
29599>>>>>>>                If (iType=XPTokenType_RightParenthesis) Function_Return "Operator )"
29602>>>>>>>                Function_Return "Unknown class"
29603>>>>>>>            End_Function
29604>>>>>>>            
29604>>>>>>>            Function XPValueTypeToString Integer iXPType Returns String
29606>>>>>>>                If (iXPType=XP_Error  ) Function_Return "unknown"
29609>>>>>>>                If (iXPType=XP_String ) Function_Return "string"
29612>>>>>>>                If (iXPType=XP_Numeric) Function_Return "numeric"
29615>>>>>>>                If (iXPType=XP_Date   ) Function_Return "date"
29618>>>>>>>                If (iXPType=XP_Integer) Function_Return "integer"
29621>>>>>>>                If (iXPType=XP_Boolean) Function_Return "boolean"
29624>>>>>>>                Function_Return "really unknown!"
29625>>>>>>>            End_Function
29626>>>>>>>
29626>>>>>>>            Procedure _RegisterError tXPError ByRef strError Integer iPos String sErrorText
29628>>>>>>>                If (strError.iPos=0) Begin
29630>>>>>>>                    Move iPos to strError.iPos
29631>>>>>>>                    Move sErrorText to strError.sErrorText
29632>>>>>>>                End
29632>>>>>>>>
29632>>>>>>>            End_Procedure
29633>>>>>>>
29633>>>>>>>            Function _ErrorState tXPError strError Returns Boolean
29635>>>>>>>                Function_Return (strError.sErrorText<>"")
29636>>>>>>>            End_Function
29637>>>>>>>
29637>>>>>>>            Procedure _ParseStringConstant Address pExpr Integer ByRef iPos Integer iLen tXPToken ByRef strToken tXPError ByRef strError
29639>>>>>>>                Boolean bFin
29639>>>>>>>                String sQuotChar sChar
29639>>>>>>>                Move strToken.sValue to sQuotChar
29640>>>>>>>                Move "" to strToken.sValue
29641>>>>>>>                Move False to bFin
29642>>>>>>>                Repeat
29642>>>>>>>>
29642>>>>>>>                    Increment iPos
29643>>>>>>>                    If (iPos<=iLen) Begin
29645>>>>>>>                        Move (Character(DeRefC(pExpr,iPos))) to sChar
29646>>>>>>>                        If (sChar=sQuotChar) Begin
29648>>>>>>>                            Move True to bFin
29649>>>>>>>                            Increment iPos // Skip quotation character
29650>>>>>>>                        End
29650>>>>>>>>
29650>>>>>>>                        Else Begin
29651>>>>>>>                            Move (strToken.sValue+sChar) to strToken.sValue
29652>>>>>>>                        End
29652>>>>>>>>
29652>>>>>>>                    End
29652>>>>>>>>
29652>>>>>>>                    Else Begin
29653>>>>>>>                        Move True to bFin
29654>>>>>>>                        Send _RegisterError (&strError) -1 ("Missing "+sQuotChar+" in expression")
29655>>>>>>>                    End
29655>>>>>>>>
29655>>>>>>>                Until (bFin)
29657>>>>>>>            End_Procedure
29658>>>>>>>
29658>>>>>>>            Procedure _ParseNumericConstant Address pExpr Integer ByRef iPos Integer iLen tXPToken ByRef strToken tXPError ByRef strError
29660>>>>>>>                Boolean bFin bDecimalPlaceIndendified
29660>>>>>>>                String sChar
29660>>>>>>>
29660>>>>>>>                Move (strToken.sValue=".") to bDecimalPlaceIndendified
29661>>>>>>>                Repeat
29661>>>>>>>>
29661>>>>>>>                    Increment iPos
29662>>>>>>>                    If (iPos<=iLen) Begin
29664>>>>>>>                        Move (Character(DeRefC(pExpr,iPos))) to sChar
29665>>>>>>>                        If ("0123456789." contains sChar) Begin
29667>>>>>>>                            Move (strToken.sValue+sChar) to strToken.sValue
29668>>>>>>>                            If (sChar=".") Begin
29670>>>>>>>                                If (bDecimalPlaceIndendified) Begin
29672>>>>>>>                                    Move True to bFin
29673>>>>>>>                                    Send _RegisterError (&strError) iPos "Redundant decimal separator encountered"
29674>>>>>>>                                End
29674>>>>>>>>
29674>>>>>>>                                Else Begin
29675>>>>>>>                                    Move True to bDecimalPlaceIndendified
29676>>>>>>>                                End
29676>>>>>>>>
29676>>>>>>>                            End
29676>>>>>>>>
29676>>>>>>>                        End
29676>>>>>>>>
29676>>>>>>>                        Else Begin
29677>>>>>>>                            Move True to bFin
29678>>>>>>>                        End
29678>>>>>>>>
29678>>>>>>>                    End
29678>>>>>>>>
29678>>>>>>>                    Else Begin
29679>>>>>>>                        Move True to bFin
29680>>>>>>>                    End
29680>>>>>>>>
29680>>>>>>>                Until (bFin)
29682>>>>>>>                Move (If(bDecimalPlaceIndendified,XPTokenType_NumberConstant,XPTokenType_IntegerConstant)) to strToken.iType
29683>>>>>>>            End_Procedure
29684>>>>>>>
29684>>>>>>>            Procedure _ParseOperator String sOperatorTestString Address pExpr Integer ByRef iPos Integer iLen tXPToken ByRef strToken tXPError ByRef strError
29686>>>>>>>                Boolean bFin
29686>>>>>>>                String sChar
29686>>>>>>>                Move False to bFin
29687>>>>>>>                Repeat
29687>>>>>>>>
29687>>>>>>>                    Increment iPos
29688>>>>>>>                    If (iPos<=iLen) Begin
29690>>>>>>>                        Move (Character(DeRefC(pExpr,iPos))) to sChar
29691>>>>>>>                        If (sOperatorTestString contains (" "+Uppercase(strToken.sValue+sChar)+" ")) Begin
29693>>>>>>>                            Move (strToken.sValue+sChar) to strToken.sValue
29694>>>>>>>                        End
29694>>>>>>>>
29694>>>>>>>                        Else Begin
29695>>>>>>>                            Move True to bFin
29696>>>>>>>                        End
29696>>>>>>>>
29696>>>>>>>                    End
29696>>>>>>>>
29696>>>>>>>                    Else Begin
29697>>>>>>>                        Move True to bFin
29698>>>>>>>                    End
29698>>>>>>>>
29698>>>>>>>                Until (bFin)
29700>>>>>>>                If (not(sOperatorTestString contains (" "+Uppercase(strToken.sValue)+" "))) Begin
29702>>>>>>>                    Send _RegisterError (&strError) strToken.iStartPos ("Symbol not recognised: "+strToken.sValue)
29703>>>>>>>                End
29703>>>>>>>>
29703>>>>>>>            End_Procedure
29704>>>>>>>
29704>>>>>>>                Procedure _ParseResolveFunctionCall tXPGrammar strGrammar tXPToken ByRef strToken Integer iArgCount tXPError ByRef strError
29706>>>>>>>                    Boolean bResolved bFunctionFound
29706>>>>>>>                    Integer iMax iItem
29706>>>>>>>                    String sFunction
29706>>>>>>>                    Move (SizeOfArray(strGrammar.aFunctions)-1) to iMax
29707>>>>>>>                    Move 0 to iItem
29708>>>>>>>                    Move False to bResolved
29709>>>>>>>                    Move False to bFunctionFound
29710>>>>>>>                    Move (Uppercase(strToken.sValue)) to sFunction
29711>>>>>>>                    While (not(bResolved) and iItem<=iMax)
29715>>>>>>>                        If (sFunction=Uppercase(strGrammar.aFunctions[iItem].sFunction)) Begin
29717>>>>>>>                            Move True to bFunctionFound
29718>>>>>>>                            If (iArgCount=strGrammar.aFunctions[iItem].iArgumentCount) Begin
29720>>>>>>>                                Move iItem to strToken.iOperatorIndex
29721>>>>>>>                                Move True to bResolved
29722>>>>>>>                            End
29722>>>>>>>>
29722>>>>>>>                        End
29722>>>>>>>>
29722>>>>>>>                        Increment iItem
29723>>>>>>>                    Loop
29724>>>>>>>>
29724>>>>>>>                    If (not(bResolved)) Begin
29726>>>>>>>                        If (bFunctionFound) Begin
29728>>>>>>>                            Send _RegisterError (&strError) strToken.iStartPos ("Wrong number of parameters (function: "+strToken.sValue+")")
29729>>>>>>>                        End
29729>>>>>>>>
29729>>>>>>>                        Else Begin
29730>>>>>>>                            Send _RegisterError (&strError) strToken.iStartPos ("Function not defined: ("+strToken.sValue+")")
29731>>>>>>>                        End
29731>>>>>>>>
29731>>>>>>>                    End
29731>>>>>>>>
29731>>>>>>>                End_Procedure
29732>>>>>>>
29732>>>>>>>                Procedure _ParseResolveOperator tXPGrammar strGrammar tXPToken ByRef strToken Integer iArgCount tXPError ByRef strError
29734>>>>>>>                    Boolean bResolved bOperatorFound
29734>>>>>>>                    Integer iMax iItem
29734>>>>>>>                    String sOperator
29734>>>>>>>                    Move (SizeOfArray(strGrammar.aOperators)-1) to iMax
29735>>>>>>>                    Move 0 to iItem
29736>>>>>>>                    Move False to bResolved
29737>>>>>>>                    Move False to bOperatorFound
29738>>>>>>>                    Move (Uppercase(strToken.sValue)) to sOperator
29739>>>>>>>                    While (not(bResolved) and iItem<=iMax)
29743>>>>>>>                        If (sOperator=Uppercase(strGrammar.aOperators[iItem].sSymbol)) Begin
29745>>>>>>>                            Move True to bOperatorFound
29746>>>>>>>                            If (iArgCount=strGrammar.aOperators[iItem].iArgumentCount) Begin
29748>>>>>>>                                Move iItem to strToken.iOperatorIndex
29749>>>>>>>                                Move True to bResolved
29750>>>>>>>                            End
29750>>>>>>>>
29750>>>>>>>                        End
29750>>>>>>>>
29750>>>>>>>                        Increment iItem
29751>>>>>>>                    Loop
29752>>>>>>>>
29752>>>>>>>                    If (not(bResolved)) Begin
29754>>>>>>>                        If (bOperatorFound) Begin
29756>>>>>>>                            Send _RegisterError (&strError) strToken.iStartPos ("Wrong number of operands (operator: "+strToken.sValue+")")
29757>>>>>>>                        End
29757>>>>>>>>
29757>>>>>>>                        Else Begin
29758>>>>>>>                            Send _RegisterError (&strError) strToken.iStartPos ("Operator not defined: ("+strToken.sValue+")")
29759>>>>>>>                        End
29759>>>>>>>>
29759>>>>>>>                    End
29759>>>>>>>>
29759>>>>>>>                End_Procedure
29760>>>>>>>            
29760>>>>>>>
29760>>>>>>>                    Function OnColumnNameToNumber Integer iTable String sName Returns Integer
29762>>>>>>>                        Integer iMax iField
29762>>>>>>>                        String sFieldName
29762>>>>>>>                        Move (Lowercase(sName)) to sName
29763>>>>>>>                        Get_Attribute DF_FILE_NUMBER_FIELDS of iTable to iMax
29766>>>>>>>                        For iField from 1 to iMax
29772>>>>>>>>
29772>>>>>>>                            Get_Attribute DF_FIELD_NAME of iTable iField to sFieldName
29775>>>>>>>                            If (sName=Lowercase(sFieldName)) Begin
29777>>>>>>>                                Function_Return iField
29778>>>>>>>                            End
29778>>>>>>>>
29778>>>>>>>                        Loop
29779>>>>>>>>
29779>>>>>>>                        If (sName="recnum") Begin
29781>>>>>>>                            Function_Return 0
29782>>>>>>>                        End
29782>>>>>>>>
29782>>>>>>>                        Function_Return -1 // not found
29783>>>>>>>                    End_Function
29784>>>>>>>                
29784>>>>>>>                    Function OnTableNameToNumber String sLogicalName Returns Integer
29786>>>>>>>                        Integer iTable
29786>>>>>>>                        String sValue
29786>>>>>>>                        Move (Uppercase(sLogicalName)) to sLogicalName
29787>>>>>>>                        Move 0 to iTable
29788>>>>>>>                        Repeat
29788>>>>>>>>
29788>>>>>>>                            Get_Attribute DF_FILE_NEXT_USED of iTable to iTable
29791>>>>>>>                            If (iTable<>0) Begin
29793>>>>>>>                                Get_Attribute DF_FILE_LOGICAL_NAME of iTable to sValue
29796>>>>>>>                                If (sLogicalName=Uppercase(sValue)) Begin
29798>>>>>>>                                    Function_Return iTable
29799>>>>>>>                                End
29799>>>>>>>>
29799>>>>>>>                            End
29799>>>>>>>>
29799>>>>>>>                        Until (iTable=0)
29801>>>>>>>                
29801>>>>>>>                        Function_Return -1
29802>>>>>>>                    End_Function
29803>>>>>>>                    
29803>>>>>>>                    Function OnIsTableColumnReference String sSymbol Returns Boolean
29805>>>>>>>                        // ToDo: Check for exactly 1 dot in the name. And that it is not the last character
29805>>>>>>>                        Function_Return (sSymbol contains ".") // Not good enough!
29806>>>>>>>                    End_Function
29807>>>>>>>                    
29807>>>>>>>                    Function OnGetTableColumnType Integer iTable Integer iColumn Returns Integer
29809>>>>>>>                        Integer iDFType
29809>>>>>>>                        Get_Attribute DF_FIELD_TYPE of iTable iColumn to iDFType
29812>>>>>>>                        
29812>>>>>>>                        If (iDFType=DF_ASCII or iDFType=DF_TEXT)       Function_Return XP_String
29815>>>>>>>                        If (iDFType=DF_DATE or iDFType=DF_DATETIME)    Function_Return XP_Date
29818>>>>>>>                        If (iDFType=DF_BCD)                            Function_Return XP_Numeric
29821>>>>>>>                        Function_Return XP_Error // Unknown type
29822>>>>>>>                    End_Function
29823>>>>>>>                    
29823>>>>>>>                    Procedure OnAddTableColumnHint tXPToken ByRef strSymbolToken tXPError ByRef strError
29825>>>>>>>                        Integer iTable iColumn iPos
29825>>>>>>>                        String sSymbol sTable sColumn
29825>>>>>>>                        Move strSymbolToken.sValue to sSymbol
29826>>>>>>>                        Move (Pos(".",sSymbol)) to iPos
29827>>>>>>>                        If (iPos>0) Begin
29829>>>>>>>                            Move (Left(sSymbol,iPos-1)) to sTable
29830>>>>>>>                            Move (Replace(sTable+".",sSymbol,"")) to sColumn
29831>>>>>>>                            Get OnTableNameToNumber sTable to iTable
29832>>>>>>>                            If (iTable>0) Begin
29834>>>>>>>                                Get OnColumnNameToNumber iTable sColumn to iColumn
29835>>>>>>>                                If (iColumn>0) Begin
29837>>>>>>>                                    Move iTable to strSymbolToken.strValueHint.iTable
29838>>>>>>>                                    Move iColumn to strSymbolToken.strValueHint.iColumn
29839>>>>>>>                                    Get OnGetTableColumnType iTable iColumn to strSymbolToken.strValueHint.iValueType
29840>>>>>>>                                End
29840>>>>>>>>
29840>>>>>>>                                Else Begin
29841>>>>>>>                                    Send _RegisterError (&strError) strSymbolToken.iStartPos ("ExprParser: '"+sColumn+"' not a column name in table '"+sTable+"'")
29842>>>>>>>                                End
29842>>>>>>>>
29842>>>>>>>                            End
29842>>>>>>>>
29842>>>>>>>                            Else Begin
29843>>>>>>>                                Send _RegisterError (&strError) strSymbolToken.iStartPos ("ExprParser: '"+sTable+"' not a table name")
29844>>>>>>>                            End
29844>>>>>>>>
29844>>>>>>>                        End
29844>>>>>>>>
29844>>>>>>>                        Else Begin
29845>>>>>>>                            Send _RegisterError (&strError) strSymbolToken.iStartPos ("ExprParser: '"+sSymbol+"' not a table column reference")
29846>>>>>>>                        End
29846>>>>>>>>
29846>>>>>>>                    End_Procedure
29847>>>>>>>
29847>>>>>>>            Procedure OnAddSymbolRetrievalHint tXPGrammar strGrammar tXPToken ByRef strSymbolToken tXPError ByRef strError
29849>>>>>>>                String sSymbol
29849>>>>>>>                Move strSymbolToken.sValue to sSymbol
29850>>>>>>>                If (OnIsTableColumnReference(Self,sSymbol)) Begin
29852>>>>>>>                    Send OnAddTableColumnHint (&strSymbolToken) (&strError)
29853>>>>>>>                End
29853>>>>>>>>
29853>>>>>>>                Else Begin
29854>>>>>>>                    Get _FindConstantIndex strGrammar sSymbol to strSymbolToken.strValueHint.iConstantIndex
29855>>>>>>>                End
29855>>>>>>>>
29855>>>>>>>                // Check to see if its a 
29855>>>>>>>            End_Procedure
29856>>>>>>>                
29856>>>>>>>            Procedure _AddSymbolValueRetrievalHints tXPGrammar strGrammar tXPToken[] ByRef aTokens tXPError ByRef strError
29858>>>>>>>                Integer iItem iMax  
29858>>>>>>>                Move (SizeOfArray(aTokens)-1) to iMax
29859>>>>>>>                For iItem from 0 to iMax
29865>>>>>>>>
29865>>>>>>>                    If (aTokens[iItem].iType=XPTokenType_Symbol) Begin
29867>>>>>>>                        Send OnAddSymbolRetrievalHint strGrammar (&aTokens[iItem]) (&strError)
29868>>>>>>>                    End
29868>>>>>>>>
29868>>>>>>>                Loop
29869>>>>>>>>
29869>>>>>>>            End_Procedure
29870>>>>>>>
29870>>>>>>>            // Procedure _TokenizeFinalize will resolve all operators and function calls according to
29870>>>>>>>            // the number of arguments each of them has as compared to the grammar.
29870>>>>>>>            Procedure _TokenizeFinalize tXPGrammar strGrammar tXPToken[] ByRef aTokens tXPError ByRef strError
29872>>>>>>>                Integer iItem iMax iType iCountIndex iOperatorArgCount
29872>>>>>>>                Integer[] aFunctionCallStack //
29873>>>>>>>                Integer[] aFunctionParameterCounters //
29874>>>>>>>                Move (SizeOfArray(aTokens)-1) to iMax
29875>>>>>>>                For iItem from 0 to iMax
29881>>>>>>>>
29881>>>>>>>                    Move aTokens[iItem].iType to iType
29882>>>>>>>                    If (iType=XPTokenType_FunctionCall) Begin
29884>>>>>>>                        Send IntegerPush of oStackFunctions iItem (&aFunctionCallStack)
29885>>>>>>>                        Move (SizeOfArray(aFunctionCallStack)-1) to iCountIndex
29886>>>>>>>                        Move 0 to aFunctionParameterCounters[iCountIndex]
29887>>>>>>>                    End
29887>>>>>>>>
29887>>>>>>>                    Else If (iType=XPTokenType_EndFunctionCall) Begin
29890>>>>>>>                        If (aTokens[iItem-1].iType<>XPTokenType_FunctionCall) Begin
29892>>>>>>>                            Increment aFunctionParameterCounters[iCountIndex]
29893>>>>>>>                        End
29893>>>>>>>>
29893>>>>>>>                        Send _ParseResolveFunctionCall strGrammar (&aTokens[aFunctionCallStack[iCountIndex]]) aFunctionParameterCounters[iCountIndex] (&strError)
29894>>>>>>>                        Send IntegerDrop of oStackFunctions (&aFunctionCallStack)
29895>>>>>>>                        Move (SizeOfArray(aFunctionCallStack)-1) to iCountIndex
29896>>>>>>>                    End
29896>>>>>>>>
29896>>>>>>>                    Else If (iType=XPTokenType_NewParameter) Begin
29899>>>>>>>                        // Check for un-motivated new parameter 
29899>>>>>>>                        If (IntegerIsEmpty(oStackFunctions,aFunctionCallStack)) Begin
29901>>>>>>>                            Send _RegisterError (&strError) aTokens[iItem].iStartPos "Un-motivated new parameter"
29902>>>>>>>                        End
29902>>>>>>>>
29902>>>>>>>                        Else Begin
29903>>>>>>>                            Increment aFunctionParameterCounters[iCountIndex]
29904>>>>>>>                        End
29904>>>>>>>>
29904>>>>>>>                    End
29904>>>>>>>>
29904>>>>>>>                    Else If (iType=XPTokenType_Operator) Begin
29907>>>>>>>                        Move 0 to iOperatorArgCount
29908>>>>>>>                        // If there's something in front of it and it is not a left parenthesis or a comma
29908>>>>>>>                        // then we have a parameter to the left of the operator:
29908>>>>>>>                        If (iItem>0 and aTokens[iItem-1].iType<>XPTokenType_FunctionCall and ;                                        aTokens[iItem-1].iType<>XPTokenType_NewParameter) Begin
29910>>>>>>>                            Increment iOperatorArgCount
29911>>>>>>>                        End
29911>>>>>>>>
29911>>>>>>>                        // If there is something after it and it is not a right parenthesis or a function-end or a new parameter
29911>>>>>>>                        // then we have a parameter to the right of us:
29911>>>>>>>                        If (iItem<iMax and aTokens[iItem+1].sValue<>")" and aTokens[iItem+1].iType<>XPTokenType_NewParameter) Begin
29913>>>>>>>                            Increment iOperatorArgCount
29914>>>>>>>                        End
29914>>>>>>>>
29914>>>>>>>                        Send _ParseResolveOperator strGrammar (&aTokens[iItem]) iOperatorArgCount (&strError)
29915>>>>>>>                    End
29915>>>>>>>>
29915>>>>>>>                Loop
29916>>>>>>>>
29916>>>>>>>            End_Procedure
29917>>>>>>>
29917>>>>>>>    Function TokenizeString tXPGrammar strGrammar String sExpression tXPError ByRef strError Returns tXPToken[]
29919>>>>>>>        Boolean bTokenFound bFin
29919>>>>>>>        Boolean bTokenTerminatedByLeftParenthesis
29919>>>>>>>        Boolean[] aParenthesisLevelIsFunctionCall
29920>>>>>>>        Integer iTokenCount
29920>>>>>>>        Integer iPos iLen
29920>>>>>>>        Integer iItem iMax
29920>>>>>>>        String sChar sTemp
29920>>>>>>>        Address pExpr
29920>>>>>>>        tXPToken[] aTokens
29920>>>>>>>        tXPToken[] aTokens
29921>>>>>>>        tXPToken strNextToken
29921>>>>>>>        tXPToken strNextToken
29921>>>>>>>        tXPError strNoError
29921>>>>>>>        tXPError strNoError
29921>>>>>>>
29921>>>>>>>        Move (AddressOf(sExpression)) to pExpr
29922>>>>>>>        Move (Length(sExpression)) to iLen
29923>>>>>>>        Move 0 to iPos // First character is in position 0
29924>>>>>>>
29924>>>>>>>        Move strNoError to strError
29925>>>>>>>        Move 0 to iTokenCount
29926>>>>>>>
29926>>>>>>>        Repeat // until (not(bTokenFound))
29926>>>>>>>>
29926>>>>>>>
29926>>>>>>>            // Remove leadin whitespace (and set bTokenFound):
29926>>>>>>>            Move False to bFin
29927>>>>>>>            Move False to bTokenFound
29928>>>>>>>            Repeat
29928>>>>>>>>
29928>>>>>>>                If (iPos<=iLen) Begin
29930>>>>>>>                    Move (Character(DeRefC(pExpr,iPos))) to sChar
29931>>>>>>>                    If (Ascii(sChar)<=32) Begin
29933>>>>>>>                        Increment iPos // Skip blanks, tabs, cr/lf's and the lot
29934>>>>>>>                    End
29934>>>>>>>>
29934>>>>>>>                    Else Begin
29935>>>>>>>                        Move True to bFin
29936>>>>>>>                        Move True to bTokenFound
29937>>>>>>>                    End
29937>>>>>>>>
29937>>>>>>>                End
29937>>>>>>>>
29937>>>>>>>                Else begin
29938>>>>>>>                    Move True to bFin
29939>>>>>>>                End
29939>>>>>>>>
29939>>>>>>>            Until bFin
29941>>>>>>>
29941>>>>>>>            If (bTokenFound) Begin
29943>>>>>>>                // Initialize new token:
29943>>>>>>>                Move -1 to strNextToken.iType         // Type unknown
29944>>>>>>>                Move "" to strNextToken.sValue         // No value yet
29945>>>>>>>                Move -1 to strNextToken.strValueHint.iConstantIndex
29946>>>>>>>                Move (iPos+1) to strNextToken.iStartPos    // Start position of the symbol
29947>>>>>>>                Move -1 to strNextToken.iOperatorIndex
29948>>>>>>>
29948>>>>>>>                Move (Character(DeRefC(pExpr,iPos))) to sChar
29949>>>>>>>                Move sChar to strNextToken.sValue
29950>>>>>>>
29950>>>>>>>                If (C_EPSymbolLegalFirstCharacters contains sChar) Begin
29952>>>>>>>                    // It's an operator or a symbol. Or a function call if the terminating character is a "("
29952>>>>>>>                    Move False to bFin
29953>>>>>>>                    Move False to bTokenTerminatedByLeftParenthesis
29954>>>>>>>                    Repeat
29954>>>>>>>>
29954>>>>>>>                        Increment iPos
29955>>>>>>>                        If (iPos<=iLen) Begin
29957>>>>>>>                            Move (Character(DeRefC(pExpr,iPos))) to sChar
29958>>>>>>>                            If (C_EPSymbolLegalCharacters contains sChar) Begin
29960>>>>>>>                                Move (strNextToken.sValue+sChar) to strNextToken.sValue
29961>>>>>>>                            End
29961>>>>>>>>
29961>>>>>>>                            Else Begin
29962>>>>>>>                                If (sChar="(") Begin // A function call most likely!
29964>>>>>>>                                    Move True to bTokenTerminatedByLeftParenthesis
29965>>>>>>>                                End
29965>>>>>>>>
29965>>>>>>>                                Move True to bFin
29966>>>>>>>                            End
29966>>>>>>>>
29966>>>>>>>                        End
29966>>>>>>>>
29966>>>>>>>                        Else Begin
29967>>>>>>>                            Move True to bFin
29968>>>>>>>                        End
29968>>>>>>>>
29968>>>>>>>                    Until (bFin)
29970>>>>>>>                    If (strGrammar._sOperatorTestString contains (" "+Uppercase(strNextToken.sValue)+" ")) Begin
29972>>>>>>>                        // Operator!
29972>>>>>>>                        Move XPTokenType_Operator to strNextToken.iType
29973>>>>>>>                        If (strNextToken.sValue=")") Begin
29975>>>>>>>                            If (BooleanPop(oStackFunctions,&aParenthesisLevelIsFunctionCall)) Begin
29977>>>>>>>                                Move XPTokenType_EndFunctionCall to strNextToken.iType
29978>>>>>>>                            End
29978>>>>>>>>
29978>>>>>>>                        End
29978>>>>>>>>
29978>>>>>>>                    End
29978>>>>>>>>
29978>>>>>>>                    Else Begin
29979>>>>>>>                        // Symbol or function call!
29979>>>>>>>                        If (bTokenTerminatedByLeftParenthesis) Begin // Then it's a function call
29981>>>>>>>//                                Increment iPos // Skip the parenthesis
29981>>>>>>>                            Move XPTokenType_FunctionCall to strNextToken.iType
29982>>>>>>>                            Send BooleanPush of oStackFunctions True (&aParenthesisLevelIsFunctionCall)
29983>>>>>>>                        End
29983>>>>>>>>
29983>>>>>>>                        Else Begin
29984>>>>>>>                            Move XPTokenType_Symbol to strNextToken.iType
29985>>>>>>>                        End
29985>>>>>>>>
29985>>>>>>>                    End
29985>>>>>>>>
29985>>>>>>>                End
29985>>>>>>>>
29985>>>>>>>                Else Begin // Operator or constant
29986>>>>>>>                    If (("'"+'"') contains sChar) Begin // Constant string?
29988>>>>>>>                        // String constant
29988>>>>>>>                        Send _ParseStringConstant pExpr (&iPos) iLen (&strNextToken) (&strError)
29989>>>>>>>                        Move XPTokenType_StringConstant to strNextToken.iType
29990>>>>>>>                    End
29990>>>>>>>>
29990>>>>>>>                    Else If ("0123456789." contains sChar) Begin // Constant numeric?
29993>>>>>>>                        Send _ParseNumericConstant pExpr (&iPos) iLen (&strNextToken) (&strError)
29994>>>>>>>                    End
29994>>>>>>>>
29994>>>>>>>                    Else Begin // Then operator
29995>>>>>>>                        Send _ParseOperator strGrammar._sOperatorTestString pExpr (&iPos) iLen (&strNextToken) (&strError)
29996>>>>>>>                        Move XPTokenType_Operator to strNextToken.iType
29997>>>>>>>                        If (strNextToken.sValue="(") Begin
29999>>>>>>>                            If (not(iTokenCount>0 and aTokens[iTokenCount-1].iType=XPTokenType_FunctionCall)) Begin
30001>>>>>>>                                Send BooleanPush of oStackFunctions False (&aParenthesisLevelIsFunctionCall)
30002>>>>>>>                            End
30002>>>>>>>>
30002>>>>>>>                            Move XPTokenType_LeftParenthesis to strNextToken.iType
30003>>>>>>>                        End
30003>>>>>>>>
30003>>>>>>>                        Else If (strNextToken.sValue=")") Begin
30006>>>>>>>                            If (BooleanIsEmpty(oStackFunctions,aParenthesisLevelIsFunctionCall)) Begin
30008>>>>>>>                                Send _RegisterError (&strError) strNextToken.iStartPos "Cannot unstack )"
30009>>>>>>>                            End
30009>>>>>>>>
30009>>>>>>>                            Else Begin
30010>>>>>>>                                If (BooleanPop(oStackFunctions,&aParenthesisLevelIsFunctionCall)) Begin
30012>>>>>>>                                    Move XPTokenType_EndFunctionCall to strNextToken.iType
30013>>>>>>>                                End
30013>>>>>>>>
30013>>>>>>>                                Else Begin
30014>>>>>>>                                    Move XPTokenType_RightParenthesis to strNextToken.iType
30015>>>>>>>                                End
30015>>>>>>>>
30015>>>>>>>                            End
30015>>>>>>>>
30015>>>>>>>                        End
30015>>>>>>>>
30015>>>>>>>                        Else If (strNextToken.sValue=",") Begin
30018>>>>>>>                            Move XPTokenType_NewParameter to strNextToken.iType
30019>>>>>>>                        End
30019>>>>>>>>
30019>>>>>>>                    End
30019>>>>>>>>
30019>>>>>>>                End
30019>>>>>>>>
30019>>>>>>>
30019>>>>>>>                Move strNextToken to aTokens[iTokenCount]
30020>>>>>>>                Increment iTokenCount
30021>>>>>>>            End
30021>>>>>>>>
30021>>>>>>>        Until (not(bTokenFound))
30023>>>>>>>
30023>>>>>>>        If (SizeOfArray(aParenthesisLevelIsFunctionCall)>0) Begin
30025>>>>>>>            If (strError.iPos=0) Begin
30027>>>>>>>                Move -1 to strError.iPos
30028>>>>>>>                Move "Unbalanced parenthesis" to strError.sErrorText
30029>>>>>>>            End
30029>>>>>>>>
30029>>>>>>>        End
30029>>>>>>>>
30029>>>>>>>
30029>>>>>>>        Send _TokenizeFinalize strGrammar (&aTokens) (&strError)
30030>>>>>>>        
30030>>>>>>>        // Translate for example column names into iTable iColumn format instead
30030>>>>>>>        Send _AddSymbolValueRetrievalHints strGrammar (&aTokens) (&strError)
30031>>>>>>>        
30031>>>>>>>        Function_Return aTokens
30032>>>>>>>    End_Function
30033>>>>>>>
30033>>>>>>>        Procedure _OperatorStackPush tXPToken[] ByRef aOperatorStack tXPToken strToken
30035>>>>>>>            Move strToken to aOperatorStack[SizeOfArray(aOperatorStack)]
30036>>>>>>>        End_Procedure
30037>>>>>>>
30037>>>>>>>        Function _OperatorStackPop tXPToken[] ByRef aOperatorStack Returns tXPToken
30039>>>>>>>            Integer iIndex
30039>>>>>>>            tXPToken strToken strEmptyToken
30039>>>>>>>            tXPToken strToken strEmptyToken
30039>>>>>>>            Move (SizeOfArray(aOperatorStack)-1) to iIndex
30040>>>>>>>            If (iIndex>=0) Begin
30042>>>>>>>                Move aOperatorStack[iIndex] to strToken
30043>>>>>>>                Move (RemoveFromArray(aOperatorStack,iIndex)) to aOperatorStack
30044>>>>>>>                Function_Return strToken
30045>>>>>>>            End
30045>>>>>>>>
30045>>>>>>>            Error DFERR_OPERATOR ("ExprParser: Attempt to pop from empty stack")
30046>>>>>>>>
30046>>>>>>>            Function_Return strEmptyToken
30047>>>>>>>        End_Function
30048>>>>>>>
30048>>>>>>>        Function _OperatorStackCopy tXPToken[] aOperatorStack Returns tXPToken
30050>>>>>>>            Integer iIndex
30050>>>>>>>            tXPToken strEmptyToken
30050>>>>>>>            tXPToken strEmptyToken
30050>>>>>>>            Move (SizeOfArray(aOperatorStack)-1) to iIndex
30051>>>>>>>            If (iIndex>=0) Begin
30053>>>>>>>                Function_Return aOperatorStack[iIndex]
30054>>>>>>>            End
30054>>>>>>>>
30054>>>>>>>            Error DFERR_OPERATOR ("ExprParser: Attempt to copy from empty stack")
30055>>>>>>>>
30055>>>>>>>            Function_Return strEmptyToken
30056>>>>>>>        End_Function
30057>>>>>>>
30057>>>>>>>        Function _OperatorStackIsEmpty tXPToken[] aOperatorStack Returns Boolean
30059>>>>>>>            Function_Return (SizeOfArray(aOperatorStack)=0)
30060>>>>>>>        End_Function
30061>>>>>>>
30061>>>>>>>    Function ReversePolishNotation tXPGrammar strGrammar tXPToken[] aInputTokens tXPError ByRef strError Returns tXPToken[]
30063>>>>>>>        Integer iInputTokensMax iInputTokenIndex iAssociativity iPrecendence
30063>>>>>>>        Boolean bFin
30063>>>>>>>        tXPToken[] aOutputTokens
30063>>>>>>>        tXPToken[] aOutputTokens
30064>>>>>>>        tXPToken[] aOperatorStack
30064>>>>>>>        tXPToken[] aOperatorStack
30065>>>>>>>        tXPToken strInputToken strToken
30065>>>>>>>        tXPToken strInputToken strToken
30065>>>>>>>
30065>>>>>>>        Move (SizeOfArray(aInputTokens)) to iInputTokensMax
30066>>>>>>>        Move 0 to iInputTokenIndex
30067>>>>>>>        
30067>>>>>>>        While (iInputTokenIndex<iInputTokensMax)
30071>>>>>>>            Move aInputTokens[iInputTokenIndex] to strInputToken
30072>>>>>>>            If (strInputToken.iType=XPTokenType_IntegerConstant or ;                strInputToken.iType=XPTokenType_NumberConstant or ;                strInputToken.iType=XPTokenType_StringConstant or ;                strInputToken.iType=XPTokenType_Symbol) Begin
30074>>>>>>>                // If the token is an operand, then add it to the output
30074>>>>>>>                Move aInputTokens[iInputTokenIndex] to aOutputTokens[SizeOfArray(aOutputTokens)]
30075>>>>>>>            End
30075>>>>>>>>
30075>>>>>>>            Else If (strInputToken.iType=XPTokenType_FunctionCall) Begin
30078>>>>>>>                // If the token is a function, then push it onto the stack
30078>>>>>>>                Send _OperatorStackPush (&aOperatorStack) aInputTokens[iInputTokenIndex]
30079>>>>>>>            End
30079>>>>>>>>
30079>>>>>>>            Else If (strInputToken.iType=XPTokenType_NewParameter) Begin
30082>>>>>>>                // If the token is a function argument separator (e.g., a comma):
30082>>>>>>>                //   Until the token at the top of the stack is a left parenthesis, pop operators
30082>>>>>>>                //   off the stack onto the output queue. If no left parentheses are encountered,
30082>>>>>>>                //   either the separator was misplaced or parentheses were mismatched.
30082>>>>>>>                Repeat
30082>>>>>>>>
30082>>>>>>>                    Get _OperatorStackCopy aOperatorStack to strToken
30083>>>>>>>                    If (strToken.iType<>XPTokenType_LeftParenthesis and strToken.iType<>XPTokenType_Error) Begin
30085>>>>>>>                        Get _OperatorStackPop (&aOperatorStack) to aOutputTokens[SizeOfArray(aOutputTokens)]
30086>>>>>>>                    End
30086>>>>>>>>
30086>>>>>>>                Until (strToken.iType=XPTokenType_LeftParenthesis or strToken.iType=XPTokenType_Error)
30088>>>>>>>            End
30088>>>>>>>>
30088>>>>>>>            Else If (strInputToken.iType=XPTokenType_Operator) Begin
30091>>>>>>>                // If the token is an operator, o1, then:
30091>>>>>>>                //     While there is an operator token, o2, at the top of the stack, and
30091>>>>>>>                //         either o1 is left-associative and its precedence is less than or equal to that of o2,
30091>>>>>>>                //         or o1 has precedence less than that of o2,
30091>>>>>>>                //     pop o2 off the stack, onto the Output queue;
30091>>>>>>>                // push o1 onto the stack.
30091>>>>>>>
30091>>>>>>>                // associativity and precedence of o1:
30091>>>>>>>                Move strGrammar.aOperators[strInputToken.iOperatorIndex].iAssociativity to iAssociativity
30092>>>>>>>                Move strGrammar.aOperators[strInputToken.iOperatorIndex].iPrecedence to iPrecendence
30093>>>>>>>                Repeat
30093>>>>>>>>
30093>>>>>>>                    Move True to bFin // We assume we are done
30094>>>>>>>                    If (not(_OperatorStackIsEmpty(Self,aOperatorStack))) Begin
30096>>>>>>>                        Get _OperatorStackCopy aOperatorStack to strToken // o2
30097>>>>>>>                        If (strToken.iType=XPTokenType_Operator) Begin // Check that its an actual operator (and not "(" for example)
30099>>>>>>>                            // Note that I have reversed the order of precedence according to prescription:
30099>>>>>>>                            If ((iAssociativity=0 and ;                                  iPrecendence>=strGrammar.aOperators[strToken.iOperatorIndex].iPrecedence) or ;                                  iPrecendence>strGrammar.aOperators[strToken.iOperatorIndex].iPrecedence) Begin
30101>>>>>>>                                Move False to bFin // Oh! We weren't done at all
30102>>>>>>>                            End
30102>>>>>>>>
30102>>>>>>>                        End
30102>>>>>>>>
30102>>>>>>>                    End
30102>>>>>>>>
30102>>>>>>>                    If (not(bFin)) Begin
30104>>>>>>>                        Move (_OperatorStackPop(Self,&aOperatorStack)) to aOutputTokens[SizeOfArray(aOutputTokens)]
30105>>>>>>>                    End
30105>>>>>>>>
30105>>>>>>>                Until (bFin)
30107>>>>>>>                Send _OperatorStackPush (&aOperatorStack) strInputToken
30108>>>>>>>            End
30108>>>>>>>>
30108>>>>>>>            Else If (strInputToken.iType=XPTokenType_LeftParenthesis) Begin
30111>>>>>>>                // If the token is a left parenthesis, then push it onto the stack.
30111>>>>>>>                Send _OperatorStackPush (&aOperatorStack) strInputToken
30112>>>>>>>            End
30112>>>>>>>>
30112>>>>>>>            Else If (strInputToken.iType=XPTokenType_RightParenthesis or ;                     strInputToken.iType=XPTokenType_EndFunctionCall) Begin
30115>>>>>>>                // If the token is a right parenthesis:
30115>>>>>>>                //    * Until the token at the top of the stack is a left parenthesis, pop operators off the stack onto the output queue.
30115>>>>>>>                //    * Pop the left parenthesis from the stack, but not onto the output queue.
30115>>>>>>>                //    * If the token at the top of the stack is a function token, pop it onto the Output queue.
30115>>>>>>>                //    * If the stack runs out without finding a left parenthesis, then there are mismatched parentheses.
30115>>>>>>>                Repeat
30115>>>>>>>>
30115>>>>>>>                    Move True to bFin
30116>>>>>>>                    If (_OperatorStackIsEmpty(Self,aOperatorStack)) Begin
30118>>>>>>>                        Send _RegisterError (&strError) -1 "Mismatched parenthesis"
30119>>>>>>>                    End
30119>>>>>>>>
30119>>>>>>>                    Else Begin
30120>>>>>>>                        Get _OperatorStackPop (&aOperatorStack) to strToken
30121>>>>>>>                        If (strToken.iType<>XPTokenType_LeftParenthesis) Begin
30123>>>>>>>                            Move False to bFin
30124>>>>>>>                            Move strToken to aOutputTokens[SizeOfArray(aOutputTokens)]
30125>>>>>>>                        End
30125>>>>>>>>
30125>>>>>>>                        Else Begin
30126>>>>>>>                            // Do nothing
30126>>>>>>>                        End
30126>>>>>>>>
30126>>>>>>>                    End
30126>>>>>>>>
30126>>>>>>>                Until (bFin)
30128>>>>>>>                If (not(_OperatorStackIsEmpty(Self,aOperatorStack))) Begin
30130>>>>>>>                    Get _OperatorStackCopy aOperatorStack to strToken
30131>>>>>>>                End
30131>>>>>>>>
30131>>>>>>>                If (strToken.iType=XPTokenType_FunctionCall) Begin
30133>>>>>>>                    Get _OperatorStackPop (&aOperatorStack) to aOutputTokens[SizeOfArray(aOutputTokens)]
30134>>>>>>>                End
30134>>>>>>>>
30134>>>>>>>            End
30134>>>>>>>>
30134>>>>>>>            Else Begin
30135>>>>>>>                Send Info_Box "Token not handled! (error)"
30136>>>>>>>            End
30136>>>>>>>>
30136>>>>>>>            Increment iInputTokenIndex
30137>>>>>>>        Loop
30138>>>>>>>>
30138>>>>>>>
30138>>>>>>>//      When there are no more tokens to read:
30138>>>>>>>//        While there are still operator tokens in the stack:
30138>>>>>>>//          If the operator token on the top of the stack is a parenthesis, then there are mismatched parentheses.
30138>>>>>>>//          Pop the operator onto the output queue.
30138>>>>>>>//
30138>>>>>>>        While (not(_OperatorStackIsEmpty(Self,aOperatorStack)))
30142>>>>>>>            Get _OperatorStackPop (&aOperatorStack) to strToken
30143>>>>>>>            If (strToken.iType=XPTokenType_LeftParenthesis or strToken.iType=XPTokenType_RightParenthesis) Begin
30145>>>>>>>                Send _RegisterError (&strError) -1 "Mis-matched parenthesis"
30146>>>>>>>            End
30146>>>>>>>>
30146>>>>>>>            Move strToken to aOutputTokens[SizeOfArray(aOutputTokens)]
30147>>>>>>>        Loop
30148>>>>>>>>
30148>>>>>>>
30148>>>>>>>        Function_Return aOutputTokens
30149>>>>>>>    End_Function
30150>>>>>>>    
30150>>>>>>>    Function OnGetSymbolValue tXPToken strToken Returns tXPValue
30152>>>>>>>        tXPValue strValue
30152>>>>>>>        tXPValue strValue
30152>>>>>>>        Move XP_Error to strValue.iValueType
30153>>>>>>>        Move ("Don't know "+strToken.sValue) to strValue.sValue
30154>>>>>>>        Function_Return strValue
30155>>>>>>>    End_Function
30156>>>>>>>    
30156>>>>>>>    Function _OnGetSymbolValue tXPGrammar strGrammar tXPToken strToken Returns tXPValue
30158>>>>>>>        tXPValue strValue
30158>>>>>>>        tXPValue strValue
30158>>>>>>>        If (strToken.strValueHint.iTable<>0) Begin // Retrieve table.column value
30160>>>>>>>            Get_Field_Value strToken.strValueHint.iTable strToken.strValueHint.iColumn to strValue.sValue
30163>>>>>>>            Move (Rtrim(strValue.sValue)) to strValue.sValue
30164>>>>>>>            Move strToken.strValueHint.iValueType to strValue.iValueType
30165>>>>>>>        End
30165>>>>>>>>
30165>>>>>>>        Else If (strToken.strValueHint.iConstantIndex>=0) Begin // Retrieve constant value
30168>>>>>>>            Move strGrammar.aConstants[strToken.strValueHint.iConstantIndex] to strValue
30169>>>>>>>        End
30169>>>>>>>>
30169>>>>>>>        Else Begin
30170>>>>>>>            Get OnGetSymbolValue strToken to strValue
30171>>>>>>>        End
30171>>>>>>>>
30171>>>>>>>        Function_Return strValue
30172>>>>>>>    End_Function
30173>>>>>>>    
30173>>>>>>>    Function _ExecuteFunctionOrOperand _tXPFunctionPointer strFuncPointer tXPValue[] aParameters tXPError ByRef strError Returns tXPValue
30175>>>>>>>        tXPValue strValue
30175>>>>>>>        tXPValue strValue
30175>>>>>>>        Integer hFunc hObject
30175>>>>>>>        Move strFuncPointer.iMsg to hFunc
30176>>>>>>>        Move strFuncPointer.iObj to hObject
30177>>>>>>>        Get hFunc of hObject aParameters to strValue
30178>>>>>>>        Function_Return strValue
30179>>>>>>>    End_Function
30180>>>>>>>
30180>>>>>>>    //From http://en.wikipedia.org/wiki/Reverse_Polish_notation
30180>>>>>>>    // 
30180>>>>>>>    //   * While there are input tokens left
30180>>>>>>>    //      * Read the next token from input.
30180>>>>>>>    //      * If the token is a value
30180>>>>>>>    //          * Push it onto the stack.
30180>>>>>>>    //      * Otherwise, the token is an operator (operator here includes both operators, and functions).
30180>>>>>>>    //          * It is known a priori that the operator takes n arguments.
30180>>>>>>>    //          * If there are fewer than n values on the stack
30180>>>>>>>    //              * (Error) The user has not input sufficient values in the expression.
30180>>>>>>>    //          * Else, Pop the top n values from the stack.
30180>>>>>>>    //          * Evaluate the operator, with the values as arguments.
30180>>>>>>>    //          * Push the returned results, If any, back onto the stack.
30180>>>>>>>    //   * If there is only one value in the stack
30180>>>>>>>    //      * That value is the result of the calculation.
30180>>>>>>>    //   * If there are more values in the stack
30180>>>>>>>    //      * (Error) The user input has too many values.
30180>>>>>>>    
30180>>>>>>>    Function Evaluate tXPGrammar strGrammar tXPToken[] aInput tXPError ByRef strError Returns tXPValue
30182>>>>>>>        Integer iItem iMaxSymbol
30182>>>>>>>        Integer iOperatorIndex
30182>>>>>>>        Integer iStackSize
30182>>>>>>>        Integer hFunc hObject
30182>>>>>>>        
30182>>>>>>>        tXPValue[] aOperandStack 
30182>>>>>>>        tXPValue[] aOperandStack 
30183>>>>>>>        tXPToken strToken
30183>>>>>>>        tXPToken strToken
30183>>>>>>>        tXPOperator strOperator
30183>>>>>>>        tXPOperator strOperator
30183>>>>>>>        tXPFunction strFunction
30183>>>>>>>        tXPFunction strFunction
30183>>>>>>>        tXPValue strValue
30183>>>>>>>        tXPValue strValue
30183>>>>>>>        
30183>>>>>>>        Move (SizeOfArray(aInput)-1) to iMaxSymbol
30184>>>>>>>        For iItem from 0 to iMaxSymbol
30190>>>>>>>>
30190>>>>>>>            Move aInput[iItem] to strToken
30191>>>>>>>            
30191>>>>>>>            If (strToken.iType=XPTokenType_IntegerConstant) Begin
30193>>>>>>>                // If the token is a value push it on the operand stack:
30193>>>>>>>                Move strToken.sValue to strValue.sValue
30194>>>>>>>                Move XP_Integer to strValue.iValueType
30195>>>>>>>                Move strValue to aOperandStack[SizeOfArray(aOperandStack)]
30196>>>>>>>            End
30196>>>>>>>>
30196>>>>>>>            Else If (strToken.iType=XPTokenType_NumberConstant) Begin 
30199>>>>>>>                Move strToken.sValue to strValue.sValue
30200>>>>>>>                Move XP_Numeric to strValue.iValueType
30201>>>>>>>                Move strValue to aOperandStack[SizeOfArray(aOperandStack)]
30202>>>>>>>            End
30202>>>>>>>>
30202>>>>>>>            Else If (strToken.iType=XPTokenType_StringConstant) Begin 
30205>>>>>>>                Move strToken.sValue to strValue.sValue
30206>>>>>>>                Move XP_String to strValue.iValueType
30207>>>>>>>                Move strValue to aOperandStack[SizeOfArray(aOperandStack)]
30208>>>>>>>            End
30208>>>>>>>>
30208>>>>>>>            Else If (strToken.iType=XPTokenType_Symbol) Begin 
30211>>>>>>>                Get _OnGetSymbolValue strGrammar strToken to strValue
30212>>>>>>>                Move strValue to aOperandStack[SizeOfArray(aOperandStack)]
30213>>>>>>>            End
30213>>>>>>>>
30213>>>>>>>            Else If (strToken.iType=XPTokenType_FunctionCall) Begin
30216>>>>>>>                Move strGrammar.aFunctions[strToken.iOperatorIndex] to strFunction
30217>>>>>>>                Move (SizeOfArray(aOperandStack)) to iStackSize
30218>>>>>>>                If (iStackSize>=strFunction.iArgumentCount) Begin
30220>>>>>>>                    Get _ExecuteFunctionOrOperand strFunction.strDispatch (CopyArray(aOperandStack,iStackSize-strFunction.iArgumentCount,iStackSize-1)) (&strError) to strValue
30221>>>>>>>                    If (strFunction.iArgumentCount>0) Begin
30223>>>>>>>                        // Pop params off the stack
30223>>>>>>>                        Move (ResizeArray(aOperandStack,iStackSize-strFunction.iArgumentCount)) to aOperandStack
30224>>>>>>>                    End
30224>>>>>>>>
30224>>>>>>>                    Move strValue to aOperandStack[SizeOfArray(aOperandStack)] // Push result back on
30225>>>>>>>                End
30225>>>>>>>>
30225>>>>>>>                Else Begin
30226>>>>>>>                    Send _RegisterError (&strError) strToken.iStartPos "ExprParser: Eval error, not enough parameters on stack (function call)"
30227>>>>>>>                End
30227>>>>>>>>
30227>>>>>>>            End
30227>>>>>>>>
30227>>>>>>>            Else If (strToken.iType=XPTokenType_Operator) Begin 
30230>>>>>>>                Move strGrammar.aOperators[strToken.iOperatorIndex] to strOperator
30231>>>>>>>                Move (SizeOfArray(aOperandStack)) to iStackSize
30232>>>>>>>                If (iStackSize>=strOperator.iArgumentCount) Begin
30234>>>>>>>                    Get _ExecuteFunctionOrOperand strOperator.strDispatch (CopyArray(aOperandStack,iStackSize-strOperator.iArgumentCount,iStackSize-1)) (&strError) to strValue
30235>>>>>>>                    If (strOperator.iArgumentCount>0) Begin
30237>>>>>>>                        // Pop params off the stack
30237>>>>>>>                        Move (ResizeArray(aOperandStack,iStackSize-strOperator.iArgumentCount)) to aOperandStack
30238>>>>>>>                    End
30238>>>>>>>>
30238>>>>>>>                    Move strValue to aOperandStack[SizeOfArray(aOperandStack)] // Push result back on
30239>>>>>>>                End
30239>>>>>>>>
30239>>>>>>>                Else Begin
30240>>>>>>>                    Send _RegisterError (&strError) strToken.iStartPos "ExprParser: Eval error, not enough parameters on stack (operator)"
30241>>>>>>>                End
30241>>>>>>>>
30241>>>>>>>            End
30241>>>>>>>>
30241>>>>>>>            Else Begin
30242>>>>>>>                Send _RegisterError (&strError) strToken.iStartPos "ExprParser: Token type not recognised by Evaluate function"
30243>>>>>>>            End
30243>>>>>>>>
30243>>>>>>>            
30243>>>>>>>        Loop
30244>>>>>>>>
30244>>>>>>>        
30244>>>>>>>        If (SizeOfArray(aOperandStack)=1) Begin
30246>>>>>>>            Function_Return aOperandStack[0]
30247>>>>>>>        End
30247>>>>>>>>
30247>>>>>>>        Else If (SizeOfArray(aOperandStack)=0) Begin
30250>>>>>>>            Send _RegisterError (&strError) -1 "ExprParser: Missing return value"
30251>>>>>>>        End
30251>>>>>>>>
30251>>>>>>>        Else Begin
30252>>>>>>>            Send _RegisterError (&strError) -1 "ExprParser: Too many operands on stack"
30253>>>>>>>        End
30253>>>>>>>>
30253>>>>>>>        Move XP_Error to strValue.iValueType
30254>>>>>>>        
30254>>>>>>>        Function_Return strValue
30255>>>>>>>    End_Function
30256>>>>>>>End_Class
30257>>>>>>>
30257>>>>>>>Class cExpressionParser is a cExpressionParserBasic
30258>>>>>>>
30258>>>>>>>            Function _RoundNumber Number nValue Integer iDecimals Returns Number
30260>>>>>>>                String sValue
30260>>>>>>>                Get NumberToString of oStringFunctions nValue iDecimals to sValue
30261>>>>>>>                Function_Return (Number(sValue))
30262>>>>>>>            End_Function
30263>>>>>>>
30263>>>>>>>// Number functions
30263>>>>>>>
30263>>>>>>>        Function _fRound tXPValue[] aParameters Returns tXPValue
30265>>>>>>>            Integer iDecimal
30265>>>>>>>            Number nValue
30265>>>>>>>            tXPValue strRval strParam
30265>>>>>>>            tXPValue strRval strParam
30265>>>>>>>            Move aParameters[0] to strParam
30266>>>>>>>            If (strParam.iValueType=XP_Integer or strParam.iValueType=XP_Numeric) Begin
30268>>>>>>>                Move strParam.sValue to nValue
30269>>>>>>>                Move aParameters[1] to strParam
30270>>>>>>>                If (strParam.iValueType=XP_Integer) Begin
30272>>>>>>>                    Get _RoundNumber nValue iDecimal to strRval.sValue
30273>>>>>>>                    Move XP_Numeric to strRval.iValueType
30274>>>>>>>                End
30274>>>>>>>>
30274>>>>>>>                Else Begin
30275>>>>>>>                    Move XP_Error to strRval.iValueType
30276>>>>>>>                    Error DFERR_OPERATOR "ExprParser: Illegal parameter passed to 'Round'"
30277>>>>>>>>
30277>>>>>>>                End
30277>>>>>>>>
30277>>>>>>>            End
30277>>>>>>>>
30277>>>>>>>            Else Begin
30278>>>>>>>                Move XP_Error to strRval.iValueType
30279>>>>>>>                Error DFERR_OPERATOR "ExprParser: Illegal parameter passed to 'Round'"
30280>>>>>>>>
30280>>>>>>>            End
30280>>>>>>>>
30280>>>>>>>            Function_Return strRval
30281>>>>>>>        End_Function
30282>>>>>>>
30282>>>>>>>// Date functions
30282>>>>>>>
30282>>>>>>>        Function _fToday tXPValue[] aParameters Returns tXPValue // No params
30284>>>>>>>            tXPValue strValue
30284>>>>>>>            tXPValue strValue
30284>>>>>>>            Move (Integer(SystemDate(oDateFunctions))) to strValue.sValue
30285>>>>>>>            Move XP_Date to strValue.iValueType
30286>>>>>>>            Function_Return strValue
30287>>>>>>>        End_Function
30288>>>>>>>
30288>>>>>>>        Function _fDateSegment tXPValue[] aParameters Integer iDateSegment Returns tXPValue
30290>>>>>>>            Date dValue
30290>>>>>>>            tXPValue strParam strRval
30290>>>>>>>            tXPValue strParam strRval
30290>>>>>>>            Move aParameters[0] to strParam
30291>>>>>>>            If (strParam.iValueType=XP_Date) Begin
30293>>>>>>>                Move strParam.sValue to dValue
30294>>>>>>>                Get DateSegment of oDateFunctions dValue iDateSegment to strRval.sValue
30295>>>>>>>                Move XP_Integer to strRval.iValueType
30296>>>>>>>            End
30296>>>>>>>>
30296>>>>>>>            Else Begin
30297>>>>>>>                Move XP_Error to strRval.iValueType
30298>>>>>>>                Error DFERR_OPERATOR "ExprParser: Illegal parameter passed to 'DateSegment'"
30299>>>>>>>>
30299>>>>>>>            End
30299>>>>>>>>
30299>>>>>>>            Function_Return strRval
30300>>>>>>>        End_Function
30301>>>>>>>
30301>>>>>>>        Function _fMonth tXPValue[] aParameters Returns tXPValue
30303>>>>>>>            Function_Return (_fDateSegment(Self,aParameters,DS_MONTH))
30304>>>>>>>        End_Function
30305>>>>>>>        Function _fWeek tXPValue[] aParameters Returns tXPValue
30307>>>>>>>            Function_Return (_fDateSegment(Self,aParameters,DS_WEEK))
30308>>>>>>>        End_Function
30309>>>>>>>        Function _fYear tXPValue[] aParameters Returns tXPValue
30311>>>>>>>            Function_Return (_fDateSegment(Self,aParameters,DS_YEAR))
30312>>>>>>>        End_Function
30313>>>>>>>        Function _fDay tXPValue[] aParameters Returns tXPValue
30315>>>>>>>            Function_Return (_fDateSegment(Self,aParameters,DS_DAY))
30316>>>>>>>        End_Function
30317>>>>>>>        Function _fDayName tXPValue[] aParameters Returns tXPValue
30319>>>>>>>            Integer iIndex
30319>>>>>>>            tXPValue strParam strRval
30319>>>>>>>            tXPValue strParam strRval
30319>>>>>>>            Move aParameters[0] to strParam
30320>>>>>>>            If (strParam.iValueType=XP_Integer) Begin
30322>>>>>>>                Move strParam.sValue to iIndex
30323>>>>>>>                Get DayName of oDateFunctions iIndex to strRval.sValue
30324>>>>>>>                Move XP_String to strRval.iValueType
30325>>>>>>>            End
30325>>>>>>>>
30325>>>>>>>            Else Begin
30326>>>>>>>                Move XP_Error to strRval.iValueType
30327>>>>>>>                Error DFERR_OPERATOR "ExprParser: Illegal parameter passed to 'DayName'"
30328>>>>>>>>
30328>>>>>>>            End
30328>>>>>>>>
30328>>>>>>>            Function_Return strRval
30329>>>>>>>        End_Function
30330>>>>>>>        Function _fMonthName tXPValue[] aParameters Returns tXPValue
30332>>>>>>>            Integer iIndex
30332>>>>>>>            tXPValue strParam strRval
30332>>>>>>>            tXPValue strParam strRval
30332>>>>>>>            Move aParameters[0] to strParam
30333>>>>>>>            If (strParam.iValueType=XP_Integer) Begin
30335>>>>>>>                Move strParam.sValue to iIndex
30336>>>>>>>                Get MonthName of oDateFunctions iIndex to strRval.sValue
30337>>>>>>>                Move XP_String to strRval.iValueType
30338>>>>>>>            End
30338>>>>>>>>
30338>>>>>>>            Else Begin
30339>>>>>>>                Move XP_Error to strRval.iValueType
30340>>>>>>>                Error DFERR_OPERATOR "ExprParser: Illegal parameter passed to 'MonthName'"
30341>>>>>>>>
30341>>>>>>>            End
30341>>>>>>>>
30341>>>>>>>            Function_Return strRval
30342>>>>>>>        End_Function
30343>>>>>>>
30343>>>>>>>// Operators
30343>>>>>>>        Function _fExponential tXPValue[] aParameters Returns tXPValue
30345>>>>>>>            tXPValue strValue
30345>>>>>>>            tXPValue strValue
30345>>>>>>>            Number nBase nPower
30345>>>>>>>            Get StringToNumber of oStringFunctions aParameters[0].sValue to nBase
30346>>>>>>>            Get StringToNumber of oStringFunctions aParameters[1].sValue to nPower
30347>>>>>>>            Move (nBase^nPower) to strValue.sValue
30348>>>>>>>            Move XP_Numeric to strValue.iValueType
30349>>>>>>>            Function_Return strValue
30350>>>>>>>        End_Function
30351>>>>>>>        
30351>>>>>>>        Function _fUnaryMinus tXPValue[] aParameters Returns tXPValue
30353>>>>>>>            tXPValue strValue
30353>>>>>>>            tXPValue strValue
30353>>>>>>>            Number nValue
30353>>>>>>>            Get StringToNumber of oStringFunctions aParameters[0].sValue to nValue
30354>>>>>>>            Move (-nValue) to strValue.sValue
30355>>>>>>>            Move XP_Numeric to strValue.iValueType
30356>>>>>>>            Function_Return strValue
30357>>>>>>>        End_Function
30358>>>>>>>        
30358>>>>>>>        Function _fUnaryPlus tXPValue[] aParameters Returns tXPValue
30360>>>>>>>            Function_Return aParameters[0]
30361>>>>>>>        End_Function
30362>>>>>>>        
30362>>>>>>>        Function _fMultiply tXPValue[] aParameters Returns tXPValue
30364>>>>>>>            tXPValue strVal1 strVal2
30364>>>>>>>            tXPValue strVal1 strVal2
30364>>>>>>>            tXPValue strRval
30364>>>>>>>            tXPValue strRval
30364>>>>>>>            Move aParameters[0] to strVal1
30365>>>>>>>            Move aParameters[1] to strVal2
30366>>>>>>>            If (strVal1.iValueType=XP_Integer or strVal1.iValueType=XP_Numeric or strVal1.iValueType=XP_Boolean) Begin
30368>>>>>>>                Move (StringToNumber(oStringFunctions,strVal1.sValue)*StringToNumber(oStringFunctions,strVal2.sValue)) to strRval.sValue
30369>>>>>>>                Move (If(strVal1.iValueType=XP_Integer and strVal2.iValueType=XP_Integer,XP_Integer,XP_Numeric)) to strRval.iValueType
30370>>>>>>>                If (strRval.iValueType=XP_Integer) Begin
30372>>>>>>>                    Move (Integer(strRval.sValue)) to strRval.sValue
30373>>>>>>>                End
30373>>>>>>>>
30373>>>>>>>            End
30373>>>>>>>>
30373>>>>>>>            Else If (strVal1.iValueType=XP_String) Begin
30376>>>>>>>                Move (strVal1.sValue*strVal2.sValue) to strRval.sValue
30377>>>>>>>                Move XP_String to strRval.iValueType
30378>>>>>>>            End
30378>>>>>>>>
30378>>>>>>>            Else Begin
30379>>>>>>>                Move XP_Error to strRval.iValueType
30380>>>>>>>                Error DFERR_OPERATOR "ExprParser: Illegal parameter passed to '*' (multiply)"
30381>>>>>>>>
30381>>>>>>>            End
30381>>>>>>>>
30381>>>>>>>            Function_Return strRval
30382>>>>>>>        End_Function
30383>>>>>>>        
30383>>>>>>>        Function _fDivide tXPValue[] aParameters Returns tXPValue
30385>>>>>>>            tXPValue strVal1 strVal2
30385>>>>>>>            tXPValue strVal1 strVal2
30385>>>>>>>            tXPValue strRval
30385>>>>>>>            tXPValue strRval
30385>>>>>>>            Move aParameters[0] to strVal1
30386>>>>>>>            Move aParameters[1] to strVal2
30387>>>>>>>            If (strVal1.iValueType=XP_Integer or strVal1.iValueType=XP_Numeric or strVal1.iValueType=XP_Boolean) Begin
30389>>>>>>>                Move (Number(strVal1.sValue)/Number(strVal2.sValue)) to strRval.sValue
30390>>>>>>>                Move (If(strVal1.iValueType=XP_Integer and strVal2.iValueType=XP_Integer,XP_Integer,XP_Numeric)) to strRval.iValueType
30391>>>>>>>                If (strRval.iValueType=XP_Integer) Begin
30393>>>>>>>                    Move (Integer(strRval.sValue)) to strRval.sValue
30394>>>>>>>                End
30394>>>>>>>>
30394>>>>>>>            End
30394>>>>>>>>
30394>>>>>>>            Else If (strVal1.iValueType=XP_String) Begin
30397>>>>>>>                Move (strVal1.sValue-strVal2.sValue) to strRval.sValue
30398>>>>>>>                Move XP_String to strRval.iValueType
30399>>>>>>>            End
30399>>>>>>>>
30399>>>>>>>            Else Begin
30400>>>>>>>                Move XP_Error to strRval.iValueType
30401>>>>>>>                Error DFERR_OPERATOR "ExprParser: Illegal parameter passed to '/' (divide)"
30402>>>>>>>>
30402>>>>>>>            End
30402>>>>>>>>
30402>>>>>>>            Function_Return strRval
30403>>>>>>>        End_Function
30404>>>>>>>        
30404>>>>>>>        Function _fRemainder tXPValue[] aParameters Returns tXPValue
30406>>>>>>>            tXPValue strVal1 strVal2
30406>>>>>>>            tXPValue strVal1 strVal2
30406>>>>>>>            tXPValue strRval
30406>>>>>>>            tXPValue strRval
30406>>>>>>>            Move aParameters[0] to strVal1
30407>>>>>>>            Move aParameters[1] to strVal2
30408>>>>>>>            If (strVal1.iValueType=XP_Integer or strVal1.iValueType=XP_Numeric) Begin
30410>>>>>>>                Move (Mod(Integer(strVal1.sValue),Integer(strVal2.sValue))) to strRval.sValue
30411>>>>>>>                Move XP_Integer to strRval.iValueType
30412>>>>>>>            End
30412>>>>>>>>
30412>>>>>>>            Else Begin
30413>>>>>>>                Move XP_Error to strRval.iValueType
30414>>>>>>>                Error DFERR_OPERATOR "ExprParser: Illegal parameter passed to '%' (remainder)"
30415>>>>>>>>
30415>>>>>>>            End
30415>>>>>>>>
30415>>>>>>>            Function_Return strRval
30416>>>>>>>        End_Function
30417>>>>>>>        
30417>>>>>>>        Function _fPlus tXPValue[] aParameters Returns tXPValue
30419>>>>>>>            tXPValue strVal1 strVal2
30419>>>>>>>            tXPValue strVal1 strVal2
30419>>>>>>>            tXPValue strRval
30419>>>>>>>            tXPValue strRval
30419>>>>>>>            Move aParameters[0] to strVal1
30420>>>>>>>            Move aParameters[1] to strVal2
30421>>>>>>>            If (strVal1.iValueType=XP_Integer or strVal1.iValueType=XP_Numeric) Begin
30423>>>>>>>                Move (Number(strVal1.sValue)+Number(strVal2.sValue)) to strRval.sValue
30424>>>>>>>                Move (If(strVal1.iValueType=XP_Integer and strVal2.iValueType=XP_Integer,XP_Integer,XP_Numeric)) to strRval.iValueType
30425>>>>>>>                If (strRval.iValueType=XP_Integer) Begin
30427>>>>>>>                    Move (Integer(strRval.sValue)) to strRval.sValue
30428>>>>>>>                End
30428>>>>>>>>
30428>>>>>>>            End
30428>>>>>>>>
30428>>>>>>>            Else If (strVal1.iValueType=XP_Date) Begin
30431>>>>>>>                Move (Date(Integer(strVal1.sValue)+Integer(strVal2.sValue))) to strRval.sValue
30432>>>>>>>                Move XP_Date to strRval.iValueType
30433>>>>>>>            End
30433>>>>>>>>
30433>>>>>>>            Else If (strVal1.iValueType=XP_String) Begin
30436>>>>>>>                Move (strVal1.sValue+strVal2.sValue) to strRval.sValue
30437>>>>>>>                Move XP_String to strRval.iValueType
30438>>>>>>>            End
30438>>>>>>>>
30438>>>>>>>            Else Begin
30439>>>>>>>                Move XP_Error to strRval.iValueType
30440>>>>>>>                Error DFERR_OPERATOR "ExprParser: Illegal parameter passed to '+' (plus)"
30441>>>>>>>>
30441>>>>>>>            End
30441>>>>>>>>
30441>>>>>>>            Function_Return strRval
30442>>>>>>>        End_Function
30443>>>>>>>
30443>>>>>>>        Function _fMinus tXPValue[] aParameters Returns tXPValue
30445>>>>>>>            tXPValue strVal1 strVal2
30445>>>>>>>            tXPValue strVal1 strVal2
30445>>>>>>>            tXPValue strRval
30445>>>>>>>            tXPValue strRval
30445>>>>>>>            Move aParameters[0] to strVal1
30446>>>>>>>            Move aParameters[1] to strVal2
30447>>>>>>>            If (strVal1.iValueType=XP_Integer or strVal1.iValueType=XP_Numeric) Begin
30449>>>>>>>                Move (Number(strVal1.sValue)-Number(strVal2.sValue)) to strRval.sValue
30450>>>>>>>                Move (If(strVal1.iValueType=XP_Integer and strVal2.iValueType=XP_Integer,XP_Integer,XP_Numeric)) to strRval.iValueType
30451>>>>>>>                If (strRval.iValueType=XP_Integer) Begin
30453>>>>>>>                    Move (Integer(strRval.sValue)) to strRval.sValue
30454>>>>>>>                End
30454>>>>>>>>
30454>>>>>>>            End
30454>>>>>>>>
30454>>>>>>>            Else If (strVal1.iValueType=XP_Date) Begin
30457>>>>>>>                Move (Date(Integer(strVal1.sValue)+Integer(strVal2.sValue))) to strRval.sValue
30458>>>>>>>                Move XP_Date to strRval.iValueType
30459>>>>>>>            End
30459>>>>>>>>
30459>>>>>>>            Else If (strVal1.iValueType=XP_String) Begin
30462>>>>>>>                Move (strVal1.sValue-strVal2.sValue) to strRval.sValue
30463>>>>>>>                Move XP_String to strRval.iValueType
30464>>>>>>>            End
30464>>>>>>>>
30464>>>>>>>            Else Begin
30465>>>>>>>                Move XP_Error to strRval.iValueType
30466>>>>>>>                Error DFERR_OPERATOR "ExprParser: Illegal parameter passed to '-' (minus)"
30467>>>>>>>>
30467>>>>>>>            End
30467>>>>>>>>
30467>>>>>>>            Function_Return strRval
30468>>>>>>>        End_Function
30469>>>>>>>
30469>>>>>>>
30469>>>>>>>        Function _fMin tXPValue[] aParameters Returns tXPValue
30471>>>>>>>        End_Function
30472>>>>>>>        
30472>>>>>>>        Function _fMax tXPValue[] aParameters Returns tXPValue
30474>>>>>>>        End_Function
30475>>>>>>>        
30475>>>>>>>        Register_Function _DyadicBooleanOperation tXPValue[] aParameters Integer hFunc Returns tXPValue
30475>>>>>>>
30475>>>>>>>        Function _fGT tXPValue[] aParameters Returns tXPValue
30477>>>>>>>            Function_Return (_DyadicBooleanOperation(Self,aParameters,GT))
30478>>>>>>>        End_Function
30479>>>>>>>        Function _fLT tXPValue[] aParameters Returns tXPValue
30481>>>>>>>            Function_Return (_DyadicBooleanOperation(Self,aParameters,LT))
30482>>>>>>>        End_Function
30483>>>>>>>        Function _fGE tXPValue[] aParameters Returns tXPValue
30485>>>>>>>            Function_Return (_DyadicBooleanOperation(Self,aParameters,GE))
30486>>>>>>>        End_Function
30487>>>>>>>        Function _fLE tXPValue[] aParameters Returns tXPValue
30489>>>>>>>            Function_Return (_DyadicBooleanOperation(Self,aParameters,LE))
30490>>>>>>>        End_Function
30491>>>>>>>        Function _fNE tXPValue[] aParameters Returns tXPValue
30493>>>>>>>            Function_Return (_DyadicBooleanOperation(Self,aParameters,NE))
30494>>>>>>>        End_Function
30495>>>>>>>        Function _fEQ tXPValue[] aParameters Returns tXPValue
30497>>>>>>>            Function_Return (_DyadicBooleanOperation(Self,aParameters,EQ))
30498>>>>>>>        End_Function
30499>>>>>>>        
30499>>>>>>>// String functions
30499>>>>>>>
30499>>>>>>>        Function _fMid tXPValue[] aPar Returns tXPValue // 3 param
30501>>>>>>>            tXPValue strValue
30501>>>>>>>            tXPValue strValue
30501>>>>>>>            Move (Mid(aPar[0].sValue, aPar[1].sValue, aPar[2].sValue)) to strValue.sValue
30502>>>>>>>            Move XP_String to strValue.iValueType
30503>>>>>>>            Function_Return strValue
30504>>>>>>>        End_Function
30505>>>>>>>    
30505>>>>>>>        Function _fLeft tXPValue[] aPar Returns tXPValue // 2 param
30507>>>>>>>            tXPValue strValue
30507>>>>>>>            tXPValue strValue
30507>>>>>>>            Move (Left(aPar[0].sValue, aPar[1].sValue)) to strValue.sValue
30508>>>>>>>            Move XP_String to strValue.iValueType
30509>>>>>>>            Function_Return strValue
30510>>>>>>>        End_Function
30511>>>>>>>    
30511>>>>>>>        Function _fRight tXPValue[] aPar Returns tXPValue // 2 param
30513>>>>>>>            tXPValue strValue
30513>>>>>>>            tXPValue strValue
30513>>>>>>>            Move (Right(aPar[0].sValue, aPar[1].sValue)) to strValue.sValue
30514>>>>>>>            Move XP_String to strValue.iValueType
30515>>>>>>>            Function_Return strValue
30516>>>>>>>        End_Function
30517>>>>>>>    
30517>>>>>>>        Function _fUppercase tXPValue[] aPar Returns tXPValue // 1 param
30519>>>>>>>            tXPValue strValue
30519>>>>>>>            tXPValue strValue
30519>>>>>>>            Move (Uppercase(aPar[0].sValue)) to strValue.sValue
30520>>>>>>>            Move XP_String to strValue.iValueType
30521>>>>>>>            Function_Return strValue
30522>>>>>>>        End_Function
30523>>>>>>>    
30523>>>>>>>        Function _fLowercase tXPValue[] aPar Returns tXPValue // 1 param
30525>>>>>>>            tXPValue strValue
30525>>>>>>>            tXPValue strValue
30525>>>>>>>            Move (Lowercase(aPar[0].sValue)) to strValue.sValue
30526>>>>>>>            Move XP_String to strValue.iValueType
30527>>>>>>>            Function_Return strValue
30528>>>>>>>        End_Function
30529>>>>>>>    
30529>>>>>>>        Function _fLength tXPValue[] aPar Returns tXPValue // 1 param
30531>>>>>>>            tXPValue strValue
30531>>>>>>>            tXPValue strValue
30531>>>>>>>            Move (Length(aPar[0].sValue)) to strValue.sValue
30532>>>>>>>            Move XP_Integer to strValue.iValueType
30533>>>>>>>            Function_Return strValue
30534>>>>>>>        End_Function
30535>>>>>>>    
30535>>>>>>>        Function _fTrim tXPValue[] aPar Returns tXPValue // 1 param
30537>>>>>>>            tXPValue strValue
30537>>>>>>>            tXPValue strValue
30537>>>>>>>            Move (Trim(aPar[0].sValue)) to strValue.sValue
30538>>>>>>>            Move XP_String to strValue.iValueType
30539>>>>>>>            Function_Return strValue
30540>>>>>>>        End_Function
30541>>>>>>>    
30541>>>>>>>        Function _fPos tXPValue[] aPar Returns tXPValue // 2 param
30543>>>>>>>            tXPValue strValue
30543>>>>>>>            tXPValue strValue
30543>>>>>>>            Move (pos(aPar[0].sValue, aPar[1].sValue)) to strValue.sValue
30544>>>>>>>            Move XP_Integer to strValue.iValueType
30545>>>>>>>            Function_Return strValue
30546>>>>>>>        End_Function
30547>>>>>>>
30547>>>>>>>        
30547>>>>>>>            Function _WinningType Integer iTypeLeft Integer iTypeRight Returns Integer
30549>>>>>>>                If (iTypeLeft=XP_String or iTypeRight=XP_String) Function_Return XP_String
30552>>>>>>>                If (iTypeLeft=XP_Numeric or iTypeRight=XP_Numeric) Function_Return XP_Numeric
30555>>>>>>>                If (iTypeLeft=XP_Integer or iTypeRight=XP_Integer) Function_Return XP_Integer
30558>>>>>>>                Function_Return iTypeLeft // ???
30559>>>>>>>            End_Function
30560>>>>>>>        
30560>>>>>>>            Function _DyadicBooleanOperation tXPValue[] aParams Integer iComp Returns tXPValue
30562>>>>>>>                tXPValue strRval strParam1 strParam2
30562>>>>>>>                tXPValue strRval strParam1 strParam2
30562>>>>>>>                Integer iType
30562>>>>>>>                String sLeft sRight
30562>>>>>>>                Number nLeft nRight
30562>>>>>>>                
30562>>>>>>>                Move aParams[0] to strParam1
30563>>>>>>>                Move aParams[1] to strParam2
30564>>>>>>>                If (strParam1.iValueType<>strParam2.iValueType) Begin // Cast them alike:
30566>>>>>>>                    Get _WinningType strParam1.iValueType strParam2.iValueType to iType
30567>>>>>>>                    Get _CastValueAs strParam1 iType to strParam1
30568>>>>>>>                    Get _CastValueAs strParam2 iType to strParam2
30569>>>>>>>                End
30569>>>>>>>>
30569>>>>>>>
30569>>>>>>>                If (strParam1.iValueType=XP_String) Begin
30571>>>>>>>                    Move strParam1.sValue to sLeft
30572>>>>>>>                    Move strParam2.sValue to sRight
30573>>>>>>>                    If (iComp=EQ) Begin
30575>>>>>>>                        Move (sLeft=sRight) to strRval.sValue
30576>>>>>>>                    End
30576>>>>>>>>
30576>>>>>>>                    Else If (iComp=NE) Begin
30579>>>>>>>                        Move (sLeft<>sRight) to strRval.sValue
30580>>>>>>>                    End
30580>>>>>>>>
30580>>>>>>>                    Else If (iComp=GT) Begin
30583>>>>>>>                        Move (sLeft>sRight) to strRval.sValue
30584>>>>>>>                    End
30584>>>>>>>>
30584>>>>>>>                    Else If (iComp=LT) Begin
30587>>>>>>>                        Move (sLeft<sRight) to strRval.sValue
30588>>>>>>>                    End
30588>>>>>>>>
30588>>>>>>>                    Else If (iComp=GE) Begin
30591>>>>>>>                        Move (sLeft>=sRight) to strRval.sValue
30592>>>>>>>                    End
30592>>>>>>>>
30592>>>>>>>                    Else If (iComp=LE) Begin
30595>>>>>>>                        Move (sLeft<=sRight) to strRval.sValue
30596>>>>>>>                    End
30596>>>>>>>>
30596>>>>>>>                End
30596>>>>>>>>
30596>>>>>>>                Else Begin
30597>>>>>>>                    Get StringToNumber of oStringFunctions strParam1.sValue to nLeft
30598>>>>>>>                    Get StringToNumber of oStringFunctions strParam2.sValue to nRight
30599>>>>>>>                    If (iComp=EQ) Begin
30601>>>>>>>                        Move (nLeft=nRight) to strRval.sValue
30602>>>>>>>                    End
30602>>>>>>>>
30602>>>>>>>                    Else If (iComp=NE) Begin
30605>>>>>>>                        Move (nLeft<>nRight) to strRval.sValue
30606>>>>>>>                    End
30606>>>>>>>>
30606>>>>>>>                    Else If (iComp=GT) Begin
30609>>>>>>>                        Move (nLeft>nRight) to strRval.sValue
30610>>>>>>>                    End
30610>>>>>>>>
30610>>>>>>>                    Else If (iComp=LT) Begin
30613>>>>>>>                        Move (nLeft<nRight) to strRval.sValue
30614>>>>>>>                    End
30614>>>>>>>>
30614>>>>>>>                    Else If (iComp=GE) Begin
30617>>>>>>>                        Move (nLeft>=nRight) to strRval.sValue
30618>>>>>>>                    End
30618>>>>>>>>
30618>>>>>>>                    Else If (iComp=LE) Begin
30621>>>>>>>                        Move (nLeft<=nRight) to strRval.sValue
30622>>>>>>>                    End
30622>>>>>>>>
30622>>>>>>>                End
30622>>>>>>>>
30622>>>>>>>                
30622>>>>>>>                Move XP_Boolean to strRval.iValueType
30623>>>>>>>                Function_Return strRval
30624>>>>>>>            End_Function
30625>>>>>>>
30625>>>>>>>    Function _fAnd tXPValue[] aParameters Returns tXPValue
30627>>>>>>>        tXPValue strRval strParameter1 strParameter2
30627>>>>>>>        tXPValue strRval strParameter1 strParameter2
30627>>>>>>>        Number nVal1 nVal2
30627>>>>>>>        Move aParameters[0] to strParameter1
30628>>>>>>>        Move aParameters[1] to strParameter2
30629>>>>>>>        If ((strParameter1.iValueType=XP_Integer or strParameter1.iValueType=XP_Numeric) and (strParameter2.iValueType=XP_Integer or strParameter2.iValueType=XP_Numeric)) Begin
30631>>>>>>>            Move XP_Boolean to strRval.iValueType
30632>>>>>>>            Move strParameter1.sValue to nVal1
30633>>>>>>>            Move strParameter2.sValue to nVal2
30634>>>>>>>            Move (nVal1<>0 and nVal2<>0) to strRval.sValue
30635>>>>>>>        End
30635>>>>>>>>
30635>>>>>>>        Else Begin
30636>>>>>>>            Move XP_Error to strRval.iValueType
30637>>>>>>>            Error DFERR_OPERATOR "ExprParser: Illegal parameter passed to 'and'"
30638>>>>>>>>
30638>>>>>>>        End
30638>>>>>>>>
30638>>>>>>>        Function_Return strRval
30639>>>>>>>    End_Function
30640>>>>>>>    
30640>>>>>>>    Function _fOr tXPValue[] aParameters Returns tXPValue
30642>>>>>>>        tXPValue strRval strParameter1 strParameter2
30642>>>>>>>        tXPValue strRval strParameter1 strParameter2
30642>>>>>>>        Number nVal1 nVal2
30642>>>>>>>        Move aParameters[0] to strParameter1
30643>>>>>>>        Move aParameters[1] to strParameter2
30644>>>>>>>        If ((strParameter1.iValueType=XP_Integer or strParameter1.iValueType=XP_Numeric) and (strParameter2.iValueType=XP_Integer or strParameter2.iValueType=XP_Numeric)) Begin
30646>>>>>>>            Move XP_Boolean to strRval.iValueType
30647>>>>>>>            Move strParameter1.sValue to nVal1
30648>>>>>>>            Move strParameter2.sValue to nVal2
30649>>>>>>>            Move (nVal1<>0 or nVal2<>0) to strRval.sValue
30650>>>>>>>        End
30650>>>>>>>>
30650>>>>>>>        Else Begin
30651>>>>>>>            Move XP_Error to strRval.iValueType
30652>>>>>>>            Error DFERR_OPERATOR "ExprParser: Illegal parameter passed to 'or'"
30653>>>>>>>>
30653>>>>>>>        End
30653>>>>>>>>
30653>>>>>>>        Function_Return strRval
30654>>>>>>>    End_Function
30655>>>>>>>    
30655>>>>>>>        Function _fNot tXPValue[] aParameters Returns tXPValue // 1 param
30657>>>>>>>            Number nValue
30657>>>>>>>            tXPValue strParam strRval
30657>>>>>>>            tXPValue strParam strRval
30657>>>>>>>            Move aParameters[0] to strParam
30658>>>>>>>            If (strParam.iValueType=XP_Integer or strParam.iValueType=XP_Numeric or strParam.iValueType=XP_Boolean) Begin
30660>>>>>>>                Move strParam.sValue to nValue
30661>>>>>>>                Move (nValue=0) to strRval.sValue
30662>>>>>>>                Move XP_Boolean to strRval.iValueType
30663>>>>>>>            End
30663>>>>>>>>
30663>>>>>>>            Else Begin
30664>>>>>>>                Move XP_Error to strRval.iValueType
30665>>>>>>>                Error DFERR_OPERATOR "ExprParser: Illegal parameter passed to 'not'"
30666>>>>>>>>
30666>>>>>>>            End
30666>>>>>>>>
30666>>>>>>>            Function_Return strRval
30667>>>>>>>        End_Function
30668>>>>>>>
30668>>>>>>>    Function _fSin tXPValue[] aParameters Returns tXPValue
30670>>>>>>>        tXPValue strRval strParameter
30670>>>>>>>        tXPValue strRval strParameter
30670>>>>>>>        Move aParameters[0] to strParameter
30671>>>>>>>        If (strParameter.iValueType=XP_Integer or strParameter.iValueType=XP_Numeric) Begin
30673>>>>>>>            Move XP_Numeric to strRval.iValueType
30674>>>>>>>            Move (Sin(strParameter.sValue)) to strRval.sValue
30675>>>>>>>        End
30675>>>>>>>>
30675>>>>>>>        Else Begin
30676>>>>>>>            Move XP_Error to strRval.iValueType
30677>>>>>>>            Error DFERR_OPERATOR "ExprParser: Illegal parameter passed to 'sin'"
30678>>>>>>>>
30678>>>>>>>        End
30678>>>>>>>>
30678>>>>>>>        Function_Return strRval
30679>>>>>>>    End_Function
30680>>>>>>>
30680>>>>>>>    Function _fCos tXPValue[] aParameters Returns tXPValue
30682>>>>>>>        tXPValue strRval strParameter
30682>>>>>>>        tXPValue strRval strParameter
30682>>>>>>>        Move aParameters[0] to strParameter
30683>>>>>>>        If (strParameter.iValueType=XP_Integer or strParameter.iValueType=XP_Numeric) Begin
30685>>>>>>>            Move XP_Numeric to strRval.iValueType
30686>>>>>>>            Move (Cos(strParameter.sValue)) to strRval.sValue
30687>>>>>>>        End
30687>>>>>>>>
30687>>>>>>>        Else Begin
30688>>>>>>>            Move XP_Error to strRval.iValueType
30689>>>>>>>            Error DFERR_OPERATOR "ExprParser: Illegal parameter passed to 'cos'"
30690>>>>>>>>
30690>>>>>>>        End
30690>>>>>>>>
30690>>>>>>>        Function_Return strRval
30691>>>>>>>    End_Function
30692>>>>>>>
30692>>>>>>>    Procedure OnDefineOperators tXPGrammar ByRef strGrammar
30694>>>>>>>        // By insiration from: http://en.cppreference.com/w/cpp/language/operator_precedence
30694>>>>>>>        
30694>>>>>>>// ToDo: Someone ought to take a look at this. It can not be right. The precedense looks suspicious
30694>>>>>>>        Forward Send OnDefineOperators (&strGrammar)
30696>>>>>>>        // Priority 1
30696>>>>>>>        Send DefineOperator (&strGrammar) "^"    2 1 1 (RefFunc(_fExponential))
30697>>>>>>>        // Priority 2
30697>>>>>>>        Send DefineOperator (&strGrammar) "-"    1 2 0 (RefFunc(_fUnaryMinus))
30698>>>>>>>        Send DefineOperator (&strGrammar) "+"    1 2 0 (RefFunc(_fUnaryPlus))
30699>>>>>>>        // Priority 3
30699>>>>>>>        Send DefineOperator (&strGrammar) "*"    2 3 0 (RefFunc(_fMultiply))
30700>>>>>>>        Send DefineOperator (&strGrammar) "/"    2 3 0 (RefFunc(_fDivide))
30701>>>>>>>        Send DefineOperator (&strGrammar) "%"    2 3 0 (RefFunc(_fRemainder))
30702>>>>>>>        // Priority 4        
30702>>>>>>>        Send DefineOperator (&strGrammar) "+"    2 4 0 (RefFunc(_fPlus))
30703>>>>>>>        Send DefineOperator (&strGrammar) "-"    2 4 0 (RefFunc(_fMinus))
30704>>>>>>>        // Priority 6
30704>>>>>>>        Send DefineOperator (&strGrammar) ">"    2 6 0 (RefFunc(_fGT))
30705>>>>>>>        Send DefineOperator (&strGrammar) "<"    2 6 0 (RefFunc(_fLT))
30706>>>>>>>        Send DefineOperator (&strGrammar) ">="   2 6 0 (RefFunc(_fGE))
30707>>>>>>>        Send DefineOperator (&strGrammar) "<="   2 6 0 (RefFunc(_fLE))
30708>>>>>>>        // Priority 7
30708>>>>>>>        Send DefineOperator (&strGrammar) "<>"   2 7 0 (RefFunc(_fNE))
30709>>>>>>>        Send DefineOperator (&strGrammar) "="    2 7 0 (RefFunc(_fEQ))
30710>>>>>>>        // Priority 9
30710>>>>>>>        Send DefineOperator (&strGrammar) "and"  2 9 0 (RefFunc(_fAnd))
30711>>>>>>>        Send DefineOperator (&strGrammar) "or"   2 9 0 (RefFunc(_fOr))
30712>>>>>>>        // Priority ? (I have no idea):
30712>>>>>>>        Send DefineOperator (&strGrammar) "not"  1 0 0 (RefFunc(_fNot))
30713>>>>>>>        Send DefineOperator (&strGrammar) "min"  2 0 0 (RefFunc(_fMin))
30714>>>>>>>        Send DefineOperator (&strGrammar) "max"  2 0 0 (RefFunc(_fMax))
30715>>>>>>>        // Priority nil (they just have to be here)
30715>>>>>>>        Send DefineOperator (&strGrammar) "("   -1 0 0 0 
30716>>>>>>>        Send DefineOperator (&strGrammar) ")"   -1 0 0 0 
30717>>>>>>>        Send DefineOperator (&strGrammar) ","   -1 0 0 0 
30718>>>>>>>//        Send DefineOperator (&strGrammar) "string" 1
30718>>>>>>>//        Send DefineOperator (&strGrammar) "number" 1
30718>>>>>>>//        Send DefineOperator (&strGrammar) "integer" 1
30718>>>>>>>//        Send DefineOperator (&strGrammar) "date" 1
30718>>>>>>>//        Send DefineOperator (&strGrammar) "boolean" 1
30718>>>>>>>    End_Procedure
30719>>>>>>>    
30719>>>>>>>    Procedure OnDefineFunctions tXPGrammar ByRef strGrammar
30721>>>>>>>        Forward Send OnDefineFunctions (&strGrammar)
30723>>>>>>>        Send DefineFunction (&strGrammar) "Round"     1 XP_Numeric (RefFunc(_fRound))
30724>>>>>>>        Send DefineFunction (&strGrammar) "Today"     0 XP_Date    (RefFunc(_fToday))
30725>>>>>>>        Send DefineFunction (&strGrammar) "Month"     1 XP_Integer (RefFunc(_fMonth))
30726>>>>>>>        Send DefineFunction (&strGrammar) "Week"      1 XP_Integer (RefFunc(_fWeek))
30727>>>>>>>        Send DefineFunction (&strGrammar) "Year"      1 XP_Integer (RefFunc(_fYear))
30728>>>>>>>        Send DefineFunction (&strGrammar) "Day"       1 XP_Integer (RefFunc(_fDay))
30729>>>>>>>        Send DefineFunction (&strGrammar) "DayName"   1 XP_String  (RefFunc(_fDayName))
30730>>>>>>>        Send DefineFunction (&strGrammar) "MonthName" 1 XP_String  (RefFunc(_fMonthName))
30731>>>>>>>        Send DefineFunction (&strGrammar) "Sin"       1 XP_Numeric (RefFunc(_fSin))
30732>>>>>>>        Send DefineFunction (&strGrammar) "Cos"       1 XP_Numeric (RefFunc(_fCos))
30733>>>>>>>        Send DefineFunction (&strGrammar) "Mid"       3 XP_String  (RefFunc(_fMid))
30734>>>>>>>        Send DefineFunction (&strGrammar) "Left"      2 XP_String  (RefFunc(_fLeft))
30735>>>>>>>        Send DefineFunction (&strGrammar) "Right"     2 XP_String  (RefFunc(_fRight))
30736>>>>>>>        Send DefineFunction (&strGrammar) "Uppercase" 1 XP_String  (RefFunc(_fUppercase))
30737>>>>>>>        Send DefineFunction (&strGrammar) "Lowercase" 1 XP_String  (RefFunc(_fLowercase))
30738>>>>>>>        Send DefineFunction (&strGrammar) "Length"    1 XP_Integer (RefFunc(_fLength))
30739>>>>>>>        Send DefineFunction (&strGrammar) "Trim"      1 XP_String  (RefFunc(_fTrim))
30740>>>>>>>        Send DefineFunction (&strGrammar) "Pos"       2 XP_Integer (RefFunc(_fPos))
30741>>>>>>>    End_Procedure
30742>>>>>>>    
30742>>>>>>>    Procedure OnDefineConstants tXPGrammar ByRef strGrammar
30744>>>>>>>        Forward Send OnDefineConstants (&strGrammar)
30746>>>>>>>        Send DefineConstant (&strGrammar) "pi" 3.1415926 XP_Numeric
30747>>>>>>>    End_Procedure
30748>>>>>>>
30748>>>>>>>End_Class
30749>>>>>Use TableQueryFunctions.pkg
Including file: TableQueryFunctions.pkg    (Z:\VmShare\Projects\WebQuery18-0\StureApsPublicLib\AppSrc\TableQueryFunctions.pkg)
30749>>>>>>>//> <h1>TableQueryFunctions.pkg</h1>
30749>>>>>>>//>
30749>>>>>>>//> <p>The idea is that you declare a variable of type tTableQuery and tell it what table and what
30749>>>>>>>//> filters you want and what output order you want. TQ then calculates the index to use for the.
30749>>>>>>>//> scan. If it can not find an index in accordance with the desired output it will collect
30749>>>>>>>//> all the sorting information in memory and refind the records in the desired order.
30749>>>>>>>//>
30749>>>>>>>//> If the code happens to be running against an MSSQL backend it will skip all the figuring
30749>>>>>>>//> out and apply embedded SQL to the problem. This gives a potentially huge performance
30749>>>>>>>//> increase at no effort on behalf of the programmer.
30749>>>>>>>//>
30749>>>>>>>//> oTQ is a global object (of class cTableQueryFunctions) that encapsulates a group of
30749>>>>>>>//> functions. Using it to scan all orders in the order table goes like this:</p>
30749>>>>>>>//>
30749>>>>>>>//> <code>
30749>>>>>>>//>     Use TableQueryFunctions.pkg // Define oTableQueryFunctions object
30749>>>>>>>//>
30749>>>>>>>//>     Procedure RunQuery
30749>>>>>>>//>         tTableQuery strQuery // I use the prefix 'str' to signify a struct type variable.
30749>>>>>>>//>
30749>>>>>>>//>         Get NewQuery of oTQ Order.File_Number to strQuery
30749>>>>>>>//>
30749>>>>>>>//>         While (FindRecord(oTQ,&strQuery))
30749>>>>>>>//>             Showln Order.Order_Number
30749>>>>>>>//>         Loop
30749>>>>>>>//>     End_Procedure
30749>>>>>>>//> </code>
30749>>>>>>>//>
30749>>>>>>>//> <p>Note that the strQuery parameter is passed "by reference" to the FindRecord
30749>>>>>>>//> function. That variable maintains the complete state of the scan and it is
30749>>>>>>>//> modified for each iteration. The table query object itself is stateless.
30749>>>>>>>//>
30749>>>>>>>//> For every loop of the FindRecord function the record buffer of the order
30749>>>>>>>//> table will be active with the record found. If you are planning on modifying or
30749>>>>>>>//> deleting these rows you should force a "prefetch" of the rows by inserting</p>
30749>>>>>>>//>
30749>>>>>>>//> <code>
30749>>>>>>>//>     Send ForcePrefetch of oTQ (&strQuery)
30749>>>>>>>//> </code>
30749>>>>>>>//>
30749>>>>>>>//> right after the "Get NewQuery..." line. Transparantly to the FindRecord loop this
30749>>>>>>>//> will find all the rows in advance and store their rowid's in an array. Only
30749>>>>>>>//> then will it start looping through the array finding each record (again) by its rowid.
30749>>>>>>>//>
30749>>>>>>>//>
30749>>>>>>>//> Not having to constantly write 'of oTQ' the code becomes easier to
30749>>>>>>>//> read and therefore this form will be used from here on. But in real life, always
30749>>>>>>>//> use the oTQ object.
30749>>>>>>>//>
30749>>>>>>>//>
30749>>>>>>>//> Now let us say that we wanted (1) all invoices for a particular customer that was (2)
30749>>>>>>>//> payed after a given date. Furthermore this Invoice table has a column called Country
30749>>>>>>>//> and (3) we only want invoices for a subset of countries. And the records should be
30749>>>>>>>//> ordered by the amount on the order, highest amount first (4).
30749>>>>>>>//>
30749>>>>>>>//> <code>
30749>>>>>>>//>     Object oMyQuery is a cTableQueryFunctions
30749>>>>>>>//>         Procedure RunQuery
30749>>>>>>>//>             String[] aCountries
30749>>>>>>>//>             tTableQuery strQuery
30749>>>>>>>//>
30749>>>>>>>//>             Get ListOfCountries to aCountries // Arbitrary list. It's an array of strings. That's what's important.
30749>>>>>>>//>
30749>>>>>>>//>             Get NewQuery Invoice.File_Number to strQuery
30749>>>>>>>//>             Send AddFilterRelate (&strQuery) Customer.File_Number // 1
30749>>>>>>>//>             Send AddFilter (&strQuery) File_Field Invoice.Payed_Date tqGT dSomeDate // 2
30749>>>>>>>//>             Send AddFilterOrlist (&strQuery) File_Field Invoice.Country aCountries // 3 (must be a string array no matter the column data type)
30749>>>>>>>//>
30749>>>>>>>//>             // And we also want it to be ordered backwards by the order total:
30749>>>>>>>//>             Send AddOrderBy (&strQuery) File_Field Invoice.Total True False // 4 (bDescending=True bUppercase=False)
30749>>>>>>>//>             // (add more ordering segments)
30749>>>>>>>//>
30749>>>>>>>//>             While (FindRecord(Self,&strQuery))
30749>>>>>>>//>                 Showln Invoice.Invoice_Number " " Invoice.Total
30749>>>>>>>//>             Loop
30749>>>>>>>//>         End_Procedure
30749>>>>>>>//>     End_Object
30749>>>>>>>//> </code>
30749>>>>>>>//>
30749>>>>>>>//> If you look at filter (2) in the example above you can see that the ">"-comperator is represented by
30749>>>>>>>//> a tqGT symbol. Other comperators that may be used are:
30749>>>>>>>//>
30749>>>>>>>//>              tqLT, tqLE, tqEQ, tqGE, tqGT
30749>>>>>>>//>
30749>>>>>>>//> end then there are these special ones intended for string evaluation and which cannot be used
30749>>>>>>>//> for search optimization:
30749>>>>>>>//>
30749>>>>>>>//>              tqNE, tqMATCH, tqUCMATCH
30749>>>>>>>//>
30749>>>>>>>//> Well, tqNE is not just for string evaluation.
30749>>>>>>>//>  
30749>>>>>>>//>
30749>>>>>>>//> You can run nested queries like this:
30749>>>>>>>//>
30749>>>>>>>//> <code>
30749>>>>>>>//>     Object oMyQuery is a cTableQueryFunctions
30749>>>>>>>//>         Procedure RunQuery
30749>>>>>>>//>             tTableQuery strOrderQ strOrderLineQ
30749>>>>>>>//>
30749>>>>>>>//>             Get NewQuery Order.File_Number to strOrderQ
30749>>>>>>>//>
30749>>>>>>>//>             While (FindRecord(Self,&strOrderQ)) // <-- Go through all orders
30749>>>>>>>//>                 Get NewQuery OrderLine.File_Number to strOrderLineQ
30749>>>>>>>//>                 Send AddFilterRelate (&strOrderLineQ) Order.File_Number
30749>>>>>>>//>
30749>>>>>>>//>                 While (FindRecord(Self,&strOrderLineQ)) // <-- Go through all lines on active order
30749>>>>>>>//>                     // Something
30749>>>>>>>//>                 Loop
30749>>>>>>>//>             Loop
30749>>>>>>>//>         End_Procedure
30749>>>>>>>//>     End_Object
30749>>>>>>>//> </code>
30749>>>>>>>//>
30749>>>>>>>//> If you have a 2 level scan like above, you can save execution time by creating
30749>>>>>>>//> the sub-query only once and then call ReUse to reinitialise it.
30749>>>>>>>//>
30749>>>>>>>//> With the ReUse method you can skip the repeated compilation (of the inner query):
30749>>>>>>>//>
30749>>>>>>>//> <code>
30749>>>>>>>//>     Object oMyQuery is a cTableQueryFunctions
30749>>>>>>>//>         Procedure RunQuery
30749>>>>>>>//>             Open Order
30749>>>>>>>//>             Open OrderLin
30749>>>>>>>//>             tTableQuery strOrderQ strOrderlineQ
30749>>>>>>>//>             Get NewQuery Order.file_number to strOrderQ
30749>>>>>>>//>             Get NewQuery OrderLin.file_number to strOrderlineQ
30749>>>>>>>//>             Send AddFilterRelate (&strOrderlineQ) Order.file_number
30749>>>>>>>//>
30749>>>>>>>//>             While (FindRecord(Self,&strOrderQ))
30749>>>>>>>//>                 Send ReUse (&strOrderlineQ) // Only "compile" once
30749>>>>>>>//>                 While (FindRecord(Self,&strOrderlineQ))
30749>>>>>>>//>                 Loop
30749>>>>>>>//>             Loop
30749>>>>>>>//>         End_Procedure
30749>>>>>>>//>     End_Object
30749>>>>>>>//> </code>
30749>>>>>>>//>
30749>>>>>>>//> You may use the .iLimit member of the tTableQuery value to limit
30749>>>>>>>//> the number of rows returned:
30749>>>>>>>//>
30749>>>>>>>//> <code>
30749>>>>>>>//>     Send SetLimit (&strQuery) 50
30749>>>>>>>//> </code>
30749>>>>>>>//>
30749>>>>>>>//> And finally, to quickly find out if a query will return any rows at all
30749>>>>>>>//> you can call function HasData:
30749>>>>>>>//>
30749>>>>>>>//> <code>
30749>>>>>>>//>     Get HasData strQuery to bContinue // Note that strQuery for once is _not_ byref'ed.
30749>>>>>>>//> </code>
30749>>>>>>>//>
30749>>>>>>>//> Calling HasData could be a lot faster than setting iLimit to 1 since the latter
30749>>>>>>>//> strategy may still force the query machine into generating the whole result-set and
30749>>>>>>>//> sort it some way in order to find out which record is actually the first. Calling
30749>>>>>>>//> HasData does not do that.
30749>>>>>>>//>
30749>>>>>>>//> If the table that you are table querying is an SQL table and it has been "opened as", TableQuery
30749>>>>>>>//> has no way of knowing what table name to use in the select statement. If you prepare the
30749>>>>>>>//> query with this line:
30749>>>>>>>//>
30749>>>>>>>//> <code>
30749>>>>>>>//>     Send ForceSQLTableName (&strQuery) "Customer"
30749>>>>>>>//> </code>
30749>>>>>>>//>
30749>>>>>>>//> that name will be used in the ESQL select statement and you'll be fine.
30749>>>>>>>//>
30749>>>>>>>//> A note on the source code in this package:
30749>>>>>>>//>
30749>>>>>>>//> An "_" character in the beginning of a name indicates that the procedure, property or whatever is
30749>>>>>>>//> meant to be used internally by this package only.
30749>>>>>>>//>
30749>>>>>>>//> Variable names are prefixed by s if string, b if boolean asf. Struct type variables are prefixed
30749>>>>>>>//> 'str' which should make one think 'struct' (not 'string').
30749>>>>>>>//>
30749>>>>>>>//> In order to test the function of TableQueryFunctions.pkg without actually programming you may
30749>>>>>>>//> download VDFXray (a multi-purpose VDF utility) from this address:
30749>>>>>>>//>
30749>>>>>>>//>             ftp.stureaps.dk/software/visualdataflex/vdfxray/
30749>>>>>>>//>
30749>>>>>>>//> Use VDFXray to open a workspace, select a table in the tables list. Right click and select
30749>>>>>>>//> "TableQuery Engine Inspector".
30749>>>>>>>//>
30749>>>>>>>//> You'll notice two panels appearing with the "TableQuery test facility" panel on top. If
30749>>>>>>>//> your screen is large enough try to position that panel so that you can see the list of
30749>>>>>>>//> columns in the panel behind it. If necessary by dragging the second panel partly off
30749>>>>>>>//> screen. You'll see the selection of that list changes as you specify columns to filter by.
30749>>>>>>>
30749>>>>>>>//> pkg.doc.end
30749>>>>>>>
30749>>>>>>>
30749>>>>>>>// DAW packages:
30749>>>>>>>Use VdfBase.pkg
30749>>>>>>>Use cli.pkg
30749>>>>>>>Use sql.pkg
30749>>>>>>>
30749>>>>>>>// StureApsPublicLib packages
30749>>>>>>>Use DateFunctions.pkg   // oDateFunctions object
30749>>>>>>>Use StringFunctions.pkg // oStringFunctions object
30749>>>>>>>Use IndexFunctions.pkg
Including file: IndexFunctions.pkg    (Z:\VmShare\Projects\WebQuery18-0\StureApsPublicLib\AppSrc\IndexFunctions.pkg)
30749>>>>>>>>>Use VdfBase.pkg
30749>>>>>>>>>
30749>>>>>>>>>Use StringFunctions.pkg // Define oStringFunctions object
30749>>>>>>>>>Use DateFunctions.pkg // Define oDateFunctions object
30749>>>>>>>>>Use _OverlapColumnFunctions.pkg
Including file: _OverlapColumnFunctions.pkg    (Z:\VmShare\Projects\WebQuery18-0\StureApsPublicLib\AppSrc\_OverlapColumnFunctions.pkg)
30749>>>>>>>>>>>Use VdfBase.pkg
30749>>>>>>>>>>>
30749>>>>>>>>>>>// The next three structs are used for creating a bank
30749>>>>>>>>>>>Struct tocIndexSegment
30749>>>>>>>>>>>    Integer iColumn
30749>>>>>>>>>>>    Boolean bUppercase
30749>>>>>>>>>>>    Boolean bDescending
30749>>>>>>>>>>>End_Struct
30749>>>>>>>>>>>
30749>>>>>>>>>>>Struct tocIndex
30749>>>>>>>>>>>    Integer iIndex
30749>>>>>>>>>>>    Boolean bOnline
30749>>>>>>>>>>>    tocIndexSegment[] aSegments
30749>>>>>>>>>>>    tocIndexSegment[] aSegments
30749>>>>>>>>>>>End_Struct
30749>>>>>>>>>>>
30749>>>>>>>>>>>Struct tocColumn
30749>>>>>>>>>>>    Boolean bOverlap
30749>>>>>>>>>>>    Integer[] aOverlappingColumns
30749>>>>>>>>>>>End_Struct
30749>>>>>>>>>>>
30749>>>>>>>>>>>Struct tocTable
30749>>>>>>>>>>>    String sPhysName
30749>>>>>>>>>>>    tocColumn[] aColumns
30749>>>>>>>>>>>    tocColumn[] aColumns
30749>>>>>>>>>>>    tocIndex[] aIndices
30749>>>>>>>>>>>    tocIndex[] aIndices
30749>>>>>>>>>>>    Integer iShortestUniqueIndex
30749>>>>>>>>>>>End_Struct
30749>>>>>>>>>>>
30749>>>>>>>>>>>Global_Variable tOCTable[] gaOCIndexBank
30749>>>>>>>>>>>
30749>>>>>>>>>>>Class cOverlapColumnFunctions is a cObject
30750>>>>>>>>>>>
30750>>>>>>>>>>>    Procedure _AppendIndexSegment tocIndex ByRef strIndex Integer iColumnType Integer iColumn Boolean bUppercase Boolean bDescending
30752>>>>>>>>>>>        Integer iSegment
30752>>>>>>>>>>>        Move (SizeOfArray(strIndex.aSegments)) to iSegment
30753>>>>>>>>>>>        If (iColumnType<>DF_ASCII) Begin
30755>>>>>>>>>>>            Move False to bUppercase
30756>>>>>>>>>>>        End
30756>>>>>>>>>>>>
30756>>>>>>>>>>>        Move iColumn to strIndex.aSegments[iSegment].iColumn
30757>>>>>>>>>>>        Move bUppercase to strIndex.aSegments[iSegment].bUppercase
30758>>>>>>>>>>>        Move bDescending to strIndex.aSegments[iSegment].bDescending
30759>>>>>>>>>>>    End_Procedure
30760>>>>>>>>>>>
30760>>>>>>>>>>>    Procedure _HandleIndexSegment tocTable strTable tocIndex ByRef strIndex Integer iTable Integer iSourceColumn Boolean bUppercase Boolean bDescending
30762>>>>>>>>>>>        Integer iColumnType i iMax iColumn
30762>>>>>>>>>>>        Integer[] aColumns
30763>>>>>>>>>>>        tocIndexSegment[] aSegments
30763>>>>>>>>>>>        tocIndexSegment[] aSegments
30764>>>>>>>>>>>        Move strTable.aColumns[iSourceColumn].aOverlappingColumns to aColumns
30765>>>>>>>>>>>        Move (SizeOfArray(aColumns)-1) to iMax
30766>>>>>>>>>>>        For i from 0 to iMax
30772>>>>>>>>>>>>
30772>>>>>>>>>>>            Move aColumns[i] to iColumn
30773>>>>>>>>>>>            Get_Attribute DF_FIELD_TYPE of iTable iColumn to iColumnType
30776>>>>>>>>>>>            Send _AppendIndexSegment (&strIndex) iColumnType iColumn bUppercase bDescending
30777>>>>>>>>>>>        Loop
30778>>>>>>>>>>>>
30778>>>>>>>>>>>//        
30778>>>>>>>>>>>//        If (iColumnType=DF_OVERLAP) Begin
30778>>>>>>>>>>>//            Get_Attribute DF_FILE_NUMBER_FIELDS of iTable to iColumns
30778>>>>>>>>>>>//            For iColumn from 1 to iColumns
30778>>>>>>>>>>>//                Get_Attribute DF_FIELD_OVERLAP of iTable iSourceColumn iColumn to bOverlaps
30778>>>>>>>>>>>//                If (bOverlaps) Begin
30778>>>>>>>>>>>//                    Get_Attribute DF_FIELD_TYPE of iTable iColumn to iColumnType // Overload
30778>>>>>>>>>>>//                    If (iColumnType<>DF_OVERLAP) Begin
30778>>>>>>>>>>>//                        Send _AppendIndexSegment (&strIndex) iColumnType iColumn bUppercase bDescending
30778>>>>>>>>>>>//                    End
30778>>>>>>>>>>>//                End
30778>>>>>>>>>>>//            Loop
30778>>>>>>>>>>>//        End
30778>>>>>>>>>>>//        Else Begin
30778>>>>>>>>>>>//            Send _AppendIndexSegment (&strIndex) iColumnType iColumn bUppercase bDescending
30778>>>>>>>>>>>//        End
30778>>>>>>>>>>>    End_Procedure
30779>>>>>>>>>>>    
30779>>>>>>>>>>>    Procedure _ReadIndex tocTable ByRef strTable Integer iTable Integer iIndex Integer ByRef iBestLength
30781>>>>>>>>>>>        Integer iSegments iSegment iKeyLength
30781>>>>>>>>>>>        Integer iCase iDirection iColumn iType 
30781>>>>>>>>>>>        Boolean bUppercase bDescending bUnique
30781>>>>>>>>>>>        tocIndex strIndex
30781>>>>>>>>>>>        tocIndex strIndex
30781>>>>>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of iTable iIndex to iSegments
30784>>>>>>>>>>>        If (iSegments>0) Begin
30786>>>>>>>>>>>            Move iIndex to strIndex.iIndex
30787>>>>>>>>>>>            Get_Attribute DF_INDEX_TYPE of iTable iIndex to iType
30790>>>>>>>>>>>            Move (iType=DF_INDEX_TYPE_ONLINE) to strIndex.bOnline
30791>>>>>>>>>>>            Move True to bUnique
30792>>>>>>>>>>>            For iSegment from 1 to iSegments
30798>>>>>>>>>>>>
30798>>>>>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_FIELD of iTable iIndex iSegment to iColumn
30801>>>>>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_CASE of iTable iIndex iSegment to iCase
30804>>>>>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_DIRECTION of iTable iIndex iSegment to iDirection
30807>>>>>>>>>>>                Move (iCase=DF_CASE_IGNORED) to bUppercase
30808>>>>>>>>>>>                Move (iDirection=DF_DESCENDING) to bDescending
30809>>>>>>>>>>>                Send _HandleIndexSegment strTable (&strIndex) iTable iColumn bUppercase bDescending
30810>>>>>>>>>>>                If (iColumn=0) Begin
30812>>>>>>>>>>>                    Move False to bUnique
30813>>>>>>>>>>>                End
30813>>>>>>>>>>>>
30813>>>>>>>>>>>            Loop
30814>>>>>>>>>>>>
30814>>>>>>>>>>>            Move strIndex to strTable.aIndices[iIndex]
30815>>>>>>>>>>>            
30815>>>>>>>>>>>            If (bUnique) Begin
30817>>>>>>>>>>>                Get_Attribute DF_INDEX_KEY_LENGTH of iTable iIndex to iKeyLength
30820>>>>>>>>>>>                If (iKeyLength<iBestLength) Begin
30822>>>>>>>>>>>                    Move iIndex to strTable.iShortestUniqueIndex
30823>>>>>>>>>>>                    Move iKeyLength to iBestLength
30824>>>>>>>>>>>                End
30824>>>>>>>>>>>>
30824>>>>>>>>>>>            End
30824>>>>>>>>>>>>
30824>>>>>>>>>>>        End
30824>>>>>>>>>>>>
30824>>>>>>>>>>>    End_Procedure
30825>>>>>>>>>>>    
30825>>>>>>>>>>>    Function _ReadOverlapTranslation Integer iTable Integer iOverlapColumn Returns Integer[]
30827>>>>>>>>>>>        Boolean bOverlaps
30827>>>>>>>>>>>        Integer iColumn iColumns iColumnType
30827>>>>>>>>>>>        Integer[] aColumns
30828>>>>>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iTable to iColumns
30831>>>>>>>>>>>        For iColumn from 0 to iColumns
30837>>>>>>>>>>>>
30837>>>>>>>>>>>            Get_Attribute DF_FIELD_TYPE of iTable iColumn to iColumnType
30840>>>>>>>>>>>            If (iColumnType<>DF_OVERLAP) Begin
30842>>>>>>>>>>>                Get_Attribute DF_FIELD_OVERLAP of iTable iOverlapColumn iColumn to bOverlaps
30845>>>>>>>>>>>                If (bOverlaps) Begin
30847>>>>>>>>>>>                    Move iColumn to aColumns[SizeOfArray(aColumns)]
30848>>>>>>>>>>>                End
30848>>>>>>>>>>>>
30848>>>>>>>>>>>            End
30848>>>>>>>>>>>>
30848>>>>>>>>>>>        Loop
30849>>>>>>>>>>>>
30849>>>>>>>>>>>        Function_Return aColumns
30850>>>>>>>>>>>    End_Function
30851>>>>>>>>>>>    
30851>>>>>>>>>>>    Procedure ReadTableDefinition Integer iTable
30853>>>>>>>>>>>        Integer iIndex iMax
30853>>>>>>>>>>>        Integer iColumn iColumns iColumnType
30853>>>>>>>>>>>        Integer iBestLength
30853>>>>>>>>>>>        String sPhysName
30853>>>>>>>>>>>        tocTable strTable
30853>>>>>>>>>>>        tocTable strTable
30853>>>>>>>>>>>
30853>>>>>>>>>>>        // We only do something if the table definition hasn't been read before
30853>>>>>>>>>>>        // or if a new table has been opened in the same place.
30853>>>>>>>>>>>        Get_Attribute DF_FILE_PHYSICAL_NAME of iTable to sPhysName
30856>>>>>>>>>>>        If (iTable>=SizeOfArray(gaOCIndexBank) or sPhysName<>gaOCIndexBank[iTable].sPhysName) Begin
30858>>>>>>>>>>>
30858>>>>>>>>>>>            // Build column overlap information
30858>>>>>>>>>>>            Get_Attribute DF_FILE_NUMBER_FIELDS of iTable to iColumns
30861>>>>>>>>>>>            For iColumn from 0 to iColumns // Obs
30867>>>>>>>>>>>>
30867>>>>>>>>>>>                Get_Attribute DF_FIELD_TYPE of iTable iColumn to iColumnType
30870>>>>>>>>>>>                If (iColumnType=DF_OVERLAP) Begin
30872>>>>>>>>>>>                    Move True to strTable.aColumns[iColumn].bOverlap
30873>>>>>>>>>>>                    Get _ReadOverlapTranslation iTable iColumn to strTable.aColumns[iColumn].aOverlappingColumns
30874>>>>>>>>>>>                End
30874>>>>>>>>>>>>
30874>>>>>>>>>>>                Else Begin // It's not an overlap column. Therefore it corresponds to itself:
30875>>>>>>>>>>>                    Move False to strTable.aColumns[iColumn].bOverlap
30876>>>>>>>>>>>                    Move iColumn to strTable.aColumns[iColumn].aOverlappingColumns[0]
30877>>>>>>>>>>>                End
30877>>>>>>>>>>>>
30877>>>>>>>>>>>            Loop
30878>>>>>>>>>>>>
30878>>>>>>>>>>>
30878>>>>>>>>>>>            // Build index overlap information
30878>>>>>>>>>>>            Move 999 to iBestLength
30879>>>>>>>>>>>            Get_Attribute DF_FILE_LAST_INDEX_NUMBER of iTable to iMax
30882>>>>>>>>>>>            For iIndex from 1 to iMax
30888>>>>>>>>>>>>
30888>>>>>>>>>>>                Send _ReadIndex (&strTable) iTable iIndex (&iBestLength)
30889>>>>>>>>>>>            Loop
30890>>>>>>>>>>>>
30890>>>>>>>>>>>            
30890>>>>>>>>>>>            Move (SizeOfArray(strTable.aIndices)-1) to iMax
30891>>>>>>>>>>>            For iIndex from 1 to iMax
30897>>>>>>>>>>>>
30897>>>>>>>>>>>                If (SizeOfArray(strTable.aIndices[iIndex].aSegments)>0 and strTable.aIndices[iIndex].bOnline ;                    and strTable.aIndices[iIndex].aSegments[SizeOfArray(strTable.aIndices[iIndex].aSegments)-1].iColumn<>0) Begin
30899>>>>>>>>>>>                    
30899>>>>>>>>>>>                End
30899>>>>>>>>>>>>
30899>>>>>>>>>>>            Loop
30900>>>>>>>>>>>>
30900>>>>>>>>>>>
30900>>>>>>>>>>>
30900>>>>>>>>>>>            
30900>>>>>>>>>>>            // Update cache information
30900>>>>>>>>>>>            Move strTable to gaOCIndexBank[iTable]
30901>>>>>>>>>>>            Move sPhysName to gaOCIndexBank[iTable].sPhysName
30902>>>>>>>>>>>        End
30902>>>>>>>>>>>>
30902>>>>>>>>>>>    End_Procedure
30903>>>>>>>>>>>    
30903>>>>>>>>>>>    Function TableDefinition Integer iTable Returns tOCTable
30905>>>>>>>>>>>        Send ReadTableDefinition iTable
30906>>>>>>>>>>>        Function_Return gaOCIndexBank[iTable]
30907>>>>>>>>>>>    End_Function
30908>>>>>>>>>>>
30908>>>>>>>>>>>    Function IndexDefinition Integer iTable Integer iIndex Returns tOCIndex
30910>>>>>>>>>>>        tOCIndex strIndex
30910>>>>>>>>>>>        tOCIndex strIndex
30910>>>>>>>>>>>        Send ReadTableDefinition iTable
30911>>>>>>>>>>>        If (SizeOfArray(gaOCIndexBank[iTable].aIndices)>iIndex) Begin
30913>>>>>>>>>>>            Move gaOCIndexBank[iTable].aIndices[iIndex] to strIndex
30914>>>>>>>>>>>        End
30914>>>>>>>>>>>>
30914>>>>>>>>>>>        Function_Return strIndex
30915>>>>>>>>>>>    End_Function
30916>>>>>>>>>>>    
30916>>>>>>>>>>>    Function IndexDefinitionColumnNumbers Integer iTable Integer iIndex Returns Integer[]
30918>>>>>>>>>>>        Integer iSegment iSegments
30918>>>>>>>>>>>        Integer[] aColumns
30919>>>>>>>>>>>        tOCIndex strIndex
30919>>>>>>>>>>>        tOCIndex strIndex
30919>>>>>>>>>>>        Get IndexDefinition iTable iIndex to strIndex
30920>>>>>>>>>>>        Move (SizeOfArray(strIndex.aSegments)-1) to iSegments
30921>>>>>>>>>>>        For iSegment from 0 to iSegments
30927>>>>>>>>>>>>
30927>>>>>>>>>>>            Move strIndex.aSegments[iSegment].iColumn to aColumns[iSegment]
30928>>>>>>>>>>>        Loop
30929>>>>>>>>>>>>
30929>>>>>>>>>>>        Function_Return aColumns
30930>>>>>>>>>>>    End_Function
30931>>>>>>>>>>>
30931>>>>>>>>>>>    Function TranslateOverlap Integer iTable Integer iColumn Returns Integer[]
30933>>>>>>>>>>>        Send ReadTableDefinition iTable
30934>>>>>>>>>>>        Function_Return gaOCIndexBank[iTable].aColumns[iColumn].aOverlappingColumns
30935>>>>>>>>>>>    End_Function
30936>>>>>>>>>>>    
30936>>>>>>>>>>>    Procedure AppendArrays Variant[] ByRef aArray1 Variant[] aArray2
30938>>>>>>>>>>>        Integer iIndex1 iIndex2 iMax2
30938>>>>>>>>>>>        Move (SizeOfArray(aArray1)) to iIndex1
30939>>>>>>>>>>>        Move (SizeOfArray(aArray2)-1) to iMax2
30940>>>>>>>>>>>        For iIndex2 from 0 to iMax2
30946>>>>>>>>>>>>
30946>>>>>>>>>>>            Move aArray2[iIndex2] to aArray1[iIndex1]
30947>>>>>>>>>>>            Increment iIndex1
30948>>>>>>>>>>>        Loop
30949>>>>>>>>>>>>
30949>>>>>>>>>>>    End_Procedure
30950>>>>>>>>>>>
30950>>>>>>>>>>>    Function TranslateOverlaps Integer iTable Integer[] aColumns Returns Integer[]
30952>>>>>>>>>>>        Integer iMax iItem
30952>>>>>>>>>>>        Integer[] aColumnsWithoutOverlaps
30953>>>>>>>>>>>        Integer[] aTranslatedColumns
30954>>>>>>>>>>>        Move (SizeOfArray(aColumns)-1) to iMax
30955>>>>>>>>>>>        For iItem from 0 to iMax
30961>>>>>>>>>>>>
30961>>>>>>>>>>>            Get TranslateOverlap iTable aColumns[iItem] to aTranslatedColumns
30962>>>>>>>>>>>            Send AppendArrays (&aColumnsWithoutOverlaps) aTranslatedColumns
30963>>>>>>>>>>>        Loop
30964>>>>>>>>>>>>
30964>>>>>>>>>>>        Function_Return aColumnsWithoutOverlaps
30965>>>>>>>>>>>    End_Function
30966>>>>>>>>>>>    
30966>>>>>>>>>>>    Function TableColumnsRelatingBetweenTables Integer iSourceTable Integer iTargetTable Integer[] ByRef aSourceColumns Integer[] ByRef aTargetColumns Returns Boolean
30968>>>>>>>>>>>        Integer iMaxColumn iSourceColumn iTargetColumn iTest 
30968>>>>>>>>>>>        Integer[] aColumns aSourceTest aTargetTest
30971>>>>>>>>>>>        Move (ResizeArray(aSourceColumns,0)) to aSourceColumns
30972>>>>>>>>>>>        Move (ResizeArray(aTargetColumns,0)) to aTargetColumns
30973>>>>>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iSourceTable to iMaxColumn
30976>>>>>>>>>>>        For iSourceColumn from 1 to iMaxColumn
30982>>>>>>>>>>>>
30982>>>>>>>>>>>            Get_Attribute DF_FIELD_RELATED_FILE of iSourceTable iSourceColumn to iTest
30985>>>>>>>>>>>            If (iTest=iTargetTable) Begin
30987>>>>>>>>>>>                Get_Attribute DF_FIELD_RELATED_FIELD of iSourceTable iSourceColumn to iTargetColumn
30990>>>>>>>>>>>                Get TranslateOverlap iSourceTable iSourceColumn to aSourceTest
30991>>>>>>>>>>>                Get TranslateOverlap iTargetTable iTargetColumn to aTargetTest
30992>>>>>>>>>>>                Send AppendArrays (&aSourceColumns) (&aSourceTest)
30993>>>>>>>>>>>                Send AppendArrays (&aTargetColumns) (&aTargetTest)
30994>>>>>>>>>>>            End
30994>>>>>>>>>>>>
30994>>>>>>>>>>>        Loop
30995>>>>>>>>>>>>
30995>>>>>>>>>>>        Function_Return (SizeOfArray(aSourceColumns)>0 and SizeOfArray(aSourceColumns)=SizeOfArray(aTargetColumns))
30996>>>>>>>>>>>    End_Function
30997>>>>>>>>>>>    
30997>>>>>>>>>>>    Function IsOverlap Integer iTable Integer iColumn Returns Boolean
30999>>>>>>>>>>>        Function_Return gaOCIndexBank[iTable].aColumns[iColumn].bOverlap
31000>>>>>>>>>>>    End_Function
31001>>>>>>>>>>>    
31001>>>>>>>>>>>    // This procedure would be used in a well behaved program that is
31001>>>>>>>>>>>    // both capable of changing a tables definition on the fly, and at the
31001>>>>>>>>>>>    // same time use this package for something clever. In that case Reset
31001>>>>>>>>>>>    // should be sent to wipe out cached data now invalid. 
31001>>>>>>>>>>>    Procedure Reset
31003>>>>>>>>>>>        tocTable[] strEmpty
31003>>>>>>>>>>>        tocTable[] strEmpty
31004>>>>>>>>>>>        Move strEmpty to gaOCIndexBank
31005>>>>>>>>>>>    End_Procedure
31006>>>>>>>>>>>    
31006>>>>>>>>>>>End_Class // cOverlapColumnFunctions
31007>>>>>>>>>>>
31007>>>>>>>>>>>Global_Variable Integer oOverlapColumnFunctions
31007>>>>>>>>>>>
31007>>>>>>>>>>>Object _oOverlapColumnFunctions is a cOverlapColumnFunctions
31009>>>>>>>>>>>    Move Self to oOverlapColumnFunctions
31010>>>>>>>>>>>End_Object
31011>>>>>>>>>Use DataDictionaryFunctions.pkg
Including file: DataDictionaryFunctions.pkg    (Z:\VmShare\Projects\WebQuery18-0\StureApsPublicLib\AppSrc\DataDictionaryFunctions.pkg)
31011>>>>>>>>>>>// DAW packages
31011>>>>>>>>>>>Use VdfBase.pkg
31011>>>>>>>>>>>Use GlobalFunctionsProcedures.pkg
31011>>>>>>>>>>>Use Datadict.pkg
31011>>>>>>>>>>>
31011>>>>>>>>>>>// StureAps packages
31011>>>>>>>>>>>Use StackFunctions.pkg // Define oStackFunctions object
31011>>>>>>>>>>>Use RelationMapStruct.pkg // tRelationsDrawingMapItem struct
Including file: RelationMapStruct.pkg    (Z:\VmShare\Projects\WebQuery18-0\StureApsPublicLib\AppSrc\RelationMapStruct.pkg)
31011>>>>>>>>>>>>>Struct tRelationsDrawingMapItem
31011>>>>>>>>>>>>>    Integer iItemId
31011>>>>>>>>>>>>>    Integer iLevel
31011>>>>>>>>>>>>>    Boolean[] aVerticalLines
31011>>>>>>>>>>>>>    Integer iAlreadyMappedAtRow
31011>>>>>>>>>>>>>    Boolean bFirst 
31011>>>>>>>>>>>>>    Boolean bLast 
31011>>>>>>>>>>>>>    Boolean bParent 
31011>>>>>>>>>>>>>    Boolean bChild
31011>>>>>>>>>>>>>End_Struct
31011>>>>>>>>>>>>>
31011>>>>>>>>>>>Use yUML.pkg
Including file: yUML.pkg    (Z:\VmShare\Projects\WebQuery18-0\StureApsPublicLib\AppSrc\yUML.pkg)
31011>>>>>>>>>>>>>// yuml.me (Create and share simple UML diagrams in your blogs, wikis, forums, bug-trackers and emails.)
31011>>>>>>>>>>>>>// http://yuml.me/diagram/class/samples
31011>>>>>>>>>>>>>
31011>>>>>>>>>>>>>// To do:
31011>>>>>>>>>>>>>//
31011>>>>>>>>>>>>>// * Dotted lines between alias tables
31011>>>>>>>>>>>>>
31011>>>>>>>>>>>>>Use cHttpTransfer.pkg
Including file: cHttpTransfer.pkg    (E:\Program Files\DataFlex 18.0\Pkg\cHttpTransfer.pkg)
31011>>>>>>>>>>>>>>>//*************************************************************************
31011>>>>>>>>>>>>>>>//*
31011>>>>>>>>>>>>>>>//*  Copyright (c) 2001 Data Access Corporation, Miami Florida,
31011>>>>>>>>>>>>>>>//*  All rights reserved.
31011>>>>>>>>>>>>>>>//*  DataFlex is a registered trademark of Data Access Corporation.
31011>>>>>>>>>>>>>>>//*
31011>>>>>>>>>>>>>>>//*************************************************************************
31011>>>>>>>>>>>>>>>//*
31011>>>>>>>>>>>>>>>//*  Module Name:
31011>>>>>>>>>>>>>>>//*      cHttpTransfer.plg
31011>>>>>>>>>>>>>>>//*
31011>>>>>>>>>>>>>>>//*  Creator:
31011>>>>>>>>>>>>>>>//*      SF
31011>>>>>>>>>>>>>>>//*  Purpose:
31011>>>>>>>>>>>>>>>//*      Http Xfer class for VDF
31011>>>>>>>>>>>>>>>//*
31011>>>>>>>>>>>>>>>//* In VDF7 this was a base class defined in InetTransfer.pkg. That class
31011>>>>>>>>>>>>>>>//* has been renamed cBaseHttpTransfer and a sub-class is now use for this
31011>>>>>>>>>>>>>>>//* purpose. This occurred because the Post and Put runtime messages were
31011>>>>>>>>>>>>>>>//* changed to use addresses. We now create the string based put and post
31011>>>>>>>>>>>>>>>//* messages here.
31011>>>>>>>>>>>>>>>//*************************************************************************
31011>>>>>>>>>>>>>>>
31011>>>>>>>>>>>>>>>use VDFBase.pkg
31011>>>>>>>>>>>>>>>
31011>>>>>>>>>>>>>>>Class cHttpTransfer is a cBaseHttpTransfer
31012>>>>>>>>>>>>>>>
31012>>>>>>>>>>>>>>>    Function HttpPostRequest String sFilePath String sData Integer bDataIsFile Returns Integer
31014>>>>>>>>>>>>>>>         integer bStat
31014>>>>>>>>>>>>>>>         Get HttpPostAddrRequest sFilePath (AddressOf(sData)) (Length(sData)) bDataIsfile to bStat
31015>>>>>>>>>>>>>>>         Function_return bStat
31016>>>>>>>>>>>>>>>    end_function
31017>>>>>>>>>>>>>>>
31017>>>>>>>>>>>>>>>    Function HttpPutRequest String sFilePath String sData Integer bDataIsFile Returns Integer
31019>>>>>>>>>>>>>>>         integer bStat
31019>>>>>>>>>>>>>>>         Get HttpPutAddrRequest sFilePath (AddressOf(sData)) (Length(sData)) bDataIsfile to bStat
31020>>>>>>>>>>>>>>>         Function_return bStat
31021>>>>>>>>>>>>>>>    end_function
31022>>>>>>>>>>>>>>>
31022>>>>>>>>>>>>>>>end_class
31023>>>>>>>>>>>>>>>
31023>>>>>>>>>>>>>
31023>>>>>>>>>>>>>Use VdfBase.pkg
31023>>>>>>>>>>>>>Use UrlFunctions.pkg
Including file: UrlFunctions.pkg    (Z:\VmShare\Projects\WebQuery18-0\StureApsPublicLib\AppSrc\UrlFunctions.pkg)
31023>>>>>>>>>>>>>>>//> From the point of view of the URL string manipulation functions an URL
31023>>>>>>>>>>>>>>>//> is composed of the following items:
31023>>>>>>>>>>>>>>>//>
31023>>>>>>>>>>>>>>>//>    * Protocol      "http:"
31023>>>>>>>>>>>>>>>//>    * User ID       "sture"
31023>>>>>>>>>>>>>>>//>    * Password      "headset"
31023>>>>>>>>>>>>>>>//>    * Host          "www.sture.dk"
31023>>>>>>>>>>>>>>>//>    * Port          80
31023>>>>>>>>>>>>>>>//>    * Path          "/Images/EDUC2001"
31023>>>>>>>>>>>>>>>//>    * Type          "type=xml"
31023>>>>>>>>>>>>>>>//>
31023>>>>>>>>>>>>>>>//> function URL_ParseURL global string sUrl returns integer
31023>>>>>>>>>>>>>>>//>
31023>>>>>>>>>>>>>>>//> To have a URL decomposed into the items above use the URL_ParseURL
31023>>>>>>>>>>>>>>>//> function. The function returns TRUE if a host could be identidfied
31023>>>>>>>>>>>>>>>//> as part of the sUrl string and FALSE if not.
31023>>>>>>>>>>>>>>>//>
31023>>>>>>>>>>>>>>>//>
31023>>>>>>>>>>>>>>>//> function URL_Value global integer liSegment returns string
31023>>>>>>>>>>>>>>>//>
31023>>>>>>>>>>>>>>>//> After having used the URL_ParseURL to decompose an URL you should use
31023>>>>>>>>>>>>>>>//> the URL_Value function to obtain the value of each component in the
31023>>>>>>>>>>>>>>>//> URL. For example, to obtain the 'Path' part of the URL you would write
31023>>>>>>>>>>>>>>>//>
31023>>>>>>>>>>>>>>>//>   get URL_Value URL_SEGMENT_PATH to lsPath
31023>>>>>>>>>>>>>>>//>
31023>>>>>>>>>>>>>>>//> The URL_SEGMENT_PATH symbol is a constant defined by the URL.nui package.
31023>>>>>>>>>>>>>>>//> You may pass the following segment identifiers to the function:
31023>>>>>>>>>>>>>>>//>
31023>>>>>>>>>>>>>>>//>    URL_SEGMENT_PROTOCOL, URL_SEGMENT_USER, URL_SEGMENT_PASSWORD,
31023>>>>>>>>>>>>>>>//>    URL_SEGMENT_HOST, URL_SEGMENT_PORT, URL_SEGMENT_PATH and
31023>>>>>>>>>>>>>>>//>    URL_SEGMENT_TYPE
31023>>>>>>>>>>>>>>>//>
31023>>>>>>>>>>>>>>>//> These symbols may also be used as arguments to a the 'set URL_Value'
31023>>>>>>>>>>>>>>>//> procedure anabling you to set the value of each individual before
31023>>>>>>>>>>>>>>>//> calling this function:
31023>>>>>>>>>>>>>>>//>
31023>>>>>>>>>>>>>>>//> function URL_Compose global returns string
31023>>>>>>>>>>>>>>>//>
31023>>>>>>>>>>>>>>>//> This function combines all the segments setup via the 'set URL_Value'
31023>>>>>>>>>>>>>>>//> procedure (and possebly leftovers from the most recent call to
31023>>>>>>>>>>>>>>>//> URL_ParseURL) and returns a URL.
31023>>>>>>>>>>>>>>>//>
31023>>>>>>>>>>>>>>>//>
31023>>>>>>>>>>>>>>>//> Note that the URL functions decribed here are merely string manipulations.
31023>>>>>>>>>>>>>>>//> They do not interact with any internet componenents locally on the machine
31023>>>>>>>>>>>>>>>//> or on the internet itself.
31023>>>>>>>>>>>>>>>//>
31023>>>>>>>>>>>>>>>//> pkg.doc.end
31023>>>>>>>>>>>>>>>
31023>>>>>>>>>>>>>>>Use VdfBase.pkg // DAW package. Provides low level support expected of all VDF applications (windows and webapp)
31023>>>>>>>>>>>>>>>Use StringFunctions.pkg // Define oStringFunctions object
31023>>>>>>>>>>>>>>>
31023>>>>>>>>>>>>>>>Struct tUrl
31023>>>>>>>>>>>>>>>    String sProtocol //> Protocol
31023>>>>>>>>>>>>>>>    String sUser     //> User identification
31023>>>>>>>>>>>>>>>    String sPassword //> Password
31023>>>>>>>>>>>>>>>    String sHost     //> Host
31023>>>>>>>>>>>>>>>    String sPort     //> Port
31023>>>>>>>>>>>>>>>    String sPath     //> Path
31023>>>>>>>>>>>>>>>    String sType     //> Type
31023>>>>>>>>>>>>>>>End_Struct
31023>>>>>>>>>>>>>>>
31023>>>>>>>>>>>>>>>Global_Variable Integer oUrlFunctions
31023>>>>>>>>>>>>>>>
31023>>>>>>>>>>>>>>>Class cUrlFunctions is a cObject
31024>>>>>>>>>>>>>>>
31024>>>>>>>>>>>>>>>        // Private
31024>>>>>>>>>>>>>>>        Function _FindUrlToken String sToken String sValue Returns Integer
31026>>>>>>>>>>>>>>>            Integer iPos iLen iTokenLen
31026>>>>>>>>>>>>>>>            String sString
31026>>>>>>>>>>>>>>>            Move (length(sToken)) to iTokenLen
31027>>>>>>>>>>>>>>>            Move (length(sValue)) to iLen
31028>>>>>>>>>>>>>>>            For iPos from 1 to iLen
31034>>>>>>>>>>>>>>>>
31034>>>>>>>>>>>>>>>                Move (left(sValue,iPos)) to sString
31035>>>>>>>>>>>>>>>                If (right(sString,iTokenLen)=sToken) Function_Return iPos
31038>>>>>>>>>>>>>>>            Loop
31039>>>>>>>>>>>>>>>>
31039>>>>>>>>>>>>>>>            Function_Return 0
31040>>>>>>>>>>>>>>>        End_Function
31041>>>>>>>>>>>>>>>
31041>>>>>>>>>>>>>>>    //> ftp://<user>:<password>@<host>:<port>/<url-path>;type=<typecode>
31041>>>>>>>>>>>>>>>    //> If the Host member of the returns value is empty, the decoding was unsuccessful.
31041>>>>>>>>>>>>>>>    Function Decompose String sUrl Returns tUrl
31043>>>>>>>>>>>>>>>        Integer iPos
31043>>>>>>>>>>>>>>>        String sValue sValue2 sHost
31043>>>>>>>>>>>>>>>        tUrl sStructUrl
31043>>>>>>>>>>>>>>>        tUrl sStructUrl
31043>>>>>>>>>>>>>>>
31043>>>>>>>>>>>>>>>        Get _FindUrlToken ("/"+"/") sUrl to iPos // Protokol?
31044>>>>>>>>>>>>>>>        If iPos Begin // Protokol
31046>>>>>>>>>>>>>>>            Move (left(sUrl,iPos)) to sValue
31047>>>>>>>>>>>>>>>            Move (replace(sValue,sUrl,"")) to sUrl
31048>>>>>>>>>>>>>>>            Get rRemove of oStringFunctions sValue 2 to sStructUrl.sProtocol
31049>>>>>>>>>>>>>>>        End
31049>>>>>>>>>>>>>>>>
31049>>>>>>>>>>>>>>>
31049>>>>>>>>>>>>>>>        Get _FindUrlToken "@" sUrl to iPos // User ?
31050>>>>>>>>>>>>>>>        If iPos Begin // User
31052>>>>>>>>>>>>>>>            Move (left(sUrl,iPos)) to sValue
31053>>>>>>>>>>>>>>>            Move (replace(sValue,sUrl,"")) to sUrl
31054>>>>>>>>>>>>>>>            Get _FindUrlToken ":" sValue to iPos
31055>>>>>>>>>>>>>>>            If iPos Begin // User and Password
31057>>>>>>>>>>>>>>>                Move (left(sValue,iPos)) to sValue2
31058>>>>>>>>>>>>>>>                Get rRemove of oStringFunctions sValue2 1 to sStructUrl.sUser
31059>>>>>>>>>>>>>>>                Move (replace(sValue2,sValue,"")) to sValue
31060>>>>>>>>>>>>>>>                Get rRemove of oStringFunctions sValue 1 to sStructUrl.sPassword
31061>>>>>>>>>>>>>>>            End
31061>>>>>>>>>>>>>>>>
31061>>>>>>>>>>>>>>>            Else Begin // User without password
31062>>>>>>>>>>>>>>>                Get rRemove of oStringFunctions sValue 1 to sStructUrl.sUser
31063>>>>>>>>>>>>>>>            End
31063>>>>>>>>>>>>>>>>
31063>>>>>>>>>>>>>>>        End
31063>>>>>>>>>>>>>>>>
31063>>>>>>>>>>>>>>>
31063>>>>>>>>>>>>>>>        //   ftp://<user>:<password>@<host>:<port>/<url-path>;type=<typecode>
31063>>>>>>>>>>>>>>>
31063>>>>>>>>>>>>>>>        Get _FindUrlToken ";" sUrl to iPos // Type ?
31064>>>>>>>>>>>>>>>        If iPos Begin // Type!
31066>>>>>>>>>>>>>>>            Move (left(sUrl,iPos)) to sValue
31067>>>>>>>>>>>>>>>            Move (replace(sValue,sUrl,"")) to sUrl
31068>>>>>>>>>>>>>>>            Move sUrl to sStructUrl.sType
31069>>>>>>>>>>>>>>>            Get rRemove of oStringFunctions sValue 1 to sValue
31070>>>>>>>>>>>>>>>            Get _FindUrlToken "/" sValue to iPos // Path ?
31071>>>>>>>>>>>>>>>            If iPos Begin // Path! www.dataaccess.dk:80/magicpath/Images
31073>>>>>>>>>>>>>>>                Move (left(sValue,iPos-1)) to sValue2
31074>>>>>>>>>>>>>>>                Move (replace(sValue2,sValue,"")) to sStructUrl.sPath
31075>>>>>>>>>>>>>>>                Move sValue2 to sValue
31076>>>>>>>>>>>>>>>            End
31076>>>>>>>>>>>>>>>>
31076>>>>>>>>>>>>>>>            Get _FindUrlToken ":" sValue to iPos // Port ?
31077>>>>>>>>>>>>>>>            If iPos Begin // Port !  Dataaccess.kn:80
31079>>>>>>>>>>>>>>>                Move (left(sValue,iPos)) to sHost
31080>>>>>>>>>>>>>>>                Move (rRemove(oStringFunctions,sHost,1)) to sStructUrl.sHost
31081>>>>>>>>>>>>>>>                Move (replace(sHost,sValue,"")) to sStructUrl.sPort
31082>>>>>>>>>>>>>>>            End
31082>>>>>>>>>>>>>>>>
31082>>>>>>>>>>>>>>>            Else Move sValue to sStructUrl.sHost
31084>>>>>>>>>>>>>>>        End
31084>>>>>>>>>>>>>>>>
31084>>>>>>>>>>>>>>>        Else Begin
31085>>>>>>>>>>>>>>>            Get _FindUrlToken "/" sUrl to iPos // Path ?
31086>>>>>>>>>>>>>>>            If iPos Begin
31088>>>>>>>>>>>>>>>                Move sUrl to sValue
31089>>>>>>>>>>>>>>>
31089>>>>>>>>>>>>>>>                If iPos Begin // Path! www.dataaccess.dk:80/magicpath/Images
31091>>>>>>>>>>>>>>>                    Move (left(sValue,iPos-1)) to sValue2
31092>>>>>>>>>>>>>>>                    Move (replace(sValue2,sValue,"")) to sStructUrl.sPath
31093>>>>>>>>>>>>>>>                    Move sValue2 to sValue
31094>>>>>>>>>>>>>>>                End
31094>>>>>>>>>>>>>>>>
31094>>>>>>>>>>>>>>>                Get _FindUrlToken ":" sValue to iPos // Port ?
31095>>>>>>>>>>>>>>>                If iPos Begin // Port!  Dataaccess.kn:80
31097>>>>>>>>>>>>>>>                    Move (left(sValue,iPos)) to sHost
31098>>>>>>>>>>>>>>>                    Move (rRemove(oStringFunctions,sHost,1)) to sStructUrl.sHost
31099>>>>>>>>>>>>>>>                    Move (replace(sHost,sValue,"")) to sStructUrl.sPort
31100>>>>>>>>>>>>>>>                End
31100>>>>>>>>>>>>>>>>
31100>>>>>>>>>>>>>>>                Else Move sValue to sStructUrl.sHost
31102>>>>>>>>>>>>>>>            End
31102>>>>>>>>>>>>>>>>
31102>>>>>>>>>>>>>>>            Else Begin
31103>>>>>>>>>>>>>>>                Get _FindUrlToken ":" sUrl to iPos // Port?
31104>>>>>>>>>>>>>>>                If iPos Begin
31106>>>>>>>>>>>>>>>                    Move (left(sUrl,iPos)) to sValue
31107>>>>>>>>>>>>>>>                    Move (replace(sValue,sUrl,"")) to sUrl
31108>>>>>>>>>>>>>>>                    Move (rRemove(oStringFunctions,sValue,1)) to sStructUrl.sHost
31109>>>>>>>>>>>>>>>                    Move sUrl to sStructUrl.sPort
31110>>>>>>>>>>>>>>>                End
31110>>>>>>>>>>>>>>>>
31110>>>>>>>>>>>>>>>                Else Begin
31111>>>>>>>>>>>>>>>                    Move sUrl to sStructUrl.sHost
31112>>>>>>>>>>>>>>>                End
31112>>>>>>>>>>>>>>>>
31112>>>>>>>>>>>>>>>            End
31112>>>>>>>>>>>>>>>>
31112>>>>>>>>>>>>>>>        End
31112>>>>>>>>>>>>>>>>
31112>>>>>>>>>>>>>>>        Function_Return sStructUrl
31113>>>>>>>>>>>>>>>    End_Function
31114>>>>>>>>>>>>>>>
31114>>>>>>>>>>>>>>>    Function Compose tUrl sStructUrl Returns String
31116>>>>>>>>>>>>>>>        String sRval
31116>>>>>>>>>>>>>>>        If (sStructUrl.sProtocol<>"") Begin
31118>>>>>>>>>>>>>>>            Move (sStructUrl.sProtocol+"//") to sRval
31119>>>>>>>>>>>>>>>        End
31119>>>>>>>>>>>>>>>>
31119>>>>>>>>>>>>>>>
31119>>>>>>>>>>>>>>>        If (sStructUrl.sUser<>"") Begin
31121>>>>>>>>>>>>>>>            Move (sRval+sStructUrl.sUser) to sRval
31122>>>>>>>>>>>>>>>            If (sStructUrl.sPassword<>"") Move (sRval+":"+sStructUrl.sPassword) to sRval
31125>>>>>>>>>>>>>>>            Move (sRval+"@") to sRval
31126>>>>>>>>>>>>>>>        End
31126>>>>>>>>>>>>>>>>
31126>>>>>>>>>>>>>>>        Move (sRval+sStructUrl.sHost) to sRval
31127>>>>>>>>>>>>>>>        If (sStructUrl.sPort<>0) begin
31129>>>>>>>>>>>>>>>            Move (sRval+":"+String(sStructUrl.sPort)) to sRval
31130>>>>>>>>>>>>>>>        End
31130>>>>>>>>>>>>>>>>
31130>>>>>>>>>>>>>>>        If (sStructUrl.sPath<>"") Begin
31132>>>>>>>>>>>>>>>            If (left(sStructUrl.sPath,1)="/") Move (sRval+sStructUrl.sPath) to sRval
31135>>>>>>>>>>>>>>>            Else Move (sRval+"/"+sStructUrl.sPath) to sRval
31137>>>>>>>>>>>>>>>        End
31137>>>>>>>>>>>>>>>>
31137>>>>>>>>>>>>>>>        If (sStructUrl.sType<>"") Move (sRval+";"+sStructUrl.sType) to sRval
31140>>>>>>>>>>>>>>>        Function_Return sRval
31141>>>>>>>>>>>>>>>    End_Function
31142>>>>>>>>>>>>>>>
31142>>>>>>>>>>>>>>>    Function UrlCharacterEncode String sUrl Returns String
31144>>>>>>>>>>>>>>>        Integer iLen iPos
31144>>>>>>>>>>>>>>>        String sChar sHex sRval sOk
31144>>>>>>>>>>>>>>>        Move "0123456789" to sOk
31145>>>>>>>>>>>>>>>        Move (sOk+"abcdefghijklmnopqrstuvwxyz") to sOk
31146>>>>>>>>>>>>>>>        Move (sOk+"ABCDEFGHIJKLMNOPQRSTUVWXYZ") to sOk
31147>>>>>>>>>>>>>>>        Move (sOk+".-:;/+&#=?_") to sOk
31148>>>>>>>>>>>>>>>        Move (Length(sUrl)) to iLen
31149>>>>>>>>>>>>>>>        Move "" to sRval
31150>>>>>>>>>>>>>>>        For iPos from 1 to iLen
31156>>>>>>>>>>>>>>>>
31156>>>>>>>>>>>>>>>            Move (Mid(sUrl,1,iPos)) to sChar
31157>>>>>>>>>>>>>>>            If not (sOk contains sChar) Begin
31159>>>>>>>>>>>>>>>                Get ByteToHex of oStringFunctions (Ascii(sChar)) to sChar
31160>>>>>>>>>>>>>>>                Move ("%"+sChar) to sChar
31161>>>>>>>>>>>>>>>            End
31161>>>>>>>>>>>>>>>>
31161>>>>>>>>>>>>>>>            Move (sRval+sChar) to sRval
31162>>>>>>>>>>>>>>>        Loop
31163>>>>>>>>>>>>>>>>
31163>>>>>>>>>>>>>>>        Function_Return sRval
31164>>>>>>>>>>>>>>>    End_Function
31165>>>>>>>>>>>>>>>
31165>>>>>>>>>>>>>>>    //>
31165>>>>>>>>>>>>>>>    Function UrlCharacterDecode String sUrl Returns String
31167>>>>>>>>>>>>>>>        Integer iLen iPos
31167>>>>>>>>>>>>>>>        String sChar sHex sRval
31167>>>>>>>>>>>>>>>        Move (Length(sUrl)) to iLen
31168>>>>>>>>>>>>>>>        Move "" to sRval
31169>>>>>>>>>>>>>>>        Move 1 to iPos
31170>>>>>>>>>>>>>>>        While (iPos<=iLen)
31174>>>>>>>>>>>>>>>            Move (Mid(sUrl,1,iPos)) to sChar
31175>>>>>>>>>>>>>>>            Increment iPos
31176>>>>>>>>>>>>>>>            If (sChar="%") Begin
31178>>>>>>>>>>>>>>>                Move (Mid(sUrl,2,iPos)) to sHex
31179>>>>>>>>>>>>>>>                If (IsHex(oStringFunctions,sHex)) Begin
31181>>>>>>>>>>>>>>>                    Move (character(HexToByte(oStringFunctions,sHex))) to sChar
31182>>>>>>>>>>>>>>>                    Move (iPos+2) to iPos
31183>>>>>>>>>>>>>>>                End
31183>>>>>>>>>>>>>>>>
31183>>>>>>>>>>>>>>>            End
31183>>>>>>>>>>>>>>>>
31183>>>>>>>>>>>>>>>            Move (sRval+sChar) to sRval
31184>>>>>>>>>>>>>>>        Loop
31185>>>>>>>>>>>>>>>>
31185>>>>>>>>>>>>>>>        Function_Return sRval
31186>>>>>>>>>>>>>>>    End_Function
31187>>>>>>>>>>>>>>>
31187>>>>>>>>>>>>>>>    Function FileNameToUrl String sPath Returns String
31189>>>>>>>>>>>>>>>        Integer iItem iMax
31189>>>>>>>>>>>>>>>        String[] asPath
31190>>>>>>>>>>>>>>>        String sRval
31190>>>>>>>>>>>>>>>        Send SplitString of oStringFunctions sPath "\" True False (&asPath)
31191>>>>>>>>>>>>>>>        Move (SizeOfArray(asPath)) to iMax
31192>>>>>>>>>>>>>>>        If iMax Begin
31194>>>>>>>>>>>>>>>            Move asPath[0] to sRval // Should be the server
31195>>>>>>>>>>>>>>>            Decrement iMax
31196>>>>>>>>>>>>>>>            For iItem from 1 to iMax
31202>>>>>>>>>>>>>>>>
31202>>>>>>>>>>>>>>>                If (iItem<>iMax) begin
31204>>>>>>>>>>>>>>>                    Move (sRval+"/"+asPath[iItem]) to sRval
31205>>>>>>>>>>>>>>>                End
31205>>>>>>>>>>>>>>>>
31205>>>>>>>>>>>>>>>                Else begin
31206>>>>>>>>>>>>>>>                    Move (sRval+"/"+HexToString(oStringFunctions,asPath[iItem])) to sRval
31207>>>>>>>>>>>>>>>                End
31207>>>>>>>>>>>>>>>>
31207>>>>>>>>>>>>>>>            Loop
31208>>>>>>>>>>>>>>>>
31208>>>>>>>>>>>>>>>        End
31208>>>>>>>>>>>>>>>>
31208>>>>>>>>>>>>>>>        If (iMax<=0) begin
31210>>>>>>>>>>>>>>>            Move "" to sRval // There MUST be something more than the server
31211>>>>>>>>>>>>>>>        End
31211>>>>>>>>>>>>>>>>
31211>>>>>>>>>>>>>>>        Function_Return sRval
31212>>>>>>>>>>>>>>>    End_Function
31213>>>>>>>>>>>>>>>
31213>>>>>>>>>>>>>>>    Function UrlToFileName String sUrl Returns String
31215>>>>>>>>>>>>>>>        tUrl stUrl
31215>>>>>>>>>>>>>>>        tUrl stUrl
31215>>>>>>>>>>>>>>>        Integer iItem iMax
31215>>>>>>>>>>>>>>>        String[] asPath
31216>>>>>>>>>>>>>>>        String sRval
31216>>>>>>>>>>>>>>>        // First remove, protocol, user, pw and port
31216>>>>>>>>>>>>>>>        Get Decompose sUrl to stUrl
31217>>>>>>>>>>>>>>>        Move "" to stUrl.sProtocol
31218>>>>>>>>>>>>>>>        Move "" to stUrl.sPassword
31219>>>>>>>>>>>>>>>        Move "" to stUrl.sUser
31220>>>>>>>>>>>>>>>        Move "" to stUrl.sPort
31221>>>>>>>>>>>>>>>        Move "" to stUrl.sType
31222>>>>>>>>>>>>>>>        Get Compose stUrl to sUrl
31223>>>>>>>>>>>>>>>        // Then split value according to "/"'s
31223>>>>>>>>>>>>>>>        Send SplitString of oStringFunctions sUrl "/" True False (&asPath)
31224>>>>>>>>>>>>>>>        Move (SizeOfArray(asPath)) to iMax
31225>>>>>>>>>>>>>>>        If iMax Begin
31227>>>>>>>>>>>>>>>            Move asPath[0] to sRval // Should be the server
31228>>>>>>>>>>>>>>>            Decrement iMax
31229>>>>>>>>>>>>>>>            For iItem from 1 to iMax
31235>>>>>>>>>>>>>>>>
31235>>>>>>>>>>>>>>>                If (iItem<>iMax) begin
31237>>>>>>>>>>>>>>>                    Move (sRval+"\"+asPath[iItem]) to sRval
31238>>>>>>>>>>>>>>>                End
31238>>>>>>>>>>>>>>>>
31238>>>>>>>>>>>>>>>                Else begin
31239>>>>>>>>>>>>>>>                    Move (sRval+"\"+StringToHex(oStringFunctions,asPath[iItem])) to sRval
31240>>>>>>>>>>>>>>>                End
31240>>>>>>>>>>>>>>>>
31240>>>>>>>>>>>>>>>            Loop
31241>>>>>>>>>>>>>>>>
31241>>>>>>>>>>>>>>>        End
31241>>>>>>>>>>>>>>>>
31241>>>>>>>>>>>>>>>        If (iMax=0) begin
31243>>>>>>>>>>>>>>>            Move "" to sRval // There MUST be something more than the server
31244>>>>>>>>>>>>>>>        End
31244>>>>>>>>>>>>>>>>
31244>>>>>>>>>>>>>>>        Function_Return sRval
31245>>>>>>>>>>>>>>>    End_Function
31246>>>>>>>>>>>>>>>
31246>>>>>>>>>>>>>>>    Function SetOfUrls_IsMember String sUrl String[] aSetOfUrls Returns Integer
31248>>>>>>>>>>>>>>>        Integer iMax iUrl
31248>>>>>>>>>>>>>>>        Move (lowercase(sUrl)) to sUrl
31249>>>>>>>>>>>>>>>        Move (SizeOfArray(aSetOfUrls)) to iMax
31250>>>>>>>>>>>>>>>        Decrement iMax
31251>>>>>>>>>>>>>>>        For iUrl from 0 to iMax
31257>>>>>>>>>>>>>>>>
31257>>>>>>>>>>>>>>>            If (sUrl=lowercase(aSetOfUrls[iUrl])) Begin
31259>>>>>>>>>>>>>>>                Function_Return iUrl
31260>>>>>>>>>>>>>>>            End
31260>>>>>>>>>>>>>>>>
31260>>>>>>>>>>>>>>>        Loop
31261>>>>>>>>>>>>>>>>
31261>>>>>>>>>>>>>>>        Function_Return -1 // not found
31262>>>>>>>>>>>>>>>    End_Function
31263>>>>>>>>>>>>>>>
31263>>>>>>>>>>>>>>>    Procedure SetOfUrls_AddMember String sUrl String[] ByRef aSetOfUrls
31265>>>>>>>>>>>>>>>        If (SetOfUrls_IsMember(Self,sUrl,aSetOfUrls)<>-1) Begin
31267>>>>>>>>>>>>>>>            Move sUrl to aSetOfUrls[SizeOfArray(aSetOfUrls)]
31268>>>>>>>>>>>>>>>        End
31268>>>>>>>>>>>>>>>>
31268>>>>>>>>>>>>>>>    End_Procedure
31269>>>>>>>>>>>>>>>End_Class
31270>>>>>>>>>>>>>>>
31270>>>>>>>>>>>>>>>Object _oUrlFunctions is a cUrlFunctions
31272>>>>>>>>>>>>>>>    Move Self to oUrlFunctions
31273>>>>>>>>>>>>>>>End_Object
31274>>>>>>>>>>>>>
31274>>>>>>>>>>>>>Struct tYumlClass
31274>>>>>>>>>>>>>    String sLabel // Label of the entity
31274>>>>>>>>>>>>>    String sColor // Although faithfully carried around it is used for nothing
31274>>>>>>>>>>>>>End_Struct
31274>>>>>>>>>>>>>
31274>>>>>>>>>>>>>Struct tYumlClassRelation
31274>>>>>>>>>>>>>    Integer iType // 0=1:N, 1=1:N dotted, 2=1:1
31274>>>>>>>>>>>>>    Integer iFrom // From class (array index)
31274>>>>>>>>>>>>>    Integer iTo   // To class (array index)
31274>>>>>>>>>>>>>    Boolean bMark // Mark the relation with an *. I use that to mark constrained relations
31274>>>>>>>>>>>>>End_Struct
31274>>>>>>>>>>>>>
31274>>>>>>>>>>>>>Struct tYumlClassDiagram
31274>>>>>>>>>>>>>    Integer iScalePct
31274>>>>>>>>>>>>>    Integer iForceDirection  // 0=no force, 1=left-right, 2=top-down
31274>>>>>>>>>>>>>    Integer iImageType       // 1=jpg 2=pdf
31274>>>>>>>>>>>>>    Boolean bScruffy         // makes it look a little hand drawn. but just a little
31274>>>>>>>>>>>>>    String sNote             // A note that is inserted into the diagram
31274>>>>>>>>>>>>>    tYumlClass[] aClasses            // The classes (entities)
31274>>>>>>>>>>>>>    tYumlClass[] aClasses            // The classes (entities)
31274>>>>>>>>>>>>>    tYumlClassRelation[] aRelations  // And the relations between them.
31274>>>>>>>>>>>>>    tYumlClassRelation[] aRelations  // And the relations between them.
31274>>>>>>>>>>>>>End_Struct
31274>>>>>>>>>>>>>
31274>>>>>>>>>>>>>Class cYumlFunctions is a cObject
31275>>>>>>>>>>>>>    Procedure Construct_Object
31277>>>>>>>>>>>>>        Forward Send Construct_Object
31279>>>>>>>>>>>>>        Object oHttpTransfer is a cHttpTransfer
31281>>>>>>>>>>>>>            Set psRemoteHost to "yuml.me"
31282>>>>>>>>>>>>>        End_Object
31283>>>>>>>>>>>>>    End_Procedure
31284>>>>>>>>>>>>>    
31284>>>>>>>>>>>>>    Function NewDiagram Returns tYumlClassDiagram
31286>>>>>>>>>>>>>        tYumlClassDiagram strDiagram
31286>>>>>>>>>>>>>        tYumlClassDiagram strDiagram
31286>>>>>>>>>>>>>        Move 100 to strDiagram.iScalePct
31287>>>>>>>>>>>>>        Move 0 to strDiagram.iForceDirection
31288>>>>>>>>>>>>>        Move 0 to strDiagram.iImageType
31289>>>>>>>>>>>>>        Move False to strDiagram.bScruffy
31290>>>>>>>>>>>>>        Function_Return strDiagram
31291>>>>>>>>>>>>>    End_Function
31292>>>>>>>>>>>>>    
31292>>>>>>>>>>>>>        Function _FindClassLabelIndex tYumlClassDiagram strDiagram String sLabel Returns Integer
31294>>>>>>>>>>>>>            Integer iMax iIndex
31294>>>>>>>>>>>>>            Move (SizeOfArray(strDiagram.aClasses)-1) to iMax
31295>>>>>>>>>>>>>            For iIndex from 0 to iMax
31301>>>>>>>>>>>>>>
31301>>>>>>>>>>>>>                If (sLabel=strDiagram.aClasses[iIndex].sLabel) Begin
31303>>>>>>>>>>>>>                    Function_Return iIndex
31304>>>>>>>>>>>>>                End
31304>>>>>>>>>>>>>>
31304>>>>>>>>>>>>>            Loop
31305>>>>>>>>>>>>>>
31305>>>>>>>>>>>>>            Function_Return -1
31306>>>>>>>>>>>>>        End_Function
31307>>>>>>>>>>>>>        
31307>>>>>>>>>>>>>    Procedure SetClassColor tYumlClassDiagram ByRef strDiagram String sLabel String sColor
31309>>>>>>>>>>>>>        Integer iIndex
31309>>>>>>>>>>>>>        Get _FindClassLabelIndex strDiagram sLabel to iIndex
31310>>>>>>>>>>>>>        If (iIndex<>-1) Begin
31312>>>>>>>>>>>>>            Move sColor to strDiagram.aClasses[iIndex].sColor
31313>>>>>>>>>>>>>        End
31313>>>>>>>>>>>>>>
31313>>>>>>>>>>>>>        Else Begin
31314>>>>>>>>>>>>>            Error DFERR_PROGRAM ("yUML class label not found ("+sLabel+")")
31315>>>>>>>>>>>>>>
31315>>>>>>>>>>>>>        End
31315>>>>>>>>>>>>>>
31315>>>>>>>>>>>>>    End_Procedure
31316>>>>>>>>>>>>>    
31316>>>>>>>>>>>>>    Procedure AddClass tYumlClassDiagram ByRef strDiagram String sLabel
31318>>>>>>>>>>>>>        Integer iIndex
31318>>>>>>>>>>>>>        Get _FindClassLabelIndex strDiagram sLabel to iIndex
31319>>>>>>>>>>>>>        If (iIndex=-1) Begin
31321>>>>>>>>>>>>>            Move (SizeOfArray(strDiagram.aClasses)) to iIndex
31322>>>>>>>>>>>>>            Move sLabel to strDiagram.aClasses[iIndex].sLabel
31323>>>>>>>>>>>>>        End
31323>>>>>>>>>>>>>>
31323>>>>>>>>>>>>>    End_Procedure
31324>>>>>>>>>>>>>    
31324>>>>>>>>>>>>>    Procedure AddRelation tYumlClassDiagram ByRef strDiagram String sFrom String sTo Boolean bMark
31326>>>>>>>>>>>>>        Integer iFromIndex iToIndex iIndex
31326>>>>>>>>>>>>>        Send AddClass (&strDiagram) sFrom
31327>>>>>>>>>>>>>        Send AddClass (&strDiagram) sTo
31328>>>>>>>>>>>>>        Get _FindClassLabelIndex strDiagram sFrom to iFromIndex
31329>>>>>>>>>>>>>        Get _FindClassLabelIndex strDiagram sTo to iToIndex
31330>>>>>>>>>>>>>        Move (SizeOfArray(strDiagram.aRelations)) to iIndex
31331>>>>>>>>>>>>>        Move iFromIndex to strDiagram.aRelations[iIndex].iFrom
31332>>>>>>>>>>>>>        Move iToIndex to strDiagram.aRelations[iIndex].iTo
31333>>>>>>>>>>>>>        If (num_arguments>3) Begin
31335>>>>>>>>>>>>>            Move bMark to strDiagram.aRelations[iIndex].bMark
31336>>>>>>>>>>>>>        End
31336>>>>>>>>>>>>>>
31336>>>>>>>>>>>>>    End_Procedure
31337>>>>>>>>>>>>>    
31337>>>>>>>>>>>>>//        Function _DiagramUrlRelation tYumlClassDiagram strDiagram Integer iRelIndex Returns String
31337>>>>>>>>>>>>>//            String sLabelFrom sLabelTo sRval
31337>>>>>>>>>>>>>//
31337>>>>>>>>>>>>>//            Move ("["+strDiagram.aClasses[strDiagram.aRelations[iRelIndex].iFrom].sLabel+"]") to sRval
31337>>>>>>>>>>>>>//
31337>>>>>>>>>>>>>//            If (strDiagram.aRelations[iRelIndex].iType=0) Begin // 1:N
31337>>>>>>>>>>>>>//                Move (sRval+"->") to sRval
31337>>>>>>>>>>>>>//            End
31337>>>>>>>>>>>>>//            Else If (strDiagram.aRelations[iRelIndex].iType=1) Begin // 1:N dotted
31337>>>>>>>>>>>>>//                Move (sRval+"-.->") to sRval
31337>>>>>>>>>>>>>//            End
31337>>>>>>>>>>>>>//
31337>>>>>>>>>>>>>//            Move (sRval+"["+strDiagram.aClasses[strDiagram.aRelations[iRelIndex].iTo].sLabel+"]") to sRval
31337>>>>>>>>>>>>>//
31337>>>>>>>>>>>>>//            Function_Return sRval
31337>>>>>>>>>>>>>//        End_Function
31337>>>>>>>>>>>>>    
31337>>>>>>>>>>>>>        Function _DiagramUrlRelation tYumlClassDiagram strDiagram Integer iRelIndex Returns String
31339>>>>>>>>>>>>>            String sLabelFrom sLabelTo sRval
31339>>>>>>>>>>>>>
31339>>>>>>>>>>>>>
31339>>>>>>>>>>>>>            Move ("["+strDiagram.aClasses[strDiagram.aRelations[iRelIndex].iTo].sLabel+"]") to sRval
31340>>>>>>>>>>>>>
31340>>>>>>>>>>>>>            If (strDiagram.aRelations[iRelIndex].iType=0) Begin // 1:N
31342>>>>>>>>>>>>>                Move (sRval+"^-") to sRval
31343>>>>>>>>>>>>>            End
31343>>>>>>>>>>>>>>
31343>>>>>>>>>>>>>            Else If (strDiagram.aRelations[iRelIndex].iType=1) Begin // 1:N dotted
31346>>>>>>>>>>>>>//                Move (sRval+"-.->") to sRval
31346>>>>>>>>>>>>>            End
31346>>>>>>>>>>>>>>
31346>>>>>>>>>>>>>            If (strDiagram.aRelations[iRelIndex].bMark) Begin
31348>>>>>>>>>>>>>                Move (sRval+"*") to sRval
31349>>>>>>>>>>>>>            End
31349>>>>>>>>>>>>>>
31349>>>>>>>>>>>>>
31349>>>>>>>>>>>>>            Move (sRval+"["+strDiagram.aClasses[strDiagram.aRelations[iRelIndex].iFrom].sLabel+"]") to sRval
31350>>>>>>>>>>>>>
31350>>>>>>>>>>>>>            Function_Return sRval
31351>>>>>>>>>>>>>        End_Function
31352>>>>>>>>>>>>>    
31352>>>>>>>>>>>>>    Function DiagramUrl tYumlClassDiagram strDiagram Returns String
31354>>>>>>>>>>>>>        Integer iRelIndex iRelMax
31354>>>>>>>>>>>>>        String sUrl
31354>>>>>>>>>>>>>        
31354>>>>>>>>>>>>>        If (strDiagram.bScruffy) Begin
31356>>>>>>>>>>>>>            Move "http://yuml.me/diagram/scruffy/class/" to sUrl
31357>>>>>>>>>>>>>        End
31357>>>>>>>>>>>>>>
31357>>>>>>>>>>>>>        Else Begin    
31358>>>>>>>>>>>>>            Move "http://yuml.me/diagram/dir:td/class/" to sUrl
31359>>>>>>>>>>>>>        End
31359>>>>>>>>>>>>>>
31359>>>>>>>>>>>>>        
31359>>>>>>>>>>>>>        If (strDiagram.sNote<>"") Begin
31361>>>>>>>>>>>>>            Move (sUrl+"[note:"+strDiagram.sNote+"],") to sUrl
31362>>>>>>>>>>>>>        End
31362>>>>>>>>>>>>>>
31362>>>>>>>>>>>>>        
31362>>>>>>>>>>>>>        // Add all relations
31362>>>>>>>>>>>>>        Move (SizeOfArray(strDiagram.aRelations)-1) to iRelMax
31363>>>>>>>>>>>>>        For iRelIndex from 0 to iRelMax
31369>>>>>>>>>>>>>>
31369>>>>>>>>>>>>>            Move (sUrl+_DiagramUrlRelation(Self,strDiagram,iRelIndex)) to sUrl
31370>>>>>>>>>>>>>            If (iRelIndex<>iRelMax) Begin
31372>>>>>>>>>>>>>                Move (sUrl+",") to sUrl
31373>>>>>>>>>>>>>            End
31373>>>>>>>>>>>>>>
31373>>>>>>>>>>>>>        Loop
31374>>>>>>>>>>>>>>
31374>>>>>>>>>>>>>        
31374>>>>>>>>>>>>>        // Add alias file indications here
31374>>>>>>>>>>>>>        
31374>>>>>>>>>>>>>        
31374>>>>>>>>>>>>>        If (strDiagram.iImageType=1) Begin
31376>>>>>>>>>>>>>            Move (sUrl+".jpg") to sUrl
31377>>>>>>>>>>>>>        End
31377>>>>>>>>>>>>>>
31377>>>>>>>>>>>>>        Else If (strDiagram.iImageType=2) Begin
31380>>>>>>>>>>>>>            Move (sUrl+".pdf") to sUrl
31381>>>>>>>>>>>>>        End
31381>>>>>>>>>>>>>>
31381>>>>>>>>>>>>>        
31381>>>>>>>>>>>>>//        Get UrlCharacterEncode of oUrlFunctions sUrl to sUrl
31381>>>>>>>>>>>>>        
31381>>>>>>>>>>>>>        Function_Return sUrl
31382>>>>>>>>>>>>>    End_Function
31383>>>>>>>>>>>>>    
31383>>>>>>>>>>>>>    Function SaveJpgAs tYumlClassDiagram strDiagram String sJpgFileName Returns Boolean
31385>>>>>>>>>>>>>        Integer iVal
31385>>>>>>>>>>>>>        String sUrl
31385>>>>>>>>>>>>>        Set psSaveAsFile of oHttpTransfer to sJpgFileName
31386>>>>>>>>>>>>>        Get DiagramUrl strDiagram to sUrl
31387>>>>>>>>>>>>>        Get HTTPGetRequest of oHttpTransfer (Replace("http://yuml.me",sUrl,"")) to iVal
31388>>>>>>>>>>>>>        Function_Return (iVal<>0)
31389>>>>>>>>>>>>>    End_Function
31390>>>>>>>>>>>>>    
31390>>>>>>>>>>>>>End_Class // cYumlFunctions
31391>>>>>>>>>>>>>
31391>>>>>>>>>>>>>Global_Variable Integer oYumlFunctions
31391>>>>>>>>>>>>>
31391>>>>>>>>>>>>>Object _oYumlFunctions is a cYumlFunctions
31393>>>>>>>>>>>>>    Move Self to oYumlFunctions
31394>>>>>>>>>>>>>End_Object
31395>>>>>>>>>>>Use FileFunctions.pkg // Define oFileFunctions object
Including file: FileFunctions.pkg    (Z:\VmShare\Projects\WebQuery18-0\StureApsPublicLib\AppSrc\FileFunctions.pkg)
31395>>>>>>>>>>>>>// File functions encapsulated in oFileFunctions (SturesPublicLib)
31395>>>>>>>>>>>>>
31395>>>>>>>>>>>>>//> The oFileFunctions object contains methods for handling input/output and for manipulating file and folder names.
31395>>>>>>>>>>>>>//> pkg.doc.end
31395>>>>>>>>>>>>>
31395>>>>>>>>>>>>>Use VdfBase.pkg // DAW package. Provides low level support expected of all VDF applications (windows and webapp)
31395>>>>>>>>>>>>>
31395>>>>>>>>>>>>>Use StringFunctions.pkg // Define oStringFunctions object
31395>>>>>>>>>>>>>Use WindowsInfo.pkg     // NetworkUserName function
Including file: WindowsInfo.pkg    (Z:\VmShare\Projects\WebQuery18-0\StureApsPublicLib\AppSrc\WindowsInfo.pkg)
31395>>>>>>>>>>>>>>>//> The WindowsInfo object contains methods for querying Windows about this and that.
31395>>>>>>>>>>>>>>>//> pkg.doc.end
31395>>>>>>>>>>>>>>>
31395>>>>>>>>>>>>>>>Use VdfBase.pkg // DAW package. Provides low level support expected of all VDF applications (windows and webapp)
31395>>>>>>>>>>>>>>>Use GlobalFunctionsProcedures.pkg
31395>>>>>>>>>>>>>>>
31395>>>>>>>>>>>>>>>External_Function wi_WNetGetUser "WNetGetUserA" MPR.DLL Pointer lpName Pointer lpUser_Name Pointer lpLength Returns DWord
31396>>>>>>>>>>>>>>>
31396>>>>>>>>>>>>>>>External_Function wi_InternetGetConnectedState "InternetGetConnectedState" WinInet.dll Pointer lpdwFlags Integer dwReserved Returns Integer
31397>>>>>>>>>>>>>>>
31397>>>>>>>>>>>>>>>External_Function wi_WinAPI_GetDefaultPrinter "GetDefaultPrinterA" Winspool.Drv Address pszBuffer UInteger pcchBuffer Returns Boolean
31398>>>>>>>>>>>>>>>External_Function wi_WinAPI_SetDefaultPrinter "SetDefaultPrinterA" Winspool.Drv Address pszBuffer Returns Boolean
31399>>>>>>>>>>>>>>>External_Function wi_WinAPI_GetComputerName   "GetComputerNameA"   Kernel32.dll Pointer lpBuffer Pointer lpnSize Returns Integer
31400>>>>>>>>>>>>>>>
31400>>>>>>>>>>>>>>>
31400>>>>>>>>>>>>>>>Global_Variable Integer oWindowsInfo
31400>>>>>>>>>>>>>>>
31400>>>>>>>>>>>>>>>Object _oWindowsInfo is a cObject
31402>>>>>>>>>>>>>>>    Move Self to oWindowsInfo
31403>>>>>>>>>>>>>>>
31403>>>>>>>>>>>>>>>    // All of the printer stuff has been copied (and modified) from Vincents: http://www.dataaccess.com/kbasepublic/KBPrint.asp?ArticleID=2322
31403>>>>>>>>>>>>>>>
31403>>>>>>>>>>>>>>>    Function Printer_Default Returns String
31406>>>>>>>>>>>>>>>        String sPrinterName
31406>>>>>>>>>>>>>>>        Integer iBufferSize
31406>>>>>>>>>>>>>>>        Boolean bSuccess
31406>>>>>>>>>>>>>>>
31406>>>>>>>>>>>>>>>        Move 0 to iBufferSize
31407>>>>>>>>>>>>>>>        Move (wi_WinAPI_GetDefaultPrinter(0,AddressOf(iBufferSize))) to bSuccess
31408>>>>>>>>>>>>>>>        If (not (bSuccess)) Begin
31410>>>>>>>>>>>>>>>            ZeroString iBufferSize to sPrinterName
31411>>>>>>>>>>>>>>>            Move (wi_WinAPI_GetDefaultPrinter(AddressOf(sPrinterName),AddressOf(iBufferSize))) to bSuccess
31412>>>>>>>>>>>>>>>        End
31412>>>>>>>>>>>>>>>>
31412>>>>>>>>>>>>>>>
31412>>>>>>>>>>>>>>>        Move (CString(sPrinterName)) to sPrinterName
31413>>>>>>>>>>>>>>>        Move (ToOEM(sPrinterName)) to sPrinterName // Sture
31414>>>>>>>>>>>>>>>        Function_Return sPrinterName
31415>>>>>>>>>>>>>>>    End_Function
31416>>>>>>>>>>>>>>>
31416>>>>>>>>>>>>>>>    Function Printer_SetDefault String sPrinterName Returns Boolean
31419>>>>>>>>>>>>>>>        Boolean bSuccess
31419>>>>>>>>>>>>>>>        Move (ToANSI(sPrinterName)) to sPrinterName // Sture
31420>>>>>>>>>>>>>>>        Move (wi_WinAPI_SetDefaultPrinter(AddressOf(sPrinterName))) to bSuccess
31421>>>>>>>>>>>>>>>        Function_Return bSuccess
31422>>>>>>>>>>>>>>>    End_Function
31423>>>>>>>>>>>>>>>
31423>>>>>>>>>>>>>>>    Function NetworkUserName Returns String // Stolen from Dfabout.pkg
31426>>>>>>>>>>>>>>>        String sName
31426>>>>>>>>>>>>>>>        Integer iRetval iLength
31426>>>>>>>>>>>>>>>        ZeroString 255 to sName
31427>>>>>>>>>>>>>>>        Move 255 to iLength
31428>>>>>>>>>>>>>>>        Move (wi_WNetGetUser (0, AddressOf (sName), AddressOf (iLength))) to iRetval
31429>>>>>>>>>>>>>>>        If (iRetval = 0) Begin
31431>>>>>>>>>>>>>>>            Function_Return (CString (sName))
31432>>>>>>>>>>>>>>>        End
31432>>>>>>>>>>>>>>>>
31432>>>>>>>>>>>>>>>        Else Begin
31433>>>>>>>>>>>>>>>            Function_Return "User unknown"
31434>>>>>>>>>>>>>>>        End
31434>>>>>>>>>>>>>>>>
31434>>>>>>>>>>>>>>>    End_Function // Network_User_Name
31435>>>>>>>>>>>>>>>
31435>>>>>>>>>>>>>>>    Define wi_INTERNET_CONNECTION_MODEM        For 1
31435>>>>>>>>>>>>>>>    Define wi_INTERNET_CONNECTION_LAN          For 2
31435>>>>>>>>>>>>>>>    Define wi_INTERNET_CONNECTION_PROXY        For 4
31435>>>>>>>>>>>>>>>    Define wi_INTERNET_CONNECTION_MODEM_BUSY   For 8
31435>>>>>>>>>>>>>>>
31435>>>>>>>>>>>>>>>    Function InternetConnectedState Returns Integer
31438>>>>>>>>>>>>>>>        // Thanks to Raveen Ryan Sundram!
31438>>>>>>>>>>>>>>>
31438>>>>>>>>>>>>>>>        Integer iFlags iRet
31438>>>>>>>>>>>>>>>        Pointer lpdwFlags
31438>>>>>>>>>>>>>>>
31438>>>>>>>>>>>>>>>        Move 0 To iFlags
31439>>>>>>>>>>>>>>>        GetAddress Of iFlags To lpdwFlags
31440>>>>>>>>>>>>>>>        Move (wi_InternetGetConnectedState(lpdwFlags,0)) To iRet
31441>>>>>>>>>>>>>>>        If (iRet) Begin // Connected!
31443>>>>>>>>>>>>>>>          If (iFlags Iand wi_INTERNET_CONNECTION_MODEM) Begin
31445>>>>>>>>>>>>>>>              Function_Return wi_INTERNET_CONNECTION_MODEM      //  'Connection via MODEM'
31446>>>>>>>>>>>>>>>          End
31446>>>>>>>>>>>>>>>>
31446>>>>>>>>>>>>>>>          If (iFlags Iand wi_INTERNET_CONNECTION_LAN) Begin
31448>>>>>>>>>>>>>>>              Function_Return wi_INTERNET_CONNECTION_LAN        //  'Connection via LAN'
31449>>>>>>>>>>>>>>>          End
31449>>>>>>>>>>>>>>>>
31449>>>>>>>>>>>>>>>          If (iFlags Iand wi_INTERNET_CONNECTION_PROXY) Begin
31451>>>>>>>>>>>>>>>              Function_Return wi_INTERNET_CONNECTION_PROXY      //  'Connection via PROXY'
31452>>>>>>>>>>>>>>>          End
31452>>>>>>>>>>>>>>>>
31452>>>>>>>>>>>>>>>          If (iFlags Iand wi_INTERNET_CONNECTION_MODEM_BUSY) Begin
31454>>>>>>>>>>>>>>>              Function_Return wi_INTERNET_CONNECTION_MODEM_BUSY //  'Connection via MODEM but modem is BUSY'
31455>>>>>>>>>>>>>>>          End
31455>>>>>>>>>>>>>>>>
31455>>>>>>>>>>>>>>>        End
31455>>>>>>>>>>>>>>>>
31455>>>>>>>>>>>>>>>        Function_Return 0 // Not connected
31456>>>>>>>>>>>>>>>    End_Function
31457>>>>>>>>>>>>>>>
31457>>>>>>>>>>>>>>>    Function ComputerName Returns String
31460>>>>>>>>>>>>>>>        String sMachineName
31460>>>>>>>>>>>>>>>        Integer iSize iResult
31460>>>>>>>>>>>>>>>
31460>>>>>>>>>>>>>>>        Move 16 to iSize //Maximum Computer name length + 1
31461>>>>>>>>>>>>>>>        Move (repeat(Character(0),iSize)) to sMachineName
31462>>>>>>>>>>>>>>>
31462>>>>>>>>>>>>>>>        Move (wi_WinAPI_GetComputerName(AddressOf(sMachineName), AddressOf(iSize))) to iResult
31463>>>>>>>>>>>>>>>        
31463>>>>>>>>>>>>>>>        Move (CString(sMachineName)) to sMachineName
31464>>>>>>>>>>>>>>>        
31464>>>>>>>>>>>>>>>        Function_Return sMachineName
31465>>>>>>>>>>>>>>>    End_Function
31466>>>>>>>>>>>>>>>
31466>>>>>>>>>>>>>>>
31466>>>>>>>>>>>>>>>End_Object
31467>>>>>>>>>>>>>
31467>>>>>>>>>>>>>Use GlobalFunctionsProcedures.pkg // Global functions by DAW
31467>>>>>>>>>>>>>Use Seq_Chnl // Defines global sequential device management operations (DAW)
31467>>>>>>>>>>>>>
31467>>>>>>>>>>>>>
31467>>>>>>>>>>>>>// File attributes
31467>>>>>>>>>>>>>Define C_MAX_PATH                 for 260
31467>>>>>>>>>>>>>Define C_MAXDWORD                 for |CI$FFFFFFFF
31467>>>>>>>>>>>>>Define C_INVALID_HANDLE_VALUE     for -1
31467>>>>>>>>>>>>>Define C_FILE_ATTRIBUTE_READONLY  for |CI$00000001
31467>>>>>>>>>>>>>Define C_FILE_ATTRIBUTE_HIDDEN    for |CI$00000002
31467>>>>>>>>>>>>>Define C_FILE_ATTRIBUTE_SYSTEM    for |CI$00000004
31467>>>>>>>>>>>>>Define C_FILE_ATTRIBUTE_DIRECTORY for |CI$00000010
31467>>>>>>>>>>>>>Define C_FILE_ATTRIBUTE_ARCHIVE   for |CI$00000020
31467>>>>>>>>>>>>>Define C_FILE_ATTRIBUTE_NORMAL    for |CI$00000080
31467>>>>>>>>>>>>>Define C_FILE_ATTRIBUTE_TEMPORARY for |CI$00000100
31467>>>>>>>>>>>>>
31467>>>>>>>>>>>>>// File operations flag
31467>>>>>>>>>>>>>Define C_MULTIDESTFILES    for |CI$0001  // The Destination property specifies multiple destination files (one for each source file) rather than one directory where all source files are to be deposited.
31467>>>>>>>>>>>>>Define C_CONFIRMMOUSE      for |CI$0002
31467>>>>>>>>>>>>>Define C_SILENT            for |CI$0004  // Do not display a progress dialog box.
31467>>>>>>>>>>>>>Define C_RENAMEONCOLLISION for |CI$0008
31467>>>>>>>>>>>>>Define C_NOCONFIRMATION    for |CI$0010  // Respond with "Yes to All" for any dialog box that is displayed.
31467>>>>>>>>>>>>>Define C_WANTMAPPINGHANDLE for |CI$0020  // Fill in SHFILEOPSTRUCT.hNameMappings (must be freed using SHFreeNameMappings)
31467>>>>>>>>>>>>>Define C_ALLOWUNDO         for |CI$0040  // Preserve Undo information, if possible. If Source property does not contain fully qualified path and file names, this flag is ignored.
31467>>>>>>>>>>>>>Define C_FILESONLY         for |CI$0080  // Perform the operation on files only if a wildcard file name (*.*) is specified.
31467>>>>>>>>>>>>>Define C_SIMPLEPROGRESS    for |CI$0100  // Display a progress dialog box but do not show the file names.
31467>>>>>>>>>>>>>Define C_NOCONFIRMMKDIR    for |CI$0200  // Do not confirm the creation of a new directory if the operation requires one to be created.
31467>>>>>>>>>>>>>Define C_NOERRORUI         for |CI$0400  // Do not display a user interface if an error occurs.
31467>>>>>>>>>>>>>
31467>>>>>>>>>>>>>// File operations
31467>>>>>>>>>>>>>Define CFO_MOVE            for |CI$0001
31467>>>>>>>>>>>>>Define CFO_COPY            for |CI$0002
31467>>>>>>>>>>>>>Define CFO_DELETE          for |CI$0003
31467>>>>>>>>>>>>>Define CFO_RENAME          for |CI$0004
31467>>>>>>>>>>>>>
31467>>>>>>>>>>>>>//> The CSIDL symbols correspond to either file system or virtual folders.
31467>>>>>>>>>>>>>//> Where the CSIDL identifies a file system folder, a commonly used path
31467>>>>>>>>>>>>>//> is given as an example. Other paths may be used. Some CSIDLs can be
31467>>>>>>>>>>>>>//> mapped to an equivalent %VariableName% environment variable.
31467>>>>>>>>>>>>>//> CSIDLs are much more reliable, however, and should be used if at all possible.
31467>>>>>>>>>>>>>//>
31467>>>>>>>>>>>>>//> The symbols are used as parameter to the WinFolderPath function (WinFolderPath).
31467>>>>>>>>>>>>>Enum_List
31467>>>>>>>>>>>>>    Define CSIDL_ADMINTOOLS              for |CI$0030 //> File system directory that is used to store administrative tools for an individual user. The Microsoft Management Console will save customized consoles to this directory and it will roam with the user. (Version 5.0)
31467>>>>>>>>>>>>>    Define CSIDL_ALTSTARTUP              for |CI$001D //> File system directory that corresponds to the user's nonlocalized Startup program group.
31467>>>>>>>>>>>>>    Define CSIDL_APPDATA                 for |CI$001A //> File system directory that serves as a common repository for application-specific data. A typical path is C:\Documents and Settings\username\Application Data. This CSIDL is supported by the redistributable ShFolder.dll for systems that do not have the Internet Explorer 4.0 integrated shell installed. (Version 4.71)
31467>>>>>>>>>>>>>    Define CSIDL_BITBUCKET               for |CI$000A //> Virtual folder containing the objects in the user's Recycle Bin.
31467>>>>>>>>>>>>>    Define CSIDL_COMMON_ADMINTOOLS       for |CI$002F //> File system directory containing containing administrative tools for all users of the computer. Version 5
31467>>>>>>>>>>>>>    Define CSIDL_COMMON_ALTSTARTUP       for |CI$001E //> File system directory that corresponds to the nonlocalized Startup program group for all users. Valid only for Windows NT systems.
31467>>>>>>>>>>>>>    Define CSIDL_COMMON_APPDATA          for |CI$0023 //> Application data for all users. A typical path is C:\Documents and Settings\All Users\Application Data. Version 5
31467>>>>>>>>>>>>>    Define CSIDL_COMMON_DESKTOPDIRECTORY for |CI$0019 //> File system directory that contains files and folders that appear on the desktop for all users. A typical path is C:\Documents and Settings\All Users\Desktop. Valid only for Windows NT systems.
31467>>>>>>>>>>>>>    Define CSIDL_COMMON_DOCUMENTS        for |CI$002E //> File system directory that contains documents that are common to all users. A typical path is C:\Documents and Settings\All Users\Documents. Valid for Windows NT systems and Windows 95 and Windows 98 systems with Shfolder.dll installed.
31467>>>>>>>>>>>>>    Define CSIDL_COMMON_FAVORITES        for |CI$001F //> File system directory that serves as a common repository for all users' favorite items. Valid only for Windows NT systems.
31467>>>>>>>>>>>>>    Define CSIDL_COMMON_PROGRAMS         for |CI$0017 //> File system directory that contains the directories for the common program groups that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs. Valid only for Windows NT systems.
31467>>>>>>>>>>>>>    Define CSIDL_COMMON_STARTMENU        for |CI$0016 //> File system directory that contains the programs and folders that appear on the Start menu for all users. A typical path is C:\Documents and Settings\All Users\Start Menu. Valid only for Windows NT systems.
31467>>>>>>>>>>>>>    Define CSIDL_COMMON_STARTUP          for |CI$0018 //> File system directory that contains the programs that appear in the Startup folder for all users. A typical path is C:\Documents and Settings\All Users\Start Menu\Programs\Startup. Valid only for Windows NT systems.
31467>>>>>>>>>>>>>    Define CSIDL_COMMON_TEMPLATES        for |CI$002D //> File system directory that contains the templates that are available to all users. A typical path is C:\Documents and Settings\All Users\Templates. Valid only for Windows NT systems.
31467>>>>>>>>>>>>>    Define CSIDL_CONTROLS                for |CI$0003 //> Virtual folder containing icons for the Control Panel applications.
31467>>>>>>>>>>>>>    Define CSIDL_COOKIES                 for |CI$0021 //> File system directory that serves as a common repository for Internet cookies. A typical path is C:\Documents and Settings\username\Cookies.
31467>>>>>>>>>>>>>    Define CSIDL_DESKTOP                 for |CI$0000 //> Windows Desktop-virtual folder that is the root of the namespace..
31467>>>>>>>>>>>>>    Define CSIDL_DESKTOPDIRECTORY        for |CI$0010 //> File system directory used to physically store file objects on the desktop (not to be confused with the desktop folder itself). a typical path is C:\Documents and Settings\username\Desktop
31467>>>>>>>>>>>>>    Define CSIDL_DRIVES                  for |CI$0011 //> My Computer-virtual folder containing everything on the local computer: storage devices, printers, and Control Panel. The folder may also contain mapped network drives.
31467>>>>>>>>>>>>>    Define CSIDL_FAVORITES               for |CI$0006 //> File system directory that serves as a common repository for the user's favorite items. A typical path is C:\Documents and Settings\username\Favorites.
31467>>>>>>>>>>>>>    Define CSIDL_FONTS                   for |CI$0014 //> Virtual folder containing fonts. A typical path is C:\WINNT\Fonts.
31467>>>>>>>>>>>>>    Define CSIDL_HISTORY                 for |CI$0022 //> File system directory that serves as a common repository for Internet history items.
31467>>>>>>>>>>>>>    Define CSIDL_INTERNET                for |CI$0001 //> Virtual folder representing the Internet.
31467>>>>>>>>>>>>>    Define CSIDL_INTERNET_CACHE          for |CI$0020 //> File system directory that serves as a common repository for temporary Internet files. A typical path is C:\Documents and Settings\username\Temporary Internet Files.
31467>>>>>>>>>>>>>    Define CSIDL_LOCAL_APPDATA           for |CI$001C //> File system directory that serves as a data repository for local (non-roaming) applications. A typical path is C:\Documents and Settings\username\Local Settings\Application Data. Version 5
31467>>>>>>>>>>>>>    Define CSIDL_MYPICTURES              for |CI$0027 //> My Pictures folder. A typical path is C:\Documents and Settings\username\My Documents\My Pictures. Version 5
31467>>>>>>>>>>>>>    Define CSIDL_NETHOOD                 for |CI$0013 //> A file system folder containing the link objects that may exist in the My Network Places virtual folder. It is not the same as CSIDL_NETWORK, which represents the network namespace root. A typical path is C:\Documents and Settings\username\NetHood.
31467>>>>>>>>>>>>>    Define CSIDL_NETWORK                 for |CI$0012 //> Network Neighborhood-virtual folder representing the root of the network namespace hierarchy.
31467>>>>>>>>>>>>>    Define CSIDL_PERSONAL                for |CI$0005 //> File system directory that serves as a common repository for documents. A typical path is C:\Documents and Settings\username\My Documents.
31467>>>>>>>>>>>>>    Define CSIDL_PRINTERS                for |CI$0004 //> Virtual folder containing installed printers.
31467>>>>>>>>>>>>>    Define CSIDL_PRINTHOOD               for |CI$001B //> File system directory that contains the link objects that may exist in the Printers virtual folder. A typical path is C:\Documents and Settings\username\PrintHood.
31467>>>>>>>>>>>>>    Define CSIDL_PROFILE                 for |CI$0028 //> User's profile folder. Version 5
31467>>>>>>>>>>>>>    Define CSIDL_PROGRAM_FILES           for |CI$002A //> Program Files folder. A typical path is C:\Program Files. Version 5
31467>>>>>>>>>>>>>    Define CSIDL_PROGRAM_FILES_COMMON    for |CI$002B //> A folder for components that are shared across applications. A typical path is C:\Program Files\Common. Valid only for Windows NT and Windows 2000 systems. Version 5
31467>>>>>>>>>>>>>    Define CSIDL_PROGRAM_FILES_COMMONX86 for |CI$002C //> Program Files folder that is common to all users for x86 applications on RISC systems. A typical path is C:\Program Files (x86)\Common. Version 5
31467>>>>>>>>>>>>>    Define CSIDL_PROGRAMS                for |CI$0002 //> File system directory that contains the user's program groups (which are also file system directories). A typical path is C:\Documents and Settings\username\Start Menu\Programs.
31467>>>>>>>>>>>>>    Define CSIDL_RECENT                  for |CI$0008 //> File system directory that contains the user's most recently used documents. A typical path is C:\Documents and Settings\username\Recent. To create a shortcut in this folder, use SHAddToRecentDocs. In addition to creating the shortcut, this function updates the shell's list of recent documents and adds the shortcut to the Documents submenu of the Start menu.
31467>>>>>>>>>>>>>    Define CSIDL_SENDTO                  for |CI$0009 //> File system directory that contains Send To menu items. A typical path is C:\Documents and Settings\username\SendTo.
31467>>>>>>>>>>>>>    Define CSIDL_STARTMENU               for |CI$000B //> File system directory containing Start menu items. A typical path is C:\Documents and Settings\username\Start Menu.
31467>>>>>>>>>>>>>    Define CSIDL_STARTUP                 for |CI$0007 //> File system directory that corresponds to the user's Startup program group. The system starts these programs whenever any user logs onto Windows NT or starts Windows 95. A typical path is C:\Documents and Settings\username\Start Menu\Programs\Startup.
31467>>>>>>>>>>>>>    Define CSIDL_SYSTEM                  for |CI$0025 //> System folder. A typical path is C:\WINNT\SYSTEM32. Version 5
31467>>>>>>>>>>>>>    Define CSIDL_SYSTEMX86               for |CI$0029 //> System folder for x86 applications on RISC systems. A typical path is C:\WINNT\SYS32X86. Version 5
31467>>>>>>>>>>>>>    Define CSIDL_TEMPLATES               for |CI$0015 //> File system directory that serves as a common repository for document templates.
31467>>>>>>>>>>>>>    Define CSIDL_WINDOWS                 for |CI$0024 //> Version 5.0. Windows directory or SYSROOT. This corresponds to the %windir% or %SYSTEMROOT% environment variables. A typical path is C:\WINNT.
31467>>>>>>>>>>>>>
31467>>>>>>>>>>>>>    Define CSIDL_CDBURN_AREA             for |CI$003B
31467>>>>>>>>>>>>>    Define CSIDL_COMMON_MUSIC            for |CI$0035 // IE6+ The file system directory that serves as a repository for music files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Music
31467>>>>>>>>>>>>>    Define CSIDL_COMMON_PICTURES         for |CI$0036 // The file system directory that serves as a repository for image files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Pictures
31467>>>>>>>>>>>>>    Define CSIDL_COMMON_VIDEO            for |CI$0037 // IE6+ The file system directory that serves as a repository for video files common to all users. A typical path is C:\Documents and Settings\All Users\Documents\My Videos
31467>>>>>>>>>>>>>    Define CSIDL_COMPUTERSNEARME         for |CI$003D // The folder representing other machines in your workgroup
31467>>>>>>>>>>>>>    Define CSIDL_CONNECTIONS             for |CI$0031 // The virtual folder representing Network Connections, containing network and dial-up connections
31467>>>>>>>>>>>>>    Define CSIDL_MYDOCUMENTS             for |CI$000C // IE6+ The virtual folder representing the My Documents desktop item
31467>>>>>>>>>>>>>    Define CSIDL_MYMUSIC                 for |CI$000D // The file system directory that serves as a common repository for music files. A typical path is C:\Documents and Settings\User\My Documents\My Music
31467>>>>>>>>>>>>>    Define CSIDL_MYVIDEO                 for |CI$000E // IE6+ The file system directory that serves as a common repository for video files. A typical path is C:\Documents and Settings\username\My Documents\My Videos
31467>>>>>>>>>>>>>    Define CSIDL_PHOTOALBUMS             for |CI$0045 // Vista+ The virtual folder used to store photo albums, typically username\My Pictures\Photo Albums
31467>>>>>>>>>>>>>    Define CSIDL_PLAYLISTS               for |CI$003F // Vista+ The virtual folder used to store play albums, typically username\My Music\Playlists
31467>>>>>>>>>>>>>    Define CSIDL_RESOURCES               for |CI$0038 // undocumented
31467>>>>>>>>>>>>>    Define CSIDL_SAMPLE_MUSIC            for |CI$0040 // Vista+, The file system directory that contains sample music. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Music
31467>>>>>>>>>>>>>    Define CSIDL_SAMPLE_PLAYLISTS        for |CI$0041 // Vista+, The file system directory that contains sample playlists. A typical path is C:\Documents and Settings\username\My Documents\My Music\Sample Playlists
31467>>>>>>>>>>>>>    Define CSIDL_SAMPLE_PICTURES         for |CI$0042 // Vista+, The file system directory that contains sample pictures. A typical path is C:\Documents and Settings\username\My Documents\My Pictures\Sample Pictures
31467>>>>>>>>>>>>>    Define CSIDL_SAMPLE_VIDEOS           for |CI$0043 // Vista+, The file system directory that contains sample videos. A typical path is C:\Documents and Settings\username\My Documents\My Videos\Sample Videos
31467>>>>>>>>>>>>>
31467>>>>>>>>>>>>>//  Define CSIDL_FLAG_CREATE             for |CI$8000 //> If a special folder does not exist, you can force it to be created by using the following special CSIDL. (Version 5.0) Combine this CSIDL with any of the CSIDLs listed below to force the creation of the associated folder.
31467>>>>>>>>>>>>>End_Enum_List
31467>>>>>>>>>>>>>
31467>>>>>>>>>>>>>Struct tFileTimeStamp
31467>>>>>>>>>>>>>    DWord dwLowDateTime
31467>>>>>>>>>>>>>    DWord dwHighDateTime
31467>>>>>>>>>>>>>End_Struct
31467>>>>>>>>>>>>>
31467>>>>>>>>>>>>>Struct tFileSize
31467>>>>>>>>>>>>>    DWord dwHighSize
31467>>>>>>>>>>>>>    DWord dwLowSize
31467>>>>>>>>>>>>>End_Struct
31467>>>>>>>>>>>>>
31467>>>>>>>>>>>>>Struct tSystemTime
31467>>>>>>>>>>>>>    Short iYear
31467>>>>>>>>>>>>>    Short iMonth
31467>>>>>>>>>>>>>    Short iDayOfWeek
31467>>>>>>>>>>>>>    Short iDay
31467>>>>>>>>>>>>>    Short iHour
31467>>>>>>>>>>>>>    Short iMinute
31467>>>>>>>>>>>>>    Short iSecond
31467>>>>>>>>>>>>>    Short iMilliSeconds
31467>>>>>>>>>>>>>End_Struct
31467>>>>>>>>>>>>>
31467>>>>>>>>>>>>>Struct _tFileFindData
31467>>>>>>>>>>>>>    DWord dwFileAttributes
31467>>>>>>>>>>>>>    tFileTimeStamp ftCreation
31467>>>>>>>>>>>>>    tFileTimeStamp ftCreation
31467>>>>>>>>>>>>>    tFileTimeStamp ftLastAccess
31467>>>>>>>>>>>>>    tFileTimeStamp ftLastAccess
31467>>>>>>>>>>>>>    tFileTimeStamp ftLastWrite
31467>>>>>>>>>>>>>    tFileTimeStamp ftLastWrite
31467>>>>>>>>>>>>>    tFileSize fsFileSize
31467>>>>>>>>>>>>>    tFileSize fsFileSize
31467>>>>>>>>>>>>>    DWord dwReserved0
31467>>>>>>>>>>>>>    DWord dwReserved1
31467>>>>>>>>>>>>>    Char[C_MAX_PATH] csFileName// MAX_PATH=260
31467>>>>>>>>>>>>>    Char[14] csAlternateFileName
31467>>>>>>>>>>>>>End_Struct
31467>>>>>>>>>>>>>
31467>>>>>>>>>>>>>Struct tFileData
31467>>>>>>>>>>>>>    String sFileName // This is the filename stripped of its path
31467>>>>>>>>>>>>>    String sAlternateFileName // This is the 8.3 filename equivalent (DOS name)
31467>>>>>>>>>>>>>    DWord dwFileAttributes
31467>>>>>>>>>>>>>    DateTime dtCreation
31467>>>>>>>>>>>>>    DateTime dtLastAccess
31467>>>>>>>>>>>>>    DateTime dtLastWrite
31467>>>>>>>>>>>>>    Boolean bIsFolder
31467>>>>>>>>>>>>>    Boolean bSelfReference
31467>>>>>>>>>>>>>    Number nFileSize
31467>>>>>>>>>>>>>    Integer iAuxData
31467>>>>>>>>>>>>>    tFileData[] aFolderContent // if (sFileData.dwFileAttributes iand C_FILE_ATTRIBUTE_DIRECTORY) this member _may_ hold the content of a sub-folder
31467>>>>>>>>>>>>>    tFileData[] aFolderContent // if (sFileData.dwFileAttributes iand C_FILE_ATTRIBUTE_DIRECTORY) this member _may_ hold the content of a sub-folder
31467>>>>>>>>>>>>>End_Struct
31467>>>>>>>>>>>>>
31467>>>>>>>>>>>>>Struct _tFileBrowseInfo
31467>>>>>>>>>>>>>    Handle  hWndOwner
31467>>>>>>>>>>>>>    Pointer pIDLRoot
31467>>>>>>>>>>>>>    Pointer pszDisplayName
31467>>>>>>>>>>>>>    Pointer lpszTitle
31467>>>>>>>>>>>>>    dWord   ulFlags
31467>>>>>>>>>>>>>    Pointer lpfnCallback
31467>>>>>>>>>>>>>    dWord   lParam
31467>>>>>>>>>>>>>    dWord   iImage
31467>>>>>>>>>>>>>End_Struct
31467>>>>>>>>>>>>>
31467>>>>>>>>>>>>>Struct _tFileOperation
31467>>>>>>>>>>>>>    Handle  hWnd
31467>>>>>>>>>>>>>    Integer wFunc
31467>>>>>>>>>>>>>    Pointer pFrom
31467>>>>>>>>>>>>>    Pointer pTo
31467>>>>>>>>>>>>>    Short   fFlags
31467>>>>>>>>>>>>>    Short   fAnyOperationsAborted
31467>>>>>>>>>>>>>    Pointer hNameMappings
31467>>>>>>>>>>>>>    Pointer lpszProgressTitle // only used if C_SIMPLEPROGRESS
31467>>>>>>>>>>>>>End_Struct
31467>>>>>>>>>>>>>
31467>>>>>>>>>>>>>Struct tFileChop
31467>>>>>>>>>>>>>    Integer iLen
31467>>>>>>>>>>>>>    String  sContent
31467>>>>>>>>>>>>>End_Struct
31467>>>>>>>>>>>>>
31467>>>>>>>>>>>>>Struct tFileInChops
31467>>>>>>>>>>>>>    String sPath
31467>>>>>>>>>>>>>    Integer eEncoding // 0=0one, 1=hex, 2=base64.pkg, 3=base64.dll
31467>>>>>>>>>>>>>    tFileChop[] aSegments
31467>>>>>>>>>>>>>    tFileChop[] aSegments
31467>>>>>>>>>>>>>End_Struct
31467>>>>>>>>>>>>>
31467>>>>>>>>>>>>>// lpFileName      : address of name of file to search for
31467>>>>>>>>>>>>>// lpFindFileData  : address of returned information
31467>>>>>>>>>>>>>External_Function ff_FindFirstFile "FindFirstFileA"  Kernel32.dll Pointer lpFileName Pointer lpFindFileData Returns Handle
31468>>>>>>>>>>>>>
31468>>>>>>>>>>>>>// hFindFile       : handle of search
31468>>>>>>>>>>>>>// lpFindFileData  : address of structure for data on found file
31468>>>>>>>>>>>>>External_Function ff_FindNextFile "FindNextFileA" Kernel32.dll Handle hFindFile Pointer lpFindFileData Returns Integer
31469>>>>>>>>>>>>>
31469>>>>>>>>>>>>>//  hFindFile      : file search handle
31469>>>>>>>>>>>>>External_Function ff_FindClose "FindClose" Kernel32.dll Handle hFindFile Returns Integer
31470>>>>>>>>>>>>>
31470>>>>>>>>>>>>>//  lpFileTime     : pointer to file time to convert
31470>>>>>>>>>>>>>//  lpSystemTime   : pointer to structure to receive system time
31470>>>>>>>>>>>>>External_Function ff_FileTimeToSystemTime "FileTimeToSystemTime" Kernel32.Dll Pointer lpFileTime Pointer lpSystemTime Returns Integer
31471>>>>>>>>>>>>>
31471>>>>>>>>>>>>>External_Function ff_SHGetSpecialFolderPath "SHGetSpecialFolderPathA" Shell32.dll Integer i1 Integer i2 Integer i3 Integer i4 Returns Integer
31472>>>>>>>>>>>>>
31472>>>>>>>>>>>>>External_Function ff_ShellExecute "ShellExecuteA" Shell32.Dll Handle hwnd String sOperation String sFile String sParameters String sDirectory Integer nShowCmd Returns VOID_TYPE
31473>>>>>>>>>>>>>
31473>>>>>>>>>>>>>External_Function ff_CreateDirectory "CreateDirectoryA" Kernel32.dll Pointer lpFileName Pointer lpSecurityAttributes Returns Integer
31474>>>>>>>>>>>>>
31474>>>>>>>>>>>>>External_Function ff_RemoveDirectory "RemoveDirectoryA" Kernel32.dll Pointer lpFileName Returns Integer
31475>>>>>>>>>>>>>
31475>>>>>>>>>>>>>External_Function ff_SHBrowseForFolder   "SHBrowseForFolder"   Shell32.dll Pointer lpdWordx Returns DWord
31476>>>>>>>>>>>>>External_Function ff_SHGetPathFromIDList "SHGetPathFromIDList" Shell32.dll Pointer pidList Pointer lpBuffer Returns DWord
31477>>>>>>>>>>>>>External_Function ff_CoTaskMemFree       "CoTaskMemFree"       Ole32.dll   Pointer pv Returns Integer
31478>>>>>>>>>>>>>
31478>>>>>>>>>>>>>// From msdn: Returns zero if successful; otherwise nonzero. Applications normally should simply check for zero or nonzero.
31478>>>>>>>>>>>>>External_Function ff_SHFileOperation "SHFileOperationA" Shell32.dll Pointer lpFileOp Returns Integer
31479>>>>>>>>>>>>>
31479>>>>>>>>>>>>>External_Function ff_SetFileAttributes "SetFileAttributesA" Kernel32.dll Pointer lpFileName DWord dwFileAttributes Returns Integer
31480>>>>>>>>>>>>>External_Function ff_GetFileAttributes "GetFileAttributesA" Kernel32.dll Pointer lpFileName Returns DWord
31481>>>>>>>>>>>>>
31481>>>>>>>>>>>>>External_Function ff_TempPath "GetTempPathA" Kernel32.dll DWord nBufferLength Pointer lpBuffer Returns Integer
31482>>>>>>>>>>>>>
31482>>>>>>>>>>>>>External_Function ff_GetLongPathName "GetLongPathNameA" Kernel32.Dll Pointer lpszShortPath Pointer lpszLongPath DWord cchBuffer Returns DWord
31483>>>>>>>>>>>>>
31483>>>>>>>>>>>>>// This can be a file or a folder.
31483>>>>>>>>>>>>>
31483>>>>>>>>>>>>>Define FF_KILOBYTE for 1024
31483>>>>>>>>>>>>>Define FF_MEGABYTE for 1048576
31483>>>>>>>>>>>>>Define FF_GIGABYTE for 1073741824
31483>>>>>>>>>>>>>
31483>>>>>>>>>>>>>Enum_List
31483>>>>>>>>>>>>>    Define FF_ALL
31483>>>>>>>>>>>>>    Define FF_FILE
31483>>>>>>>>>>>>>    Define FF_FOLDER
31483>>>>>>>>>>>>>End_Enum_List
31483>>>>>>>>>>>>>
31483>>>>>>>>>>>>>Class cFileFunctions is a cObject
31484>>>>>>>>>>>>>    
31484>>>>>>>>>>>>>    Procedure Construct_Object
31486>>>>>>>>>>>>>        Forward Send Construct_Object
31488>>>>>>>>>>>>>        Property Boolean _pbCreateVDFXRayFolderOnReq False
31489>>>>>>>>>>>>>    End_Procedure
31490>>>>>>>>>>>>>
31490>>>>>>>>>>>>>    // Parameter naming convensions:
31490>>>>>>>>>>>>>    //
31490>>>>>>>>>>>>>    //  string sFileName   : A filename excluding folder path
31490>>>>>>>>>>>>>    //  string sPath       : Filename including absolute path
31490>>>>>>>>>>>>>    //  string sFolder     : The absolute path of a folder
31490>>>>>>>>>>>>>    //  string sFolderList : A list of folders separated by ; characters
31490>>>>>>>>>>>>>
31490>>>>>>>>>>>>>    //> Function IsLegalFileName will return the position of the first illegal character found
31490>>>>>>>>>>>>>    //> in the sFileName parameter. If sFileName contains the empty string or a string
31490>>>>>>>>>>>>>    //> beginning or ending with a space character, -1 is returned. If sFileName contains a
31490>>>>>>>>>>>>>    //> legal filename 0 is returned.
31490>>>>>>>>>>>>>    //>
31490>>>>>>>>>>>>>    //> The function does not check with the OS file system. It simply checks that
31490>>>>>>>>>>>>>    //> there are no illegal characters in the filename for our purpose (which is?)
31490>>>>>>>>>>>>>    
31490>>>>>>>>>>>>>    Function IsLegalFileName String sFileName Returns Integer
31492>>>>>>>>>>>>>        Integer iPos iLen
31492>>>>>>>>>>>>>        String sIllegalChars sChar
31492>>>>>>>>>>>>>        
31492>>>>>>>>>>>>>        Move (Length(sFileName)) to iLen
31493>>>>>>>>>>>>>        If (Trim(sFileName)<>sFileName or iLen=0) begin
31495>>>>>>>>>>>>>            Function_Return -1
31496>>>>>>>>>>>>>        End
31496>>>>>>>>>>>>>>
31496>>>>>>>>>>>>>
31496>>>>>>>>>>>>>        // These *are* legal:  ; ( )
31496>>>>>>>>>>>>>        Move ':\/"<>|' to sIllegalChars
31497>>>>>>>>>>>>>
31497>>>>>>>>>>>>>        For iPos from 1 to iLen
31503>>>>>>>>>>>>>>
31503>>>>>>>>>>>>>            Move (Mid(sFileName,1,iPos)) to sChar
31504>>>>>>>>>>>>>            If (sIllegalChars contains sChar) Function_Return iPos
31507>>>>>>>>>>>>>            If (Ascii(sChar)<32) Function_Return iPos
31510>>>>>>>>>>>>>        Loop
31511>>>>>>>>>>>>>>
31511>>>>>>>>>>>>>
31511>>>>>>>>>>>>>        Function_Return 0 // sFileName is valid as is far as characters are concerned.
31512>>>>>>>>>>>>>    End_Function
31513>>>>>>>>>>>>>
31513>>>>>>>>>>>>>    Function IsPathAbsolute String sPath Returns Boolean
31515>>>>>>>>>>>>>        Boolean bAbsolute
31515>>>>>>>>>>>>>        Move (Left(sPath,2)="\\") to bAbsolute
31516>>>>>>>>>>>>>        If (not(bAbsolute)) Begin
31518>>>>>>>>>>>>>            Move (Mid(sPath,1,2)=":") to bAbsolute
31519>>>>>>>>>>>>>        End
31519>>>>>>>>>>>>>>
31519>>>>>>>>>>>>>        Function_Return bAbsolute
31520>>>>>>>>>>>>>    End_Function
31521>>>>>>>>>>>>>
31521>>>>>>>>>>>>>    //> The AppendPath function takes a folder and a file name (without a path) and returns
31521>>>>>>>>>>>>>    //> a file name including path. Its purpose is to insert or remove a folder separator
31521>>>>>>>>>>>>>    //> if necessary.
31521>>>>>>>>>>>>>    Function AppendPath String sFolder ; //> The folder to be appended to                        String sItem ; //> The item to be appended                        Returns String
31523>>>>>>>>>>>>>        Boolean bFin
31523>>>>>>>>>>>>>        Move (Trim(sFolder)) to sFolder
31524>>>>>>>>>>>>>        Move (Trim(sItem)) to sItem
31525>>>>>>>>>>>>>
31525>>>>>>>>>>>>>        If (IsPathAbsolute(Self,sItem)) Begin
31527>>>>>>>>>>>>>            Function_Return sItem
31528>>>>>>>>>>>>>        End
31528>>>>>>>>>>>>>>
31528>>>>>>>>>>>>>
31528>>>>>>>>>>>>>        Move False to bFin
31529>>>>>>>>>>>>>        Repeat // This loop takes into account that sItem may be something like "..\Programs\*.exe".
31529>>>>>>>>>>>>>>
31529>>>>>>>>>>>>>            If (Left(sItem,2)=".\") Begin // Remove self reference
31531>>>>>>>>>>>>>                Move (Replace(".\",sItem,"")) to sItem
31532>>>>>>>>>>>>>            End
31532>>>>>>>>>>>>>>
31532>>>>>>>>>>>>>            Else If (Left(sItem,3)="..\") Begin //
31535>>>>>>>>>>>>>                Move (Replace("..\",sItem,"")) to sItem
31536>>>>>>>>>>>>>                Get PathToFolder sFolder to sFolder
31537>>>>>>>>>>>>>            End
31537>>>>>>>>>>>>>>
31537>>>>>>>>>>>>>            Else Begin
31538>>>>>>>>>>>>>                Move True to bFin
31539>>>>>>>>>>>>>            End
31539>>>>>>>>>>>>>>
31539>>>>>>>>>>>>>        Until (bFin)
31541>>>>>>>>>>>>>
31541>>>>>>>>>>>>>        If (Right(sFolder,1)="\" and Left(sItem,1)="\") Begin
31543>>>>>>>>>>>>>            Move (Replace("\",sItem,"")) to sItem
31544>>>>>>>>>>>>>        End
31544>>>>>>>>>>>>>>
31544>>>>>>>>>>>>>        If (sFolder<>"" and sItem<>"" and Right(sFolder,1)<>"\" and Left(sItem,1)<>"\") Begin
31546>>>>>>>>>>>>>            Move ("\"+sItem) to sItem
31547>>>>>>>>>>>>>        End
31547>>>>>>>>>>>>>>
31547>>>>>>>>>>>>>        Function_Return (Append(sFolder,sItem))
31548>>>>>>>>>>>>>    End_Function
31549>>>>>>>>>>>>>
31549>>>>>>>>>>>>>    //> Example: x:\vdf12\pkg\dfallent.prp -> x:\vdf12\pkg
31549>>>>>>>>>>>>>    //>          x:\windows\system32 -> x:\windows
31549>>>>>>>>>>>>>    Function PathToFolder String sPath Returns String
31551>>>>>>>>>>>>>        Integer iPos
31551>>>>>>>>>>>>>        If (Right(sPath,1)="\") Get rRemove of oStringFunctions sPath 1 to sPath
31554>>>>>>>>>>>>>        Get rPos of oStringFunctions "\" sPath to iPos
31555>>>>>>>>>>>>>        If not iPos Move (pos(":",sPath)) to iPos
31558>>>>>>>>>>>>>        If iPos Move (Left(sPath,iPos-1)) to sPath
31561>>>>>>>>>>>>>        Else Move "" to sPath
31563>>>>>>>>>>>>>        Function_Return sPath
31564>>>>>>>>>>>>>    End_Function
31565>>>>>>>>>>>>>
31565>>>>>>>>>>>>>    //> Example: x:\vdf12\pkg\dfallent.prp -> prp
31565>>>>>>>>>>>>>    Function PathToType String sPath Returns String
31567>>>>>>>>>>>>>        Integer iPos
31567>>>>>>>>>>>>>        Get rPos of oStringFunctions "\" sPath to iPos
31568>>>>>>>>>>>>>        If (iPos<>0) begin
31570>>>>>>>>>>>>>            Move (Remove(sPath,1,iPos)) to sPath
31571>>>>>>>>>>>>>        End
31571>>>>>>>>>>>>>>
31571>>>>>>>>>>>>>        Get rPos of oStringFunctions "." sPath to iPos
31572>>>>>>>>>>>>>        If (iPos<>0) begin
31574>>>>>>>>>>>>>            Move (Remove(sPath,1,iPos)) to sPath
31575>>>>>>>>>>>>>        End
31575>>>>>>>>>>>>>>
31575>>>>>>>>>>>>>        Else begin
31576>>>>>>>>>>>>>            Move "" to sPath
31577>>>>>>>>>>>>>        End
31577>>>>>>>>>>>>>>
31577>>>>>>>>>>>>>        Function_Return sPath
31578>>>>>>>>>>>>>    End_Function
31579>>>>>>>>>>>>>
31579>>>>>>>>>>>>>    //> Example: x:\vdf12\pkg\dfallent.prp --> x:\vdf12\pkg\dfallent
31579>>>>>>>>>>>>>    Function PathStripType String sPath Returns String
31581>>>>>>>>>>>>>        String sType
31581>>>>>>>>>>>>>        Get PathToType sPath to sType
31582>>>>>>>>>>>>>        If (sType<>"") Begin
31584>>>>>>>>>>>>>            Move (Left(sPath,Length(sPath)-Length(sType)-1)) to sPath
31585>>>>>>>>>>>>>        End
31585>>>>>>>>>>>>>>
31585>>>>>>>>>>>>>        Function_Return sPath
31586>>>>>>>>>>>>>    End_Function
31587>>>>>>>>>>>>>
31587>>>>>>>>>>>>>    //> Example: x:\vdf12\pkg\dfallent.prp -> dfallent.prp
31587>>>>>>>>>>>>>    Function PathToFileName String sPath Returns String
31589>>>>>>>>>>>>>        Integer iPos
31589>>>>>>>>>>>>>        If (Right(sPath,1)="\") Get rRemove of oStringFunctions sPath 1 to sPath
31592>>>>>>>>>>>>>        Get rPos of oStringFunctions "\" sPath to iPos
31593>>>>>>>>>>>>>        If not iPos Get rPos of oStringFunctions ":" sPath to iPos
31596>>>>>>>>>>>>>        If iPos Move (Remove(sPath,1,iPos)) to sPath
31599>>>>>>>>>>>>>        Function_Return sPath
31600>>>>>>>>>>>>>    End_Function
31601>>>>>>>>>>>>>
31601>>>>>>>>>>>>>    //> Example: x:\vdf12\pkg\dfallent.prp -> dfallent
31601>>>>>>>>>>>>>    Function PathToFileRootName String sPath Returns String
31603>>>>>>>>>>>>>        Integer iPos
31603>>>>>>>>>>>>>        Get PathToFileName sPath to sPath
31604>>>>>>>>>>>>>        Get rPos of oStringFunctions "." sPath to iPos
31605>>>>>>>>>>>>>        If (iPos>0) begin
31607>>>>>>>>>>>>>            Move (left(sPath,iPos-1)) to sPath
31608>>>>>>>>>>>>>        End
31608>>>>>>>>>>>>>>
31608>>>>>>>>>>>>>        Function_Return sPath
31609>>>>>>>>>>>>>    End_Function
31610>>>>>>>>>>>>>
31610>>>>>>>>>>>>>        Function _FileTime2SystemTime tFileTimeStamp stValue Returns DateTime // Private
31612>>>>>>>>>>>>>            tSystemTime stTime
31612>>>>>>>>>>>>>            tSystemTime stTime
31612>>>>>>>>>>>>>            DateTime dtRval
31612>>>>>>>>>>>>>            If (ff_FileTimeToSystemTime(AddressOf(stValue),AddressOf(stTime))) Begin
31614>>>>>>>>>>>>>                Move (DateSetSecond(dtRval,stTime.iSecond)) to dtRval
31615>>>>>>>>>>>>>                Move (DateSetMinute(dtRval,stTime.iMinute)) to dtRval
31616>>>>>>>>>>>>>                Move (DateSetHour(dtRval,stTime.iHour)) to dtRval
31617>>>>>>>>>>>>>                Move (DateSetDay(dtRval,stTime.iDay)) to dtRval
31618>>>>>>>>>>>>>                Move (DateSetMonth(dtRval,stTime.iMonth)) to dtRval
31619>>>>>>>>>>>>>                Move (DateSetYear(dtRval,stTime.iYear)) to dtRval
31620>>>>>>>>>>>>>            End
31620>>>>>>>>>>>>>>
31620>>>>>>>>>>>>>            Function_Return dtRval
31621>>>>>>>>>>>>>        End_Function
31622>>>>>>>>>>>>>
31622>>>>>>>>>>>>>        Function _FileData _tFileFindData stValue Returns tFileData // Private
31624>>>>>>>>>>>>>            tFileData stRval
31624>>>>>>>>>>>>>            tFileData stRval
31624>>>>>>>>>>>>>            String sTmp
31624>>>>>>>>>>>>>            Move stValue.dwFileAttributes to stRval.dwFileAttributes
31625>>>>>>>>>>>>>            Move (stRval.dwFileAttributes iand C_FILE_ATTRIBUTE_DIRECTORY) to stRval.bIsFolder
31626>>>>>>>>>>>>>            Get _FileTime2SystemTime stValue.ftCreation to stRval.dtCreation      // This converts the timestamps to UTC time. So 
31627>>>>>>>>>>>>>            Get _FileTime2SystemTime stValue.ftLastAccess to stRval.dtLastAccess  // they'll need converting back if their values
31628>>>>>>>>>>>>>            Get _FileTime2SystemTime stValue.ftLastWrite to stRval.dtLastWrite    // are displayed to human beings.
31629>>>>>>>>>>>>>            Move (Number(stValue.fsFileSize.dwHighSize)*C_MAXDWORD+stValue.fsFileSize.dwLowSize) to stRval.nFileSize
31630>>>>>>>>>>>>>
31630>>>>>>>>>>>>>            Move (AddressOf(stValue.csFileName)) to sTmp
31631>>>>>>>>>>>>>            Move (ToOEM(sTmp)) to stRval.sFileName
31632>>>>>>>>>>>>>
31632>>>>>>>>>>>>>            Move (sTmp="." or sTmp="..") to stRval.bSelfReference
31633>>>>>>>>>>>>>
31633>>>>>>>>>>>>>            Move (AddressOf(stValue.csAlternateFileName)) to sTmp
31634>>>>>>>>>>>>>            Move (ToOEM(sTmp)) to stRval.sAlternateFileName
31635>>>>>>>>>>>>>            Function_Return stRval
31636>>>>>>>>>>>>>        End_Function
31637>>>>>>>>>>>>>
31637>>>>>>>>>>>>>    Function ReadFileData String sPath tFileData ByRef stFileData Returns Boolean
31639>>>>>>>>>>>>>        Integer iVoid
31639>>>>>>>>>>>>>        Handle hFindFile
31639>>>>>>>>>>>>>        _tFileFindData stFileFindData
31639>>>>>>>>>>>>>        _tFileFindData stFileFindData
31639>>>>>>>>>>>>>        Move (ToAnsi(sPath)) to sPath
31640>>>>>>>>>>>>>        Move (ff_FindFirstFile(AddressOf(sPath),AddressOf(stFileFindData))) to hFindFile
31641>>>>>>>>>>>>>        If (hFindFile<>C_INVALID_HANDLE_VALUE) begin
31643>>>>>>>>>>>>>            Move (ff_FindClose(hFindFile)) to iVoid
31644>>>>>>>>>>>>>        End
31644>>>>>>>>>>>>>>
31644>>>>>>>>>>>>>        Get _FileData stFileFindData to stFileData
31645>>>>>>>>>>>>>        Function_Return (hFindFile<>C_INVALID_HANDLE_VALUE)
31646>>>>>>>>>>>>>    End_Function
31647>>>>>>>>>>>>>
31647>>>>>>>>>>>>>    Procedure ReadFileDataArray String sPath tFileData[] ByRef aFileData Integer iMode // iMode: 0:All 1:Files 2:Folders
31649>>>>>>>>>>>>>        Integer iVoid iFindNext iSize
31649>>>>>>>>>>>>>        Handle hFindFile
31649>>>>>>>>>>>>>        Boolean bFolder
31649>>>>>>>>>>>>>        _tFileFindData strFindFileData
31649>>>>>>>>>>>>>        _tFileFindData strFindFileData
31649>>>>>>>>>>>>>        Move (ToAnsi(sPath)) to sPath
31650>>>>>>>>>>>>>        Move (ff_FindFirstFile(AddressOf(sPath),AddressOf(strFindFileData))) to hFindFile
31651>>>>>>>>>>>>>        If (hFindFile<>C_INVALID_HANDLE_VALUE) Begin
31653>>>>>>>>>>>>>            Move (SizeOfArray(aFileData)) to iSize
31654>>>>>>>>>>>>>            Repeat
31654>>>>>>>>>>>>>>
31654>>>>>>>>>>>>>                Move (strFindFileData.dwFileAttributes iand C_FILE_ATTRIBUTE_DIRECTORY) to bFolder
31655>>>>>>>>>>>>>                If ((bFolder and (iMode<>FF_FILE)) or (not(bFolder) and (iMode<>FF_FOLDER))) Begin
31657>>>>>>>>>>>>>                    Get _FileData strFindFileData to aFileData[iSize]
31658>>>>>>>>>>>>>                    Increment iSize
31659>>>>>>>>>>>>>                End
31659>>>>>>>>>>>>>>
31659>>>>>>>>>>>>>                Move (ff_FindNextFile(hFindFile,AddressOf(strFindFileData))) to iFindNext
31660>>>>>>>>>>>>>            Until (iFindNext=0)
31662>>>>>>>>>>>>>            Move (ff_FindClose(hFindFile)) to iVoid // Presumably ok to call this even if hFindFile is -1
31663>>>>>>>>>>>>>        End
31663>>>>>>>>>>>>>>
31663>>>>>>>>>>>>>    End_Procedure
31664>>>>>>>>>>>>>
31664>>>>>>>>>>>>>    Procedure FileDataArraySize tFileData[] aFileData ;                                Integer ByRef iFileCount ;                                Integer ByRef iFolderCount ;                                Number ByRef nBytes
31666>>>>>>>>>>>>>        Integer iMax iIndex
31666>>>>>>>>>>>>>        Move (SizeOfArray(aFileData)-1) to iMax
31667>>>>>>>>>>>>>        For iIndex from 0 to iMax
31673>>>>>>>>>>>>>>
31673>>>>>>>>>>>>>            If (not(aFileData[iIndex].bSelfReference)) Begin
31675>>>>>>>>>>>>>                If (aFileData[iIndex].bIsFolder) Begin
31677>>>>>>>>>>>>>                    Increment iFolderCount
31678>>>>>>>>>>>>>                    Send FileDataArraySize aFileData[iIndex].aFolderContent (&iFileCount) (&iFolderCount) (&nBytes)
31679>>>>>>>>>>>>>                End
31679>>>>>>>>>>>>>>
31679>>>>>>>>>>>>>                Else Begin
31680>>>>>>>>>>>>>                    Increment iFileCount
31681>>>>>>>>>>>>>                    Move (nBytes+aFileData[iIndex].nFileSize) to nBytes
31682>>>>>>>>>>>>>                End
31682>>>>>>>>>>>>>>
31682>>>>>>>>>>>>>            End
31682>>>>>>>>>>>>>>
31682>>>>>>>>>>>>>        Loop
31683>>>>>>>>>>>>>>
31683>>>>>>>>>>>>>    End_Procedure
31684>>>>>>>>>>>>>
31684>>>>>>>>>>>>>    Function GetAttribute String sFileName Integer iAttr Returns DWord
31686>>>>>>>>>>>>>        DWord dwAttr
31686>>>>>>>>>>>>>        Pointer pAddress
31686>>>>>>>>>>>>>
31686>>>>>>>>>>>>>        Move (ToAnsi(sFileName) + Character(0)) to sFileName
31687>>>>>>>>>>>>>        Move (AddressOf(sFileName)) to pAddress
31688>>>>>>>>>>>>>        Move (ff_GetFileAttributes(pAddress)) to dwAttr
31689>>>>>>>>>>>>>        Function_Return (dwAttr iand iAttr)
31690>>>>>>>>>>>>>    End_Function
31691>>>>>>>>>>>>>
31691>>>>>>>>>>>>>    Function SetAttribute String sFileName Integer iAttr Returns Integer
31693>>>>>>>>>>>>>        Integer bOk
31693>>>>>>>>>>>>>        DWord dwAttr
31693>>>>>>>>>>>>>        Pointer pAddress
31693>>>>>>>>>>>>>
31693>>>>>>>>>>>>>        Move (ToAnsi(sFileName)+Character(0)) to sFileName
31694>>>>>>>>>>>>>        Move (AddressOf(sFileName)) to pAddress
31695>>>>>>>>>>>>>        Move (ff_GetFileAttributes(pAddress)) to dwAttr
31696>>>>>>>>>>>>>        Move (ff_SetFileAttributes(pAddress,dwAttr ior iAttr)) to bOk
31697>>>>>>>>>>>>>        Function_Return bOk
31698>>>>>>>>>>>>>    End_Function
31699>>>>>>>>>>>>>
31699>>>>>>>>>>>>>    Function RemoveAttribute String sFileName Integer iAttr Returns Integer
31701>>>>>>>>>>>>>        Integer bOk
31701>>>>>>>>>>>>>        DWord dwAttr
31701>>>>>>>>>>>>>        Pointer pAddress
31701>>>>>>>>>>>>>
31701>>>>>>>>>>>>>        Move (ToAnsi(sFileName)+Character(0)) to sFileName
31702>>>>>>>>>>>>>        Move (AddressOf(sFileName)) to pAddress
31703>>>>>>>>>>>>>        If (GetAttribute(Self,sFileName,iAttr)) Begin
31705>>>>>>>>>>>>>            Move (ff_GetFileAttributes(pAddress)) to dwAttr
31706>>>>>>>>>>>>>            Move (ff_SetFileAttributes(pAddress,dwAttr-iAttr)) to bOk
31707>>>>>>>>>>>>>        End
31707>>>>>>>>>>>>>>
31707>>>>>>>>>>>>>        Function_Return bOk
31708>>>>>>>>>>>>>    End_Function
31709>>>>>>>>>>>>>
31709>>>>>>>>>>>>>    Procedure ReadFolder String sFolder String sMask tFileData[] ByRef aFileData Integer iMode // iMode: 0:All 1:Files 2:Folders
31711>>>>>>>>>>>>>        String sPath
31711>>>>>>>>>>>>>        If (sMask="") Move "*" to sMask
31714>>>>>>>>>>>>>        Get AppendPath sFolder sMask to sPath
31715>>>>>>>>>>>>>        Send ReadFileDataArray sPath (&aFileData) iMode
31716>>>>>>>>>>>>>    End_Procedure
31717>>>>>>>>>>>>>
31717>>>>>>>>>>>>>    Function IsFolderEmpty String sFolder Returns Boolean
31719>>>>>>>>>>>>>        Integer iMax iIndex
31719>>>>>>>>>>>>>        tFileData[] aFileData
31719>>>>>>>>>>>>>        tFileData[] aFileData
31720>>>>>>>>>>>>>        Send ReadFolder sFolder "*" (&aFileData) 0 // 0: both files and folders
31721>>>>>>>>>>>>>        Move (SizeOfArray(aFileData)-1) to iMax
31722>>>>>>>>>>>>>        For iIndex from 0 to iMax
31728>>>>>>>>>>>>>>
31728>>>>>>>>>>>>>            If (not(aFileData[iIndex].bSelfReference)) Begin
31730>>>>>>>>>>>>>                Function_Return False
31731>>>>>>>>>>>>>            End
31731>>>>>>>>>>>>>>
31731>>>>>>>>>>>>>        Loop
31732>>>>>>>>>>>>>>
31732>>>>>>>>>>>>>        Function_Return True
31733>>>>>>>>>>>>>    End_Function
31734>>>>>>>>>>>>>
31734>>>>>>>>>>>>>    Procedure ReadFolderRecursive String sFolder String sMask tFileData[] ByRef aFileData Integer iMode Integer iMaxDepth //
31736>>>>>>>>>>>>>        Integer iIndex iMax
31736>>>>>>>>>>>>>        String sPath sName
31736>>>>>>>>>>>>>        If (sMask="") begin
31738>>>>>>>>>>>>>            Move "*" to sMask
31739>>>>>>>>>>>>>        End
31739>>>>>>>>>>>>>>
31739>>>>>>>>>>>>>        Get AppendPath sFolder sMask to sPath
31740>>>>>>>>>>>>>        Send ReadFileDataArray sPath (&aFileData) iMode
31741>>>>>>>>>>>>>        If (iMode=1) Begin // Files only
31743>>>>>>>>>>>>>            Get AppendPath sFolder "*" to sPath
31744>>>>>>>>>>>>>            Send ReadFileDataArray sPath (&aFileData) 2 // 2=>folders only
31745>>>>>>>>>>>>>        End
31745>>>>>>>>>>>>>>
31745>>>>>>>>>>>>>        If (iMaxDepth>0) Begin
31747>>>>>>>>>>>>>            Move (SizeOfArray(aFileData)-1) to iMax
31748>>>>>>>>>>>>>            For iIndex from 0 to iMax
31754>>>>>>>>>>>>>>
31754>>>>>>>>>>>>>                If (aFileData[iIndex].dwFileAttributes iand C_FILE_ATTRIBUTE_DIRECTORY) Begin
31756>>>>>>>>>>>>>                    Move aFileData[iIndex].sFileName to sName
31757>>>>>>>>>>>>>                    If (sName<>"." and sName<>"..") begin
31759>>>>>>>>>>>>>                        Send ReadFolderRecursive (AppendPath(Self,sFolder,sName)) sMask (&aFileData[iIndex].aFolderContent) iMode (iMaxDepth-1)
31760>>>>>>>>>>>>>                    End
31760>>>>>>>>>>>>>>
31760>>>>>>>>>>>>>                End
31760>>>>>>>>>>>>>>
31760>>>>>>>>>>>>>            Loop
31761>>>>>>>>>>>>>>
31761>>>>>>>>>>>>>        End
31761>>>>>>>>>>>>>>
31761>>>>>>>>>>>>>    End_Procedure
31762>>>>>>>>>>>>>
31762>>>>>>>>>>>>>    // ******************************************************************************************************
31762>>>>>>>>>>>>>    //
31762>>>>>>>>>>>>>
31762>>>>>>>>>>>>>    Procedure CallbackFileData String sFolder tFileData[] aFileData Integer iMode Integer hMsg Integer hObj // iMode: 0:Both  1:Files only  2:Folders only
31764>>>>>>>>>>>>>        // callback: Procedure HandleFileData String sFullPath tFileData stFileData
31764>>>>>>>>>>>>>        Integer iMax iIndex
31764>>>>>>>>>>>>>        String sFullPath
31764>>>>>>>>>>>>>        Move (SizeOfArray(aFileData)-1) to iMax
31765>>>>>>>>>>>>>        For iIndex from 0 to iMax
31771>>>>>>>>>>>>>>
31771>>>>>>>>>>>>>            If (aFileData[iIndex].bIsFolder) Begin
31773>>>>>>>>>>>>>                Get AppendPath sFolder aFileData[iIndex].sFileName to sFullPath
31774>>>>>>>>>>>>>                If (iMode<>1) Begin // If not "files only"
31776>>>>>>>>>>>>>                    Send hMsg of hObj sFullPath aFileData[iIndex]
31777>>>>>>>>>>>>>                End
31777>>>>>>>>>>>>>>
31777>>>>>>>>>>>>>                Send CallbackFileData sFullPath aFileData[iIndex].aFolderContent iMode hMsg hObj
31778>>>>>>>>>>>>>            End
31778>>>>>>>>>>>>>>
31778>>>>>>>>>>>>>            Else Begin
31779>>>>>>>>>>>>>                If (iMode<>2) Begin // If not "folders only"
31781>>>>>>>>>>>>>                    Get AppendPath sFolder aFileData[iIndex].sFileName to sFullPath
31782>>>>>>>>>>>>>                    Send hMsg of hObj sFullPath aFileData[iIndex]
31783>>>>>>>>>>>>>                End
31783>>>>>>>>>>>>>>
31783>>>>>>>>>>>>>            End
31783>>>>>>>>>>>>>>
31783>>>>>>>>>>>>>        Loop
31784>>>>>>>>>>>>>>
31784>>>>>>>>>>>>>    End_Procedure
31785>>>>>>>>>>>>>
31785>>>>>>>>>>>>>    // ******************************************************************************************************
31785>>>>>>>>>>>>>
31785>>>>>>>>>>>>>    Function FindFileDataIndex tFileData[] aFileData String sFileName Returns Integer
31787>>>>>>>>>>>>>        Integer iIndex iMax
31787>>>>>>>>>>>>>        Move (SizeOfArray(aFileData)-1) to iMax
31788>>>>>>>>>>>>>        Move (Uppercase(sFileName)) to sFileName
31789>>>>>>>>>>>>>        For iIndex from 0 to iMax
31795>>>>>>>>>>>>>>
31795>>>>>>>>>>>>>            If (sFileName=Uppercase(aFileData[iIndex].sFileName)) Function_Return iIndex
31798>>>>>>>>>>>>>        Loop
31799>>>>>>>>>>>>>>
31799>>>>>>>>>>>>>        Function_Return -1 // Not found
31800>>>>>>>>>>>>>    End_Function
31801>>>>>>>>>>>>>
31801>>>>>>>>>>>>>        Procedure _BuildFileDataCursor tFileData[] aFileData String sPath Integer[] ByRef aCursor
31803>>>>>>>>>>>>>            Integer iIndex
31803>>>>>>>>>>>>>            String[] aValues
31804>>>>>>>>>>>>>            If (sPath<>"") Begin
31806>>>>>>>>>>>>>                Send SplitString of oStringFunctions sPath "\" True False (&aValues)
31807>>>>>>>>>>>>>                If (SizeOfArray(aValues)>0) Begin // Not really necessary, since we have already checked that sPath is not blank
31809>>>>>>>>>>>>>                    Get FindFileDataIndex aFileData aValues[0] to iIndex
31810>>>>>>>>>>>>>                    If (iIndex<>-1) Begin
31812>>>>>>>>>>>>>                        Move iIndex to aCursor[SizeOfArray(aCursor)]
31813>>>>>>>>>>>>>                        Send _BuildFileDataCursor aFileData[iIndex].aFolderContent (JoinString(oStringFunctions,aValues,"\",1,0)) (&aCursor)
31814>>>>>>>>>>>>>                    End
31814>>>>>>>>>>>>>>
31814>>>>>>>>>>>>>                    Else Begin // Path not found => Reset the cursor
31815>>>>>>>>>>>>>                        Move (ResizeArray(aCursor,0)) to aCursor
31816>>>>>>>>>>>>>                    End
31816>>>>>>>>>>>>>>
31816>>>>>>>>>>>>>                End
31816>>>>>>>>>>>>>>
31816>>>>>>>>>>>>>            End
31816>>>>>>>>>>>>>>
31816>>>>>>>>>>>>>        End_Procedure
31817>>>>>>>>>>>>>
31817>>>>>>>>>>>>>    // This function combines a path like "subfolder1\subfolder2\subfolder3" with an
31817>>>>>>>>>>>>>    // array of tFileData (a recursive definition) and translates it into a
31817>>>>>>>>>>>>>    // "cursor" that is an array of integers. This array may be used to index your way
31817>>>>>>>>>>>>>    // to a specific tFileData item. If the sPath can be resolved with respect to
31817>>>>>>>>>>>>>    // aFileData True will be returned, otherwise False.
31817>>>>>>>>>>>>>    Function FileDataPathToCursor tFileData[] aFileData String sPath Integer[] ByRef aCursor Returns Boolean
31819>>>>>>>>>>>>>        If (sPath="") Begin
31821>>>>>>>>>>>>>            Function_Return False // Not legal to call with empty path.
31822>>>>>>>>>>>>>        End
31822>>>>>>>>>>>>>>
31822>>>>>>>>>>>>>        Send _BuildFileDataCursor aFileData sPath (&aCursor)
31823>>>>>>>>>>>>>        Function_Return (SizeOfArray(aCursor)<>0)
31824>>>>>>>>>>>>>    End_Function
31825>>>>>>>>>>>>>
31825>>>>>>>>>>>>>    // Function FileDataAtCursor takes a tFileData array and a "cursor" and delivers the
31825>>>>>>>>>>>>>    // corresponding tFileData element via ByRef parameter stResult. If the cursor "points
31825>>>>>>>>>>>>>    // out of" the aFileData the function will return False. Calling the function with an
31825>>>>>>>>>>>>>    // empty cursor (of length 0) is considered illegal and will also return False. Otherwise
31825>>>>>>>>>>>>>    // True is returned and parameter stResult will contain the referenced element.
31825>>>>>>>>>>>>>    Function FileDataAtCursor tFileData[] aFileData Integer[] aCursor tFileData ByRef stResult Returns Boolean
31827>>>>>>>>>>>>>        Integer iCursorMax iCursorIndex iIndex
31827>>>>>>>>>>>>>
31827>>>>>>>>>>>>>        Move (SizeOfArray(aCursor)-1) to iCursorMax
31828>>>>>>>>>>>>>        If (iCursorMax>=0) Begin
31830>>>>>>>>>>>>>            For iCursorIndex from 0 to iCursorMax
31836>>>>>>>>>>>>>>
31836>>>>>>>>>>>>>                Move aCursor[iCursorIndex] to iIndex
31837>>>>>>>>>>>>>                If (iIndex<SizeOfArray(aFileData)) Begin // We're inside the index range => ok
31839>>>>>>>>>>>>>                    If (iCursorIndex=iCursorMax) Begin
31841>>>>>>>>>>>>>                        Move aFileData[iIndex] to stResult
31842>>>>>>>>>>>>>                    End
31842>>>>>>>>>>>>>>
31842>>>>>>>>>>>>>                    Else Begin
31843>>>>>>>>>>>>>                        Move aFileData[iIndex].aFolderContent to aFileData
31844>>>>>>>>>>>>>                    End
31844>>>>>>>>>>>>>>
31844>>>>>>>>>>>>>                End
31844>>>>>>>>>>>>>>
31844>>>>>>>>>>>>>                Else Begin // Cursor points outside of aFileData => failure
31845>>>>>>>>>>>>>                    Function_Return False
31846>>>>>>>>>>>>>                End
31846>>>>>>>>>>>>>>
31846>>>>>>>>>>>>>            Loop
31847>>>>>>>>>>>>>>
31847>>>>>>>>>>>>>            Function_Return True
31848>>>>>>>>>>>>>        End
31848>>>>>>>>>>>>>>
31848>>>>>>>>>>>>>        Function_Return False
31849>>>>>>>>>>>>>    End_Function
31850>>>>>>>>>>>>>
31850>>>>>>>>>>>>>    Enum_List // sort by's
31850>>>>>>>>>>>>>        Define SB_NAME
31850>>>>>>>>>>>>>        Define SB_CREATED
31850>>>>>>>>>>>>>        Define SB_ACCESSED
31850>>>>>>>>>>>>>        Define SB_CHANGED
31850>>>>>>>>>>>>>        Define SB_SIZE
31850>>>>>>>>>>>>>    End_Enum_List
31850>>>>>>>>>>>>>
31850>>>>>>>>>>>>>            Function _CompareFileDataByName tFileData stVal1 tFileData stVal2 Returns Integer
31852>>>>>>>>>>>>>                String sValue1 sValue2
31852>>>>>>>>>>>>>                Move (Uppercase(stVal1.sFileName)) to sValue1
31853>>>>>>>>>>>>>                Move (Uppercase(stVal2.sFileName)) to sValue2
31854>>>>>>>>>>>>>                If (sValue1<sValue2) Function_Return (LT)
31857>>>>>>>>>>>>>                If (sValue1>sValue2) Function_Return (GT)
31860>>>>>>>>>>>>>                Function_Return (EQ)
31861>>>>>>>>>>>>>            End_Function
31862>>>>>>>>>>>>>            Function _CompareFileDataByCreated tFileData stVal1 tFileData stVal2 Returns Integer
31864>>>>>>>>>>>>>                If (stVal1.dtCreation<stVal2.dtCreation) Function_Return (LT)
31867>>>>>>>>>>>>>                If (stVal1.dtCreation>stVal2.dtCreation) Function_Return (GT)
31870>>>>>>>>>>>>>                Function_Return (EQ)
31871>>>>>>>>>>>>>            End_Function
31872>>>>>>>>>>>>>            Function _CompareFileDataByAccessed tFileData stVal1 tFileData stVal2 Returns Integer
31874>>>>>>>>>>>>>                If (stVal1.dtLastAccess<stVal2.dtLastAccess) Function_Return (LT)
31877>>>>>>>>>>>>>                If (stVal1.dtLastAccess>stVal2.dtLastAccess) Function_Return (GT)
31880>>>>>>>>>>>>>                Function_Return (EQ)
31881>>>>>>>>>>>>>            End_Function
31882>>>>>>>>>>>>>            Function _CompareFileDataByChanged tFileData stVal1 tFileData stVal2 Returns Integer
31884>>>>>>>>>>>>>                If (stVal1.dtLastWrite<stVal2.dtLastWrite) Function_Return (LT)
31887>>>>>>>>>>>>>                If (stVal1.dtLastWrite>stVal2.dtLastWrite) Function_Return (GT)
31890>>>>>>>>>>>>>                Function_Return (EQ)
31891>>>>>>>>>>>>>            End_Function
31892>>>>>>>>>>>>>            Function _CompareFileDataBySize tFileData stVal1 tFileData stVal2 Returns Integer
31894>>>>>>>>>>>>>                If (stVal1.nFileSize<stVal2.nFileSize) Function_Return (LT)
31897>>>>>>>>>>>>>                If (stVal1.nFileSize>stVal2.nFileSize) Function_Return (GT)
31900>>>>>>>>>>>>>                Function_Return (EQ)
31901>>>>>>>>>>>>>            End_Function
31902>>>>>>>>>>>>>
31902>>>>>>>>>>>>>    Procedure SortFileDataArray tFileData[] ByRef aFileData Integer iByWhat
31904>>>>>>>>>>>>>        If (iByWhat=SB_NAME)     Move (SortArray(aFileData,Self,GET__CompareFileDataByName)) to aFileData
31907>>>>>>>>>>>>>        If (iByWhat=SB_CREATED)  Move (SortArray(aFileData,Self,GET__CompareFileDataByCreated)) to aFileData
31910>>>>>>>>>>>>>        If (iByWhat=SB_ACCESSED) Move (SortArray(aFileData,Self,GET__CompareFileDataByAccessed)) to aFileData
31913>>>>>>>>>>>>>        If (iByWhat=SB_CHANGED)  Move (SortArray(aFileData,Self,GET__CompareFileDataByChanged)) to aFileData
31916>>>>>>>>>>>>>        If (iByWhat=SB_SIZE)     Move (SortArray(aFileData,Self,GET__CompareFileDataBySize)) to aFileData
31919>>>>>>>>>>>>>    End_Procedure
31920>>>>>>>>>>>>>
31920>>>>>>>>>>>>>    //> Function FileExists returns 0 if not, 1 if file and 2 if folder
31920>>>>>>>>>>>>>    Function FileExists String sPath Returns Integer
31922>>>>>>>>>>>>>        Integer iRval
31922>>>>>>>>>>>>>        tFileData strFileData
31922>>>>>>>>>>>>>        tFileData strFileData
31922>>>>>>>>>>>>>        If (Length(sPath)=2 and Right(sPath,1)=":") Begin
31924>>>>>>>>>>>>>            Valid_Drive sPath iRval
31925>>>>>>>>>>>>>            If (iRval=-1) Begin
31927>>>>>>>>>>>>>                Move 0 to iRval // Folder does not exist
31928>>>>>>>>>>>>>            End
31928>>>>>>>>>>>>>>
31928>>>>>>>>>>>>>            Else If (iRval=0) Begin
31931>>>>>>>>>>>>>                Move 2 to iRval // The drive exists => 'Folder' exists
31932>>>>>>>>>>>>>            End
31932>>>>>>>>>>>>>>
31932>>>>>>>>>>>>>            Else Begin
31933>>>>>>>>>>>>>                Move 0 to iRval // Unknown value => folder does not exist
31934>>>>>>>>>>>>>            End
31934>>>>>>>>>>>>>>
31934>>>>>>>>>>>>>        End
31934>>>>>>>>>>>>>>
31934>>>>>>>>>>>>>        Else Begin
31935>>>>>>>>>>>>>            If (ReadFileData(Self,sPath,&strFileData)) Begin
31937>>>>>>>>>>>>>                If (strFileData.dwFileAttributes iand C_FILE_ATTRIBUTE_DIRECTORY) Begin
31939>>>>>>>>>>>>>                    Move 2 to iRval
31940>>>>>>>>>>>>>                End
31940>>>>>>>>>>>>>>
31940>>>>>>>>>>>>>                Else Begin
31941>>>>>>>>>>>>>                    Move 1 to iRval
31942>>>>>>>>>>>>>                End
31942>>>>>>>>>>>>>>
31942>>>>>>>>>>>>>            End
31942>>>>>>>>>>>>>>
31942>>>>>>>>>>>>>            Else Begin
31943>>>>>>>>>>>>>                Move 0 to iRval
31944>>>>>>>>>>>>>            End
31944>>>>>>>>>>>>>>
31944>>>>>>>>>>>>>        End
31944>>>>>>>>>>>>>>
31944>>>>>>>>>>>>>        Function_Return iRval
31945>>>>>>>>>>>>>    End_Function
31946>>>>>>>>>>>>>
31946>>>>>>>>>>>>>    Function FindFile String sFileName String sFolderList Returns String
31948>>>>>>>>>>>>>        Integer iMax iIndex
31948>>>>>>>>>>>>>        String[] aFolders
31949>>>>>>>>>>>>>        String sFolder
31949>>>>>>>>>>>>>        Move (Replaces('"',sFolderList,'')) to sFolderList
31950>>>>>>>>>>>>>        Send SplitString of oStringFunctions sFolderList ";" True False (&aFolders)
31951>>>>>>>>>>>>>        Move (SizeOfArray(aFolders)-1) to iMax
31952>>>>>>>>>>>>>        For iIndex from 0 to iMax
31958>>>>>>>>>>>>>>
31958>>>>>>>>>>>>>            If (FileExists(Self,AppendPath(Self,aFolders[iIndex],sFileName))<>0) Begin
31960>>>>>>>>>>>>>                Function_Return aFolders[iIndex]
31961>>>>>>>>>>>>>            End
31961>>>>>>>>>>>>>>
31961>>>>>>>>>>>>>        Loop
31962>>>>>>>>>>>>>>
31962>>>>>>>>>>>>>        Function_Return "" // not found
31963>>>>>>>>>>>>>    End_Function
31964>>>>>>>>>>>>>
31964>>>>>>>>>>>>>    Function DirectOutput String sPath Returns Integer
31966>>>>>>>>>>>>>        Integer iChannel
31966>>>>>>>>>>>>>        Get Seq_New_Channel to iChannel
31967>>>>>>>>>>>>>        Move (ToAnsi(sPath)) to sPath
31968>>>>>>>>>>>>>        Direct_Output channel iChannel sPath
31970>>>>>>>>>>>>>        Function_Return iChannel
31971>>>>>>>>>>>>>    End_Function
31972>>>>>>>>>>>>>
31972>>>>>>>>>>>>>    Function AppendOutput String sPath Returns Integer
31974>>>>>>>>>>>>>        Integer iChannel
31974>>>>>>>>>>>>>        Get Seq_New_Channel to iChannel
31975>>>>>>>>>>>>>        Move (ToAnsi(sPath)) to sPath
31976>>>>>>>>>>>>>        Append_Output channel iChannel sPath
31978>>>>>>>>>>>>>        Function_Return iChannel
31979>>>>>>>>>>>>>    End_Function
31980>>>>>>>>>>>>>
31980>>>>>>>>>>>>>    //> Close output channel iChannel
31980>>>>>>>>>>>>>    Procedure CloseOutput Integer iChannel
31982>>>>>>>>>>>>>        Close_Output channel iChannel
31984>>>>>>>>>>>>>        Send Seq_Release_Channel iChannel
31985>>>>>>>>>>>>>    End_Procedure
31986>>>>>>>>>>>>>
31986>>>>>>>>>>>>>    //> The function attempts to open the file fn# for sequential reading.
31986>>>>>>>>>>>>>    //> If it succeeds a channel number will be returned, if it fails -1
31986>>>>>>>>>>>>>    //> will be returned. If the function succeeds it is the responsability
31986>>>>>>>>>>>>>    //> of the caller to release the channel (by sending the CloseInput
31986>>>>>>>>>>>>>    //> message) when done with it.
31986>>>>>>>>>>>>>    Function DirectInput String sPath Returns Integer
31988>>>>>>>>>>>>>        Integer iChannel
31988>>>>>>>>>>>>>        Get Seq_New_Channel to iChannel
31989>>>>>>>>>>>>>        Move (ToAnsi(sPath)) to sPath
31990>>>>>>>>>>>>>        Direct_Input channel iChannel sPath
31992>>>>>>>>>>>>>        If (SeqEof) Begin
31994>>>>>>>>>>>>>            Send Seq_Release_Channel iChannel
31995>>>>>>>>>>>>>            Move -1 to iChannel
31996>>>>>>>>>>>>>        End
31996>>>>>>>>>>>>>>
31996>>>>>>>>>>>>>        Function_Return iChannel
31997>>>>>>>>>>>>>    End_Function
31998>>>>>>>>>>>>>
31998>>>>>>>>>>>>>    Function DirectInputTableField Integer iTable Integer iField Returns Integer
32000>>>>>>>>>>>>>        Function_Return (DirectInput(Self,"DBMS:"+String(iTable)+","+String(iField)))
32001>>>>>>>>>>>>>    End_Function
32002>>>>>>>>>>>>>
32002>>>>>>>>>>>>>    //> Close input channel iChannel.
32002>>>>>>>>>>>>>    Procedure CloseInput Integer iChannel
32004>>>>>>>>>>>>>        Close_Input channel iChannel
32006>>>>>>>>>>>>>        Send Seq_Release_Channel iChannel
32007>>>>>>>>>>>>>    End_Procedure
32008>>>>>>>>>>>>>
32008>>>>>>>>>>>>>    //> Sometimes it's nice not to have to declare a variable just to read
32008>>>>>>>>>>>>>    //> a line in a file. Global indicator SeqEof will be False after calling
32008>>>>>>>>>>>>>    //> this function if an EOF has been reached. (What? I hope I mean True)
32008>>>>>>>>>>>>>    Function Readln Integer iChannel Returns String
32010>>>>>>>>>>>>>        String sRval
32010>>>>>>>>>>>>>        Readln channel iChannel sRval
32012>>>>>>>>>>>>>        Function_Return sRval
32013>>>>>>>>>>>>>    End_Function
32014>>>>>>>>>>>>>
32014>>>>>>>>>>>>>    //> Reads sequential channel liChannel until the value lsValue is found.
32014>>>>>>>>>>>>>    //> Return value True: Found!,  False : Value not found before end of file.
32014>>>>>>>>>>>>>    //> The function may be used to skip parts of a text file of a known format.
32014>>>>>>>>>>>>>    Function ReadLnUntilValue Integer iChannel String sValue Returns Boolean
32016>>>>>>>>>>>>>        String sLine
32016>>>>>>>>>>>>>        Repeat
32016>>>>>>>>>>>>>>
32016>>>>>>>>>>>>>          Readln channel iChannel sLine
32018>>>>>>>>>>>>>          If (SeqEof) Function_Return False
32021>>>>>>>>>>>>>          If (sLine=sValue) Function_Return True
32024>>>>>>>>>>>>>        Loop
32025>>>>>>>>>>>>>>
32025>>>>>>>>>>>>>    End_Function
32026>>>>>>>>>>>>>
32026>>>>>>>>>>>>>    //> Function ReadLnProbe reads a line from input channel iChannel without
32026>>>>>>>>>>>>>    //> affecting the current channel position of that channel. The return
32026>>>>>>>>>>>>>    //> value is of type string and will be the line read. The function sets
32026>>>>>>>>>>>>>    //> indicator SeqEof as a sideeffect.
32026>>>>>>>>>>>>>    Function ReadLnProbe Integer iChannel Returns String
32028>>>>>>>>>>>>>        Integer iPos
32028>>>>>>>>>>>>>        Boolean bSeqEof bSneakMode
32028>>>>>>>>>>>>>        String sRval sValue
32028>>>>>>>>>>>>>        Get_Channel_Position iChannel to iPos
32029>>>>>>>>>>>>>>
32029>>>>>>>>>>>>>        Readln channel iChannel sRval
32031>>>>>>>>>>>>>        Move (SeqEof) to bSeqEof
32032>>>>>>>>>>>>>        Move (iPos>0) to bSneakMode
32033>>>>>>>>>>>>>        If bSneakMode Decrement iPos
32036>>>>>>>>>>>>>        Set_Channel_Position iChannel to iPos
32037>>>>>>>>>>>>>>
32037>>>>>>>>>>>>>        If bSneakMode Read_Block channel iChannel sValue 1
32041>>>>>>>>>>>>>        indicate SeqEof as bSeqEof ne 0
32042>>>>>>>>>>>>>        Function_Return sRval
32043>>>>>>>>>>>>>    End_Function
32044>>>>>>>>>>>>>
32044>>>>>>>>>>>>>    //> This function reads a file (of whatever type) and returns its contents as a
32044>>>>>>>>>>>>>    //> String. If the file is larger than the max arg size currently Set by the
32044>>>>>>>>>>>>>    //> program, an error is declared.
32044>>>>>>>>>>>>>    Function FileAsString String sPath Returns String
32046>>>>>>>>>>>>>        Integer iChannel iArgSize
32046>>>>>>>>>>>>>        Number nSize
32046>>>>>>>>>>>>>        String sRval sError
32046>>>>>>>>>>>>>        tFileData strFileData
32046>>>>>>>>>>>>>        tFileData strFileData
32046>>>>>>>>>>>>>
32046>>>>>>>>>>>>>        Move "" to sRval
32047>>>>>>>>>>>>>        If (ReadFileData(Self,sPath,&strFileData)) Begin
32049>>>>>>>>>>>>>            Move strFileData.nFileSize to nSize
32050>>>>>>>>>>>>>            Get_Argument_Size to iArgSize
32051>>>>>>>>>>>>>
32051>>>>>>>>>>>>>            If (iArgSize<nSize) begin
32053>>>>>>>>>>>>>                Move "File too big. Adjust max arg size. (File: # MAS: #)" to sError
32054>>>>>>>>>>>>>                Move (Replace("#",sError,string(nSize))) to sError
32055>>>>>>>>>>>>>                Move (Replace("#",sError,string(iArgSize))) to sError
32056>>>>>>>>>>>>>                Error 421 sError
32057>>>>>>>>>>>>>>
32057>>>>>>>>>>>>>            end
32057>>>>>>>>>>>>>>
32057>>>>>>>>>>>>>            Get DirectInput ("binary:"+sPath) to iChannel
32058>>>>>>>>>>>>>            If (iChannel>=0) Begin
32060>>>>>>>>>>>>>                Read_Block channel iChannel sRval nSize
32062>>>>>>>>>>>>>                Send CloseInput iChannel
32063>>>>>>>>>>>>>            End
32063>>>>>>>>>>>>>>
32063>>>>>>>>>>>>>        End
32063>>>>>>>>>>>>>>
32063>>>>>>>>>>>>>        Function_Return sRval
32064>>>>>>>>>>>>>    End_Function
32065>>>>>>>>>>>>>    
32065>>>>>>>>>>>>>    Function StringAsFile String sPath String sFileContent Returns Boolean
32067>>>>>>>>>>>>>        Integer iChannel
32067>>>>>>>>>>>>>        Number nLength
32067>>>>>>>>>>>>>        Move (Length(sFileContent)) to nLength
32068>>>>>>>>>>>>>        Get DirectOutput ("binary:"+sPath) to iChannel
32069>>>>>>>>>>>>>        If (iChannel>=0) Begin
32071>>>>>>>>>>>>>            Write channel iChannel sFileContent
32073>>>>>>>>>>>>>            Send CloseOutput iChannel
32074>>>>>>>>>>>>>            Function_Return True
32075>>>>>>>>>>>>>        End
32075>>>>>>>>>>>>>>
32075>>>>>>>>>>>>>        Function_Return False
32076>>>>>>>>>>>>>    End_Function
32077>>>>>>>>>>>>>    
32077>>>>>>>>>>>>>    Function SplitFile String sPath tFileInChops ByRef strFileInChops Integer iBlockSize Returns Boolean
32079>>>>>>>>>>>>>        Integer iChannel
32079>>>>>>>>>>>>>        Integer iIndex
32079>>>>>>>>>>>>>        Integer iBytesLeft
32079>>>>>>>>>>>>>        String sBlock
32079>>>>>>>>>>>>>        tFileInChops strEmpty
32079>>>>>>>>>>>>>        tFileInChops strEmpty
32079>>>>>>>>>>>>>        Move strEmpty to strFileInChops
32080>>>>>>>>>>>>>        Get DirectInput ("binary:"+sPath) to iChannel
32081>>>>>>>>>>>>>        If (iChannel>=0) Begin
32083>>>>>>>>>>>>>            Move sPath to strFileInChops.sPath
32084>>>>>>>>>>>>>            Move 0 to iIndex
32085>>>>>>>>>>>>>            Get FileSizeBytes sPath to iBytesLeft
32086>>>>>>>>>>>>>            While (iBytesLeft>0)
32090>>>>>>>>>>>>>                Move (iBytesLeft min iBlockSize) to iBlockSize
32091>>>>>>>>>>>>>                Read_Block channel iChannel sBlock iBlockSize
32093>>>>>>>>>>>>>                Move iBlockSize to strFileInChops.aSegments[iIndex].iLen
32094>>>>>>>>>>>>>                Move sBlock to strFileInChops.aSegments[iIndex].sContent
32095>>>>>>>>>>>>>                Move (iBytesLeft-iBlockSize) to iBytesLeft
32096>>>>>>>>>>>>>                Increment iIndex
32097>>>>>>>>>>>>>            Loop
32098>>>>>>>>>>>>>>
32098>>>>>>>>>>>>>            Send CloseInput iChannel
32099>>>>>>>>>>>>>            Function_Return True
32100>>>>>>>>>>>>>        End
32100>>>>>>>>>>>>>>
32100>>>>>>>>>>>>>        Function_Return False
32101>>>>>>>>>>>>>    End_Function
32102>>>>>>>>>>>>>    
32102>>>>>>>>>>>>>    Function JoinFile String sPath tFileInChops strFileInChops Returns Boolean
32104>>>>>>>>>>>>>        Integer iChannel iIndex iMax
32104>>>>>>>>>>>>>        String sBlock
32104>>>>>>>>>>>>>        Get DirectOutput ("binary:"+sPath) to iChannel
32105>>>>>>>>>>>>>        If (iChannel>=0) Begin
32107>>>>>>>>>>>>>            Move (SizeOfArray(strFileInChops.aSegments)-1) to iMax
32108>>>>>>>>>>>>>            For iIndex from 0 to iMax
32114>>>>>>>>>>>>>>
32114>>>>>>>>>>>>>                Move strFileInChops.aSegments[iIndex].sContent to sBlock
32115>>>>>>>>>>>>>                Write channel iChannel sBlock // strFileInChops.aSegments[iIndex].sContent
32117>>>>>>>>>>>>>            Loop
32118>>>>>>>>>>>>>>
32118>>>>>>>>>>>>>            Send CloseOutput iChannel
32119>>>>>>>>>>>>>            Function_Return True
32120>>>>>>>>>>>>>        End
32120>>>>>>>>>>>>>>
32120>>>>>>>>>>>>>        Function_Return False
32121>>>>>>>>>>>>>    End_Function
32122>>>>>>>>>>>>>
32122>>>>>>>>>>>>>    Function TextFileAsArray String sPath Returns String[]
32124>>>>>>>>>>>>>        Boolean bEof
32124>>>>>>>>>>>>>        Integer iLineCount iChannel
32124>>>>>>>>>>>>>        String sLine
32124>>>>>>>>>>>>>        String[] aValues
32125>>>>>>>>>>>>>        Get DirectInput sPath to iChannel
32126>>>>>>>>>>>>>        If (iChannel>=0) Begin
32128>>>>>>>>>>>>>            Move 0 to iLineCount
32129>>>>>>>>>>>>>            Repeat
32129>>>>>>>>>>>>>>
32129>>>>>>>>>>>>>                Readln channel iChannel sLine
32131>>>>>>>>>>>>>                Move (SeqEof) to bEof
32132>>>>>>>>>>>>>                If (not(bEof)) Begin
32134>>>>>>>>>>>>>                    Move sLine to aValues[iLineCount]
32135>>>>>>>>>>>>>                    Increment iLineCount
32136>>>>>>>>>>>>>                End
32136>>>>>>>>>>>>>>
32136>>>>>>>>>>>>>            Until (bEof)
32138>>>>>>>>>>>>>            Send CloseInput iChannel
32139>>>>>>>>>>>>>        End
32139>>>>>>>>>>>>>>
32139>>>>>>>>>>>>>        Function_Return aValues
32140>>>>>>>>>>>>>    End_Function
32141>>>>>>>>>>>>>
32141>>>>>>>>>>>>>    Function FileSizeBytes String sPath Returns Number
32143>>>>>>>>>>>>>        tFileData sFileData
32143>>>>>>>>>>>>>        tFileData sFileData
32143>>>>>>>>>>>>>        If (ReadFileData(Self,sPath,&sFileData)) Begin
32145>>>>>>>>>>>>>            Function_Return sFileData.nFileSize
32146>>>>>>>>>>>>>        End
32146>>>>>>>>>>>>>>
32146>>>>>>>>>>>>>        Function_Return -1
32147>>>>>>>>>>>>>    End_Function
32148>>>>>>>>>>>>>
32148>>>>>>>>>>>>>            // (stolen from Wil van Antwerpen)
32148>>>>>>>>>>>>>            // Read about it here: http://msdn.microsoft.com/en-us/library/windows/desktop/bb762164(v=vs.85).aspx
32148>>>>>>>>>>>>>            // Remarks: You should Use fully qualified path names with this function. Using it with relative path names is not thread safe.
32148>>>>>>>>>>>>>            Function _FileOperation String sSource String sDestination Integer iOperation Integer iFlags Returns Integer
32150>>>>>>>>>>>>>                Integer iRval
32150>>>>>>>>>>>>>                _tFileOperation stOperation
32150>>>>>>>>>>>>>                _tFileOperation stOperation
32150>>>>>>>>>>>>>                
32150>>>>>>>>>>>>>                Move (ToAnsi(sSource)+Character(0)+Character(0)) to sSource // Double null termination
32151>>>>>>>>>>>>>                Move (ToAnsi(sDestination)+Character(0)+Character(0)) to sDestination // Double null termination
32152>>>>>>>>>>>>>                Move iOperation to stOperation.wFunc
32153>>>>>>>>>>>>>
32153>>>>>>>>>>>>>                Move (AddressOf(sSource)) to stOperation.pFrom
32154>>>>>>>>>>>>>                Move (AddressOf(sDestination)) to stOperation.pTo
32155>>>>>>>>>>>>>                Move iFlags to stOperation.fFlags
32156>>>>>>>>>>>>>
32156>>>>>>>>>>>>>                Move (ff_SHFileOperation(AddressOf(stOperation))) to iRval
32157>>>>>>>>>>>>>                If (stOperation.fAnyOperationsAborted<>0) begin
32159>>>>>>>>>>>>>                    Move 1 to iRval // Should be DE_OPCANCELLED really, but we haven't defined these constants anyway
32160>>>>>>>>>>>>>                End
32160>>>>>>>>>>>>>>
32160>>>>>>>>>>>>>                Function_Return iRval
32161>>>>>>>>>>>>>            End_Function
32162>>>>>>>>>>>>>
32162>>>>>>>>>>>>>    Function CopyFileNew String sPath1 String sPath2 Returns Boolean
32164>>>>>>>>>>>>>        Integer iFlags iError
32164>>>>>>>>>>>>>        Move (C_NOCONFIRMMKDIR ior C_NOCONFIRMATION) to iFlags
32165>>>>>>>>>>>>>            Move (iFlags ior C_NOERRORUI ior C_SILENT) to iFlags // If webapp: No user interface!
32166>>>>>>>>>>>>>        Get _FileOperation sPath1 sPath2 CFO_COPY iFlags to iError
32167>>>>>>>>>>>>>        Function_Return (iError=0)
32168>>>>>>>>>>>>>    End_Function
32169>>>>>>>>>>>>>
32169>>>>>>>>>>>>>    // Delete file or folder
32169>>>>>>>>>>>>>    Function DeleteFileNew String sPath Boolean bToBin Returns Boolean
32171>>>>>>>>>>>>>        Integer iFlags iError
32171>>>>>>>>>>>>>        Move (C_SILENT ior C_NOCONFIRMATION) to iFlags
32172>>>>>>>>>>>>>        If (bToBin) Move (iFlags ior C_ALLOWUNDO) to iFlags
32175>>>>>>>>>>>>>            Move (iFlags ior C_NOERRORUI) to iFlags // If webapp: No user interface!
32176>>>>>>>>>>>>>        Get _FileOperation sPath "" CFO_DELETE iFlags to iError
32177>>>>>>>>>>>>>        Function_Return (iError=0)
32178>>>>>>>>>>>>>    End_Function
32179>>>>>>>>>>>>>
32179>>>>>>>>>>>>>    Function RenameFileNew String sFileName1 String sFileName2 Returns Boolean
32181>>>>>>>>>>>>>        Integer iFlags iError
32181>>>>>>>>>>>>>        Move (C_SILENT ior C_NOCONFIRMATION) to iFlags
32182>>>>>>>>>>>>>            Move (iFlags ior C_NOERRORUI) to iFlags // If webapp: No user interface!
32183>>>>>>>>>>>>>        Get _FileOperation sFileName1 sFileName2 CFO_RENAME iFlags to iError
32184>>>>>>>>>>>>>        Function_Return (iError=0)
32185>>>>>>>>>>>>>    End_Function
32186>>>>>>>>>>>>>
32186>>>>>>>>>>>>>    Function MoveFileNew String sPath1 String sPath2 Returns Boolean
32188>>>>>>>>>>>>>        Integer iFlags iError
32188>>>>>>>>>>>>>        Move (C_NOCONFIRMMKDIR ior C_NOCONFIRMATION) to iFlags
32189>>>>>>>>>>>>>            Move (iFlags ior C_NOERRORUI) to iFlags // If webapp: No user interface!
32190>>>>>>>>>>>>>        Get _FileOperation sPath1 sPath2 CFO_MOVE iFlags to iError
32191>>>>>>>>>>>>>        Function_Return (iError=0)
32192>>>>>>>>>>>>>    End_Function
32193>>>>>>>>>>>>>
32193>>>>>>>>>>>>>    // If sNewFolder already exists the function will return False (failure)
32193>>>>>>>>>>>>>    Function CreateFolderNew String sNewFolder Returns Boolean
32195>>>>>>>>>>>>>        Integer iRval
32195>>>>>>>>>>>>>        Move (ToAnsi(sNewFolder)) to sNewFolder
32196>>>>>>>>>>>>>        // http://msdn.microsoft.com/en-us/library/windows/desktop/aa363855(v=vs.85).aspx
32196>>>>>>>>>>>>>        Move (ff_CreateDirectory(AddressOf(sNewFolder),0)) to iRval
32197>>>>>>>>>>>>>        // If the Function succeeds, the return value is nonzero.
32197>>>>>>>>>>>>>        // If the Function fails, the return value is zero. 
32197>>>>>>>>>>>>>        // To get extended Error information, call GetLastError. 
32197>>>>>>>>>>>>>        Function_Return (iRval<>0)
32198>>>>>>>>>>>>>    End_Function
32199>>>>>>>>>>>>>    
32199>>>>>>>>>>>>>    //> Returns True on success
32199>>>>>>>>>>>>>    Function CreateFolderIfNotExist String sFolder Returns Boolean
32201>>>>>>>>>>>>>        Integer iExist
32201>>>>>>>>>>>>>        Boolean bExist
32201>>>>>>>>>>>>>        Get FileExists sFolder to iExist
32202>>>>>>>>>>>>>        Move (iExist=2) to bExist // Does folder exist?
32203>>>>>>>>>>>>>        If (not(bExist)) Begin
32205>>>>>>>>>>>>>            If (iExist=0) Begin // If not, and also no file of that name exists:
32207>>>>>>>>>>>>>                Move (CreateFolderNew(Self,sFolder)) to bExist
32208>>>>>>>>>>>>>                Get FileExists sFolder to iExist
32209>>>>>>>>>>>>>                Move (iExist=2) to bExist
32210>>>>>>>>>>>>>            End
32210>>>>>>>>>>>>>>
32210>>>>>>>>>>>>>        End
32210>>>>>>>>>>>>>>
32210>>>>>>>>>>>>>        Function_Return bExist
32211>>>>>>>>>>>>>    End_Function
32212>>>>>>>>>>>>>
32212>>>>>>>>>>>>>    // sRootFolder must already exist. Returns True if the sRootFolder\sSubFolderPath can be accessed after calling the function
32212>>>>>>>>>>>>>    Function CreateFolderMultiLevel String sRootFolder String sSubFolderPath Returns Boolean
32214>>>>>>>>>>>>>        Boolean bSuccess
32214>>>>>>>>>>>>>        Integer iFolderIndex iFolderMax iExists
32214>>>>>>>>>>>>>        String[] aFolderPath
32215>>>>>>>>>>>>>
32215>>>>>>>>>>>>>        If (FileExists(Self,sRootFolder)=2) Begin
32217>>>>>>>>>>>>>
32217>>>>>>>>>>>>>            Send SplitString of oStringFunctions sSubFolderPath "\" False True (&aFolderPath)
32218>>>>>>>>>>>>>            Move (SizeOfArray(aFolderPath)-1) to iFolderMax
32219>>>>>>>>>>>>>            Move True to bSuccess
32220>>>>>>>>>>>>>            For iFolderIndex from 0 to iFolderMax
32226>>>>>>>>>>>>>>
32226>>>>>>>>>>>>>                If (bSuccess) Begin
32228>>>>>>>>>>>>>                    Get AppendPath sRootFolder aFolderPath[iFolderIndex] to sRootFolder
32229>>>>>>>>>>>>>                    Get FileExists sRootFolder to iExists
32230>>>>>>>>>>>>>                    If (iExists=0) Begin // Does not exist
32232>>>>>>>>>>>>>                        Get CreateFolderNew sRootFolder to bSuccess
32233>>>>>>>>>>>>>                    End
32233>>>>>>>>>>>>>>
32233>>>>>>>>>>>>>                    If (iExists=1) Begin // It exists and it's a file (not good)
32235>>>>>>>>>>>>>                        Move False to bSuccess
32236>>>>>>>>>>>>>                        Error 821 ("Can't create folder ('"+sRootFolder+"' is a file)")
32237>>>>>>>>>>>>>>
32237>>>>>>>>>>>>>                    End
32237>>>>>>>>>>>>>>
32237>>>>>>>>>>>>>                    If (iExists=2) Begin // It Exists and it's a folder (fine)
32239>>>>>>>>>>>>>                        // Do nothing
32239>>>>>>>>>>>>>                    End
32239>>>>>>>>>>>>>>
32239>>>>>>>>>>>>>                End
32239>>>>>>>>>>>>>>
32239>>>>>>>>>>>>>            Loop
32240>>>>>>>>>>>>>>
32240>>>>>>>>>>>>>        End
32240>>>>>>>>>>>>>>
32240>>>>>>>>>>>>>        Else Begin
32241>>>>>>>>>>>>>            Move False to bSuccess
32242>>>>>>>>>>>>>        End
32242>>>>>>>>>>>>>>
32242>>>>>>>>>>>>>        Function_Return bSuccess
32243>>>>>>>>>>>>>    End_Function
32244>>>>>>>>>>>>>
32244>>>>>>>>>>>>>    // Folder must be empty and have no sub-folders
32244>>>>>>>>>>>>>    Function DeleteFolderNew String sPath Returns Boolean
32246>>>>>>>>>>>>>        Integer iRval
32246>>>>>>>>>>>>>        Move (ToAnsi(sPath)) to sPath
32247>>>>>>>>>>>>>        Move (ff_RemoveDirectory(AddressOf(sPath))) to iRval // If the function succeeds, the return value is nonzero.
32248>>>>>>>>>>>>>        Function_Return (iRval<>0)
32249>>>>>>>>>>>>>    End_Function
32250>>>>>>>>>>>>>
32250>>>>>>>>>>>>>    Function DeleteAllFilesInFolderNew String sPath Returns Boolean
32252>>>>>>>>>>>>>        Integer iIndex iMax iFailure
32252>>>>>>>>>>>>>        String sFileName
32252>>>>>>>>>>>>>        tFileData[] aFileData
32252>>>>>>>>>>>>>        tFileData[] aFileData
32253>>>>>>>>>>>>>        Send ReadFolder sPath "*" (&aFileData) 1 // 1 means files (and not folders)
32254>>>>>>>>>>>>>        Move (SizeOfArray(aFileData)-1) to iMax
32255>>>>>>>>>>>>>        Move 0 to iFailure
32256>>>>>>>>>>>>>        For iIndex from 0 to iMax
32262>>>>>>>>>>>>>>
32262>>>>>>>>>>>>>            If (iFailure=0) Begin
32264>>>>>>>>>>>>>                Get AppendPath sPath aFileData[iIndex].sFileName to sFileName
32265>>>>>>>>>>>>>                If (not(DeleteFileNew(Self,sFileName,False))) Begin
32267>>>>>>>>>>>>>                    Error 392 ("Could not delete file "+sFileName)
32268>>>>>>>>>>>>>>
32268>>>>>>>>>>>>>                End
32268>>>>>>>>>>>>>>
32268>>>>>>>>>>>>>            End
32268>>>>>>>>>>>>>>
32268>>>>>>>>>>>>>        Loop
32269>>>>>>>>>>>>>>
32269>>>>>>>>>>>>>        Function_Return (iFailure=0)
32270>>>>>>>>>>>>>    End_Function
32271>>>>>>>>>>>>>
32271>>>>>>>>>>>>>    // Delete recursively all files and remove folders. SUPER POWERFUL AND THUS DANGEROUS!
32271>>>>>>>>>>>>>    Function DeleteFolderRecursiveNew String sPath Returns Boolean
32273>>>>>>>>>>>>>        Boolean bSuccess
32273>>>>>>>>>>>>>        Integer iIndex iMax
32273>>>>>>>>>>>>>        tFileData[] aFileData
32273>>>>>>>>>>>>>        tFileData[] aFileData
32274>>>>>>>>>>>>>        String sSubFolder
32274>>>>>>>>>>>>>        // Get rid of all files
32274>>>>>>>>>>>>>        Get DeleteAllFilesInFolderNew sPath to bSuccess
32275>>>>>>>>>>>>>        If (bSuccess) Begin
32277>>>>>>>>>>>>>            Send ReadFolder sPath "*" (&aFileData) 2 // 2 means folders (and not files)
32278>>>>>>>>>>>>>            Move (SizeOfArray(aFileData)-1) to iMax
32279>>>>>>>>>>>>>            For iIndex from 0 to iMax
32285>>>>>>>>>>>>>>
32285>>>>>>>>>>>>>                If (bSuccess and aFileData[iIndex].sFileName<>"." and aFileData[iIndex].sFileName<>"..") Begin
32287>>>>>>>>>>>>>                    Get AppendPath sPath aFileData[iIndex].sFileName to sSubFolder
32288>>>>>>>>>>>>>                    Get DeleteFolderRecursiveNew sSubFolder to bSuccess
32289>>>>>>>>>>>>>                    If (not(bSuccess)) Begin
32291>>>>>>>>>>>>>                        Error 392 ("Could not delete folder "+sSubFolder)
32292>>>>>>>>>>>>>>
32292>>>>>>>>>>>>>                    End
32292>>>>>>>>>>>>>>
32292>>>>>>>>>>>>>                End
32292>>>>>>>>>>>>>>
32292>>>>>>>>>>>>>            Loop
32293>>>>>>>>>>>>>>
32293>>>>>>>>>>>>>        End
32293>>>>>>>>>>>>>>
32293>>>>>>>>>>>>>        If (bSuccess) Begin // Remove the folder
32295>>>>>>>>>>>>>            Get DeleteFolderNew sPath to bSuccess
32296>>>>>>>>>>>>>        End
32296>>>>>>>>>>>>>>
32296>>>>>>>>>>>>>        Function_Return (bSuccess)
32297>>>>>>>>>>>>>    End_Function
32298>>>>>>>>>>>>>
32298>>>>>>>>>>>>>        Function _CopyFileDataArray tFileData[] aFileData String sSourceFolder String sTargetFolder Integer hMsg Integer hObj Returns Boolean
32300>>>>>>>>>>>>>            Boolean bSuccess
32300>>>>>>>>>>>>>            Integer iMax iIndex
32300>>>>>>>>>>>>>            String sSourceItem sTargetItem
32300>>>>>>>>>>>>>
32300>>>>>>>>>>>>>            If (CreateFolderIfNotExist(Self,sTargetFolder)) Begin
32302>>>>>>>>>>>>>                Move True to bSuccess
32303>>>>>>>>>>>>>                Move (SizeOfArray(aFileData)-1) to iMax
32304>>>>>>>>>>>>>                For iIndex from 0 to iMax
32310>>>>>>>>>>>>>>
32310>>>>>>>>>>>>>                    If (bSuccess and not(aFileData[iIndex].bSelfReference)) Begin
32312>>>>>>>>>>>>>                        Get AppendPath sSourceFolder aFileData[iIndex].sFileName to sSourceItem
32313>>>>>>>>>>>>>                        Get AppendPath sTargetFolder aFileData[iIndex].sFileName to sTargetItem
32314>>>>>>>>>>>>>                        If (aFileData[iIndex].bIsFolder) Begin // Folder
32316>>>>>>>>>>>>>                            Get _CopyFileDataArray aFileData[iIndex].aFolderContent sSourceItem sTargetItem hMsg hObj to bSuccess
32317>>>>>>>>>>>>>                        End
32317>>>>>>>>>>>>>>
32317>>>>>>>>>>>>>                        Else Begin // File
32318>>>>>>>>>>>>>                            Move (CopyFileNew(Self,sSourceItem,sTargetItem)) to bSuccess
32319>>>>>>>>>>>>>                        End
32319>>>>>>>>>>>>>>
32319>>>>>>>>>>>>>                    End
32319>>>>>>>>>>>>>>
32319>>>>>>>>>>>>>                Loop
32320>>>>>>>>>>>>>>
32320>>>>>>>>>>>>>            End
32320>>>>>>>>>>>>>>
32320>>>>>>>>>>>>>            Else Begin
32321>>>>>>>>>>>>>                Move False to bSuccess
32322>>>>>>>>>>>>>            End
32322>>>>>>>>>>>>>>
32322>>>>>>>>>>>>>
32322>>>>>>>>>>>>>            Function_Return bSuccess
32323>>>>>>>>>>>>>        End_Function
32324>>>>>>>>>>>>>
32324>>>>>>>>>>>>>    // Returns True on success. I don't think hMSG and hObj are used for anything. Set to 0
32324>>>>>>>>>>>>>    Function CopyFileDataArray tFileData[] aFileData String sSourceFolder String sTargetFolder Integer hMsg Integer hObj Returns Boolean
32326>>>>>>>>>>>>>        Function_Return (_CopyFileDataArray(Self,aFileData,sSourceFolder,sTargetFolder,hMsg,hObj))
32327>>>>>>>>>>>>>    End_Function
32328>>>>>>>>>>>>>
32328>>>>>>>>>>>>>    Function LongPathName String sShortPath Returns String
32330>>>>>>>>>>>>>        Pointer lpszShortPath lpszLongPath
32330>>>>>>>>>>>>>        Integer iVoid
32330>>>>>>>>>>>>>        String sLongPath
32330>>>>>>>>>>>>>        ZeroString C_MAX_PATH to sLongPath
32331>>>>>>>>>>>>>        Move (ToANSI(sShortPath)) to sShortPath
32332>>>>>>>>>>>>>        GetAddress of sLongPath  to lpszLongPath
32333>>>>>>>>>>>>>        GetAddress of sShortPath to lpszShortPath
32334>>>>>>>>>>>>>        Move (ff_GetLongPathName(lpszShortPath,lpszLongPath,C_MAX_PATH)) to iVoid
32335>>>>>>>>>>>>>        Function_Return (Cstring(ToOEM(sLongPath)))
32336>>>>>>>>>>>>>    End_Function // IsLongPathName
32337>>>>>>>>>>>>>
32337>>>>>>>>>>>>>    // Returns the temp folder of the system
32337>>>>>>>>>>>>>    Function UserTempFolder Returns String // published by Clayton Schirmer, 22-03-2002 on NGs
32339>>>>>>>>>>>>>        String sPath
32339>>>>>>>>>>>>>        Pointer pPath
32339>>>>>>>>>>>>>        Integer iRet
32339>>>>>>>>>>>>>        Move (Repeat(Character(0),255)) to sPath
32340>>>>>>>>>>>>>        GetAddress of sPath to pPath
32341>>>>>>>>>>>>>        Move (ff_TempPath(255,pPath)) to iRet
32342>>>>>>>>>>>>>        Function_Return (LongPathName(Self,CString(ToOEM(sPath))))
32343>>>>>>>>>>>>>    End_Function
32344>>>>>>>>>>>>>
32344>>>>>>>>>>>>>    // Use this function to obtain Windows specific folder. Parameter iWinFolderId is one of the
32344>>>>>>>>>>>>>    // "CSIDL_" defined in the top of this file. Be aware that not all folders are defined on all windows
32344>>>>>>>>>>>>>    // systems.
32344>>>>>>>>>>>>>    Function WinFolderPath Integer iWinFolderId Returns String
32346>>>>>>>>>>>>>        // This function I found on WASP (by Frank Cheng).
32346>>>>>>>>>>>>>        Integer iVoid
32346>>>>>>>>>>>>>        String sPath
32346>>>>>>>>>>>>>        ZeroString C_MAX_PATH to sPath
32347>>>>>>>>>>>>>        Move (ff_SHGetSpecialFolderPath(0,AddressOf(sPath),iWinFolderID,1)) to iVoid
32348>>>>>>>>>>>>>        If (iVoid=0) Function_Return ""
32351>>>>>>>>>>>>>        Function_Return (ToOEM(CString(sPath)))
32352>>>>>>>>>>>>>    End_Function
32353>>>>>>>>>>>>>
32353>>>>>>>>>>>>>    Enum_List //> VDF Folder id's. Used as parameter for the VdfFolderPath function (iVdfFolderId parameter).
32353>>>>>>>>>>>>>        Define VDF_ROOT     //> Root of the VDF runtime, for example "C:\VDF12".
32353>>>>>>>>>>>>>        Define VDF_HTML     //> Path to the AppHtml folder of the current work space.
32353>>>>>>>>>>>>>        Define VDF_FILELIST //> Path to Filelist.cfg of the current work space
32353>>>>>>>>>>>>>        Define VDF_OPENPATH //> Path used when opening tables via Filelist.cfg
32353>>>>>>>>>>>>>        Define VDF_PROGRAM  //> Path to the folder of the current program
32353>>>>>>>>>>>>>        Define VDF_DDSRC    //> Path of the DD source folder (if present)
32353>>>>>>>>>>>>>        Define VDF_APPSRC   //> Path of the source folder (if present)
32353>>>>>>>>>>>>>        Define VDF_BITMAPS  //> Path of bitmaps folder
32353>>>>>>>>>>>>>        Define VDF_VDFXRAY  //> Folder for VDFXRay configuration
32353>>>>>>>>>>>>>        Define VDF_APPHTML  //> Folder to AppHtml folder
32353>>>>>>>>>>>>>    End_Enum_List
32353>>>>>>>>>>>>>
32353>>>>>>>>>>>>>    Function VdfFolderPath Integer iVdfFolderId Returns String
32355>>>>>>>>>>>>>        Integer hoWorkSpace
32355>>>>>>>>>>>>>        String sFolder sOpenPath
32355>>>>>>>>>>>>>        If (iVdfFolderId=VDF_ROOT) Begin
32357>>>>>>>>>>>>>            get_profile_string "Defaults" "VdfRootDir" to sFolder
32360>>>>>>>>>>>>>        End
32360>>>>>>>>>>>>>>
32360>>>>>>>>>>>>>        If (iVdfFolderId=VDF_HTML) Begin
32362>>>>>>>>>>>>>            If (ghoApplication<>0) Begin
32364>>>>>>>>>>>>>                Get phoWorkspace of ghoApplication to hoWorkSpace
32365>>>>>>>>>>>>>                If (hoWorkSpace<>0) Begin
32367>>>>>>>>>>>>>                    Get psAppHtmlPath of hoWorkSpace to sFolder
32368>>>>>>>>>>>>>                End
32368>>>>>>>>>>>>>>
32368>>>>>>>>>>>>>            End
32368>>>>>>>>>>>>>>
32368>>>>>>>>>>>>>        End
32368>>>>>>>>>>>>>>
32368>>>>>>>>>>>>>        If (iVdfFolderId=VDF_FILELIST) Begin
32370>>>>>>>>>>>>>            Get_Attribute DF_FILELIST_NAME to sFolder
32373>>>>>>>>>>>>>            If (sFolder contains "\") Begin
32375>>>>>>>>>>>>>                // Absolute path of filelist.cfg => we must strip the "filelist.cfg" to get the folder.
32375>>>>>>>>>>>>>                Get PathToFolder sFolder to sFolder
32376>>>>>>>>>>>>>            End
32376>>>>>>>>>>>>>>
32376>>>>>>>>>>>>>            Else Begin
32377>>>>>>>>>>>>>                // Absolute path not specified => we must look for it along VDF's "open_path"
32377>>>>>>>>>>>>>                Get_Attribute DF_OPEN_PATH to sOpenPath  // This is the path we want dbquery to use
32380>>>>>>>>>>>>>                Get FindFile sFolder sOpenPath to sFolder
32381>>>>>>>>>>>>>            End
32381>>>>>>>>>>>>>>
32381>>>>>>>>>>>>>        End
32381>>>>>>>>>>>>>>
32381>>>>>>>>>>>>>        If (iVdfFolderId=VDF_OPENPATH) Begin
32383>>>>>>>>>>>>>            Get_Attribute DF_OPEN_PATH to sFolder
32386>>>>>>>>>>>>>        End
32386>>>>>>>>>>>>>>
32386>>>>>>>>>>>>>        If (iVdfFolderId=VDF_PROGRAM) Begin
32388>>>>>>>>>>>>>            If (ghoApplication<>0) Begin
32390>>>>>>>>>>>>>                Get phoWorkspace of ghoApplication to hoWorkSpace
32391>>>>>>>>>>>>>                If (hoWorkSpace<>0) Begin
32393>>>>>>>>>>>>>                    Get psProgramPath of hoWorkSpace to sFolder
32394>>>>>>>>>>>>>                End
32394>>>>>>>>>>>>>>
32394>>>>>>>>>>>>>            End
32394>>>>>>>>>>>>>>
32394>>>>>>>>>>>>>        End
32394>>>>>>>>>>>>>>
32394>>>>>>>>>>>>>        If (iVdfFolderId=VDF_BITMAPS) Begin
32396>>>>>>>>>>>>>            If (ghoApplication<>0) Begin
32398>>>>>>>>>>>>>                Get phoWorkspace of ghoApplication to hoWorkSpace
32399>>>>>>>>>>>>>                If (hoWorkSpace<>0) Begin
32401>>>>>>>>>>>>>                    Get psBitmapPath of hoWorkSpace to sFolder
32402>>>>>>>>>>>>>                    If (FileExists(Self,sFolder)=0) Begin
32404>>>>>>>>>>>>>                        Move "" to sFolder
32405>>>>>>>>>>>>>                    End
32405>>>>>>>>>>>>>>
32405>>>>>>>>>>>>>                End
32405>>>>>>>>>>>>>>
32405>>>>>>>>>>>>>            End
32405>>>>>>>>>>>>>>
32405>>>>>>>>>>>>>        End
32405>>>>>>>>>>>>>>
32405>>>>>>>>>>>>>        If (iVdfFolderId=VDF_APPHTML) Begin
32407>>>>>>>>>>>>>            If (ghoApplication<>0) Begin
32409>>>>>>>>>>>>>                Get phoWorkspace of ghoApplication to hoWorkSpace
32410>>>>>>>>>>>>>                If (hoWorkSpace<>0) Begin
32412>>>>>>>>>>>>>                    Get psAppHtmlPath of hoWorkSpace to sFolder
32413>>>>>>>>>>>>>                    If (FileExists(Self,sFolder)=0) Begin
32415>>>>>>>>>>>>>                        Move "" to sFolder
32416>>>>>>>>>>>>>                    End
32416>>>>>>>>>>>>>>
32416>>>>>>>>>>>>>                End
32416>>>>>>>>>>>>>>
32416>>>>>>>>>>>>>            End
32416>>>>>>>>>>>>>>
32416>>>>>>>>>>>>>        End
32416>>>>>>>>>>>>>>
32416>>>>>>>>>>>>>        If (iVdfFolderId=VDF_APPSRC) Begin
32418>>>>>>>>>>>>>            If (ghoApplication<>0) Begin
32420>>>>>>>>>>>>>                Get phoWorkspace of ghoApplication to hoWorkSpace
32421>>>>>>>>>>>>>                If (hoWorkSpace<>0) Begin
32423>>>>>>>>>>>>>                    Get psAppSrcPath of hoWorkSpace to sFolder
32424>>>>>>>>>>>>>                    If (FileExists(Self,sFolder)=0) Begin
32426>>>>>>>>>>>>>                        Move "" to sFolder
32427>>>>>>>>>>>>>                    End
32427>>>>>>>>>>>>>>
32427>>>>>>>>>>>>>                End
32427>>>>>>>>>>>>>>
32427>>>>>>>>>>>>>            End
32427>>>>>>>>>>>>>>
32427>>>>>>>>>>>>>        End
32427>>>>>>>>>>>>>>
32427>>>>>>>>>>>>>        If (iVdfFolderId=VDF_DDSRC) Begin
32429>>>>>>>>>>>>>            If (ghoApplication<>0) Begin
32431>>>>>>>>>>>>>                Get phoWorkspace of ghoApplication to hoWorkSpace
32432>>>>>>>>>>>>>                If (hoWorkSpace<>0) Begin
32434>>>>>>>>>>>>>                    Get psDdSrcPath of hoWorkSpace to sFolder
32435>>>>>>>>>>>>>                    If (FileExists(Self,sFolder)=0) Begin
32437>>>>>>>>>>>>>                        Move "" to sFolder
32438>>>>>>>>>>>>>                    End
32438>>>>>>>>>>>>>>
32438>>>>>>>>>>>>>                End
32438>>>>>>>>>>>>>>
32438>>>>>>>>>>>>>            End
32438>>>>>>>>>>>>>>
32438>>>>>>>>>>>>>        End
32438>>>>>>>>>>>>>>
32438>>>>>>>>>>>>>        If (iVdfFolderId=VDF_VDFXRAY) Begin
32440>>>>>>>>>>>>>            Get VdfFolderPath VDF_FILELIST to sFolder
32441>>>>>>>>>>>>>            Get PathToFolder sFolder to sFolder
32442>>>>>>>>>>>>>            Get AppendPath sFolder "VDFXRay_cfg" to sFolder
32443>>>>>>>>>>>>>            If (FileExists(Self,sFolder)<>2) Begin
32445>>>>>>>>>>>>>                If (_pbCreateVDFXRayFolderOnReq(Self)) Begin
32447>>>>>>>>>>>>>                    If (not(CreateFolderNew(Self,sFolder))) Begin
32449>>>>>>>>>>>>>                        Move "" to sFolder
32450>>>>>>>>>>>>>                    End
32450>>>>>>>>>>>>>>
32450>>>>>>>>>>>>>                End
32450>>>>>>>>>>>>>>
32450>>>>>>>>>>>>>                Else Begin
32451>>>>>>>>>>>>>                    Move "" to sFolder
32452>>>>>>>>>>>>>                End
32452>>>>>>>>>>>>>>
32452>>>>>>>>>>>>>            End
32452>>>>>>>>>>>>>>
32452>>>>>>>>>>>>>        End
32452>>>>>>>>>>>>>>
32452>>>>>>>>>>>>>        Function_Return sFolder
32453>>>>>>>>>>>>>    End_Function
32454>>>>>>>>>>>>>    
32454>>>>>>>>>>>>>    Function CreateVDFXrayConfigurationFolder Returns Boolean
32456>>>>>>>>>>>>>        String sFolder
32456>>>>>>>>>>>>>        Set _pbCreateVDFXRayFolderOnReq to True
32457>>>>>>>>>>>>>        Get VdfFolderPath VDF_VDFXRAY to sFolder
32458>>>>>>>>>>>>>        Set _pbCreateVDFXRayFolderOnReq to False
32459>>>>>>>>>>>>>        Function_Return (sFolder<>"")
32460>>>>>>>>>>>>>    End_Function
32461>>>>>>>>>>>>>    
32461>>>>>>>>>>>>>    //> Translate absolute disk folder (or file) into relative HTML folder (or file).
32461>>>>>>>>>>>>>    Function DiskFolderToHtml String sDiskFolder Returns String
32463>>>>>>>>>>>>>        String sHtmlRootFolder sRelativeFolder
32463>>>>>>>>>>>>>        Get VdfFolderPath VDF_HTML to sHtmlRootFolder
32464>>>>>>>>>>>>>        Move (Lowercase(sDiskFolder)) to sDiskFolder
32465>>>>>>>>>>>>>        Move (Lowercase(sHtmlRootFolder)) to sHtmlRootFolder
32466>>>>>>>>>>>>>        Move (Replace(sHtmlRootFolder,sDiskFolder,"")) to sRelativeFolder
32467>>>>>>>>>>>>>
32467>>>>>>>>>>>>>        If (Left(sRelativeFolder,1)="\") Move (replace("\",sRelativeFolder,"")) to sRelativeFolder
32470>>>>>>>>>>>>>        Move (Replaces("\",sRelativeFolder,"/")) to sRelativeFolder
32471>>>>>>>>>>>>>        Function_Return sRelativeFolder
32472>>>>>>>>>>>>>    End_Function
32473>>>>>>>>>>>>>
32473>>>>>>>>>>>>>    //> Returns a string containing the drive letters that are valid for the system.
32473>>>>>>>>>>>>>    Function ValidDriveLetters Returns String
32475>>>>>>>>>>>>>        Integer iLen iPos
32475>>>>>>>>>>>>>        Boolean bErr
32475>>>>>>>>>>>>>        String sDrives sDrive sValidDrives
32475>>>>>>>>>>>>>        Move "ABCDEFGHIJKLMNOPQRSTUVWXYZ" to sDrives
32476>>>>>>>>>>>>>        Move "" to sValidDrives
32477>>>>>>>>>>>>>        Move (Length(sDrives)) to iLen
32478>>>>>>>>>>>>>        For iPos from 1 to iLen
32484>>>>>>>>>>>>>>
32484>>>>>>>>>>>>>            Move (Mid(sDrives,1,iPos)) to sDrive
32485>>>>>>>>>>>>>            Valid_Drive sDrive bErr
32486>>>>>>>>>>>>>            If (not(bErr)) Move (sValidDrives+sDrive) to sValidDrives
32489>>>>>>>>>>>>>        Loop
32490>>>>>>>>>>>>>>
32490>>>>>>>>>>>>>        Function_Return sValidDrives
32491>>>>>>>>>>>>>    End_Function
32492>>>>>>>>>>>>>
32492>>>>>>>>>>>>>    //> Function DataSubFolder returns the value of sSubFolderName appended to
32492>>>>>>>>>>>>>    //> the folder name in which filelist.cfg resides.
32492>>>>>>>>>>>>>    Function DataSubFolder String sSubFolderName Boolean bCreate Returns String
32494>>>>>>>>>>>>>        String sRval
32494>>>>>>>>>>>>>        Boolean bCreateTmp
32494>>>>>>>>>>>>>        If (num_arguments>1) Begin
32496>>>>>>>>>>>>>            Move bCreate to bCreateTmp
32497>>>>>>>>>>>>>        End
32497>>>>>>>>>>>>>>
32497>>>>>>>>>>>>>        Else Begin
32498>>>>>>>>>>>>>            Move False to bCreateTmp
32499>>>>>>>>>>>>>        End
32499>>>>>>>>>>>>>>
32499>>>>>>>>>>>>>        Get VdfFolderPath VDF_FILELIST to sRval
32500>>>>>>>>>>>>>        Get AppendPath sRval sSubFolderName to sRval
32501>>>>>>>>>>>>>        If (bCreateTmp) Begin
32503>>>>>>>>>>>>>            If (FileExists(Self,sRval)=0) Begin
32505>>>>>>>>>>>>>                Get CreateFolderNew sRval to bCreateTmp
32506>>>>>>>>>>>>>            End
32506>>>>>>>>>>>>>>
32506>>>>>>>>>>>>>        End
32506>>>>>>>>>>>>>>
32506>>>>>>>>>>>>>        Function_Return sRval
32507>>>>>>>>>>>>>    End_Function
32508>>>>>>>>>>>>>
32508>>>>>>>>>>>>>    Function DataSubFolderPersonal String sSubFolderName Boolean bCreate Returns String
32510>>>>>>>>>>>>>        String sFolder
32510>>>>>>>>>>>>>        Boolean bCreateTmp
32510>>>>>>>>>>>>>        If (num_arguments>1) Begin
32512>>>>>>>>>>>>>            Move bCreate to bCreateTmp
32513>>>>>>>>>>>>>        End
32513>>>>>>>>>>>>>>
32513>>>>>>>>>>>>>        Else Begin
32514>>>>>>>>>>>>>            Move False to bCreateTmp
32515>>>>>>>>>>>>>        End
32515>>>>>>>>>>>>>>
32515>>>>>>>>>>>>>        Get DataSubFolder sSubFolderName bCreateTmp to sFolder
32516>>>>>>>>>>>>>        Get AppendPath sFolder (NetworkUserName(oWindowsInfo)) to sFolder
32517>>>>>>>>>>>>>        If (bCreateTmp) Begin
32519>>>>>>>>>>>>>            If (FileExists(Self,sFolder)=0) Begin
32521>>>>>>>>>>>>>                Get CreateFolderNew sFolder to bCreateTmp
32522>>>>>>>>>>>>>            End
32522>>>>>>>>>>>>>>
32522>>>>>>>>>>>>>        End
32522>>>>>>>>>>>>>>
32522>>>>>>>>>>>>>        Function_Return sFolder
32523>>>>>>>>>>>>>    End_Function
32524>>>>>>>>>>>>>
32524>>>>>>>>>>>>>    Function DataSubFolderFindFile String sSubFolderName String sFileName Returns String
32526>>>>>>>>>>>>>        String sRval sFolder
32526>>>>>>>>>>>>>        Get DataSubFolderPersonal sSubFolderName to sFolder
32527>>>>>>>>>>>>>        Get AppendPath sFolder sFileName to sRval
32528>>>>>>>>>>>>>        If (FileExists(Self,sRval)<>1) Begin // Is it in the personal folder?
32530>>>>>>>>>>>>>            Get DataSubFolder sSubFolderName to sFolder
32531>>>>>>>>>>>>>            Get AppendPath sFolder sFileName to sRval
32532>>>>>>>>>>>>>            If (FileExists(Self,sRval)<>1) Begin
32534>>>>>>>>>>>>>                Move "" to sRval // Not found
32535>>>>>>>>>>>>>            End
32535>>>>>>>>>>>>>>
32535>>>>>>>>>>>>>        End
32535>>>>>>>>>>>>>>
32535>>>>>>>>>>>>>        Function_Return sRval
32536>>>>>>>>>>>>>    End_Function
32537>>>>>>>>>>>>>
32537>>>>>>>>>>>>>    Function ImageTextAsString Integer iImg Returns String
32539>>>>>>>>>>>>>        Integer iChannel
32539>>>>>>>>>>>>>        String sRval sLine sChar10
32539>>>>>>>>>>>>>        Boolean bSeqEof
32539>>>>>>>>>>>>>
32539>>>>>>>>>>>>>        Move "" to sRval
32540>>>>>>>>>>>>>        Move (Character(10)) to sChar10
32541>>>>>>>>>>>>>
32541>>>>>>>>>>>>>        Get DirectInput ("image:"+String(iImg)) to iChannel
32542>>>>>>>>>>>>>        If (iChannel>=0) Begin
32544>>>>>>>>>>>>>            Repeat
32544>>>>>>>>>>>>>>
32544>>>>>>>>>>>>>                Readln sLine
32545>>>>>>>>>>>>>                Move (SeqEof) to bSeqEof
32546>>>>>>>>>>>>>                If (not(bSeqEof)) Begin
32548>>>>>>>>>>>>>                     Move (sRval+sLine+sChar10) to sRval
32549>>>>>>>>>>>>>                End
32549>>>>>>>>>>>>>>
32549>>>>>>>>>>>>>            Until (bSeqEof)
32551>>>>>>>>>>>>>
32551>>>>>>>>>>>>>            Send CloseInput iChannel
32552>>>>>>>>>>>>>        End
32552>>>>>>>>>>>>>>
32552>>>>>>>>>>>>>        Function_Return sRval
32553>>>>>>>>>>>>>    End_Function
32554>>>>>>>>>>>>>
32554>>>>>>>>>>>>>    Procedure WriteIntegerArray Integer[] aValues Integer iChannel
32556>>>>>>>>>>>>>        Integer iItem iItemMax
32556>>>>>>>>>>>>>        Move (SizeOfArray(aValues)-1) to iItemMax
32557>>>>>>>>>>>>>        Writeln channel iChannel iItemMax
32560>>>>>>>>>>>>>        For iItem from 0 to iItemMax
32566>>>>>>>>>>>>>>
32566>>>>>>>>>>>>>            Writeln aValues[iItem]
32568>>>>>>>>>>>>>        Loop
32569>>>>>>>>>>>>>>
32569>>>>>>>>>>>>>    End_Procedure
32570>>>>>>>>>>>>>
32570>>>>>>>>>>>>>    Function ReadIntegerArray Integer iChannel Returns Integer[]
32572>>>>>>>>>>>>>        Integer iItem iItemMax
32572>>>>>>>>>>>>>        Integer[] aValues
32573>>>>>>>>>>>>>        Readln channel iChannel iItemMax
32575>>>>>>>>>>>>>        For iItem from 0 to iItemMax
32581>>>>>>>>>>>>>>
32581>>>>>>>>>>>>>            Readln aValues[iItem]
32582>>>>>>>>>>>>>        Loop
32583>>>>>>>>>>>>>>
32583>>>>>>>>>>>>>        Function_Return aValues
32584>>>>>>>>>>>>>    End_Function
32585>>>>>>>>>>>>>
32585>>>>>>>>>>>>>    Procedure WriteNumberArray Number[] aValues Integer iChannel
32587>>>>>>>>>>>>>        Integer iItem iItemMax
32587>>>>>>>>>>>>>        Move (SizeOfArray(aValues)-1) to iItemMax
32588>>>>>>>>>>>>>        Writeln channel iChannel iItemMax
32591>>>>>>>>>>>>>        For iItem from 0 to iItemMax
32597>>>>>>>>>>>>>>
32597>>>>>>>>>>>>>            Writeln aValues[iItem]
32599>>>>>>>>>>>>>        Loop
32600>>>>>>>>>>>>>>
32600>>>>>>>>>>>>>    End_Procedure
32601>>>>>>>>>>>>>
32601>>>>>>>>>>>>>    Function ReadNumberArray Integer iChannel Returns Number[]
32603>>>>>>>>>>>>>        Integer iItem iItemMax
32603>>>>>>>>>>>>>        Number[] aValues
32604>>>>>>>>>>>>>        Readln channel iChannel iItemMax
32606>>>>>>>>>>>>>        For iItem from 0 to iItemMax
32612>>>>>>>>>>>>>>
32612>>>>>>>>>>>>>            Readln aValues[iItem]
32613>>>>>>>>>>>>>        Loop
32614>>>>>>>>>>>>>>
32614>>>>>>>>>>>>>        Function_Return aValues
32615>>>>>>>>>>>>>    End_Function
32616>>>>>>>>>>>>>
32616>>>>>>>>>>>>>    Procedure WriteStringArray String[] aValues Integer iChannel
32618>>>>>>>>>>>>>        Integer iItem iItemMax
32618>>>>>>>>>>>>>        Move (SizeOfArray(aValues)-1) to iItemMax
32619>>>>>>>>>>>>>        Writeln channel iChannel iItemMax
32622>>>>>>>>>>>>>        For iItem from 0 to iItemMax
32628>>>>>>>>>>>>>>
32628>>>>>>>>>>>>>            Writeln aValues[iItem]
32630>>>>>>>>>>>>>        Loop
32631>>>>>>>>>>>>>>
32631>>>>>>>>>>>>>    End_Procedure
32632>>>>>>>>>>>>>
32632>>>>>>>>>>>>>    Function ReadStringArray Integer iChannel Returns String[]
32634>>>>>>>>>>>>>        Integer iItem iItemMax
32634>>>>>>>>>>>>>        String[] aValues
32635>>>>>>>>>>>>>        Readln channel iChannel iItemMax
32637>>>>>>>>>>>>>        For iItem from 0 to iItemMax
32643>>>>>>>>>>>>>>
32643>>>>>>>>>>>>>            Readln aValues[iItem]
32644>>>>>>>>>>>>>        Loop
32645>>>>>>>>>>>>>>
32645>>>>>>>>>>>>>        Function_Return aValues
32646>>>>>>>>>>>>>    End_Function
32647>>>>>>>>>>>>>
32647>>>>>>>>>>>>>    Procedure WriteBooleanArray Boolean[] aValues Integer iChannel
32649>>>>>>>>>>>>>        Integer iItem iItemMax
32649>>>>>>>>>>>>>        Move (SizeOfArray(aValues)-1) to iItemMax
32650>>>>>>>>>>>>>        Writeln channel iChannel iItemMax
32653>>>>>>>>>>>>>        For iItem from 0 to iItemMax
32659>>>>>>>>>>>>>>
32659>>>>>>>>>>>>>            Writeln aValues[iItem]
32661>>>>>>>>>>>>>        Loop
32662>>>>>>>>>>>>>>
32662>>>>>>>>>>>>>    End_Procedure
32663>>>>>>>>>>>>>
32663>>>>>>>>>>>>>    Function ReadBooleanArray Integer iChannel Returns Boolean[]
32665>>>>>>>>>>>>>        Integer iItem iItemMax
32665>>>>>>>>>>>>>        Boolean[] aValues
32666>>>>>>>>>>>>>        Readln channel iChannel iItemMax
32668>>>>>>>>>>>>>        For iItem from 0 to iItemMax
32674>>>>>>>>>>>>>>
32674>>>>>>>>>>>>>            Readln aValues[iItem]
32675>>>>>>>>>>>>>        Loop
32676>>>>>>>>>>>>>>
32676>>>>>>>>>>>>>        Function_Return aValues
32677>>>>>>>>>>>>>    End_Function
32678>>>>>>>>>>>>>
32678>>>>>>>>>>>>>    Function AreFilesIdentical String sFile1Name String sFile2Name Boolean bBinaryCompare Returns Boolean
32680>>>>>>>>>>>>>        Integer iPos iBlockSize
32680>>>>>>>>>>>>>        Boolean bIdentical
32680>>>>>>>>>>>>>        Integer iFile1Size iFile2Size
32680>>>>>>>>>>>>>        Integer iCh1 iCh2
32680>>>>>>>>>>>>>        String sBlock1 sBlock2
32680>>>>>>>>>>>>>
32680>>>>>>>>>>>>>        If (not(bBinaryCompare)) Begin
32682>>>>>>>>>>>>>            Error 666 "Text compare not implemented"
32683>>>>>>>>>>>>>>
32683>>>>>>>>>>>>>        End
32683>>>>>>>>>>>>>>
32683>>>>>>>>>>>>>
32683>>>>>>>>>>>>>        Move True to bIdentical
32684>>>>>>>>>>>>>        Get FileSizeBytes sFile1Name to iFile1Size
32685>>>>>>>>>>>>>        Get FileSizeBytes sFile2Name to iFile2Size
32686>>>>>>>>>>>>>        If (iFile1Size=iFile2Size) Begin
32688>>>>>>>>>>>>>            Get DirectInput ("binary:"+sFile1Name) to iCh1
32689>>>>>>>>>>>>>            Get DirectInput ("binary:"+sFile2Name) to iCh2
32690>>>>>>>>>>>>>            Move 0 to iPos
32691>>>>>>>>>>>>>            While (iPos<iFile1Size)
32695>>>>>>>>>>>>>                Move ((iFile1Size-iPos) min 8192) to iBlockSize
32696>>>>>>>>>>>>>                Read_Block channel iCh1 sBlock1
32698>>>>>>>>>>>>>                Read_Block channel iCh2 sBlock2
32700>>>>>>>>>>>>>                If (sBlock1<>sBlock2) Begin
32702>>>>>>>>>>>>>                    Move False to bIdentical
32703>>>>>>>>>>>>>                    Move 0 to iFile1Size // stop the loop
32704>>>>>>>>>>>>>                End
32704>>>>>>>>>>>>>>
32704>>>>>>>>>>>>>                Move (iPos+iBlockSize) to iPos
32705>>>>>>>>>>>>>            Loop
32706>>>>>>>>>>>>>>
32706>>>>>>>>>>>>>            Send CloseInput iCh1
32707>>>>>>>>>>>>>            Send CloseInput iCh2
32708>>>>>>>>>>>>>        End
32708>>>>>>>>>>>>>>
32708>>>>>>>>>>>>>        Else Begin
32709>>>>>>>>>>>>>            Move False to bIdentical
32710>>>>>>>>>>>>>        End
32710>>>>>>>>>>>>>>
32710>>>>>>>>>>>>>        Function_Return bIdentical
32711>>>>>>>>>>>>>    End_Function
32712>>>>>>>>>>>>>    
32712>>>>>>>>>>>>>End_Class
32713>>>>>>>>>>>>>
32713>>>>>>>>>>>>>//> Handle to the current cFileFunctions object.
32713>>>>>>>>>>>>>Global_Variable Integer oFileFunctions
32713>>>>>>>>>>>>>//> And this is an object
32713>>>>>>>>>>>>>Object _oFileFunctions is a cFileFunctions
32715>>>>>>>>>>>>>    Move Self to oFileFunctions
32716>>>>>>>>>>>>>End_Object
32717>>>>>>>>>>>>>
32717>>>>>>>>>>>>>//#IFNDEF Is$WebApp // If Windows application
32717>>>>>>>>>>>>>//Object oTest is a ModalPanel
32717>>>>>>>>>>>>>//    Set Size to 170 201
32717>>>>>>>>>>>>>//
32717>>>>>>>>>>>>>//    Object oTreeView1 is a TreeView
32717>>>>>>>>>>>>>//        Set Size to 147 172
32717>>>>>>>>>>>>>//        Set Location to 13 13
32717>>>>>>>>>>>>>//
32717>>>>>>>>>>>>>//        Procedure OnCreateTree
32717>>>>>>>>>>>>>//            // Add tree items here, via the AddTreeItem function.
32717>>>>>>>>>>>>>//
32717>>>>>>>>>>>>>//            // Get AddTreeItem sText hRoot iItemData iImage iSelImage To hItem
32717>>>>>>>>>>>>>//        End_Procedure
32717>>>>>>>>>>>>>//
32717>>>>>>>>>>>>>//    End_Object
32717>>>>>>>>>>>>>//    Function BrowseFolder String sCaption String sStartFolder Returns String 
32717>>>>>>>>>>>>>//    End_Function
32717>>>>>>>>>>>>>//End_Object
32717>>>>>>>>>>>>>//#ENDIF              
32717>>>>>>>>>>>>>
32717>>>>>>>>>>>>>//Enum_List
32717>>>>>>>>>>>>>//    Define cfoCopy
32717>>>>>>>>>>>>>//    Define cfoRename
32717>>>>>>>>>>>>>//    Define cfoDelete
32717>>>>>>>>>>>>>//    Define cfoMove
32717>>>>>>>>>>>>>//End_Enum_List
32717>>>>>>>>>>>>>//
32717>>>>>>>>>>>>>//Struct tFileOperation
32717>>>>>>>>>>>>>//    Integer eOperation
32717>>>>>>>>>>>>>//    Boolean bFolder // File or folder?
32717>>>>>>>>>>>>>//    String sSource
32717>>>>>>>>>>>>>//    String sTarget
32717>>>>>>>>>>>>>//End_Struct
32717>>>>>>>>>>>>>
32717>>>>>>>>>>>>>//Function CopyFile String sPath1 String sPath2 Returns Integer
32717>>>>>>>>>>>>>//Function DeleteFile String sPath Boolean bToBin Returns Integer
32717>>>>>>>>>>>>>//Function RenameFile String sFileName1 String sFileName2 Returns Integer
32717>>>>>>>>>>>>>//Function MoveFile String sPath1 String sPath2 Returns Integer
32717>>>>>>>>>>>>>//// Returns False on success. If sNewFolder already exists the function will return True (failure)
32717>>>>>>>>>>>>>//Function CreateFolder String sNewFolder Returns Boolean
32717>>>>>>>>>>>>>////> Returns True on success
32717>>>>>>>>>>>>>//Function CreateFolderIfNotExist String sFolder Returns Boolean
32717>>>>>>>>>>>>>//// sRootFolder must already exist. Returns True if the sRootFolder\sSubFolderPath can be accessed after calling the function
32717>>>>>>>>>>>>>//Function CreateFolderMultiLevel String sRootFolder String sSubFolderPath Returns Boolean
32717>>>>>>>>>>>>>//Function DeleteFolder String sPath Returns Integer
32717>>>>>>>>>>>>>//Function DeleteAllFilesInFolder String sPath Returns Integer
32717>>>>>>>>>>>>>//Function DeleteFolderRecursive String sPath Returns Integer
32717>>>>>>>>>>>>>//    
32717>>>>>>>>>>>
32717>>>>>>>>>>>
32717>>>>>>>>>>>Global_Variable Integer oDataDictionaryFunctions
32717>>>>>>>>>>>
32717>>>>>>>>>>>Procedure _RegisterAllMainDDObjects for cObject
32719>>>>>>>>>>>    Integer iDM iMainDD
32719>>>>>>>>>>>    Get Delegation_Mode to iDM
32720>>>>>>>>>>>    Set Delegation_Mode to No_Delegate_Or_Error
32721>>>>>>>>>>>    Get Main_DD to iMainDD
32722>>>>>>>>>>>    Set Delegation_Mode to iDM
32723>>>>>>>>>>>    If (iMainDD<>0) Begin
32725>>>>>>>>>>>        Send _AllDataDictionaryContainersRegister of oDataDictionaryFunctions Self    
32726>>>>>>>>>>>    End
32726>>>>>>>>>>>>
32726>>>>>>>>>>>End_Procedure
32727>>>>>>>>>>>
32727>>>>>>>>>>>Struct tDDORelation
32727>>>>>>>>>>>    Integer hFromDDO
32727>>>>>>>>>>>    Integer hToDDO
32727>>>>>>>>>>>    Boolean bConstrained // Constrain_File is set
32727>>>>>>>>>>>End_Struct
32727>>>>>>>>>>>
32727>>>>>>>>>>>Object _oDataDictionaryFunctions is a cObject
32729>>>>>>>>>>>    Move Self to oDataDictionaryFunctions
32730>>>>>>>>>>>
32730>>>>>>>>>>>    Global_Variable Integer[] _gaDdoClasses
32730>>>>>>>>>>>    Global_Variable Integer[] _gaDdoObjects
32730>>>>>>>>>>>
32730>>>>>>>>>>>    // This method lets you decide the class of object to be queried when reading DatabaseBuilder settings.
32730>>>>>>>>>>>    Procedure Set DDO_Class Integer iTable Integer iClass
32733>>>>>>>>>>>        Move iClass to _gaDdoClasses[iTable]
32734>>>>>>>>>>>    End_Procedure
32735>>>>>>>>>>>
32735>>>>>>>>>>>    Function DDO_Class Integer iTable Returns Integer
32738>>>>>>>>>>>        If (SizeOfArray(_gaDdoClasses)>iTable) Begin
32740>>>>>>>>>>>            Function_Return _gaDdoClasses[iTable]
32741>>>>>>>>>>>        End
32741>>>>>>>>>>>>
32741>>>>>>>>>>>        Function_Return 0
32742>>>>>>>>>>>    End_Function
32743>>>>>>>>>>>    
32743>>>>>>>>>>>    // DDO's created by this function are only meant for
32743>>>>>>>>>>>    // querying properties, not for updating tables.
32743>>>>>>>>>>>    // Table must be Open prior to calling this Function!
32743>>>>>>>>>>>    Function DDO_Object Integer iTable Returns Integer
32746>>>>>>>>>>>        Integer hDDO iClass
32746>>>>>>>>>>>
32746>>>>>>>>>>>        Move 0 to hDDO
32747>>>>>>>>>>>        If (SizeOfArray(_gaDdoObjects)>iTable) Begin
32749>>>>>>>>>>>            Move _gaDdoObjects[iTable] to hDDO
32750>>>>>>>>>>>        End
32750>>>>>>>>>>>>
32750>>>>>>>>>>>        
32750>>>>>>>>>>>        If (hDDO=0) Begin // If the object isn't there we'll try to create it
32752>>>>>>>>>>>            Get DDO_Class iTable to iClass // Get registered class for the table
32753>>>>>>>>>>>            If (iClass<>0) Begin // If there was one:
32755>>>>>>>>>>>                Get Create iClass to hDDO // create new DDO
32756>>>>>>>>>>>                Move hDDO to _gaDdoObjects[iTable]
32757>>>>>>>>>>>            End
32757>>>>>>>>>>>>
32757>>>>>>>>>>>        End
32757>>>>>>>>>>>>
32757>>>>>>>>>>>        Function_Return hDDO
32758>>>>>>>>>>>    End_Function
32759>>>>>>>>>>>    
32759>>>>>>>>>>>    //> Returns an array of connected child DDOs of hDDO
32759>>>>>>>>>>>    Function ChildDdoArray Integer hDDO Returns Integer[]
32762>>>>>>>>>>>        Integer iMax iIndex
32762>>>>>>>>>>>        Integer[] aDDOs
32763>>>>>>>>>>>        Get Data_Set_Client_Count of hDDO to iMax
32764>>>>>>>>>>>        Decrement iMax
32765>>>>>>>>>>>        For iIndex from 0 to iMax
32771>>>>>>>>>>>>
32771>>>>>>>>>>>            Get Data_Set_Client of hDDO iIndex to aDDOs[iIndex]
32772>>>>>>>>>>>        Loop
32773>>>>>>>>>>>>
32773>>>>>>>>>>>        Function_Return aDDOs
32774>>>>>>>>>>>    End_Function
32775>>>>>>>>>>>
32775>>>>>>>>>>>    //> Returns an array of connected parent DDOs of hDDO
32775>>>>>>>>>>>    Function ParentDdoArray Integer hDDO Returns Integer[]
32778>>>>>>>>>>>        Integer iMax iIndex
32778>>>>>>>>>>>        Integer[] aDDOs
32779>>>>>>>>>>>        Get Data_Set_Server_Count of hDDO to iMax
32780>>>>>>>>>>>        Decrement iMax
32781>>>>>>>>>>>        For iIndex from 0 to iMax
32787>>>>>>>>>>>>
32787>>>>>>>>>>>            Get Data_Set_Server of hDDO iIndex to aDDOs[iIndex]
32788>>>>>>>>>>>        Loop
32789>>>>>>>>>>>>
32789>>>>>>>>>>>        Function_Return aDDOs
32790>>>>>>>>>>>    End_Function
32791>>>>>>>>>>>    
32791>>>>>>>>>>>    //> Returns an array of required child tables of hDDO. These are the tables
32791>>>>>>>>>>>    //> that should be represented by connecting DDOs (if a delete operation is to
32791>>>>>>>>>>>    //> succeed)
32791>>>>>>>>>>>    Function RequiredChildTableArray Integer hDDO Returns Integer[]
32794>>>>>>>>>>>        Integer iMax iIndex
32794>>>>>>>>>>>        Integer[] aTables
32795>>>>>>>>>>>        Get Client_File_Count of hDDO to iMax
32796>>>>>>>>>>>        Decrement iMax
32797>>>>>>>>>>>        For iIndex from 0 to iMax
32803>>>>>>>>>>>>
32803>>>>>>>>>>>            Get Client_File of hDDO iIndex to aTables[iIndex]
32804>>>>>>>>>>>        Loop
32805>>>>>>>>>>>>
32805>>>>>>>>>>>        Function_Return aTables
32806>>>>>>>>>>>    End_Function
32807>>>>>>>>>>>
32807>>>>>>>>>>>    //> Returns an array of required parent tables of hDDO. These are the tables
32807>>>>>>>>>>>    //> that should be represented by connected DDOs (if a save operation is to
32807>>>>>>>>>>>    //> succeed)
32807>>>>>>>>>>>    Function RequiredParentTableArray Integer hDDO Returns Integer[]
32810>>>>>>>>>>>        Integer iMax iIndex
32810>>>>>>>>>>>        Integer[] aTables
32811>>>>>>>>>>>        Get Server_File_Count of hDDO to iMax
32812>>>>>>>>>>>        Decrement iMax
32813>>>>>>>>>>>        For iIndex from 0 to iMax
32819>>>>>>>>>>>>
32819>>>>>>>>>>>            Get Server_File of hDDO iIndex to aTables[iIndex]
32820>>>>>>>>>>>        Loop
32821>>>>>>>>>>>>
32821>>>>>>>>>>>        Function_Return aTables
32822>>>>>>>>>>>    End_Function
32823>>>>>>>>>>>
32823>>>>>>>>>>>        Function _SearchDdoArrayForTable Integer[] aDDO Integer iTable Returns Integer
32826>>>>>>>>>>>            Integer iMax iIndex
32826>>>>>>>>>>>            Move (SizeOfArray(aDDO)-1) to iMax
32827>>>>>>>>>>>            For iIndex from 0 to iMax
32833>>>>>>>>>>>>
32833>>>>>>>>>>>                If (iTable=main_file(aDDO[iIndex])) Begin
32835>>>>>>>>>>>                    Function_Return iIndex
32836>>>>>>>>>>>                End
32836>>>>>>>>>>>>
32836>>>>>>>>>>>            Loop
32837>>>>>>>>>>>>
32837>>>>>>>>>>>            Function_Return -1
32838>>>>>>>>>>>        End_Function
32839>>>>>>>>>>>    
32839>>>>>>>>>>>    Function MissingChildTableArray Integer hDDO Returns Integer[]
32842>>>>>>>>>>>        Integer iMax iIndex iMissingIndex
32842>>>>>>>>>>>        Integer[] aRequiredChildTables aChildDDOs aMissingTables
32845>>>>>>>>>>>        Get ChildDdoArray hDDO to aChildDDOs
32846>>>>>>>>>>>        Get RequiredChildTableArray hDDO to aRequiredChildTables
32847>>>>>>>>>>>        Move 0 to iMissingIndex
32848>>>>>>>>>>>        Move (SizeOfArray(aRequiredChildTables)-1) to iMax
32849>>>>>>>>>>>        For iIndex from 0 to iMax
32855>>>>>>>>>>>>
32855>>>>>>>>>>>            If (_SearchDdoArrayForTable(Self,aChildDDOs,aRequiredChildTables[iIndex])=-1) Begin
32857>>>>>>>>>>>                Move aRequiredChildTables[iIndex] to aMissingTables[iMissingIndex]
32858>>>>>>>>>>>                Increment iMissingIndex
32859>>>>>>>>>>>            End
32859>>>>>>>>>>>>
32859>>>>>>>>>>>        Loop
32860>>>>>>>>>>>>
32860>>>>>>>>>>>        Function_Return aMissingTables
32861>>>>>>>>>>>    End_Function
32862>>>>>>>>>>>    
32862>>>>>>>>>>>    Function MissingParentTableArray Integer hDDO Returns Integer[]
32865>>>>>>>>>>>        Integer iMax iIndex iMissingIndex
32865>>>>>>>>>>>        Integer[] aRequiredParentTables aParentDDOs aMissingTables
32868>>>>>>>>>>>        Get ParentDdoArray hDDO to aParentDDOs
32869>>>>>>>>>>>        Get RequiredParentTableArray hDDO to aRequiredParentTables
32870>>>>>>>>>>>        Move 0 to iMissingIndex
32871>>>>>>>>>>>        Move (SizeOfArray(aRequiredParentTables)-1) to iMax
32872>>>>>>>>>>>        For iIndex from 0 to iMax
32878>>>>>>>>>>>>
32878>>>>>>>>>>>            If (_SearchDdoArrayForTable(Self,aParentDDOs,aRequiredParentTables[iIndex])=-1) Begin
32880>>>>>>>>>>>                Move aRequiredParentTables[iIndex] to aMissingTables[iMissingIndex]
32881>>>>>>>>>>>                Increment iMissingIndex
32882>>>>>>>>>>>            End
32882>>>>>>>>>>>>
32882>>>>>>>>>>>        Loop
32883>>>>>>>>>>>>
32883>>>>>>>>>>>        Function_Return aMissingTables
32884>>>>>>>>>>>    End_Function
32885>>>>>>>>>>>    
32885>>>>>>>>>>>        Function _IsMember Integer iValue Integer[] aValues Returns Boolean
32888>>>>>>>>>>>            Integer iIndex
32888>>>>>>>>>>>            Move (SearchArray(iValue,aValues)) to iIndex
32889>>>>>>>>>>>            Function_Return (iIndex<>-1)
32890>>>>>>>>>>>        End_Function
32891>>>>>>>>>>>        
32891>>>>>>>>>>>        Procedure _BuildParentStructure Integer hDDO Boolean bParentFirst Integer[] ByRef aDDOs Integer[] ByRef aBeingHandled 
32894>>>>>>>>>>>            Integer iMax iItem hParentDD
32894>>>>>>>>>>>            
32894>>>>>>>>>>>            Get Data_Set_Server_Count of hDDO to iMax
32895>>>>>>>>>>>            Decrement iMax
32896>>>>>>>>>>>            For iItem from 0 to iMax
32902>>>>>>>>>>>>
32902>>>>>>>>>>>                Get Data_Set_Server of hDDO iItem to hParentDD
32903>>>>>>>>>>>                
32903>>>>>>>>>>>                If (not(_IsMember(Self,hParentDD,aBeingHandled))) Begin
32905>>>>>>>>>>>                    Move hParentDD to aBeingHandled[SizeOfArray(aBeingHandled)]
32906>>>>>>>>>>>                     
32906>>>>>>>>>>>                    If (bParentFirst) Begin
32908>>>>>>>>>>>                        Send _BuildParentStructure hParentDD bParentFirst (&aDDOs) (&aBeingHandled)
32909>>>>>>>>>>>                        Send _BuildChildStructure hParentDD bParentFirst (&aDDOs) (&aBeingHandled)
32910>>>>>>>>>>>                    End
32910>>>>>>>>>>>>
32910>>>>>>>>>>>    
32910>>>>>>>>>>>                    Move hParentDD to aDDOs[SizeOfArray(aDDOs)]
32911>>>>>>>>>>>    
32911>>>>>>>>>>>                    If (not(bParentFirst)) Begin
32913>>>>>>>>>>>                        Send _BuildChildStructure hParentDD bParentFirst (&aDDOs) (&aBeingHandled)
32914>>>>>>>>>>>                        Send _BuildParentStructure hParentDD bParentFirst (&aDDOs) (&aBeingHandled)
32915>>>>>>>>>>>                    End
32915>>>>>>>>>>>>
32915>>>>>>>>>>>                End
32915>>>>>>>>>>>>
32915>>>>>>>>>>>            Loop
32916>>>>>>>>>>>>
32916>>>>>>>>>>>        End_Procedure
32917>>>>>>>>>>>    
32917>>>>>>>>>>>        Procedure _BuildChildStructure Integer hDDO Boolean bParentFirst Integer[] ByRef aDDOs Integer[] ByRef aBeingHandled 
32920>>>>>>>>>>>            Integer iMax iItem hChildDD
32920>>>>>>>>>>>            
32920>>>>>>>>>>>            Get Data_Set_Client_Count of hDDO to iMax
32921>>>>>>>>>>>            Decrement iMax
32922>>>>>>>>>>>            For iItem from 0 to iMax
32928>>>>>>>>>>>>
32928>>>>>>>>>>>                Get Data_Set_Client of hDDO iItem to hChildDD
32929>>>>>>>>>>>                
32929>>>>>>>>>>>                If (not(_IsMember(Self,hChildDD,aBeingHandled))) Begin
32931>>>>>>>>>>>                    Move hChildDD to aBeingHandled[SizeOfArray(aBeingHandled)]
32932>>>>>>>>>>>
32932>>>>>>>>>>>                    If (bParentFirst) Begin
32934>>>>>>>>>>>                        Send _BuildParentStructure hChildDD bParentFirst (&aDDOs) (&aBeingHandled)
32935>>>>>>>>>>>                        Send _BuildChildStructure hChildDD bParentFirst (&aDDOs) (&aBeingHandled)
32936>>>>>>>>>>>                    End
32936>>>>>>>>>>>>
32936>>>>>>>>>>>
32936>>>>>>>>>>>                    Move hChildDD to aDDOs[SizeOfArray(aDDOs)]
32937>>>>>>>>>>>    
32937>>>>>>>>>>>                    If (not(bParentFirst)) Begin
32939>>>>>>>>>>>                        Send _BuildChildStructure hChildDD bParentFirst (&aDDOs) (&aBeingHandled)
32940>>>>>>>>>>>                        Send _BuildParentStructure hChildDD bParentFirst (&aDDOs) (&aBeingHandled)
32941>>>>>>>>>>>                    End
32941>>>>>>>>>>>>
32941>>>>>>>>>>>                End
32941>>>>>>>>>>>>
32941>>>>>>>>>>>            Loop
32942>>>>>>>>>>>>
32942>>>>>>>>>>>        End_Procedure
32943>>>>>>>>>>>
32943>>>>>>>>>>>    // Returns an array of DDO handles.
32943>>>>>>>>>>>    Function ParentStructure Integer hRootDD Boolean bParentFirst Returns Integer[]
32946>>>>>>>>>>>        Integer[] aRval aBeingHandled
32948>>>>>>>>>>>        Move hRootDD to aBeingHandled[0]
32949>>>>>>>>>>>        Send _BuildParentStructure hRootDD bParentFirst (&aRval) (&aBeingHandled)
32950>>>>>>>>>>>        Function_Return aRval
32951>>>>>>>>>>>    End_Function
32952>>>>>>>>>>>    
32952>>>>>>>>>>>    // Returns an array of DDO handles.
32952>>>>>>>>>>>    Function ChildStructure Integer hRootDD Boolean bParentFirst Returns Integer[]
32955>>>>>>>>>>>        Integer[] aRval aBeingHandled
32957>>>>>>>>>>>        Move hRootDD to aBeingHandled[0]
32958>>>>>>>>>>>        Send _BuildChildStructure hRootDD bParentFirst (&aRval) (&aBeingHandled)
32959>>>>>>>>>>>        Function_Return aRval
32960>>>>>>>>>>>    End_Function
32961>>>>>>>>>>>    
32961>>>>>>>>>>>    //> Returns an array of DDO objects
32961>>>>>>>>>>>    Function CompleteStructure Integer hRootDD Boolean bParentFirst Returns Integer[]
32964>>>>>>>>>>>        Integer[] aRval aBeingHandled
32966>>>>>>>>>>>        If (bParentFirst) Begin
32968>>>>>>>>>>>            Send _BuildParentStructure hRootDD bParentFirst (&aRval) (&aBeingHandled)
32969>>>>>>>>>>>            If (SizeOfArray(aRval)=0) Begin
32971>>>>>>>>>>>                Send _BuildChildStructure hRootDD bParentFirst (&aRval) (&aBeingHandled)
32972>>>>>>>>>>>            End
32972>>>>>>>>>>>>
32972>>>>>>>>>>>        End 
32972>>>>>>>>>>>>
32972>>>>>>>>>>>        Else Begin
32973>>>>>>>>>>>            Send _BuildChildStructure hRootDD bParentFirst (&aRval) (&aBeingHandled)
32974>>>>>>>>>>>            If (SizeOfArray(aRval)=0) Begin
32976>>>>>>>>>>>                Send _BuildParentStructure hRootDD bParentFirst (&aRval) (&aBeingHandled)
32977>>>>>>>>>>>            End
32977>>>>>>>>>>>>
32977>>>>>>>>>>>        End
32977>>>>>>>>>>>>
32977>>>>>>>>>>>        If (not(_IsMember(Self,hRootDD,aRval))) Begin
32979>>>>>>>>>>>            Move hRootDD to aRval[SizeOfArray(aRval)]
32980>>>>>>>>>>>        End
32980>>>>>>>>>>>>
32980>>>>>>>>>>>        Function_Return aRval
32981>>>>>>>>>>>    End_Function
32982>>>>>>>>>>>
32982>>>>>>>>>>>        Procedure _RequiredTablesSave Integer hDD Integer[] ByRef aTables
32985>>>>>>>>>>>            Integer iMax iIndex iTable
32985>>>>>>>>>>>            Integer hParentDD
32985>>>>>>>>>>>            Get Server_File_Count of hDD to iMax
32986>>>>>>>>>>>            Decrement iMax
32987>>>>>>>>>>>            For iIndex from 0 to iMax
32993>>>>>>>>>>>>
32993>>>>>>>>>>>                Get Server_File of hDD iIndex to iTable
32994>>>>>>>>>>>                If (not(_IsMember(Self,iTable,aTables))) Begin
32996>>>>>>>>>>>                    Move iTable to aTables[SizeOfArray(aTables)]
32997>>>>>>>>>>>                    Get Data_Set of hDD iTable to hParentDD
32998>>>>>>>>>>>                    If (hParentDD>0) Begin
33000>>>>>>>>>>>                        Send _RequiredTablesSave hParentDD (&aTables)
33001>>>>>>>>>>>                    End
33001>>>>>>>>>>>>
33001>>>>>>>>>>>                End
33001>>>>>>>>>>>>
33001>>>>>>>>>>>            Loop
33002>>>>>>>>>>>>
33002>>>>>>>>>>>        End_Procedure
33003>>>>>>>>>>>    
33003>>>>>>>>>>>    //> Returns a list of required tables
33003>>>>>>>>>>>    Function RequiredTablesSave Integer hRootDD Returns Integer[]
33006>>>>>>>>>>>        Integer[] aTables
33007>>>>>>>>>>>        Send _RequiredTablesSave hRootDD (&aTables)
33008>>>>>>>>>>>        Function_Return aTables
33009>>>>>>>>>>>    End_Function
33010>>>>>>>>>>>    
33010>>>>>>>>>>>    Function CheckRequiredTables Integer hRootDD Integer[] aTables Returns Integer[]
33013>>>>>>>>>>>        Integer iMax iIndex iTable
33013>>>>>>>>>>>        Integer hDD
33013>>>>>>>>>>>        Integer[] aMissingTables
33014>>>>>>>>>>>        Move (SizeOfArray(aTables)-1) to iMax
33015>>>>>>>>>>>        For iIndex from 0 to iMax
33021>>>>>>>>>>>>
33021>>>>>>>>>>>            Move aTables[iIndex] to iTable
33022>>>>>>>>>>>            Get Data_Set of hRootDD iTable to hDD
33023>>>>>>>>>>>            If (hDD<=0) Begin
33025>>>>>>>>>>>                Move iTable to aMissingTables[SizeOfArray(aMissingTables)]  
33026>>>>>>>>>>>            End
33026>>>>>>>>>>>>
33026>>>>>>>>>>>        Loop
33027>>>>>>>>>>>>
33027>>>>>>>>>>>        Function_Return aMissingTables
33028>>>>>>>>>>>    End_Function
33029>>>>>>>>>>>    
33029>>>>>>>>>>>    Function TableArrayIntegerToName Integer[] aTables Integer iAttr Returns String[]
33032>>>>>>>>>>>        Integer iMax iIndex
33032>>>>>>>>>>>        String[] aValues
33033>>>>>>>>>>>        If (iAttr=DF_FILE_LOGICAL_NAME or iAttr=DF_FILE_ROOT_NAME or iAttr=DF_FILE_DISPLAY_NAME) Begin
33035>>>>>>>>>>>            Move (SizeOfArray(aTables)-1) to iMax
33036>>>>>>>>>>>            For iIndex from 0 to iMax
33042>>>>>>>>>>>>
33042>>>>>>>>>>>                Get_Attribute iAttr of aTables[iIndex] to aValues[iIndex]
33045>>>>>>>>>>>            Loop
33046>>>>>>>>>>>>
33046>>>>>>>>>>>        End
33046>>>>>>>>>>>>
33046>>>>>>>>>>>        Function_Return aValues
33047>>>>>>>>>>>    End_Function
33048>>>>>>>>>>>
33048>>>>>>>>>>>    // This is not sofisticated enough. The tOIDeoInfo variable cannot hold
33048>>>>>>>>>>>    // the definition of a dbGrid type object and can therefore not extract
33048>>>>>>>>>>>    // the correct label name.
33048>>>>>>>>>>>    Function ControlLabel Integer hDDO Integer iTable Integer iField Returns String
33051>>>>>>>>>>>    End_Function
33052>>>>>>>>>>>
33052>>>>>>>>>>>    Procedure ShowDebugPanel
33055>>>>>>>>>>>    End_Procedure
33056>>>>>>>>>>>
33056>>>>>>>>>>>    // Call function hFunc in object hObject without creating an error
33056>>>>>>>>>>>    // if the object does not understand the call
33056>>>>>>>>>>>    Function _PaddedValue Integer hObject Integer hFunc Returns Integer
33059>>>>>>>>>>>        Integer iDm
33059>>>>>>>>>>>        String sValue
33059>>>>>>>>>>>        Get Delegation_Mode of hObject to iDm        
33060>>>>>>>>>>>        Set Delegation_Mode of hObject to NO_DELEGATE_OR_ERROR
33061>>>>>>>>>>>        Get hFunc of hObject to sValue
33062>>>>>>>>>>>        Set Delegation_Mode of hObject to iDm
33063>>>>>>>>>>>        Function_Return sValue
33064>>>>>>>>>>>    End_Function
33065>>>>>>>>>>>    
33065>>>>>>>>>>>    // Call function hFunc in object hObject with aurgunent iItem without
33065>>>>>>>>>>>    // creating an Error if the object does not understand the call
33065>>>>>>>>>>>    Function _PaddedItemValue Integer hObject Integer hFunc Integer iItem Returns Integer
33068>>>>>>>>>>>        Integer iDm
33068>>>>>>>>>>>        String sValue
33068>>>>>>>>>>>        Get Delegation_Mode of hObject to iDm        
33069>>>>>>>>>>>        Set Delegation_Mode of hObject to NO_DELEGATE_OR_ERROR
33070>>>>>>>>>>>        Get hFunc of hObject iItem to sValue
33071>>>>>>>>>>>        Set Delegation_Mode of hObject to iDm
33072>>>>>>>>>>>        Function_Return sValue
33073>>>>>>>>>>>    End_Function
33074>>>>>>>>>>>    
33074>>>>>>>>>>>    Function _PaddedDataFile Integer hObject Returns Integer
33077>>>>>>>>>>>        Integer iItem iTable
33077>>>>>>>>>>>        Get _PaddedValue hObject GET_Current_Item to iItem
33078>>>>>>>>>>>        Get _PaddedItemValue hObject GET_Data_File iItem to iTable
33079>>>>>>>>>>>        Function_Return iTable
33080>>>>>>>>>>>    End_Function
33081>>>>>>>>>>>    
33081>>>>>>>>>>>    Function DdoArrayToTableArray Integer[] aDDOs Returns Integer[]
33084>>>>>>>>>>>        Integer iMax iIndex iTable
33084>>>>>>>>>>>        Integer[] aTables
33085>>>>>>>>>>>        Move (SizeOfArray(aDDOs)-1) to iMax
33086>>>>>>>>>>>        For iIndex from 0 to iMax
33092>>>>>>>>>>>>
33092>>>>>>>>>>>            Get main_file of aDDOs[iIndex] to iTable
33093>>>>>>>>>>>            Move iTable to aTables[iIndex]
33094>>>>>>>>>>>        Loop
33095>>>>>>>>>>>>
33095>>>>>>>>>>>        Function_Return aTables
33096>>>>>>>>>>>    End_Function
33097>>>>>>>>>>>
33097>>>>>>>>>>>        Procedure _TrimParentDdoStructure Integer hDDO
33100>>>>>>>>>>>            Integer iMax iIndex
33100>>>>>>>>>>>            Integer[] aRequiredTables aParentDDOs aParentTables
33103>>>>>>>>>>>            Get RequiredParentTableArray hDDO to aRequiredTables
33104>>>>>>>>>>>            Get ParentDdoArray hDDO to aParentDDOs
33105>>>>>>>>>>>            Get DdoArrayToTableArray aParentDDOs to aParentTables
33106>>>>>>>>>>>            Move (SizeOfArray(aRequiredTables)-1) to iMax
33107>>>>>>>>>>>            For iIndex from 0 to iMax
33113>>>>>>>>>>>>
33113>>>>>>>>>>>                If (not(IntegerIsMember(oStackFunctions,aParentTables,aRequiredTables[iIndex]))) Begin
33115>>>>>>>>>>>                    // Remove required parent file
33115>>>>>>>>>>>                    Send Remove_Server_File of hDDO aRequiredTables[iIndex]
33116>>>>>>>>>>>                End
33116>>>>>>>>>>>>
33116>>>>>>>>>>>            Loop
33117>>>>>>>>>>>>
33117>>>>>>>>>>>        End_Procedure
33118>>>>>>>>>>>
33118>>>>>>>>>>>    Procedure TrimGrandParentDdoStructure Integer hDDO
33121>>>>>>>>>>>        Integer iMax iIndex
33121>>>>>>>>>>>        Integer[] aParentDDOs
33122>>>>>>>>>>>        Get ParentDdoArray hDDO to aParentDDOs
33123>>>>>>>>>>>        Move (SizeOfArray(aParentDDOs)-1) to iMax
33124>>>>>>>>>>>        For iIndex from 0 to iMax
33130>>>>>>>>>>>>
33130>>>>>>>>>>>            Send _TrimParentDdoStructure aParentDDOs[iIndex]
33131>>>>>>>>>>>        Loop
33132>>>>>>>>>>>>
33132>>>>>>>>>>>    End_Procedure
33133>>>>>>>>>>>
33133>>>>>>>>>>>    Procedure TrimParentDdoStructure integer hDDO
33136>>>>>>>>>>>        // NOTE! Not safeguarded against cyclic DDO_Server's
33136>>>>>>>>>>>        Integer iMax iIndex
33136>>>>>>>>>>>        Integer[] aParentDDOs
33137>>>>>>>>>>>        Send _TrimParentDdoStructure hDDO
33138>>>>>>>>>>>        Get ParentDdoArray hDDO to aParentDDOs
33139>>>>>>>>>>>        Move (SizeOfArray(aParentDDOs)-1) to iMax
33140>>>>>>>>>>>        For iIndex from 0 to iMax
33146>>>>>>>>>>>>
33146>>>>>>>>>>>            Send TrimParentDdoStructure aParentDDOs[iIndex]
33147>>>>>>>>>>>        Loop
33148>>>>>>>>>>>>
33148>>>>>>>>>>>    End_Procedure
33149>>>>>>>>>>>
33149>>>>>>>>>>>        Procedure _CreateMissingParentDDOs Integer hDDO Boolean bRecursive
33152>>>>>>>>>>>            Integer iMax iIndex iDDClass hNewDDO
33152>>>>>>>>>>>            Integer[] aRequiredTables aParentDDOs aParentTables
33155>>>>>>>>>>>            Get RequiredParentTableArray hDDO to aRequiredTables
33156>>>>>>>>>>>            Get ParentDdoArray hDDO to aParentDDOs
33157>>>>>>>>>>>            Get DdoArrayToTableArray aParentDDOs to aParentTables
33158>>>>>>>>>>>            Move (SizeOfArray(aRequiredTables)-1) to iMax
33159>>>>>>>>>>>            For iIndex from 0 to iMax
33165>>>>>>>>>>>>
33165>>>>>>>>>>>                If (not(IntegerIsMember(oStackFunctions,aParentTables,aRequiredTables[iIndex]))) Begin
33167>>>>>>>>>>>                    // Attempt to create the missing DDO:
33167>>>>>>>>>>>                    Get DDO_Class aRequiredTables[iIndex] to iDDClass
33168>>>>>>>>>>>                    If (iDDClass<>0) Begin
33170>>>>>>>>>>>                        Get Create of (Parent(hDDO)) iDDClass to hNewDDO
33171>>>>>>>>>>>                        Set DDO_Server of hDDO to hNewDDO
33172>>>>>>>>>>>                        If (bRecursive) Begin
33174>>>>>>>>>>>                            Send _CreateMissingParentDDOs hNewDDO bRecursive
33175>>>>>>>>>>>                        End
33175>>>>>>>>>>>>
33175>>>>>>>>>>>                    End
33175>>>>>>>>>>>>
33175>>>>>>>>>>>                    Else Begin
33176>>>>>>>>>>>                        Error 232 ("Can't create DDO for table "+String(aRequiredTables[iIndex])+" (missing class)")
33177>>>>>>>>>>>>
33177>>>>>>>>>>>                    End
33177>>>>>>>>>>>>
33177>>>>>>>>>>>                End
33177>>>>>>>>>>>>
33177>>>>>>>>>>>            Loop
33178>>>>>>>>>>>>
33178>>>>>>>>>>>        End_Procedure
33179>>>>>>>>>>>
33179>>>>>>>>>>>    Procedure CreateMissingParentDDOs Integer hDDO Boolean bRecursive
33182>>>>>>>>>>>        Send _CreateMissingParentDDOs hDDO bRecursive
33183>>>>>>>>>>>    End_Procedure
33184>>>>>>>>>>>    
33184>>>>>>>>>>>    //> This function adds missing child DDOs to hDDO passed as parameter.
33184>>>>>>>>>>>    Procedure CreateMissingImmediateChildDDOs Integer hDDO 
33187>>>>>>>>>>>        Integer iMax iIndex hChildDDO
33187>>>>>>>>>>>        Integer[] aChildTables
33188>>>>>>>>>>>        
33188>>>>>>>>>>>        If (Cascade_Delete_State(hDDO)) Begin
33190>>>>>>>>>>>            Error 231 "Cascade_Delete_State state must be set to false in order to use the CreateMissingParentDDOs method"
33191>>>>>>>>>>>>
33191>>>>>>>>>>>        End
33191>>>>>>>>>>>>
33191>>>>>>>>>>>        Else Begin
33192>>>>>>>>>>>            Get MissingChildTableArray hDDO to aChildTables
33193>>>>>>>>>>>            Move (SizeOfArray(aChildTables)-1) to iMax
33194>>>>>>>>>>>            For iIndex from 0 to iMax
33200>>>>>>>>>>>>
33200>>>>>>>>>>>                Get Create of (Parent(hDDO)) U_DataDictionary to hChildDDO // Create as siblings of hDDO
33201>>>>>>>>>>>                Set main_file of hChildDDO to aChildTables[iIndex]
33202>>>>>>>>>>>                Set DDO_Server of hChildDDO to hDDO
33203>>>>>>>>>>>            Loop
33204>>>>>>>>>>>>
33204>>>>>>>>>>>        End
33204>>>>>>>>>>>>
33204>>>>>>>>>>>    End_Procedure
33205>>>>>>>>>>>    
33205>>>>>>>>>>>    Procedure CreateMissingImmediateChildDDOsNoWarning Integer hDDO
33208>>>>>>>>>>>        Integer iMax iIndex hChildDDO
33208>>>>>>>>>>>        Integer[] aChildTables
33209>>>>>>>>>>>
33209>>>>>>>>>>>        Get MissingChildTableArray hDDO to aChildTables
33210>>>>>>>>>>>        Move (SizeOfArray(aChildTables)-1) to iMax
33211>>>>>>>>>>>        For iIndex from 0 to iMax
33217>>>>>>>>>>>>
33217>>>>>>>>>>>            Get Create of (Parent(hDDO)) U_DataDictionary to hChildDDO // Create as siblings of hDDO
33218>>>>>>>>>>>            Set Main_File of hChildDDO to aChildTables[iIndex]
33219>>>>>>>>>>>            Set DDO_Server of hChildDDO to hDDO
33220>>>>>>>>>>>        Loop
33221>>>>>>>>>>>>
33221>>>>>>>>>>>    End_Procedure
33222>>>>>>>>>>>
33222>>>>>>>>>>>    //Function ParentPath Returns Integer[]
33222>>>>>>>>>>>    //End_Function
33222>>>>>>>>>>>
33222>>>>>>>>>>>// -------------- Build "graphical" representation of DDO relationships -----------------
33222>>>>>>>>>>>
33222>>>>>>>>>>>                Function _AlreadyMappedAtRow Integer hDDO tRelationsDrawingMapItem[] aMap Returns Integer
33225>>>>>>>>>>>                    Integer iMax iIndex
33225>>>>>>>>>>>                    Move (SizeOfArray(aMap)-1) to iMax
33226>>>>>>>>>>>                    For iIndex from 0 to iMax
33232>>>>>>>>>>>>
33232>>>>>>>>>>>                        If (hDDO=aMap[iIndex].iItemId) Begin
33234>>>>>>>>>>>                            Function_Return iIndex // hDDO already mapped at row iIndex
33235>>>>>>>>>>>                        End
33235>>>>>>>>>>>>
33235>>>>>>>>>>>                    Loop
33236>>>>>>>>>>>>
33236>>>>>>>>>>>                    Function_Return -1 // not mapped
33237>>>>>>>>>>>                End_Function
33238>>>>>>>>>>>                
33238>>>>>>>>>>>                Function _RemoveValueFromArray Integer hValue Integer[] aValues Returns Integer[]
33241>>>>>>>>>>>                    Integer iMax iIndex
33241>>>>>>>>>>>                    Integer[] aRval
33242>>>>>>>>>>>                    Move (SizeOfArray(aValues)-1) to iMax
33243>>>>>>>>>>>                    For iIndex from 0 to iMax
33249>>>>>>>>>>>>
33249>>>>>>>>>>>                        If (hValue<>aValues[iIndex]) Begin
33251>>>>>>>>>>>                            Move aValues[iIndex] to aRval[SizeOfArray(aRval)]
33252>>>>>>>>>>>                        End
33252>>>>>>>>>>>>
33252>>>>>>>>>>>                    Loop
33253>>>>>>>>>>>>
33253>>>>>>>>>>>                    Function_Return aRval
33254>>>>>>>>>>>                End_Function
33255>>>>>>>>>>>                
33255>>>>>>>>>>>                Global_Variable Integer[] _gaDDFVisited
33255>>>>>>>>>>>               
33255>>>>>>>>>>>                Procedure _DmrAddToVisited Integer hDD
33258>>>>>>>>>>>                    Move hDD to _gaDDFVisited[SizeOfArray(_gaDDFVisited)]
33259>>>>>>>>>>>                End_Procedure
33260>>>>>>>>>>>               
33260>>>>>>>>>>>                Function _DmrAlreadyVisited Integer hDD Returns Boolean
33263>>>>>>>>>>>                    Integer iMax iIndex
33263>>>>>>>>>>>                    Move (SizeOfArray(_gaDDFVisited)-1) to iMax
33264>>>>>>>>>>>                    For iIndex from 0 to iMax
33270>>>>>>>>>>>>
33270>>>>>>>>>>>                        If (hDD=_gaDDFVisited[iIndex]) Begin
33272>>>>>>>>>>>                            Function_Return True
33273>>>>>>>>>>>                        End
33273>>>>>>>>>>>>
33273>>>>>>>>>>>                    Loop
33274>>>>>>>>>>>>
33274>>>>>>>>>>>                    Function_Return False
33275>>>>>>>>>>>                End_Function
33276>>>>>>>>>>>                
33276>>>>>>>>>>>        Global_Variable Boolean[] __gaDDFVerticalLines
33276>>>>>>>>>>>        
33276>>>>>>>>>>>        Procedure __doRelationsMapAddDdoRelation tDDORelation[] ByRef aDdoRelations Integer hChildTableDDO Integer hParentTableDDO
33279>>>>>>>>>>>            Integer iIndex iMax
33279>>>>>>>>>>>            Move (SizeOfArray(aDdoRelations)-1) to iMax
33280>>>>>>>>>>>            For iIndex from 0 to iMax
33286>>>>>>>>>>>>
33286>>>>>>>>>>>                If (aDdoRelations[iIndex].hFromDDO=hChildTableDDO and aDdoRelations[iIndex].hToDDO=hParentTableDDO) Begin
33288>>>>>>>>>>>                    Procedure_Return
33289>>>>>>>>>>>                End
33289>>>>>>>>>>>>
33289>>>>>>>>>>>            Loop
33290>>>>>>>>>>>>
33290>>>>>>>>>>>            
33290>>>>>>>>>>>            Move (SizeOfArray(aDdoRelations)) to iIndex
33291>>>>>>>>>>>            Move hChildTableDDO to aDdoRelations[iIndex].hFromDDO
33292>>>>>>>>>>>            Move hParentTableDDO to aDdoRelations[iIndex].hToDDO
33293>>>>>>>>>>>            Move (Constrain_File(hChildTableDDO)<>0 and Constrain_File(hChildTableDDO)=Main_File(hParentTableDDO)) to aDdoRelations[iIndex].bConstrained
33294>>>>>>>>>>>        End_Procedure
33295>>>>>>>>>>>                                                                                                                    
33295>>>>>>>>>>>        Procedure _doRelationsMap Integer hDDO Integer hIgnoreDD Integer iLevel tRelationsDrawingMapItem[] ByRef aMap Boolean bFirst Boolean bLast Boolean bParent Boolean bChild tDDORelation[] ByRef aDdoRelations
33298>>>>>>>>>>>            Integer iMax iIndex
33298>>>>>>>>>>>            Integer iAlreadyMappedAtRow
33298>>>>>>>>>>>            Boolean bUp bDown bLeft bRight     
33298>>>>>>>>>>>            Integer[] aParentDDOs aChildDDOs
33300>>>>>>>>>>>            String sValue
33300>>>>>>>>>>>            Boolean bAlreadyVisited
33300>>>>>>>>>>>            Integer hChildTableDDO hParentTableDDO
33300>>>>>>>>>>>
33300>>>>>>>>>>>            //Has the DDO already been mapped?
33300>>>>>>>>>>>            
33300>>>>>>>>>>>            Get _AlreadyMappedAtRow hDDO aMap to iAlreadyMappedAtRow
33301>>>>>>>>>>>            
33301>>>>>>>>>>>            Get _DmrAlreadyVisited hDDO to bAlreadyVisited
33302>>>>>>>>>>>            If (not(bAlreadyVisited)) Begin
33304>>>>>>>>>>>                Send _DmrAddToVisited hDDO
33305>>>>>>>>>>>            End
33305>>>>>>>>>>>>
33305>>>>>>>>>>> 
33305>>>>>>>>>>>            If (not(bAlreadyVisited)) Begin
33307>>>>>>>>>>>                Get ParentDdoArray hDDO to aParentDDOs
33308>>>>>>>>>>>                Get ChildDdoArray hDDO to aChildDDOs
33309>>>>>>>>>>>                Get _RemoveValueFromArray hIgnoreDD aParentDDOs to aParentDDOs
33310>>>>>>>>>>>                Get _RemoveValueFromArray hIgnoreDD aChildDDOs to aChildDDOs
33311>>>>>>>>>>>            End
33311>>>>>>>>>>>>
33311>>>>>>>>>>>
33311>>>>>>>>>>>            Move (SizeOfArray(aMap)-1) to iIndex
33312>>>>>>>>>>>            
33312>>>>>>>>>>>            Move False to __gaDDFVerticalLines[iLevel]
33313>>>>>>>>>>>            
33313>>>>>>>>>>>            If (not(bAlreadyVisited)) Begin
33315>>>>>>>>>>>                Move (SizeOfArray(aParentDDOs)-1) to iMax
33316>>>>>>>>>>>                For iIndex from 0 to iMax
33322>>>>>>>>>>>>
33322>>>>>>>>>>>                    Send __doRelationsMapAddDdoRelation (&aDdoRelations) hDDO aParentDDOs[iIndex]
33323>>>>>>>>>>>                    Send _doRelationsMap aParentDDOs[iIndex] hDDO (iLevel+1) (&aMap) (iIndex=0) (iIndex=iMax) True False (&aDdoRelations)
33324>>>>>>>>>>>                Loop
33325>>>>>>>>>>>>
33325>>>>>>>>>>>            End
33325>>>>>>>>>>>>
33325>>>>>>>>>>>            If (bParent and bFirst and iLevel>0) Begin
33327>>>>>>>>>>>                Move True to __gaDDFVerticalLines[iLevel-1] // Turn on parent vertical line
33328>>>>>>>>>>>            End
33328>>>>>>>>>>>>
33328>>>>>>>>>>>
33328>>>>>>>>>>>            Send BooleanDrop of oStackFunctions (&__gaDDFVerticalLines) 
33329>>>>>>>>>>>
33329>>>>>>>>>>>            Move (SizeOfArray(aMap)) to iIndex
33330>>>>>>>>>>>            Move hDDO to aMap[iIndex].iItemId
33331>>>>>>>>>>>            Move iLevel to aMap[iIndex].iLevel
33332>>>>>>>>>>>            Move __gaDDFVerticalLines to aMap[iIndex].aVerticalLines
33333>>>>>>>>>>>
33333>>>>>>>>>>>            If (iAlreadyMappedAtRow=-1 and bAlreadyVisited) Begin
33335>>>>>>>>>>>                Move -2 to iAlreadyMappedAtRow // Means that we don't yet know in what row the it "was" mapped in (may be fixed in a second pass)
33336>>>>>>>>>>>            End
33336>>>>>>>>>>>>
33336>>>>>>>>>>>            
33336>>>>>>>>>>>            Move iAlreadyMappedAtRow to aMap[iIndex].iAlreadyMappedAtRow
33337>>>>>>>>>>>            Move bFirst  to aMap[iIndex].bFirst
33338>>>>>>>>>>>            Move bLast   to aMap[iIndex].bLast  
33339>>>>>>>>>>>            Move bParent to aMap[iIndex].bParent
33340>>>>>>>>>>>            Move bChild  to aMap[iIndex].bChild
33341>>>>>>>>>>>
33341>>>>>>>>>>>            If (bChild and bLast and iLevel>0) Begin
33343>>>>>>>>>>>                Move False to __gaDDFVerticalLines[iLevel-1]
33344>>>>>>>>>>>            End
33344>>>>>>>>>>>>
33344>>>>>>>>>>>            
33344>>>>>>>>>>>            If (not(bAlreadyVisited)) Begin
33346>>>>>>>>>>>                Move True to __gaDDFVerticalLines[iLevel]
33347>>>>>>>>>>>                Move (SizeOfArray(aChildDDOs)-1) to iMax
33348>>>>>>>>>>>                For iIndex from 0 to iMax
33354>>>>>>>>>>>>
33354>>>>>>>>>>>                    Send __doRelationsMapAddDdoRelation (&aDdoRelations) aChildDDOs[iIndex] hDDO 
33355>>>>>>>>>>>                    Send _doRelationsMap aChildDDOs[iIndex] hDDO (iLevel+1) (&aMap) (iIndex=0) (iIndex=iMax) False True (&aDdoRelations)
33356>>>>>>>>>>>                Loop
33357>>>>>>>>>>>>
33357>>>>>>>>>>>                Send BooleanDrop of oStackFunctions (&__gaDDFVerticalLines)
33358>>>>>>>>>>>            End
33358>>>>>>>>>>>>
33358>>>>>>>>>>>
33358>>>>>>>>>>>       End_Procedure
33359>>>>>>>>>>>    
33359>>>>>>>>>>>    Function DDO_RelationsDrawingMap Integer hRootDD Returns tRelationsDrawingMapItem[]
33362>>>>>>>>>>>        tRelationsDrawingMapItem[] aMap
33362>>>>>>>>>>>        tRelationsDrawingMapItem[] aMap
33363>>>>>>>>>>>        tDDORelation[] aDdoRelations
33363>>>>>>>>>>>        tDDORelation[] aDdoRelations
33364>>>>>>>>>>>        Boolean[] aVerticalLines
33365>>>>>>>>>>>        Move (ResizeArray(_gaDDFVisited,0)) to _gaDDFVisited
33366>>>>>>>>>>>        Move (ResizeArray(__gaDDFVerticalLines,0)) to __gaDDFVerticalLines
33367>>>>>>>>>>>        If (hRootDD<>0) Begin
33369>>>>>>>>>>>            Send _doRelationsMap hRootDD 0 0 (&aMap) False False False False (&aDdoRelations)
33370>>>>>>>>>>>        End
33370>>>>>>>>>>>>
33370>>>>>>>>>>>        Function_Return aMap
33371>>>>>>>>>>>    End_Function
33372>>>>>>>>>>>    
33372>>>>>>>>>>>    Function DDO_Relations Integer hRootDD Returns tDDORelation[]
33375>>>>>>>>>>>        tRelationsDrawingMapItem[] aMap
33375>>>>>>>>>>>        tRelationsDrawingMapItem[] aMap
33376>>>>>>>>>>>        tDDORelation[] aDdoRelations
33376>>>>>>>>>>>        tDDORelation[] aDdoRelations
33377>>>>>>>>>>>        Boolean[] aVerticalLines
33378>>>>>>>>>>>        Move (ResizeArray(_gaDDFVisited,0)) to _gaDDFVisited
33379>>>>>>>>>>>        Move (ResizeArray(__gaDDFVerticalLines,0)) to __gaDDFVerticalLines
33380>>>>>>>>>>>        If (hRootDD<>0) Begin
33382>>>>>>>>>>>            Send _doRelationsMap hRootDD 0 0 (&aMap) False False False False (&aDdoRelations)
33383>>>>>>>>>>>        End
33383>>>>>>>>>>>>
33383>>>>>>>>>>>        Function_Return aDdoRelations
33384>>>>>>>>>>>    End_Function
33385>>>>>>>>>>>    
33385>>>>>>>>>>>                
33385>>>>>>>>>>>//          +--Zip
33385>>>>>>>>>>>//      +--Customer
33385>>>>>>>>>>>//      |--SalesP
33385>>>>>>>>>>>//     Order
33385>>>>>>>>>>>//      |       +--Country
33385>>>>>>>>>>>//      |   +--Vendor
33385>>>>>>>>>>>//      |   |--Product
33385>>>>>>>>>>>//      |   |   +--Stock
33385>>>>>>>>>>>//      +--Line
33385>>>>>>>>>>>//          |           +--Locations
33385>>>>>>>>>>>//          |       +--Pallets
33385>>>>>>>>>>>//          |   +--Packids
33385>>>>>>>>>>>//          +--Reservations
33385>>>>>>>>>>>//              +--Labels
33385>>>>>>>>>>>//
33385>>>>>>>>>>>//        +--Zip
33385>>>>>>>>>>>//     +--Customer
33385>>>>>>>>>>>//     |--SalesP
33385>>>>>>>>>>>//     Order
33385>>>>>>>>>>>//     |     +--Country
33385>>>>>>>>>>>//     |  +--Vendor
33385>>>>>>>>>>>//     |  |--Product
33385>>>>>>>>>>>//     |  |  +--Stock
33385>>>>>>>>>>>//     +--Line
33385>>>>>>>>>>>//        |        +--Locations
33385>>>>>>>>>>>//        |     +--Pallets
33385>>>>>>>>>>>//        |  +--Packids
33385>>>>>>>>>>>//        +--Reservations
33385>>>>>>>>>>>//           +--Labels
33385>>>>>>>>>>>//
33385>>>>>>>>>>>//       +-Zip
33385>>>>>>>>>>>//     +-Customer
33385>>>>>>>>>>>//     |-SalesP
33385>>>>>>>>>>>//     Order
33385>>>>>>>>>>>//     |   +-Country
33385>>>>>>>>>>>//     | +-Vendor
33385>>>>>>>>>>>//     | |-Product
33385>>>>>>>>>>>//     | | +-Stock
33385>>>>>>>>>>>//     +-Line
33385>>>>>>>>>>>//       |     +-Locations
33385>>>>>>>>>>>//       |   +-Pallets
33385>>>>>>>>>>>//       | +-Packids
33385>>>>>>>>>>>//       +-Reservations
33385>>>>>>>>>>>//         +-Labels
33385>>>>>>>>>>>
33385>>>>>>>>>>>// --------------------------------------------------------------------------------------
33385>>>>>>>>>>>    Function IsExtendedFieldDefinitionMissing Integer hDD Integer iField Returns Boolean
33388>>>>>>>>>>>        Integer iType
33388>>>>>>>>>>>        Integer hFieldObjects hFieldObject
33388>>>>>>>>>>>
33388>>>>>>>>>>>        Get_Attribute DF_FIELD_TYPE of (Main_File(hDD)) iField to iType
33391>>>>>>>>>>>
33391>>>>>>>>>>>        If (iType=DF_TEXT or iType=DF_BINARY) Begin
33393>>>>>>>>>>>            Get Field_Objects of hDD to hFieldObjects
33394>>>>>>>>>>>            If (hFieldObject<>0) Begin
33396>>>>>>>>>>>                Get Field_Object of hDD iField to hFieldObject
33397>>>>>>>>>>>                Function_Return (hFieldObject<>0)
33398>>>>>>>>>>>            End
33398>>>>>>>>>>>>
33398>>>>>>>>>>>            Function_Return True
33399>>>>>>>>>>>        End
33399>>>>>>>>>>>>
33399>>>>>>>>>>>        Function_Return False
33400>>>>>>>>>>>    End_Function
33401>>>>>>>>>>>
33401>>>>>>>>>>>// --------------------------------------------------------------------------------------
33401>>>>>>>>>>>    Function CreateCompleteDDO Integer iTable Returns Handle
33404>>>>>>>>>>>        Integer hDDO hDDC
33404>>>>>>>>>>>
33404>>>>>>>>>>>        // First create the root ddo:
33404>>>>>>>>>>>        Get DDO_Class iTable to hDDC
33405>>>>>>>>>>>        If (hDDC=0) Begin
33407>>>>>>>>>>>            Error 233 ("DD class not spedified for table "+String(iTable))
33408>>>>>>>>>>>>
33408>>>>>>>>>>>        End
33408>>>>>>>>>>>>
33408>>>>>>>>>>>        Else Begin
33409>>>>>>>>>>>            Get Create hDDC to hDDO
33410>>>>>>>>>>>            Send CreateMissingImmediateChildDDOsNoWarning hDDO
33411>>>>>>>>>>>            Send CreateMissingParentDDOs hDDO True
33412>>>>>>>>>>>        End
33412>>>>>>>>>>>>
33412>>>>>>>>>>>
33412>>>>>>>>>>>        Function_Return hDDO
33413>>>>>>>>>>>    End_Function
33414>>>>>>>>>>>
33414>>>>>>>>>>>    Struct tAutoIncrementColumn
33414>>>>>>>>>>>        Integer iTable
33414>>>>>>>>>>>        Integer iColumn
33414>>>>>>>>>>>        Integer iSourceTable
33414>>>>>>>>>>>        Integer iSourceColumn
33414>>>>>>>>>>>        Number  nMaxValue
33414>>>>>>>>>>>        Number  nCounterValue
33414>>>>>>>>>>>    End_Struct
33414>>>>>>>>>>>    
33414>>>>>>>>>>>        Procedure _AutoIncrementStatus tAutoIncrementColumn stAutoIncrementColumn Number ByRef nColumnHighestValue Number ByRef nCounter Boolean bUpdateSource
33417>>>>>>>>>>>            Integer iIndex iSourceRecords
33417>>>>>>>>>>>
33417>>>>>>>>>>>            Get_Attribute DF_FIELD_INDEX of stAutoIncrementColumn.iTable stAutoIncrementColumn.iColumn to iIndex
33420>>>>>>>>>>>            Clear stAutoIncrementColumn.iTable
33421>>>>>>>>>>>            Vfind stAutoIncrementColumn.iTable iIndex LT // Finds the last record according to index
33423>>>>>>>>>>>            Get_Field_Value stAutoIncrementColumn.iTable stAutoIncrementColumn.iColumn to nColumnHighestValue
33426>>>>>>>>>>>            
33426>>>>>>>>>>>            Get_Attribute DF_FILE_MAX_RECORDS of stAutoIncrementColumn.iSourceTable to iSourceRecords
33429>>>>>>>>>>>            
33429>>>>>>>>>>>            If (iSourceRecords=1) Begin
33431>>>>>>>>>>>                Reread stAutoIncrementColumn.iSourceTable    
33435>>>>>>>>>>>            End
33435>>>>>>>>>>>>
33435>>>>>>>>>>>            Else Begin
33436>>>>>>>>>>>                Lock
33437>>>>>>>>>>>>
33437>>>>>>>>>>>                Relate stAutoIncrementColumn.iTable
33438>>>>>>>>>>>            End
33438>>>>>>>>>>>>
33438>>>>>>>>>>>            Get_Field_Value stAutoIncrementColumn.iSourceTable stAutoIncrementColumn.iSourceColumn to nCounter
33441>>>>>>>>>>>            
33441>>>>>>>>>>>            If (bUpdateSource) Begin
33443>>>>>>>>>>>                If (nColumnHighestValue<>nCounter) Begin
33445>>>>>>>>>>>                    Set_Field_Value stAutoIncrementColumn.iSourceTable stAutoIncrementColumn.iSourceColumn to nColumnHighestValue
33448>>>>>>>>>>>                    SaveRecord stAutoIncrementColumn.iSourceTable
33449>>>>>>>>>>>                End
33449>>>>>>>>>>>>
33449>>>>>>>>>>>            End
33449>>>>>>>>>>>>
33449>>>>>>>>>>>            
33449>>>>>>>>>>>            Unlock
33450>>>>>>>>>>>>
33450>>>>>>>>>>>        End_Procedure
33451>>>>>>>>>>>        
33451>>>>>>>>>>>    Function AutoIncrementColumns Integer iTable Returns tAutoIncrementColumn[]
33454>>>>>>>>>>>        Integer hDDO iIndex iMax
33454>>>>>>>>>>>        Integer[] aAutoIncFields
33455>>>>>>>>>>>        tDDFileField[] aSysFileFields
33455>>>>>>>>>>>        tDDFileField[] aSysFileFields
33456>>>>>>>>>>>        tAutoIncrementColumn[] aColumns
33456>>>>>>>>>>>        tAutoIncrementColumn[] aColumns
33457>>>>>>>>>>>        Get DDO_Object iTable to hDDO
33458>>>>>>>>>>>        If (hDDO<>0) Begin
33460>>>>>>>>>>>            Get pAutoIncrementFields of hDDO to aAutoIncFields
33461>>>>>>>>>>>            Get pAutoIncrementSysFileFields of hDDO to aSysFileFields
33462>>>>>>>>>>>            Move (SizeOfArray(aAutoIncFields)-1) to iMax
33463>>>>>>>>>>>            For iIndex from 0 to iMax
33469>>>>>>>>>>>>
33469>>>>>>>>>>>                Move iTable to aColumns[iIndex].iTable
33470>>>>>>>>>>>                Move aAutoIncFields[iIndex] to aColumns[iIndex].iColumn
33471>>>>>>>>>>>                Move aSysFileFields[iIndex].iFile to aColumns[iIndex].iSourceTable
33472>>>>>>>>>>>                Move aSysFileFields[iIndex].iField to aColumns[iIndex].iSourceColumn
33473>>>>>>>>>>>                Send _AutoIncrementStatus aColumns[iIndex] (&aColumns[iIndex].nMaxValue) (&aColumns[iIndex].nCounterValue) False
33474>>>>>>>>>>>            Loop
33475>>>>>>>>>>>>
33475>>>>>>>>>>>        End
33475>>>>>>>>>>>>
33475>>>>>>>>>>>        Function_Return aColumns
33476>>>>>>>>>>>    End_Function
33477>>>>>>>>>>>    
33477>>>>>>>>>>>    Procedure AutoIncrementColumnsRepair Integer iTable
33480>>>>>>>>>>>        Integer iIndex iMax
33480>>>>>>>>>>>        Number nHigh nCount
33480>>>>>>>>>>>        tAutoIncrementColumn[] aColumns
33480>>>>>>>>>>>        tAutoIncrementColumn[] aColumns
33481>>>>>>>>>>>        Get AutoIncrementColumns iTable to aColumns
33482>>>>>>>>>>>        Move (SizeOfArray(aColumns)-1) to iMax
33483>>>>>>>>>>>        For iIndex from 0 to iMax
33489>>>>>>>>>>>>
33489>>>>>>>>>>>            Send _AutoIncrementStatus aColumns[iIndex] (&nHigh) (&nCount) True
33490>>>>>>>>>>>        Loop
33491>>>>>>>>>>>>
33491>>>>>>>>>>>    End_Procedure
33492>>>>>>>>>>>
33492>>>>>>>>>>>    Procedure AutoIncrementColumnsRepairAll
33495>>>>>>>>>>>        Integer iTable iMax 
33495>>>>>>>>>>>        Move (SizeOfArray(_gaDdoClasses)-1) to iMax
33496>>>>>>>>>>>        
33496>>>>>>>>>>>        For iTable from 1 to iMax
33502>>>>>>>>>>>>
33502>>>>>>>>>>>            If (_gaDdoClasses[iTable]<>0) Begin
33504>>>>>>>>>>>                Send AutoIncrementColumnsRepair iTable //_gaDdoClasses[iTable]
33505>>>>>>>>>>>            End
33505>>>>>>>>>>>>
33505>>>>>>>>>>>        Loop
33506>>>>>>>>>>>>
33506>>>>>>>>>>>    End_Procedure
33507>>>>>>>>>>>    
33507>>>>>>>>>>>    Function AutoIncrementStatusTable Integer iTable Returns tAutoIncrementColumn[]
33510>>>>>>>>>>>        tAutoIncrementColumn[] aAutoIncrementColumn
33510>>>>>>>>>>>        tAutoIncrementColumn[] aAutoIncrementColumn
33511>>>>>>>>>>>        Get AutoIncrementColumns iTable to aAutoIncrementColumn
33512>>>>>>>>>>>        Function_Return aAutoIncrementColumn
33513>>>>>>>>>>>    End_Function
33514>>>>>>>>>>>    
33514>>>>>>>>>>>        Function _AppendtAutoIncrementColumnArrays tAutoIncrementColumn[] aColumns1 tAutoIncrementColumn[] aColumns2 Returns tAutoIncrementColumn[]
33517>>>>>>>>>>>            Integer iIndex iMax iCount
33517>>>>>>>>>>>            Move (SizeOfArray(aColumns2)-1) to iMax
33518>>>>>>>>>>>            Move (SizeOfArray(aColumns1)) to iCount
33519>>>>>>>>>>>            For iIndex from 0 to iMax
33525>>>>>>>>>>>>
33525>>>>>>>>>>>                Move aColumns2[iIndex] to aColumns1[iCount]
33526>>>>>>>>>>>                Increment iCount
33527>>>>>>>>>>>            Loop
33528>>>>>>>>>>>>
33528>>>>>>>>>>>            Function_Return aColumns1
33529>>>>>>>>>>>        End_Function
33530>>>>>>>>>>>    
33530>>>>>>>>>>>    Function AutoIncrementStatusAll Returns tAutoIncrementColumn[]
33533>>>>>>>>>>>        Integer iTable iMax 
33533>>>>>>>>>>>        Move (SizeOfArray(_gaDdoClasses)-1) to iMax
33534>>>>>>>>>>>        tAutoIncrementColumn[] aAutoIncrementColumn aRval
33534>>>>>>>>>>>        tAutoIncrementColumn[] aAutoIncrementColumn aRval
33536>>>>>>>>>>>
33536>>>>>>>>>>>        For iTable from 1 to iMax
33542>>>>>>>>>>>>
33542>>>>>>>>>>>            If (_gaDdoClasses[iTable]<>0) Begin
33544>>>>>>>>>>>                Get AutoIncrementStatusTable iTable to aAutoIncrementColumn
33545>>>>>>>>>>>                Get _AppendtAutoIncrementColumnArrays aRval aAutoIncrementColumn to aRval
33546>>>>>>>>>>>//                Get AutoIncrementColumns iTable to aAutoIncrementColumn
33546>>>>>>>>>>>            End
33546>>>>>>>>>>>>
33546>>>>>>>>>>>        Loop
33547>>>>>>>>>>>>
33547>>>>>>>>>>>
33547>>>>>>>>>>>        Function_Return aRval
33548>>>>>>>>>>>    End_Function 
33549>>>>>>>>>>>        
33549>>>>>>>>>>>        Property Integer[] _paDdContainers
33551>>>>>>>>>>>        
33551>>>>>>>>>>>        Procedure _AllDataDictionaryContainersRegister Integer hDDContainer
33554>>>>>>>>>>>            Integer[] aContainers
33555>>>>>>>>>>>            Get _paDdContainers to aContainers
33556>>>>>>>>>>>            Move hDDContainer to aContainers[SizeOfArray(aContainers)]
33557>>>>>>>>>>>            Set _paDdContainers to aContainers
33558>>>>>>>>>>>        End_Procedure
33559>>>>>>>>>>>    
33559>>>>>>>>>>>    Function AllDataDictionaryContainers Integer hRoot Returns Integer[]
33562>>>>>>>>>>>        Integer[] aContainers
33563>>>>>>>>>>>        Set _paDdContainers to aContainers
33564>>>>>>>>>>>        If (hRoot=0) Begin
33566>>>>>>>>>>>            Move Desktop to hRoot
33567>>>>>>>>>>>        End
33567>>>>>>>>>>>>
33567>>>>>>>>>>>        Broadcast Recursive Send _RegisterAllMainDDObjects of hRoot
33569>>>>>>>>>>>        Get _paDdContainers to aContainers
33570>>>>>>>>>>>        Function_Return aContainers
33571>>>>>>>>>>>    End_Function
33572>>>>>>>>>>>    
33572>>>>>>>>>>>        Function _DDStateIndicator Integer hDD Returns String
33575>>>>>>>>>>>            Boolean bState
33575>>>>>>>>>>>            String sValue
33575>>>>>>>>>>>            Get HasRecord of hDD to bState
33576>>>>>>>>>>>            If (bState) Move (sValue+"R") to sValue
33579>>>>>>>>>>>            Get Changed_State of hDD to bState
33580>>>>>>>>>>>            If (bState) Move (sValue+"C") to sValue
33583>>>>>>>>>>>            Get Should_Save of hDD to bState
33584>>>>>>>>>>>            If (bState) Move (sValue+"S") to sValue
33587>>>>>>>>>>>            If (sValue<>"") Begin
33589>>>>>>>>>>>                Move ("("+sValue+")") to sValue
33590>>>>>>>>>>>            End
33590>>>>>>>>>>>>
33590>>>>>>>>>>>            Else Begin
33591>>>>>>>>>>>                Move "(at ease)" to sValue
33592>>>>>>>>>>>            End
33592>>>>>>>>>>>>
33592>>>>>>>>>>>            Function_Return sValue
33593>>>>>>>>>>>        End_Function
33594>>>>>>>>>>>    
33594>>>>>>>>>>>    Function yUML_DDODiagram Integer hCont Boolean bIncludeCurrentState Returns tYumlClassDiagram
33597>>>>>>>>>>>        Integer iMax iIndex hMainDD 
33597>>>>>>>>>>>        String sFromLabel sToLabel sContainerName
33597>>>>>>>>>>>        String sProject sStateIndicator
33597>>>>>>>>>>>        tYumlClassDiagram strDiagram
33597>>>>>>>>>>>        tYumlClassDiagram strDiagram
33597>>>>>>>>>>>        tDDORelation[] aDdoRelations
33597>>>>>>>>>>>        tDDORelation[] aDdoRelations
33598>>>>>>>>>>>    
33598>>>>>>>>>>>        Get Module_Name to sProject
33599>>>>>>>>>>>        Move (Lowercase(Name(hCont))) to sContainerName
33600>>>>>>>>>>>    
33600>>>>>>>>>>>        Get NewDiagram of oYumlFunctions to strDiagram
33601>>>>>>>>>>>        Move ("DDO relations project '"+sProject+"' object path '"+sContainerName+"'") to strDiagram.sNote
33602>>>>>>>>>>>        If (bIncludeCurrentState) Begin
33604>>>>>>>>>>>            Move (strDiagram.sNote+" (R=HasRecord C=Changed_State S=Should_Save)") to strDiagram.sNote
33605>>>>>>>>>>>        End
33605>>>>>>>>>>>>
33605>>>>>>>>>>>        Get Main_DD of hCont to hMainDD
33606>>>>>>>>>>>        Get DDO_Relations of oDataDictionaryFunctions hMainDD to aDdoRelations
33607>>>>>>>>>>>    
33607>>>>>>>>>>>        Move (SizeOfArray(aDdoRelations)-1) to iMax
33608>>>>>>>>>>>        For iIndex from 0 to iMax
33614>>>>>>>>>>>>
33614>>>>>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of (Main_File(aDdoRelations[iIndex].hFromDDO)) to sFromLabel
33617>>>>>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of (Main_File(aDdoRelations[iIndex].hToDDO)) to sToLabel
33620>>>>>>>>>>>            If (bIncludeCurrentState) Begin
33622>>>>>>>>>>>                Get _DDStateIndicator aDdoRelations[iIndex].hFromDDO to sStateIndicator 
33623>>>>>>>>>>>                Move (sFromLabel+" "+sStateIndicator) to sFromLabel
33624>>>>>>>>>>>                Get _DDStateIndicator aDdoRelations[iIndex].hToDDO to sStateIndicator 
33625>>>>>>>>>>>                Move (sToLabel+" "+sStateIndicator) to sToLabel
33626>>>>>>>>>>>            End
33626>>>>>>>>>>>>
33626>>>>>>>>>>>            Send AddRelation of oYumlFunctions (&strDiagram) sFromLabel sToLabel aDdoRelations[iIndex].bConstrained
33627>>>>>>>>>>>        Loop
33628>>>>>>>>>>>>
33628>>>>>>>>>>>    
33628>>>>>>>>>>>        Function_Return strDiagram
33629>>>>>>>>>>>    End_Function
33630>>>>>>>>>>>
33630>>>>>>>>>>>    Procedure _yUML_GenerateOneDiagram Integer hCont Integer iChannel
33633>>>>>>>>>>>        Integer iMax iIndex hMainDD
33633>>>>>>>>>>>        String sUrl sFromLabel sToLabel sContainerName
33633>>>>>>>>>>>        tYumlClassDiagram strDiagram
33633>>>>>>>>>>>        tYumlClassDiagram strDiagram
33633>>>>>>>>>>>        tDDORelation[] aDdoRelations
33633>>>>>>>>>>>        tDDORelation[] aDdoRelations
33634>>>>>>>>>>>    
33634>>>>>>>>>>>        Move (Lowercase(Name(hCont))) to sContainerName
33635>>>>>>>>>>>        Writeln channel iChannel sContainerName
33638>>>>>>>>>>>        
33638>>>>>>>>>>>        Get yUML_DDODiagram hCont False to strDiagram
33639>>>>>>>>>>>        
33639>>>>>>>>>>>        Get DiagramUrl of oYumlFunctions strDiagram to sUrl
33640>>>>>>>>>>>        Writeln channel iChannel sUrl
33643>>>>>>>>>>>    End_Procedure
33644>>>>>>>>>>>    
33644>>>>>>>>>>>    Procedure yUML_GenerateAllDdoDiagrams
33647>>>>>>>>>>>        Integer iChannel iIndex iMax
33647>>>>>>>>>>>        String sFolder sFileName
33647>>>>>>>>>>>        Integer[] aDdoContainers
33648>>>>>>>>>>>    
33648>>>>>>>>>>>        // Get all objects that has a main_dd property set to a non-zero value.
33648>>>>>>>>>>>        Get AllDataDictionaryContainers of oDataDictionaryFunctions Desktop to aDdoContainers
33649>>>>>>>>>>>    
33649>>>>>>>>>>>        Get VdfFolderPath of oFileFunctions VDF_PROGRAM to sFolder
33650>>>>>>>>>>>        Get Module_Name to sFileName
33651>>>>>>>>>>>        Get AppendPath of oFileFunctions sFolder sFileName to sFileName
33652>>>>>>>>>>>        Move (sFileName+".yuml") to sFileName
33653>>>>>>>>>>>        Get DirectOutput of oFileFunctions sFileName to iChannel
33654>>>>>>>>>>>        If (iChannel>=0) Begin
33656>>>>>>>>>>>            Move (SizeOfArray(aDdoContainers)-1) to iMax
33657>>>>>>>>>>>            For iIndex from 0 to iMax
33663>>>>>>>>>>>>
33663>>>>>>>>>>>                Send _yUML_GenerateOneDiagram aDdoContainers[iIndex] iChannel 
33664>>>>>>>>>>>            Loop
33665>>>>>>>>>>>>
33665>>>>>>>>>>>            Send CloseOutput of oFileFunctions iChannel
33666>>>>>>>>>>>        End
33666>>>>>>>>>>>>
33666>>>>>>>>>>>    End_Procedure
33667>>>>>>>>>>>    
33667>>>>>>>>>>>    Procedure VDFXRay_ExtractAllProjectInfoAndSave
33670>>>>>>>>>>>    End_Procedure
33671>>>>>>>>>>>    
33671>>>>>>>>>>>    Function ReadFirstRow Integer hDD Integer iTable Integer iIndex Returns Boolean
33674>>>>>>>>>>>        Send Request_Read of hDD FIRST_RECORD iTable iIndex
33675>>>>>>>>>>>        Function_Return (Found)
33676>>>>>>>>>>>    End_Function
33677>>>>>>>>>>>
33677>>>>>>>>>>>    Function ReadNextRow Integer hDD Integer iTable Integer iIndex Returns Boolean
33680>>>>>>>>>>>        Send Request_Read of hDD GT iTable iIndex
33681>>>>>>>>>>>        Function_Return (Found)
33682>>>>>>>>>>>    End_Function
33683>>>>>>>>>>>        
33683>>>>>>>>>>>End_Object // oDataDictionaryFunctions
33684>>>>>>>>>>>
33684>>>>>>>>>>>Global_Variable Integer _goDdoDebugView // _giDDCallLevel 
33684>>>>>>>>>>>//Move 0 to _giDDCallLevel
33684>>>>>>>>>>>Move 0 to _goDdoDebugView
33685>>>>>>>>>>>
33685>>>>>>>>>>>
33685>>>>>>>>>>>// No need at all for this from 17.1 and on
33685>>>>>>>>>>>
33685>>>>>>>>>>>Class cfreeDataDictionary is a DataDictionary
33686>>>>>>>>>>>    Procedure Construct_Object
33688>>>>>>>>>>>        Forward Send Construct_Object
33690>>>>>>>>>>>        Property Boolean pbConditionalParent False
33691>>>>>>>>>>>        Property Boolean _pbPartofOperation True
33692>>>>>>>>>>>    End_Procedure
33693>>>>>>>>>>>    
33693>>>>>>>>>>>    Procedure Set DDO_Server Handle ObjId
33695>>>>>>>>>>>        If (ObjId<>0) Begin
33697>>>>>>>>>>>            Forward Set DDO_Server to ObjId
33699>>>>>>>>>>>        End
33699>>>>>>>>>>>>
33699>>>>>>>>>>>        Else Begin
33700>>>>>>>>>>>            Error 201 ("Unknown object in "+Name(Self)+" DDO_Server setting")
33701>>>>>>>>>>>>
33701>>>>>>>>>>>        End
33701>>>>>>>>>>>>
33701>>>>>>>>>>>    End_Procedure
33702>>>>>>>>>>>    
33702>>>>>>>>>>>//    Procedure LogTransaction String sMethod // sMethod = Save, Edit or Delete
33702>>>>>>>>>>>//    End_Procedure
33702>>>>>>>>>>>//    
33702>>>>>>>>>>>//    Procedure LogTableAccess String sMethod // sMethod = Save, Edit or Delete
33702>>>>>>>>>>>//    End_Procedure
33702>>>>>>>>>>>//    
33702>>>>>>>>>>>//    Procedure Request_Clear
33702>>>>>>>>>>>//        Forward Send Request_Clear
33702>>>>>>>>>>>//    End_Procedure
33702>>>>>>>>>>>//    
33702>>>>>>>>>>>//    Procedure Request_Delete
33702>>>>>>>>>>>//        Send LogTransaction "Delete"
33702>>>>>>>>>>>//        Forward Send Request_Delete
33702>>>>>>>>>>>//    End_Procedure
33702>>>>>>>>>>>//
33702>>>>>>>>>>>//    Procedure Request_Save
33702>>>>>>>>>>>//        Boolean bEdit
33702>>>>>>>>>>>//        Get HasRecord to bEdit
33702>>>>>>>>>>>//        Send LogTransaction (If(bEdit,"Edit","Create"))
33702>>>>>>>>>>>//        Forward Send Request_Save
33702>>>>>>>>>>>//    End_Procedure
33702>>>>>>>>>>>    
33702>>>>>>>>>>>    Function Is_cfreeDataDictionary Returns Boolean
33704>>>>>>>>>>>        Function_Return True
33705>>>>>>>>>>>    End_Function
33706>>>>>>>>>>>    
33706>>>>>>>>>>>    
33706>>>>>>>>>>>    
33706>>>>>>>>>>>    //> If pbConditionalParent is true we may have to redirect message clear
33706>>>>>>>>>>>    //> to another DDO. The reason is that if we allow for cleared parent records
33706>>>>>>>>>>>    //> pressing F5 while in a parent table should clear the parent table rather
33706>>>>>>>>>>>    //> than clearing the whole view.
33706>>>>>>>>>>>    
33706>>>>>>>>>>>    //> Unfortunately message clear is sent during object initialization in which
33706>>>>>>>>>>>    //> case there is no meaningful Focus to check for.
33706>>>>>>>>>>>    
33706>>>>>>>>>>>        Procedure _SetChangedStateChildren Integer hParent
33708>>>>>>>>>>>            Integer iMax iIndex
33708>>>>>>>>>>>            Integer[] aChildDDOs
33709>>>>>>>>>>>            Get ChildDdoArray of oDataDictionaryFunctions hParent to aChildDDOs
33710>>>>>>>>>>>            Move (SizeOfArray(aChildDDOs)-1) to iMax
33711>>>>>>>>>>>            For iIndex from 0 to iMax
33717>>>>>>>>>>>>
33717>>>>>>>>>>>                Set Changed_State of aChildDDOs[iIndex] to True
33718>>>>>>>>>>>            Loop
33719>>>>>>>>>>>>
33719>>>>>>>>>>>        End_Procedure
33720>>>>>>>>>>>
33720>>>>>>>>>>>    Procedure Clear // Augmentation
33722>>>>>>>>>>>        Integer hFoc iTable hDD
33722>>>>>>>>>>>        Boolean bConditionalParent
33722>>>>>>>>>>>        Move 0 to hDD
33723>>>>>>>>>>>        
33723>>>>>>>>>>>        Get Focus of desktop to hFoc
33724>>>>>>>>>>>        
33724>>>>>>>>>>>        If (hFoc>Desktop) Begin // If any object at hall has the focus
33726>>>>>>>>>>>            Get _PaddedDataFile of oDataDictionaryFunctions hFoc to iTable // Very carefully: Do you have a datafile?
33727>>>>>>>>>>>            
33727>>>>>>>>>>>            If (iTable<>0 and iTable<>Main_File(Self)) Begin // It is not the same as our own main_file
33729>>>>>>>>>>>                Get Data_Set iTable to hDD
33730>>>>>>>>>>>                
33730>>>>>>>>>>>                If (hDD<>0) Begin // DDO object for that table does exist!
33732>>>>>>>>>>>                                                                    
33732>>>>>>>>>>>                    Get _PaddedValue of oDataDictionaryFunctions hDD GET_pbConditionalParent to bConditionalParent
33733>>>>>>>>>>>                    
33733>>>>>>>>>>>                    If (bConditionalParent) Begin
33735>>>>>>>>>>>                    
33735>>>>>>>>>>>                        // A test is needed here to determine whether we are at the tail of a save operation
33735>>>>>>>>>>>                    
33735>>>>>>>>>>>                        If (HasRecord(hDD)) Begin
33737>>>>>>>>>>>                            // At this point we need to se the changed_state of the parent of hDD
33737>>>>>>>>>>>                            // the same way it is set if a new parent record is found.
33737>>>>>>>>>>>//                            Set Changed_State of hDD to True
33737>>>>>>>>>>>                        End
33737>>>>>>>>>>>>
33737>>>>>>>>>>>                        Else Begin
33738>>>>>>>>>>>                            // If it does not currently have a record we cancel
33738>>>>>>>>>>>                            // the clever clear behavior
33738>>>>>>>>>>>                            Move 0 to hDD
33739>>>>>>>>>>>                        End
33739>>>>>>>>>>>>
33739>>>>>>>>>>>                    End
33739>>>>>>>>>>>>
33739>>>>>>>>>>>                    Else Begin
33740>>>>>>>>>>>                        Move 0 to hDD
33741>>>>>>>>>>>                    End
33741>>>>>>>>>>>>
33741>>>>>>>>>>>                End
33741>>>>>>>>>>>>
33741>>>>>>>>>>>            End
33741>>>>>>>>>>>>
33741>>>>>>>>>>>        End
33741>>>>>>>>>>>>
33741>>>>>>>>>>>
33741>>>>>>>>>>>        If (hDD>0) Begin
33743>>>>>>>>>>>            Send Clear of hDD
33744>>>>>>>>>>>            // When a parent is changed (even if it's cleared) we must set changed_state of all children:
33744>>>>>>>>>>>            Send _SetChangedStateChildren hDD
33745>>>>>>>>>>>        End
33745>>>>>>>>>>>>
33745>>>>>>>>>>>        Else Begin
33746>>>>>>>>>>>            Forward Send Clear
33748>>>>>>>>>>>        End
33748>>>>>>>>>>>>
33748>>>>>>>>>>>    End_Procedure
33749>>>>>>>>>>>    
33749>>>>>>>>>>>    Function _IsForeign Returns Boolean
33751>>>>>>>>>>>        Boolean bForeign
33751>>>>>>>>>>>        Move (Self<>OPERATION_ORIGIN) to bForeign
33752>>>>>>>>>>>        Function_Return bForeign
33753>>>>>>>>>>>    End_Function
33754>>>>>>>>>>>    
33754>>>>>>>>>>>    Function _IgnoreSaveMainFile Returns Boolean
33756>>>>>>>>>>>        Function_Return (pbConditionalParent(Self) and _IsForeign(Self) and not(HasRecord(Self)))
33757>>>>>>>>>>>    End_Function
33758>>>>>>>>>>>    
33758>>>>>>>>>>>    // Procedure Save_Main_File should be cancelled if we are representing a conditional parent
33758>>>>>>>>>>>    // that does not have a record.
33758>>>>>>>>>>>    Procedure Save_Main_File
33760>>>>>>>>>>>//        Integer iTable
33760>>>>>>>>>>>//        Boolean bActiveRecord
33760>>>>>>>>>>>        If (_IgnoreSaveMainFile(Self)) Begin
33762>>>>>>>>>>>        End
33762>>>>>>>>>>>>
33762>>>>>>>>>>>        Else Begin
33763>>>>>>>>>>>//            Get main_file to iTable
33763>>>>>>>>>>>//            Move (not(IsNullRowID(GetRowID(iTable)))) to bActiveRecord
33763>>>>>>>>>>>//            Send LogTableAccess (If(bActiveRecord,"Edit","Save"))
33763>>>>>>>>>>>            Forward Send Save_Main_File
33765>>>>>>>>>>>        End
33765>>>>>>>>>>>>
33765>>>>>>>>>>>    End_Procedure
33766>>>>>>>>>>>    
33766>>>>>>>>>>>    Procedure Delete_Main_File
33768>>>>>>>>>>>//        Send LogTableAccess "Delete"
33768>>>>>>>>>>>        Forward Send Delete_Main_File
33770>>>>>>>>>>>    End_Procedure
33771>>>>>>>>>>>
33771>>>>>>>>>>>    // Function Validate_Field should not validate if we are representing a conditional parent
33771>>>>>>>>>>>    // that does not have a record.
33771>>>>>>>>>>>    Function Validate_Field Integer iField Returns Integer
33773>>>>>>>>>>>        Integer iResult
33773>>>>>>>>>>>        If (pbConditionalParent(Self) and _IsForeign(Self) and not(HasRecord(Self))) Begin
33775>>>>>>>>>>>            Move 0 to iResult // no validation
33776>>>>>>>>>>>        End
33776>>>>>>>>>>>>
33776>>>>>>>>>>>        Else Begin
33777>>>>>>>>>>>            Forward Get Validate_Field iField to iResult
33779>>>>>>>>>>>        End
33779>>>>>>>>>>>>
33779>>>>>>>>>>>        Function_Return iResult
33780>>>>>>>>>>>    End_Function
33781>>>>>>>>>>>End_Class // cfreeDataDictionary
33782>>>>>>>>>>>
33782>>>>>>>>>Use VdfRuntime.pkg
Including file: VdfRuntime.pkg    (Z:\VmShare\Projects\WebQuery18-0\StureApsPublicLib\AppSrc\VdfRuntime.pkg)
33782>>>>>>>>>>>Use VdfBase.pkg
33782>>>>>>>>>>>// VDFRuntime
33782>>>>>>>>>>>Use Winkern.pkg
33782>>>>>>>>>>>Use RegistryFunctions.pkg
Including file: RegistryFunctions.pkg    (Z:\VmShare\Projects\WebQuery18-0\StureApsPublicLib\AppSrc\RegistryFunctions.pkg)
33782>>>>>>>>>>>>>//  Use RegistryFunctions.pkg //
33782>>>>>>>>>>>>>
33782>>>>>>>>>>>>>Use NamedValueFunctions.pkg
Including file: NamedValueFunctions.pkg    (Z:\VmShare\Projects\WebQuery18-0\StureApsPublicLib\AppSrc\NamedValueFunctions.pkg)
33782>>>>>>>>>>>>>>>//  Use NamedValueFunctions.pkg // oNamedValueFunctions object
33782>>>>>>>>>>>>>>>
33782>>>>>>>>>>>>>>>Struct tNamedValue
33782>>>>>>>>>>>>>>>    String  sName
33782>>>>>>>>>>>>>>>    String  sValue
33782>>>>>>>>>>>>>>>End_Struct
33782>>>>>>>>>>>>>>>
33782>>>>>>>>>>>>>>>Struct tNamedValueList
33782>>>>>>>>>>>>>>>    Boolean bCaseSensitive
33782>>>>>>>>>>>>>>>    tNamedValue[] aNamedValues
33782>>>>>>>>>>>>>>>    tNamedValue[] aNamedValues
33782>>>>>>>>>>>>>>>End_Struct
33782>>>>>>>>>>>>>>>
33782>>>>>>>>>>>>>>>Global_Variable Integer oNamedValueFunctions
33782>>>>>>>>>>>>>>>
33782>>>>>>>>>>>>>>>Object _oNamedValueFunctions is a cObject
33784>>>>>>>>>>>>>>>    
33784>>>>>>>>>>>>>>>    Move Self to oNamedValueFunctions
33785>>>>>>>>>>>>>>>    
33785>>>>>>>>>>>>>>>    Function NewNamedValueList Boolean bCaseSensitive Returns tNamedValueList
33788>>>>>>>>>>>>>>>        tNamedValueList strEmptyList
33788>>>>>>>>>>>>>>>        tNamedValueList strEmptyList
33788>>>>>>>>>>>>>>>        Move bCaseSensitive to strEmptyList.bCaseSensitive
33789>>>>>>>>>>>>>>>        Function_Return strEmptyList
33790>>>>>>>>>>>>>>>    End_Function
33791>>>>>>>>>>>>>>>    
33791>>>>>>>>>>>>>>>        Function _FindName Boolean bCaseSense tNamedValue[] aValues String sName Returns Integer
33794>>>>>>>>>>>>>>>            Integer iIndex iMax
33794>>>>>>>>>>>>>>>            Move (SizeOfArray(aValues)-1) to iMax
33795>>>>>>>>>>>>>>>            For iIndex from 0 to iMax
33801>>>>>>>>>>>>>>>>
33801>>>>>>>>>>>>>>>                If (sName=aValues[iIndex].sName) Begin
33803>>>>>>>>>>>>>>>                    Function_Return iIndex
33804>>>>>>>>>>>>>>>                End
33804>>>>>>>>>>>>>>>>
33804>>>>>>>>>>>>>>>            Loop
33805>>>>>>>>>>>>>>>>
33805>>>>>>>>>>>>>>>            Function_Return -1
33806>>>>>>>>>>>>>>>        End_Function
33807>>>>>>>>>>>>>>>        
33807>>>>>>>>>>>>>>>    Function NameHasValue tNamedValueList strList String sName Returns Boolean
33810>>>>>>>>>>>>>>>        Function_Return (_FindName(Self,strList.bCaseSensitive,strList.aNamedValues,sName)>=0)
33811>>>>>>>>>>>>>>>    End_Function
33812>>>>>>>>>>>>>>>        
33812>>>>>>>>>>>>>>>    Procedure Set NamedValue tNamedValueList ByRef strList String sName String sValue
33815>>>>>>>>>>>>>>>        Integer iIndex
33815>>>>>>>>>>>>>>>        Get _FindName strList.bCaseSensitive strList.aNamedValues sName to iIndex
33816>>>>>>>>>>>>>>>        If (iIndex=-1) Begin
33818>>>>>>>>>>>>>>>            Move (SizeOfArray(strList.aNamedValues)) to iIndex
33819>>>>>>>>>>>>>>>            Move sName to strList.aNamedValues[iIndex].sName
33820>>>>>>>>>>>>>>>        End
33820>>>>>>>>>>>>>>>>
33820>>>>>>>>>>>>>>>        Move sValue to strList.aNamedValues[iIndex].sValue
33821>>>>>>>>>>>>>>>    End_Procedure
33822>>>>>>>>>>>>>>>    
33822>>>>>>>>>>>>>>>    Function NamedValue tNamedValueList strList String sName Returns String
33825>>>>>>>>>>>>>>>        Integer iIndex
33825>>>>>>>>>>>>>>>        Get _FindName True strList.aNamedValues sName to iIndex
33826>>>>>>>>>>>>>>>        If (iIndex<>-1) Begin
33828>>>>>>>>>>>>>>>            Function_Return strList.aNamedValues[iIndex].sValue
33829>>>>>>>>>>>>>>>        End
33829>>>>>>>>>>>>>>>>
33829>>>>>>>>>>>>>>>        Function_Return ""
33830>>>>>>>>>>>>>>>    End_Function
33831>>>>>>>>>>>>>>>    
33831>>>>>>>>>>>>>>>End_Object
33832>>>>>>>>>>>>>Use FileFunctions.pkg // Define oFileFunctions object
33832>>>>>>>>>>>>>Use cRegistry.pkg
33832>>>>>>>>>>>>>
33832>>>>>>>>>>>>>Struct tRegKeyData
33832>>>>>>>>>>>>>    Integer hRoot
33832>>>>>>>>>>>>>    String sKey
33832>>>>>>>>>>>>>    String[] aSubKeys
33832>>>>>>>>>>>>>    tNamedValue[] aValues
33832>>>>>>>>>>>>>    tNamedValue[] aValues
33832>>>>>>>>>>>>>End_Struct
33832>>>>>>>>>>>>>
33832>>>>>>>>>>>>>Global_Variable Integer oRegistryFunctions
33832>>>>>>>>>>>>>
33832>>>>>>>>>>>>>Object _oRegistryFunctions is a cObject
33834>>>>>>>>>>>>>    
33834>>>>>>>>>>>>>    Move Self to oRegistryFunctions
33835>>>>>>>>>>>>>        
33835>>>>>>>>>>>>>    Object _oRegistry is a cRegistry // Private
33837>>>>>>>>>>>>>        Set pbLazyWrite to False
33838>>>>>>>>>>>>>        Set pfAccessRights to KEY_READ
33839>>>>>>>>>>>>>//        Set pfAccessRights to KEY_ALL_ACCESS
33839>>>>>>>>>>>>>        Function _ReadKeyData Handle hRoot String sKey tRegKeyData ByRef stKeyData Boolean bReadBinaries Returns Boolean
33842>>>>>>>>>>>>>            Boolean bOpen
33842>>>>>>>>>>>>>            Integer iKey iMaxKey iValueType
33842>>>>>>>>>>>>>            Handle hoArray
33842>>>>>>>>>>>>>            String sName
33842>>>>>>>>>>>>>            String[] aValues
33843>>>>>>>>>>>>>            tRegKeyData stEmptyKeyData
33843>>>>>>>>>>>>>            tRegKeyData stEmptyKeyData
33843>>>>>>>>>>>>>            
33843>>>>>>>>>>>>>            Move stEmptyKeyData to stKeyData
33844>>>>>>>>>>>>>            Move hRoot to stKeyData.hRoot
33845>>>>>>>>>>>>>            Move sKey to stKeyData.sKey
33846>>>>>>>>>>>>>
33846>>>>>>>>>>>>>            Set pfAccessRights to KEY_READ
33847>>>>>>>>>>>>>            
33847>>>>>>>>>>>>>            Set phRootKey to hRoot
33848>>>>>>>>>>>>>            Get OpenKey sKey to bOpen
33849>>>>>>>>>>>>>            If (bOpen) Begin
33851>>>>>>>>>>>>>            
33851>>>>>>>>>>>>>                Get Create U_Array to hoArray // Create an array object
33852>>>>>>>>>>>>>                Get GetSubkeys hoArray to iMaxKey
33853>>>>>>>>>>>>>                Decrement iMaxKey
33854>>>>>>>>>>>>>              
33854>>>>>>>>>>>>>                For iKey from 0 to iMaxKey
33860>>>>>>>>>>>>>>
33860>>>>>>>>>>>>>                    Get Value of hoArray iKey to stKeyData.aSubKeys[iKey]
33861>>>>>>>>>>>>>                Loop
33862>>>>>>>>>>>>>>
33862>>>>>>>>>>>>>                
33862>>>>>>>>>>>>>                Send Delete_Data of hoArray
33863>>>>>>>>>>>>>                Get GetValues hoArray to iMaxKey
33864>>>>>>>>>>>>>                Decrement iMaxKey
33865>>>>>>>>>>>>>                
33865>>>>>>>>>>>>>                For iKey from 0 to iMaxKey
33871>>>>>>>>>>>>>>
33871>>>>>>>>>>>>>                    Get Value of hoArray iKey to sName
33872>>>>>>>>>>>>>                    Move sName to stKeyData.aValues[iKey].sName 
33873>>>>>>>>>>>>>                    
33873>>>>>>>>>>>>>                    Get ValueType sName to iValueType
33874>>>>>>>>>>>>>                    
33874>>>>>>>>>>>>>                    If (iValueType=rdString) Begin
33876>>>>>>>>>>>>>                        Get ReadString sName to stKeyData.aValues[iKey].sValue
33877>>>>>>>>>>>>>                    End
33877>>>>>>>>>>>>>>
33877>>>>>>>>>>>>>                    Else If (iValueType=rdDword) Begin
33880>>>>>>>>>>>>>                        Get ReadDword sName to stKeyData.aValues[iKey].sValue
33881>>>>>>>>>>>>>                    End
33881>>>>>>>>>>>>>>
33881>>>>>>>>>>>>>    //                        If (iValueType=rdBinary) Begin // Not that simple
33881>>>>>>>>>>>>>    //                            //Get ReadBinary sName to stKeyData.aValues[iKey].sValue
33881>>>>>>>>>>>>>    //                        End
33881>>>>>>>>>>>>>    //                        If (iValueType=rdUnknown) Begin
33881>>>>>>>>>>>>>    //                        End
33881>>>>>>>>>>>>>                Loop
33882>>>>>>>>>>>>>>
33882>>>>>>>>>>>>>                
33882>>>>>>>>>>>>>                Send CloseKey // must close all open Keys
33883>>>>>>>>>>>>>                
33883>>>>>>>>>>>>>                Send Destroy of hoArray // Remove the array object from memory.
33884>>>>>>>>>>>>>                Function_Return True
33885>>>>>>>>>>>>>            End
33885>>>>>>>>>>>>>>
33885>>>>>>>>>>>>>            Function_Return False
33886>>>>>>>>>>>>>        End_Function
33887>>>>>>>>>>>>>
33887>>>>>>>>>>>>>        // Types: rdString rdDword rdBinary 
33887>>>>>>>>>>>>>        Procedure _WriteRegValue Handle hRoot String sKey String sName String sValue Integer iValueType
33890>>>>>>>>>>>>>            Boolean bExists bOpened 
33890>>>>>>>>>>>>>            Integer iType
33890>>>>>>>>>>>>>            Set phRootKey to hRoot
33891>>>>>>>>>>>>>            
33891>>>>>>>>>>>>>            Set pfAccessRights to KEY_ALL_ACCESS
33892>>>>>>>>>>>>>            Get KeyExistsCreateIfNot hRoot sKey to bExists
33893>>>>>>>>>>>>>            If (bExists) Begin
33895>>>>>>>>>>>>>                Get OpenKey sKey to bOpened
33896>>>>>>>>>>>>>                If (bOpened) Begin
33898>>>>>>>>>>>>>                    If (ValueExists(Self,sName)) Begin
33900>>>>>>>>>>>>>                        Get ValueType sName to iType
33901>>>>>>>>>>>>>                    End
33901>>>>>>>>>>>>>>
33901>>>>>>>>>>>>>                    Else Begin
33902>>>>>>>>>>>>>                        Move iValueType to iType
33903>>>>>>>>>>>>>                    End
33903>>>>>>>>>>>>>>
33903>>>>>>>>>>>>>                    
33903>>>>>>>>>>>>>                    If (iType=rdString) Begin
33905>>>>>>>>>>>>>                        Send WriteString sName sValue
33906>>>>>>>>>>>>>                    End
33906>>>>>>>>>>>>>>
33906>>>>>>>>>>>>>                    Else If (iType=rdDword) Begin
33909>>>>>>>>>>>>>                        Send WriteDword sName sValue
33910>>>>>>>>>>>>>                    End
33910>>>>>>>>>>>>>>
33910>>>>>>>>>>>>>                    Else If (iType=rdBinary) Begin
33913>>>>>>>>>>>>>                        Send WriteBinary sName (AddressOf(sValue)) (Length(sValue))
33914>>>>>>>>>>>>>                    End
33914>>>>>>>>>>>>>>
33914>>>>>>>>>>>>>                    Else Begin
33915>>>>>>>>>>>>>                        Error 803 "Illegal value type"
33916>>>>>>>>>>>>>>
33916>>>>>>>>>>>>>                    End
33916>>>>>>>>>>>>>>
33916>>>>>>>>>>>>>                    
33916>>>>>>>>>>>>>                    Send CloseKey
33917>>>>>>>>>>>>>                End
33917>>>>>>>>>>>>>>
33917>>>>>>>>>>>>>                Else Begin
33918>>>>>>>>>>>>>                    Error 802 "Insufficient rights to change value of registry key"
33919>>>>>>>>>>>>>>
33919>>>>>>>>>>>>>                End
33919>>>>>>>>>>>>>>
33919>>>>>>>>>>>>>                Set pfAccessRights to KEY_READ
33920>>>>>>>>>>>>>            End
33920>>>>>>>>>>>>>>
33920>>>>>>>>>>>>>            Else Begin
33921>>>>>>>>>>>>>                Error 802 "Registry key does not exist"
33922>>>>>>>>>>>>>>
33922>>>>>>>>>>>>>            End
33922>>>>>>>>>>>>>>
33922>>>>>>>>>>>>>        End_Procedure
33923>>>>>>>>>>>>>        
33923>>>>>>>>>>>>>        Function _DeleteRegValue Handle hRoot String sKey String sName Returns Boolean
33926>>>>>>>>>>>>>            Boolean bExists bOpened bSucces 
33926>>>>>>>>>>>>>            Integer iType
33926>>>>>>>>>>>>>            Set phRootKey to hRoot
33927>>>>>>>>>>>>>            
33927>>>>>>>>>>>>>            Set pfAccessRights to KEY_ALL_ACCESS
33928>>>>>>>>>>>>>            Get KeyExistsCreateIfNot hRoot sKey to bExists
33929>>>>>>>>>>>>>            If (bExists) Begin
33931>>>>>>>>>>>>>                Get OpenKey sKey to bOpened
33932>>>>>>>>>>>>>                If (bOpened) Begin
33934>>>>>>>>>>>>>                    If (ValueExists(Self,sName)) Begin                          
33936>>>>>>>>>>>>>                        Get DeleteValue sName to bSucces
33937>>>>>>>>>>>>>                    End
33937>>>>>>>>>>>>>>
33937>>>>>>>>>>>>>                    
33937>>>>>>>>>>>>>                    Send CloseKey
33938>>>>>>>>>>>>>                End
33938>>>>>>>>>>>>>>
33938>>>>>>>>>>>>>                Else Begin
33939>>>>>>>>>>>>>                    Error 802 "Insufficient rights to change value of registry key"
33940>>>>>>>>>>>>>>
33940>>>>>>>>>>>>>                End
33940>>>>>>>>>>>>>>
33940>>>>>>>>>>>>>                Set pfAccessRights to KEY_READ
33941>>>>>>>>>>>>>            End
33941>>>>>>>>>>>>>>
33941>>>>>>>>>>>>>//            Else Begin
33941>>>>>>>>>>>>>//                Error 802 "Registry key does not exist"
33941>>>>>>>>>>>>>//            End
33941>>>>>>>>>>>>>            Function_Return bSucces
33942>>>>>>>>>>>>>        End_Function
33943>>>>>>>>>>>>>        
33943>>>>>>>>>>>>>        Function _DeleteRegKey Handle hRoot String sKey String sSubKey Returns Boolean
33946>>>>>>>>>>>>>            Boolean bExists bOpened bSucces 
33946>>>>>>>>>>>>>            Integer iType
33946>>>>>>>>>>>>>            Set phRootKey to hRoot
33947>>>>>>>>>>>>>            
33947>>>>>>>>>>>>>            Set pfAccessRights to KEY_ALL_ACCESS
33948>>>>>>>>>>>>>            Get KeyExists sKey to bExists
33949>>>>>>>>>>>>>            If (bExists) Begin
33951>>>>>>>>>>>>>                Get OpenKey sKey to bOpened
33952>>>>>>>>>>>>>                If (bOpened) Begin
33954>>>>>>>>>>>>>                    If (KeyExists(Self,sSubKey)) Begin
33956>>>>>>>>>>>>>                        Get DeleteKey (sKey+"\"+sSubKey) to bSucces
33957>>>>>>>>>>>>>                    End
33957>>>>>>>>>>>>>>
33957>>>>>>>>>>>>>                    
33957>>>>>>>>>>>>>                    Send CloseKey
33958>>>>>>>>>>>>>                End
33958>>>>>>>>>>>>>>
33958>>>>>>>>>>>>>                Else Begin
33959>>>>>>>>>>>>>                    Error 802 "Insufficient rights to delete sub-registry-key"
33960>>>>>>>>>>>>>>
33960>>>>>>>>>>>>>                End
33960>>>>>>>>>>>>>>
33960>>>>>>>>>>>>>                Set pfAccessRights to KEY_READ
33961>>>>>>>>>>>>>            End
33961>>>>>>>>>>>>>>
33961>>>>>>>>>>>>>//            Else Begin
33961>>>>>>>>>>>>>//                Error 802 "Registry key does not exist"
33961>>>>>>>>>>>>>//            End
33961>>>>>>>>>>>>>            Function_Return bSucces
33962>>>>>>>>>>>>>        End_Function
33963>>>>>>>>>>>>>            
33963>>>>>>>>>>>>>    End_Object // _oRegistry
33964>>>>>>>>>>>>>
33964>>>>>>>>>>>>>    Enum_List // Standard Registry Keys
33964>>>>>>>>>>>>>        Define SRK_VDF_ROOT
33964>>>>>>>>>>>>>        Define SRK_VDF_ROOT_CURRENT_VERSION
33964>>>>>>>>>>>>>    End_Enum_List
33964>>>>>>>>>>>>>
33964>>>>>>>>>>>>>    Function _CurrentVdfVer Returns String
33967>>>>>>>>>>>>>        String sMajor sMinor
33967>>>>>>>>>>>>>        Move (String(FMAC_VERSION)) to sMajor
33968>>>>>>>>>>>>>        Move (String(FMAC_REVISION)) to sMinor
33969>>>>>>>>>>>>>        Function_Return (sMajor+"."+sMinor)
33970>>>>>>>>>>>>>    End_Function
33971>>>>>>>>>>>>>    
33971>>>>>>>>>>>>>    Procedure GetStandardKey Integer iKey Handle ByRef hRoot String ByRef sKey
33974>>>>>>>>>>>>>        String sVdfVer
33974>>>>>>>>>>>>>        If (iKey=SRK_VDF_ROOT) Begin
33976>>>>>>>>>>>>>            Move HKEY_LOCAL_MACHINE to hRoot
33977>>>>>>>>>>>>>            Move "SOFTWARE\Data Access Worldwide\Visual DataFlex" to sKey
33978>>>>>>>>>>>>>        End
33978>>>>>>>>>>>>>>
33978>>>>>>>>>>>>>        If (iKey=SRK_VDF_ROOT_CURRENT_VERSION) Begin
33980>>>>>>>>>>>>>            Move HKEY_LOCAL_MACHINE to hRoot
33981>>>>>>>>>>>>>            Get _CurrentVdfVer to sVdfVer
33982>>>>>>>>>>>>>            Move ("SOFTWARE\Data Access Worldwide\Visual DataFlex\"+sVdfVer) to sKey
33983>>>>>>>>>>>>>        End
33983>>>>>>>>>>>>>>
33983>>>>>>>>>>>>>    End_Procedure
33984>>>>>>>>>>>>>    
33984>>>>>>>>>>>>>    Function ReadKeyData Handle hRoot String sKey tRegKeyData ByRef stKeyData Boolean bReadBinaries Returns Boolean
33987>>>>>>>>>>>>>        Function_Return (_ReadKeyData(_oRegistry,hRoot,sKey,&stKeyData,bReadBinaries))
33988>>>>>>>>>>>>>    End_Function
33989>>>>>>>>>>>>>    
33989>>>>>>>>>>>>>    Function NamedRegValue tRegKeyData stKeyData String sName Returns String
33992>>>>>>>>>>>>>        tNamedValueList strList
33992>>>>>>>>>>>>>        tNamedValueList strList
33992>>>>>>>>>>>>>        String sValue
33992>>>>>>>>>>>>>        Get NewNamedValueList of oNamedValueFunctions True to strList
33993>>>>>>>>>>>>>        Move stKeyData.aValues to strList.aNamedValues
33994>>>>>>>>>>>>>        Get NamedValue of oNamedValueFunctions strList sName to sValue
33995>>>>>>>>>>>>>        Function_Return sValue
33996>>>>>>>>>>>>>    End_Function
33997>>>>>>>>>>>>>    
33997>>>>>>>>>>>>>    Function KeyExists Handle hRoot String sKey Returns Boolean
34000>>>>>>>>>>>>>        Set phRootKey of _oRegistry to hRoot
34001>>>>>>>>>>>>>        Function_Return (KeyExists(_oRegistry,sKey))
34002>>>>>>>>>>>>>    End_Function
34003>>>>>>>>>>>>>    
34003>>>>>>>>>>>>>    Function CreateKey Handle hRoot String sKey Returns Boolean
34006>>>>>>>>>>>>>        Integer iError
34006>>>>>>>>>>>>>        Set phRootKey of _oRegistry to hRoot
34007>>>>>>>>>>>>>        Get CreateKey of _oRegistry sKey to iError
34008>>>>>>>>>>>>>        If (iError<>0) Begin
34010>>>>>>>>>>>>>            Send Info_Box ("CreateKey returned the following error from Windows: "+String(iError))
34011>>>>>>>>>>>>>        End
34011>>>>>>>>>>>>>>
34011>>>>>>>>>>>>>        Function_Return (iError=0)
34012>>>>>>>>>>>>>//        Function_Return (CreateKey(_oRegistry,sKey))
34012>>>>>>>>>>>>>    End_Function
34013>>>>>>>>>>>>>    
34013>>>>>>>>>>>>>    Function KeyExistsCreateIfNot Handle hRoot String sKey Returns Boolean
34016>>>>>>>>>>>>>        Boolean bCreated
34016>>>>>>>>>>>>>        String sParentKey 
34016>>>>>>>>>>>>>        If (sKey="") Begin
34018>>>>>>>>>>>>>            Function_Return False
34019>>>>>>>>>>>>>        End
34019>>>>>>>>>>>>>>
34019>>>>>>>>>>>>>        If (not(KeyExists(Self,hRoot,sKey))) Begin
34021>>>>>>>>>>>>>            Get PathToFolder of oFileFunctions sKey to sParentKey
34022>>>>>>>>>>>>>            Get KeyExistsCreateIfNot hRoot sParentKey to bCreated
34023>>>>>>>>>>>>>            If (bCreated) Begin
34025>>>>>>>>>>>>>                Get CreateKey hRoot sKey to bCreated
34026>>>>>>>>>>>>>                If (bCreated) Begin
34028>>>>>>>>>>>>>                    Send CloseKey of _oRegistry 
34029>>>>>>>>>>>>>                End
34029>>>>>>>>>>>>>>
34029>>>>>>>>>>>>>                Function_Return bCreated
34030>>>>>>>>>>>>>            End
34030>>>>>>>>>>>>>>
34030>>>>>>>>>>>>>        End
34030>>>>>>>>>>>>>>
34030>>>>>>>>>>>>>        Function_Return (KeyExists(Self,hRoot,sKey))
34031>>>>>>>>>>>>>    End_Function
34032>>>>>>>>>>>>>
34032>>>>>>>>>>>>>    // iValueType is rdString rdDword or rdBinary
34032>>>>>>>>>>>>>    Procedure WriteRegValue Handle hRoot String sKey String sName String sValue Integer iValueType
34035>>>>>>>>>>>>>        Send _WriteRegValue of _oRegistry hRoot sKey sName sValue iValueType
34036>>>>>>>>>>>>>    End_Procedure
34037>>>>>>>>>>>>>    
34037>>>>>>>>>>>>>    Function DeleteRegValue Handle hRoot String sKey String sName Returns Boolean
34040>>>>>>>>>>>>>        Boolean bSucces
34040>>>>>>>>>>>>>        Get _DeleteRegValue of _oRegistry hRoot sKey sName to bSucces
34041>>>>>>>>>>>>>        Function_Return bSucces
34042>>>>>>>>>>>>>    End_Function
34043>>>>>>>>>>>>>    
34043>>>>>>>>>>>>>    Function DeleteRegKey Handle hRoot String sKey String sSubKey Returns Boolean
34046>>>>>>>>>>>>>        Boolean bSucces
34046>>>>>>>>>>>>>        Get _DeleteRegKey of _oRegistry hRoot sKey sSubKey to bSucces
34047>>>>>>>>>>>>>        Function_Return bSucces
34048>>>>>>>>>>>>>    End_Function
34049>>>>>>>>>>>>>    
34049>>>>>>>>>>>>>End_Object
34050>>>>>>>>>>>Use FileFunctions.pkg // Define oFileFunctions object
34050>>>>>>>>>>>
34050>>>>>>>>>>>Struct tVdfRuntime
34050>>>>>>>>>>>    String  sRegistryKey
34050>>>>>>>>>>>    String  sVdfVersion
34050>>>>>>>>>>>    String  sRootFolder
34050>>>>>>>>>>>    String  sDfPath
34050>>>>>>>>>>>    String  sCollateLanguage
34050>>>>>>>>>>>    Boolean WAS_bEnableSlaveNode
34050>>>>>>>>>>>    Integer WAS_iGracefulTerminate
34050>>>>>>>>>>>    Integer WAS_iListen
34050>>>>>>>>>>>    Integer WAS_iMaxSessions
34050>>>>>>>>>>>    Integer WAS_iMessageTimeout
34050>>>>>>>>>>>    String  WAS_sProductClass
34050>>>>>>>>>>>    Integer WAS_iRefreshInterval
34050>>>>>>>>>>>    String  WAS_sRegCode
34050>>>>>>>>>>>    String  WAS_sRegName
34050>>>>>>>>>>>    String  WAS_sRegNumber
34050>>>>>>>>>>>    String  WAS_sUsers
34050>>>>>>>>>>>    Integer WAS_iTransactionTimeout
34050>>>>>>>>>>>End_Struct
34050>>>>>>>>>>>
34050>>>>>>>>>>>Struct tVdfWebApplication
34050>>>>>>>>>>>    String  sVdfVersion // Pointer to runtime array
34050>>>>>>>>>>>    String  sName
34050>>>>>>>>>>>    Integer iRuntimeIndex // Obsoleted by sVdfVersion
34050>>>>>>>>>>>    String  sRegistryKey
34050>>>>>>>>>>>    Boolean bDisable
34050>>>>>>>>>>>    Boolean bLogAccess
34050>>>>>>>>>>>    String  sLogFile
34050>>>>>>>>>>>    Integer iMaxLogEntries
34050>>>>>>>>>>>    Integer iMinPool
34050>>>>>>>>>>>    Integer iMaxPool
34050>>>>>>>>>>>    String  sOperationMode
34050>>>>>>>>>>>    String  sProgramParameters
34050>>>>>>>>>>>    String  sProgramPath
34050>>>>>>>>>>>    Integer iPurgePoolInterval
34050>>>>>>>>>>>    Boolean bUseConnectorPool
34050>>>>>>>>>>>    String  sDataPath
34050>>>>>>>>>>>End_Struct
34050>>>>>>>>>>>
34050>>>>>>>>>>>Global_Variable tVdfRuntime[] gaRuntimes // Filled in automatically at program start
34050>>>>>>>>>>>Global_Variable tVdfWebApplication[] gaWebApplications // This too
34050>>>>>>>>>>>
34050>>>>>>>>>>>Global_Variable Integer oVdfRuntimeFunctions
34050>>>>>>>>>>>
34050>>>>>>>>>>>
34050>>>>>>>>>>>Struct tCollateLanguage
34050>>>>>>>>>>>    String sName
34050>>>>>>>>>>>    String sCollateString
34050>>>>>>>>>>>End_Struct
34050>>>>>>>>>>>
34050>>>>>>>>>>>Global_Variable tCollateLanguage[] gaCollateStrings
34050>>>>>>>>>>>
34050>>>>>>>>>>>//External_Function VDFR_IsDebuggerPresent "IsDebuggerPresent" Kernel32.dll Returns Integer
34050>>>>>>>>>>>
34050>>>>>>>>>>>Object _oVdfRuntimeFunctions is a cObject
34052>>>>>>>>>>>    Move Self to oVdfRuntimeFunctions
34053>>>>>>>>>>>
34053>>>>>>>>>>>    Property String _psCurrentCollateString ""
34055>>>>>>>>>>>
34055>>>>>>>>>>>    Function CurrentCollateString Returns String
34058>>>>>>>>>>>        Integer iChar iItem iMax hArr
34058>>>>>>>>>>>        String sValue
34058>>>>>>>>>>>        If (_psCurrentCollateString(Self)="") Begin
34060>>>>>>>>>>>            Get Create U_Array to hArr
34061>>>>>>>>>>>            Send Delete_Data of hArr
34062>>>>>>>>>>>            For iChar from 32 to 255
34068>>>>>>>>>>>>
34068>>>>>>>>>>>                Set Value of hArr (iChar-32) to (Character(iChar))
34069>>>>>>>>>>>            Loop
34070>>>>>>>>>>>>
34070>>>>>>>>>>>            Send Sort_Items of hArr Ascending // This reveals the true sorting of the current runtime.
34071>>>>>>>>>>>            Get Item_Count of hArr to iMax
34072>>>>>>>>>>>            Decrement iMax
34073>>>>>>>>>>>            Move "" to sValue
34074>>>>>>>>>>>            For iItem from 0 to iMax
34080>>>>>>>>>>>>
34080>>>>>>>>>>>                Move (sValue+Value(hArr,iItem)) to sValue
34081>>>>>>>>>>>            Loop
34082>>>>>>>>>>>>
34082>>>>>>>>>>>            Set _psCurrentCollateString to sValue
34083>>>>>>>>>>>            Send Destroy of hArr
34084>>>>>>>>>>>        End
34084>>>>>>>>>>>>
34084>>>>>>>>>>>        Function_Return (_psCurrentCollateString(Self))
34085>>>>>>>>>>>    End_Function
34086>>>>>>>>>>>    
34086>>>>>>>>>>>    Function MinimumCollateCharacter Returns String
34089>>>>>>>>>>>        String sCurrentCollateString 
34089>>>>>>>>>>>//        Get _psCurrentCollateString to sCurrentCollateString
34089>>>>>>>>>>>        Get CurrentCollateString to sCurrentCollateString
34090>>>>>>>>>>>        Function_Return (Left(sCurrentCollateString,1))
34091>>>>>>>>>>>    End_Function
34092>>>>>>>>>>>    
34092>>>>>>>>>>>    Function MaximumCollateCharacter Returns String
34095>>>>>>>>>>>        String sCurrentCollateString 
34095>>>>>>>>>>>//        Get _psCurrentCollateString to sCurrentCollateString
34095>>>>>>>>>>>        Get CurrentCollateString to sCurrentCollateString
34096>>>>>>>>>>>        Function_Return (Right(sCurrentCollateString,1))
34097>>>>>>>>>>>    End_Function
34098>>>>>>>>>>>
34098>>>>>>>>>>>             Function _MakeString String sValue Returns String
34101>>>>>>>>>>>                Integer iMax iIndex iChar
34101>>>>>>>>>>>                String sRval
34101>>>>>>>>>>>                String[] aValues
34102>>>>>>>>>>>
34102>>>>>>>>>>>                Move "" to sRval
34103>>>>>>>>>>>                Send SplitString of oStringFunctions sValue " " True False (&aValues)
34104>>>>>>>>>>>                Move (SizeOfArray(aValues)-1) to iMax
34105>>>>>>>>>>>                For iIndex from 0 to iMax
34111>>>>>>>>>>>>
34111>>>>>>>>>>>                    Move aValues[iIndex] to iChar
34112>>>>>>>>>>>                    Move (sRval+Character(iChar)) to sRval
34113>>>>>>>>>>>                Loop
34114>>>>>>>>>>>>
34114>>>>>>>>>>>                Function_Return sRval
34115>>>>>>>>>>>             End_Function
34116>>>>>>>>>>>
34116>>>>>>>>>>>            Function _DanishCollateString Returns String
34119>>>>>>>>>>>                String sValue
34119>>>>>>>>>>>                Move "32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 58 59 60 61 62 63 95 127 48 49 50 51 52 53 54 55 56 57 65 97 66 98 67 99 68 100 69 64 144 158 201 101 96 130 174 233 172 70 102 71 103 72 104 73 105 74 106" to sValue
34120>>>>>>>>>>>                Move (sValue+" 75 107 76 108 77 109 78 110 79 111 80 112 81 113 82 114 83 115 84 116 85 117 86 118 87 119 88 120 89 121 94 154 220 219 160 126 129 232 252 161 90 122 91 123 92 124 93 125 146 152 198 211 162 145 168 230 215") to sValue
34121>>>>>>>>>>>                Move (sValue+" 163 157 191 216 210 155 207 248 214 143 150 197 208 134 166 167 170 229 212 171 128 131 132 133 135 136 137 138 139 140 141 142 147 148 149 151 153 156 159 164 165 169 173 175 176 177 178 179 180 181 182 183") to sValue
34122>>>>>>>>>>>                Move (sValue+" 184 185 186 187 188 189 190 192 193 194 195 196 199 200 202 203 204 205 206 209 213 217 218 221 222 223 224 225 226 227 228 231 234 235 236 237 238 239 240 241 242 243 244 245 246 247 249 250 251 253 254 255") to sValue
34123>>>>>>>>>>>                Function_Return (_MakeString(Self,sValue))
34124>>>>>>>>>>>            End_Function
34125>>>>>>>>>>>        
34125>>>>>>>>>>>            Function _SwedishCollateString Returns String
34128>>>>>>>>>>>                String sValue
34128>>>>>>>>>>>                Move "32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 58 59 60 61 62 63 95 127 48 49 50 51 52 53 54 55 56 57 65 97 66 98 67 99 68 100 69 64 144 158 201 168 101 96 130 174 233 169 70 102 71 103 72 104 73 105 74" to sValue
34129>>>>>>>>>>>                Move (sValue+" 106 75 107 76 108 77 109 78 110 79 111 80 112 81 113 82 114 83 115 84 116 85 117 86 118 87 119 88 120 89 121 94 154 216 220 219 126 129 232 252 207 167 90 122 93 125 91 123 92 124 143 150 197 208 161 134 166") to sValue
34130>>>>>>>>>>>                Move (sValue+" 229 212 142 147 196 132 164 162 165 163 228 153 188 214 148 204 218 246 206 128 131 133 135 136 137 138 139 140 141 145 146 149 151 152 155 156 157 159 160 170 171 172 173 175 176 177 178 179 180 181 182 183") to sValue
34131>>>>>>>>>>>                Move (sValue+" 184 185 186 187 189 190 191 192 193 194 195 198 199 200 202 203 205 209 210 211 213 215 217 221 222 223 224 225 226 227 230 231 234 235 236 237 238 239 240 241 242 243 244 245 247 248 249 250 251 253 254 255") to sValue
34132>>>>>>>>>>>                Function_Return (_MakeString(Self,sValue))
34133>>>>>>>>>>>            End_Function
34134>>>>>>>>>>>        
34134>>>>>>>>>>>            Function _NorwegianCollateString Returns String
34137>>>>>>>>>>>                String sValue
34137>>>>>>>>>>>                Move "32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 58 59 60 61 62 63 95 127 48 49 50 51 52 53 54 55 56 57 65 97 66 98 67 99 68 100 69 64 144 158 201 101 96 130 174 233 172 70 102 71 103 72 104 73 105 74 106" to sValue
34138>>>>>>>>>>>                Move (sValue+" 75 107 76 108 77 109 78 110 79 111 80 112 81 113 82 114 83 115 84 116 85 117 86 118 87 119 88 120 89 121 94 154 220 219 160 126 129 232 252 161 90 122 91 123 92 124 93 125 146 152 198 211 162 145 168 230 215") to sValue
34139>>>>>>>>>>>                Move (sValue+" 163 157 191 216 210 155 207 248 214 143 150 197 208 134 166 167 170 229 212 171 128 131 132 133 135 136 137 138 139 140 141 142 147 148 149 151 153 156 159 164 165 169 173 175 176 177 178 179 180 181 182 183") to sValue
34140>>>>>>>>>>>                Move (sValue+" 184 185 186 187 188 189 190 192 193 194 195 196 199 200 202 203 204 205 206 209 213 217 218 221 222 223 224 225 226 227 228 231 234 235 236 237 238 239 240 241 242 243 244 245 246 247 249 250 251 253 254 255") to sValue
34141>>>>>>>>>>>                Function_Return (_MakeString(Self,sValue))
34142>>>>>>>>>>>            End_Function
34143>>>>>>>>>>>        
34143>>>>>>>>>>>            Function _GermanCollateString Returns String
34146>>>>>>>>>>>                String sValue
34146>>>>>>>>>>>                Move "32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 58 59 60 61 62 63 64 94 95 96 127 48 49 50 51 52 53 54 55 56 57 65 91 142 147 196 97 123 132 163 228 66 98 67 99 68 100 69 101 70 102 71 103 72 104 73 105" to sValue
34147>>>>>>>>>>>                Move (sValue+" 74 106 75 107 76 108 77 109 78 110 79 92 153 188 218 214 111 124 148 204 206 246 80 112 81 113 82 114 83 115 126 225 238 222 223 84 116 85 93 154 216 219 220 117 125 129 232 207 252 86 118 87 119 88 120 89 121") to sValue
34148>>>>>>>>>>>                Move (sValue+" 90 122 128 130 131 133 134 135 136 137 138 139 140 141 143 144 145 146 149 150 151 152 155 156 157 158 159 160 161 162 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185") to sValue
34149>>>>>>>>>>>                Move (sValue+" 186 187 189 190 191 192 193 194 195 197 198 199 200 201 202 203 205 208 209 210 211 212 213 215 217 221 224 226 227 229 230 231 233 234 235 236 237 239 240 241 242 243 244 245 247 248 249 250 251 253 254 255") to sValue
34150>>>>>>>>>>>                Function_Return (_MakeString(Self,sValue))
34151>>>>>>>>>>>            End_Function
34152>>>>>>>>>>>        
34152>>>>>>>>>>>            Function _SpanishCollateString Returns String
34155>>>>>>>>>>>                String sValue
34155>>>>>>>>>>>                Move "32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 58 59 60 61 62 63 91 92 93 94 95 96 123 124 125 126 127 128 131 132 133 134 135 136 137 138 139 140 141 142 143 145 146 147 148 149 150 151 152 153 155 156" to sValue
34156>>>>>>>>>>>                Move (sValue+" 157 158 159 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 215 216") to sValue
34157>>>>>>>>>>>                Move (sValue+" 217 218 219 220 221 222 223 225 226 227 228 229 230 231 232 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 48 49 50 51 52 53 54 55 56 57 64 65 97 181 160 66 98 67 99") to sValue
34158>>>>>>>>>>>                Move (sValue+" 68 100 69 101 144 130 70 102 71 103 72 104 73 105 214 161 74 106 75 107 76 108 77 109 78 110 165 164 79 111 224 162 80 112 81 113 82 114 83 115 84 116 85 117 233 163 154 129 86 118 87 119 88 120 89 121 90 122") to sValue
34159>>>>>>>>>>>                Function_Return (_MakeString(Self,sValue))
34160>>>>>>>>>>>            End_Function
34161>>>>>>>>>>>        
34161>>>>>>>>>>>            Function _PortugueseCollateString Returns String
34164>>>>>>>>>>>                String sValue
34164>>>>>>>>>>>                Move "32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 58 59 60 61 62 63 91 92 93 94 95 96 123 124 125 126 127 145 146 155 156 157 158 159 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 184" to sValue
34165>>>>>>>>>>>                Move (sValue+" 185 186 187 188 189 190 191 192 193 194 195 196 197 200 201 202 203 204 205 206 207 208 209 217 218 219 220 221 230 231 232 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 134") to sValue
34166>>>>>>>>>>>                Move (sValue+" 143 152 213 223 225 48 49 50 51 52 53 54 55 56 57 64 65 97 181 160 183 133 182 131 142 132 199 198 66 98 67 99 128 135 68 100 69 101 144 130 212 138 210 136 211 137 70 102 71 103 72 104 73 105 214 161 222 141") to sValue
34167>>>>>>>>>>>                Move (sValue+" 215 140 216 139 74 106 75 107 76 108 77 109 78 110 79 111 224 162 227 149 226 147 153 148 229 228 80 112 81 113 82 114 83 115 84 116 85 117 233 163 235 151 234 150 154 129 86 118 87 119 88 120 89 121 90 122") to sValue
34168>>>>>>>>>>>                Function_Return (_MakeString(Self,sValue))
34169>>>>>>>>>>>            End_Function
34170>>>>>>>>>>>        
34170>>>>>>>>>>>            Function _DutchCollateString Returns String
34173>>>>>>>>>>>                String sValue
34173>>>>>>>>>>>                Move "32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 58 59 60 61 62 63 91 92 93 94 95 96 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152" to sValue
34174>>>>>>>>>>>                Move (sValue+" 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204") to sValue
34175>>>>>>>>>>>                Move (sValue+" 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 48") to sValue
34176>>>>>>>>>>>                Move (sValue+" 49 50 51 52 53 54 55 56 57 64 65 97 66 98 67 99 68 100 69 101 70 102 71 103 72 104 73 105 74 106 75 107 76 108 77 109 78 110 79 111 80 112 81 113 82 114 83 115 84 116 85 117 86 118 87 119 88 120 89 121 90 122") to sValue
34177>>>>>>>>>>>                Function_Return (_MakeString(Self,sValue))
34178>>>>>>>>>>>            End_Function
34179>>>>>>>>>>>        
34179>>>>>>>>>>>            Function _RussianCollateString Returns String
34182>>>>>>>>>>>                String sValue
34182>>>>>>>>>>>                Move "32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 58 59 60 61 62 63 91 92 93 94 95 96 123 124 125 126 127 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200" to sValue
34183>>>>>>>>>>>                Move (sValue+" 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 242 243 244 245 246 247 248 249 250 251 252 253 254 255 48 49 50 51 52 53 54 55 56 57 64 65 97 66 98 67 99 68 100 69") to sValue
34184>>>>>>>>>>>                Move (sValue+" 101 70 102 71 103 72 104 73 105 74 106 75 107 76 108 77 109 78 110 79 111 80 112 81 113 82 114 83 115 84 116 85 117 86 118 87 119 88 120 89 121 90 122 128 160 129 161 130 162 131 163 132 164 133 165 240 241") to sValue
34185>>>>>>>>>>>                Move (sValue+" 134 166 135 167 136 168 137 169 138 170 139 171 140 172 141 173 142 174 143 175 144 224 145 225 146 226 147 227 148 228 149 229 150 230 151 231 152 232 153 233 154 234 155 235 156 236 157 237 158 238 159 239") to sValue
34186>>>>>>>>>>>                Function_Return (_MakeString(Self,sValue))
34187>>>>>>>>>>>            End_Function
34188>>>>>>>>>>>        
34188>>>>>>>>>>>            Function _FrenchCollateString Returns String
34191>>>>>>>>>>>                String sValue
34191>>>>>>>>>>>                Move "32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 58 59 60 61 62 63 91 92 93 94 95 96 123 124 125 126 127 145 146 155 156 157 158 159 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 184" to sValue
34192>>>>>>>>>>>                Move (sValue+" 185 186 187 188 189 190 191 192 193 194 195 196 197 200 201 202 203 204 205 206 207 208 209 217 218 219 220 221 230 231 232 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 134") to sValue
34193>>>>>>>>>>>                Move (sValue+" 143 152 213 223 225 48 49 50 51 52 53 54 55 56 57 64 65 97 181 160 183 133 182 131 142 132 199 198 66 98 67 99 128 135 68 100 69 101 144 130 212 138 210 136 211 137 70 102 71 103 72 104 73 105 214 161 222 141") to sValue
34194>>>>>>>>>>>                Move (sValue+" 215 140 216 139 74 106 75 107 76 108 77 109 78 110 79 111 224 162 227 149 226 147 153 148 229 228 80 112 81 113 82 114 83 115 84 116 85 117 233 163 235 151 234 150 154 129 86 118 87 119 88 120 89 121 90 122") to sValue
34195>>>>>>>>>>>                Function_Return (_MakeString(Self,sValue))
34196>>>>>>>>>>>            End_Function
34197>>>>>>>>>>>        
34197>>>>>>>>>>>            Function _EnglishCollateString Returns String
34200>>>>>>>>>>>                String sValue
34200>>>>>>>>>>>                Move "32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 58 59 60 61 62 63 91 92 93 94 95 96 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152" to sValue
34201>>>>>>>>>>>                Move (sValue+" 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204") to sValue
34202>>>>>>>>>>>                Move (sValue+" 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 48") to sValue
34203>>>>>>>>>>>                Move (sValue+" 49 50 51 52 53 54 55 56 57 64 65 97 66 98 67 99 68 100 69 101 70 102 71 103 72 104 73 105 74 106 75 107 76 108 77 109 78 110 79 111 80 112 81 113 82 114 83 115 84 116 85 117 86 118 87 119 88 120 89 121 90 122") to sValue
34204>>>>>>>>>>>                Function_Return (_MakeString(Self,sValue))
34205>>>>>>>>>>>            End_Function
34206>>>>>>>>>>>        
34206>>>>>>>>>>>            Procedure _AddCollate String sName String sCollateString
34209>>>>>>>>>>>                Integer iIndex
34209>>>>>>>>>>>                Move (SizeOfArray(gaCollateStrings)) to iIndex
34210>>>>>>>>>>>                Move sName to gaCollateStrings[iIndex].sName
34211>>>>>>>>>>>                Move sCollateString to gaCollateStrings[iIndex].sCollateString
34212>>>>>>>>>>>            End_Procedure
34213>>>>>>>>>>>            
34213>>>>>>>>>>>            Function _CollateLanguage String sCollate Returns String
34216>>>>>>>>>>>                Integer iMax iIndex
34216>>>>>>>>>>>                String sRval
34216>>>>>>>>>>>                If (SizeOfArray(gaCollateStrings)=0) Begin
34218>>>>>>>>>>>                    Send _AddCollate "English"    (_EnglishCollateString(Self))
34219>>>>>>>>>>>                    Send _AddCollate "Dutch"      (_DutchCollateString(Self))
34220>>>>>>>>>>>                    Send _AddCollate "Danish"     (_DanishCollateString(Self))
34221>>>>>>>>>>>                    Send _AddCollate "Norwegian"  (_NorwegianCollateString(Self))
34222>>>>>>>>>>>                    Send _AddCollate "Swedish"    (_SwedishCollateString(Self))
34223>>>>>>>>>>>                    Send _AddCollate "German"     (_GermanCollateString(Self))
34224>>>>>>>>>>>                    Send _AddCollate "Spanish"    (_SpanishCollateString(Self))
34225>>>>>>>>>>>                    Send _AddCollate "Portuguese" (_PortugueseCollateString(Self))
34226>>>>>>>>>>>                    Send _AddCollate "Russian"    (_RussianCollateString(Self))
34227>>>>>>>>>>>                    Send _AddCollate "French"     (_FrenchCollateString(Self))
34228>>>>>>>>>>>                End
34228>>>>>>>>>>>>
34228>>>>>>>>>>>                Move "" to sRval
34229>>>>>>>>>>>                Move (SizeOfArray(gaCollateStrings)-1) to iMax
34230>>>>>>>>>>>                For iIndex from 0 to iMax
34236>>>>>>>>>>>>
34236>>>>>>>>>>>                    If (sCollate=gaCollateStrings[iIndex].sCollateString) Begin
34238>>>>>>>>>>>                        If (sRval<>"") Move (sRval+", ") to sRval
34241>>>>>>>>>>>                        Move (sRval+gaCollateStrings[iIndex].sName) to sRval
34242>>>>>>>>>>>                    End
34242>>>>>>>>>>>>
34242>>>>>>>>>>>                Loop
34243>>>>>>>>>>>>
34243>>>>>>>>>>>                If (sRval="") Move "Unknown" to sRval
34246>>>>>>>>>>>                Function_Return sRval
34247>>>>>>>>>>>            End_Function
34248>>>>>>>>>>>
34248>>>>>>>>>>>    Function CurrentCollateLanguage Returns String
34251>>>>>>>>>>>        String sCurrentCollate 
34251>>>>>>>>>>>        Get CurrentCollateString to sCurrentCollate
34252>>>>>>>>>>>        Function_Return (_CollateLanguage(Self,sCurrentCollate))
34253>>>>>>>>>>>    End_Function
34254>>>>>>>>>>>    
34254>>>>>>>>>>>    Function RuntimeIndex String sVdfVer Returns Integer
34257>>>>>>>>>>>        Integer iMax iItem
34257>>>>>>>>>>>        Move (SizeOfArray(gaRuntimes)-1) to iMax
34258>>>>>>>>>>>        For iItem from 0 to iMax
34264>>>>>>>>>>>>
34264>>>>>>>>>>>            If (sVdfVer=gaRuntimes[iItem].sVdfVersion) Begin
34266>>>>>>>>>>>                Function_Return iItem
34267>>>>>>>>>>>            End
34267>>>>>>>>>>>>
34267>>>>>>>>>>>        Loop
34268>>>>>>>>>>>>
34268>>>>>>>>>>>        Function_Return -1
34269>>>>>>>>>>>    End_Function
34270>>>>>>>>>>>    
34270>>>>>>>>>>>    Function RuntimeStruct String sVdfVer Returns tVdfRuntime
34273>>>>>>>>>>>        Integer iItem
34273>>>>>>>>>>>        tVdfRuntime strRuntime
34273>>>>>>>>>>>        tVdfRuntime strRuntime
34273>>>>>>>>>>>        Get RuntimeIndex sVdfVer to iItem
34274>>>>>>>>>>>        If (iItem>=0) Begin
34276>>>>>>>>>>>            Move gaRuntimes[iItem] to strRuntime
34277>>>>>>>>>>>        End
34277>>>>>>>>>>>>
34277>>>>>>>>>>>        Function_Return strRuntime
34278>>>>>>>>>>>    End_Function
34279>>>>>>>>>>>    
34279>>>>>>>>>>>    Property String _psOriginalProgramPath
34281>>>>>>>>>>>    
34281>>>>>>>>>>>            Function _ReadFileDfCollateCfg String sPath Returns String
34284>>>>>>>>>>>                Integer iChannel iPos iRangeStart iRangeStop iChar iLen
34284>>>>>>>>>>>                Boolean bSeqEof
34284>>>>>>>>>>>                String sValue sLine sText
34284>>>>>>>>>>>                String[] aItems
34285>>>>>>>>>>>                
34285>>>>>>>>>>>                Get DirectInput of oFileFunctions sPath to iChannel
34286>>>>>>>>>>>                If (iChannel>=0) Begin
34288>>>>>>>>>>>                    Move 1 to iPos
34289>>>>>>>>>>>                    Repeat
34289>>>>>>>>>>>>
34289>>>>>>>>>>>                        Readln channel iChannel sLine
34291>>>>>>>>>>>                        Move (SeqEof) to bSeqEof
34292>>>>>>>>>>>                        If (not(bSeqEof)) Begin
34294>>>>>>>>>>>                            Send SplitString of oStringFunctions sLine " " True False (&aItems)
34295>>>>>>>>>>>                            If (Left(sLine,5)="RANGE") Begin
34297>>>>>>>>>>>                                Move aItems[1] to iRangeStart
34298>>>>>>>>>>>                                Move aItems[2] to iRangeStop
34299>>>>>>>>>>>                                For iChar from iRangeStart to iRangeStop
34305>>>>>>>>>>>>
34305>>>>>>>>>>>                                    Move (Overstrike(Character(iChar),sValue,iPos)) to sValue
34306>>>>>>>>>>>                                    Increment iPos
34307>>>>>>>>>>>                                Loop
34308>>>>>>>>>>>>
34308>>>>>>>>>>>                            End
34308>>>>>>>>>>>>
34308>>>>>>>>>>>                            If (Left(sLine,6)="SINGLE") Begin
34310>>>>>>>>>>>                                Move aItems[1] to iChar
34311>>>>>>>>>>>                                Move (Overstrike(Character(iChar),sValue,iPos)) to sValue
34312>>>>>>>>>>>                                Increment iPos                               
34313>>>>>>>>>>>                            End
34313>>>>>>>>>>>>
34313>>>>>>>>>>>                            If (Left(sLine,4)="TEXT") Begin
34315>>>>>>>>>>>                                Move aItems[1] to sText
34316>>>>>>>>>>>                                Move (Replace('"',sText,"")) to sText
34317>>>>>>>>>>>                                Move (Length(sText)-1) to iLen
34318>>>>>>>>>>>                                Move (Left(sText,iLen)) to sText
34319>>>>>>>>>>>                                Move (Overstrike(sText,sValue,iPos)) to sValue
34320>>>>>>>>>>>                                Move (iPos+iLen) to iPos
34321>>>>>>>>>>>                            End
34321>>>>>>>>>>>>
34321>>>>>>>>>>>                        End
34321>>>>>>>>>>>>
34321>>>>>>>>>>>                    Until (bSeqEof)
34323>>>>>>>>>>>                    Send CloseInput of oFileFunctions iChannel
34324>>>>>>>>>>>                End
34324>>>>>>>>>>>>
34324>>>>>>>>>>>                Function_Return (Remove(sValue,1,32))
34325>>>>>>>>>>>            End_Function
34326>>>>>>>>>>>
34326>>>>>>>>>>>            // Updates global array gaRuntimes
34326>>>>>>>>>>>            Procedure _EnumerateRuntimes
34329>>>>>>>>>>>                Boolean bContinue
34329>>>>>>>>>>>                Integer iVersionIndex iVersionMax
34329>>>>>>>>>>>                String sRoot sVdfVersion sCollate
34329>>>>>>>>>>>                tRegKeyData stVdfVersions stKeyData
34329>>>>>>>>>>>                tRegKeyData stVdfVersions stKeyData
34329>>>>>>>>>>>
34329>>>>>>>>>>>                Move (ResizeArray(gaRuntimes,0)) to gaRuntimes
34330>>>>>>>>>>>
34330>>>>>>>>>>>                Move "SOFTWARE\Data Access Worldwide\Visual DataFlex" to sRoot
34331>>>>>>>>>>>                Get ReadKeyData of oRegistryFunctions HKEY_LOCAL_MACHINE sRoot (&stVdfVersions) False to bContinue
34332>>>>>>>>>>>//                If (not(bContinue)) Begin
34332>>>>>>>>>>>//                    Move "SOFTWARE\Wow6432Node\Data Access Worldwide\Visual DataFlex" to sRoot
34332>>>>>>>>>>>//                    Get ReadKeyData of oRegistryFunctions HKEY_LOCAL_MACHINE sRoot (&stVdfVersions) False to bContinue
34332>>>>>>>>>>>//                End
34332>>>>>>>>>>>                If (bContinue) Begin
34334>>>>>>>>>>>                    Move (SizeOfArray(stVdfVersions.aSubKeys)-1) to iVersionMax
34335>>>>>>>>>>>                    For iVersionIndex from 0 to iVersionMax
34341>>>>>>>>>>>>
34341>>>>>>>>>>>                        Move stVdfVersions.aSubKeys[iVersionIndex] to sVdfVersion
34342>>>>>>>>>>>                        Move sVdfVersion to gaRuntimes[iVersionIndex].sVdfVersion
34343>>>>>>>>>>>                        Move (sRoot+"\"+sVdfVersion) to gaRuntimes[iVersionIndex].sRegistryKey
34344>>>>>>>>>>>                        If (ReadKeyData(oRegistryFunctions,HKEY_LOCAL_MACHINE,sRoot+"\"+sVdfVersion+"\Defaults",&stKeyData,False)) Begin
34346>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stKeyData "DFPath"     to gaRuntimes[iVersionIndex].sDfPath
34347>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stKeyData "VDFRootDir" to gaRuntimes[iVersionIndex].sRootFolder
34348>>>>>>>>>>>                            
34348>>>>>>>>>>>                            Get _ReadFileDfCollateCfg (AppendPath(oFileFunctions,gaRuntimes[iVersionIndex].sRootFolder,"Bin\df_collate.cfg")) to sCollate
34349>>>>>>>>>>>                            Get _CollateLanguage sCollate to gaRuntimes[iVersionIndex].sCollateLanguage
34350>>>>>>>>>>>                            
34350>>>>>>>>>>>                        End
34350>>>>>>>>>>>>
34350>>>>>>>>>>>                        If (ReadKeyData(oRegistryFunctions,HKEY_LOCAL_MACHINE,sRoot+"\"+sVdfVersion+"\WebApp Server",&stKeyData,False)) Begin
34352>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stKeyData "EnableSlaveNode"    to gaRuntimes[iVersionIndex].WAS_bEnableSlaveNode
34353>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stKeyData "GracefulTerminate"  to gaRuntimes[iVersionIndex].WAS_iGracefulTerminate
34354>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stKeyData "Listen"             to gaRuntimes[iVersionIndex].WAS_iListen
34355>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stKeyData "MaxSessions"        to gaRuntimes[iVersionIndex].WAS_iMaxSessions
34356>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stKeyData "MessageTimeout"     to gaRuntimes[iVersionIndex].WAS_iMessageTimeout
34357>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stKeyData "Product Class"      to gaRuntimes[iVersionIndex].WAS_sProductClass
34358>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stKeyData "RefreshInterval"    to gaRuntimes[iVersionIndex].WAS_iRefreshInterval
34359>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stKeyData "Registration Code"  to gaRuntimes[iVersionIndex].WAS_sRegCode
34360>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stKeyData "Registration Name"  to gaRuntimes[iVersionIndex].WAS_sRegName
34361>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stKeyData "Serial Number"      to gaRuntimes[iVersionIndex].WAS_sRegNumber
34362>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stKeyData "Users"              to gaRuntimes[iVersionIndex].WAS_sUsers
34363>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stKeyData "TransactionTimeout" to gaRuntimes[iVersionIndex].WAS_iTransactionTimeout
34364>>>>>>>>>>>                        End
34364>>>>>>>>>>>>
34364>>>>>>>>>>>                    Loop
34365>>>>>>>>>>>>
34365>>>>>>>>>>>                End
34365>>>>>>>>>>>>
34365>>>>>>>>>>>            End_Procedure
34366>>>>>>>>>>>
34366>>>>>>>>>>>            // Updates index iRuntimeIndex of global array gaWebApplications with the webapplications belonging
34366>>>>>>>>>>>            // to the runtime specified in parameter stRuntime
34366>>>>>>>>>>>            Procedure _EnumerateWebApplications Integer iRuntimeIndex tVdfRuntime stRuntime
34369>>>>>>>>>>>                Integer iAppIndex iAppMax
34369>>>>>>>>>>>                String sWebAppsRootKey sWebAppRootKey sAppName sPath
34369>>>>>>>>>>>                tRegKeyData stWebAppsRootKeyData stWebAppKeyData
34369>>>>>>>>>>>                tRegKeyData stWebAppsRootKeyData stWebAppKeyData
34369>>>>>>>>>>>                tVdfWebApplication stWebApplication
34369>>>>>>>>>>>                tVdfWebApplication stWebApplication
34369>>>>>>>>>>>
34369>>>>>>>>>>>                Move (stRuntime.sRegistryKey+"\WebApp Server\Web Applications") to sWebAppsRootKey
34370>>>>>>>>>>>
34370>>>>>>>>>>>                If (ReadKeyData(oRegistryFunctions,HKEY_LOCAL_MACHINE,sWebAppsRootKey,&stWebAppsRootKeyData,False)) Begin
34372>>>>>>>>>>>                    Move (SizeOfArray(stWebAppsRootKeyData.aSubKeys)-1) to iAppMax
34373>>>>>>>>>>>                    For iAppIndex from 0 to iAppMax
34379>>>>>>>>>>>>
34379>>>>>>>>>>>                        Move stWebAppsRootKeyData.aSubKeys[iAppIndex] to sAppName
34380>>>>>>>>>>>                        Move sAppName to stWebApplication.sName
34381>>>>>>>>>>>                        Move (sWebAppsRootKey+"\"+sAppName) to sWebAppRootKey
34382>>>>>>>>>>>                        Move sWebAppRootKey to stWebApplication.sRegistryKey
34383>>>>>>>>>>>                        Move iRuntimeIndex to stWebApplication.iRuntimeIndex
34384>>>>>>>>>>>                        Move gaRuntimes[iRuntimeIndex].sVdfVersion to stWebApplication.sVdfVersion
34385>>>>>>>>>>>                        
34385>>>>>>>>>>>                        If (ReadKeyData(oRegistryFunctions,HKEY_LOCAL_MACHINE,sWebAppRootKey,&stWebAppKeyData,False)) Begin
34387>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "Disable"            to stWebApplication.bDisable
34388>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "LogAccess"          to stWebApplication.bLogAccess
34389>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "LogFile"            to stWebApplication.sLogFile
34390>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "MaxLogEntries"      to stWebApplication.iMaxLogEntries
34391>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "MinPool"            to stWebApplication.iMinPool
34392>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "MaxPool"            to stWebApplication.iMaxPool
34393>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "OperationMode"      to stWebApplication.sOperationMode
34394>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "ProgramParameters"  to stWebApplication.sProgramParameters
34395>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "ProgramPath"        to sPath
34396>>>>>>>>>>>                            Move sPath to stWebApplication.sProgramPath
34397>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "PurgePoolInterval"  to stWebApplication.iPurgePoolInterval
34398>>>>>>>>>>>                            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "UseConnectorPool"   to stWebApplication.bUseConnectorPool
34399>>>>>>>>>>>
34399>>>>>>>>>>>                            Get PathToFolder of oFileFunctions sPath to sPath // C:\Samples\AJAX Order Entry\Programs\webapp.exe -> C:\VDF12\Samples\AJAX Order Entry\Programs
34400>>>>>>>>>>>                            Get PathToFolder of oFileFunctions sPath to sPath // C:\Samples\AJAX Order Entry\Programs -> C:\VDF12\Samples\AJAX Order Entry
34401>>>>>>>>>>>                            Get AppendPath of oFileFunctions sPath "Data" to sPath
34402>>>>>>>>>>>                            Move sPath to stWebApplication.sDataPath
34403>>>>>>>>>>>
34403>>>>>>>>>>>                        End
34403>>>>>>>>>>>>
34403>>>>>>>>>>>                        Move stWebApplication to gaWebApplications[SizeOfArray(gaWebApplications)]
34404>>>>>>>>>>>                    Loop
34405>>>>>>>>>>>>
34405>>>>>>>>>>>                End
34405>>>>>>>>>>>>
34405>>>>>>>>>>>            End_Procedure
34406>>>>>>>>>>>
34406>>>>>>>>>>>    Procedure RereadWebApplications
34409>>>>>>>>>>>        Integer iRuntimeIndex iRunTimeMax
34409>>>>>>>>>>>        String sWebAppRoot
34409>>>>>>>>>>>
34409>>>>>>>>>>>        Send _EnumerateRuntimes
34410>>>>>>>>>>>
34410>>>>>>>>>>>        Move (ResizeArray(gaWebApplications,0)) to gaWebApplications
34411>>>>>>>>>>>
34411>>>>>>>>>>>        Move (SizeOfArray(gaRuntimes)-1) to iRunTimeMax
34412>>>>>>>>>>>        For iRuntimeIndex from 0 to iRunTimeMax
34418>>>>>>>>>>>>
34418>>>>>>>>>>>            Send _EnumerateWebApplications iRuntimeIndex gaRuntimes[iRuntimeIndex]
34419>>>>>>>>>>>        Loop
34420>>>>>>>>>>>>
34420>>>>>>>>>>>        Move 0 to WindowIndex
34421>>>>>>>>>>>    End_Procedure
34422>>>>>>>>>>>
34422>>>>>>>>>>>    Function WebApplication Integer iWebAppIndex Returns tVdfWebApplication
34425>>>>>>>>>>>        String sWebAppRootKey sPath
34425>>>>>>>>>>>        tVdfWebApplication stWebApp
34425>>>>>>>>>>>        tVdfWebApplication stWebApp
34425>>>>>>>>>>>        tRegKeyData stWebAppKeyData
34425>>>>>>>>>>>        tRegKeyData stWebAppKeyData
34425>>>>>>>>>>>
34425>>>>>>>>>>>        Move gaWebApplications[iWebAppIndex].sRegistryKey to sWebAppRootKey
34426>>>>>>>>>>>        Move gaWebApplications[iWebAppIndex] to stWebApp
34427>>>>>>>>>>>
34427>>>>>>>>>>>        If (ReadKeyData(oRegistryFunctions,HKEY_LOCAL_MACHINE,sWebAppRootKey,&stWebAppKeyData,False)) Begin
34429>>>>>>>>>>>            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "Disable"            to stWebApp.bDisable
34430>>>>>>>>>>>            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "LogAccess"          to stWebApp.bLogAccess
34431>>>>>>>>>>>            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "LogFile"            to stWebApp.sLogFile
34432>>>>>>>>>>>            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "MaxLogEntries"      to stWebApp.iMaxLogEntries
34433>>>>>>>>>>>            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "MinPool"            to stWebApp.iMinPool
34434>>>>>>>>>>>            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "MaxPool"            to stWebApp.iMaxPool
34435>>>>>>>>>>>            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "OperationMode"      to stWebApp.sOperationMode
34436>>>>>>>>>>>            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "ProgramParameters"  to stWebApp.sProgramParameters
34437>>>>>>>>>>>            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "ProgramPath"        to sPath
34438>>>>>>>>>>>            Move sPath to stWebApp.sProgramPath
34439>>>>>>>>>>>            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "PurgePoolInterval"  to stWebApp.iPurgePoolInterval
34440>>>>>>>>>>>            Get NamedRegValue of oRegistryFunctions stWebAppKeyData "UseConnectorPool"   to stWebApp.bUseConnectorPool
34441>>>>>>>>>>>
34441>>>>>>>>>>>            Get PathToFolder of oFileFunctions sPath to sPath // C:\Samples\AJAX Order Entry\Programs\webapp.exe -> C:\VDF12\Samples\AJAX Order Entry\Programs
34442>>>>>>>>>>>            Get PathToFolder of oFileFunctions sPath to sPath // C:\Samples\AJAX Order Entry\Programs -> C:\VDF12\Samples\AJAX Order Entry
34443>>>>>>>>>>>            Get AppendPath of oFileFunctions sPath "Data" to sPath
34444>>>>>>>>>>>            Move sPath to stWebApp.sDataPath
34445>>>>>>>>>>>
34445>>>>>>>>>>>        End
34445>>>>>>>>>>>>
34445>>>>>>>>>>>        Else Begin
34446>>>>>>>>>>>            Error 832 "Could not read WebApp registry"
34447>>>>>>>>>>>>
34447>>>>>>>>>>>        End
34447>>>>>>>>>>>>
34447>>>>>>>>>>>        Function_Return stWebApp
34448>>>>>>>>>>>    End_Function
34449>>>>>>>>>>>
34449>>>>>>>>>>>    Procedure RereadWebApplication Integer iWebAppIndex
34452>>>>>>>>>>>        get WebApplication iWebAppIndex to gaWebApplications[iWebAppIndex]
34453>>>>>>>>>>>    End_Procedure
34454>>>>>>>>>>>
34454>>>>>>>>>>>    Procedure Set WebAppRunState Integer iWebAppIndex Boolean bRunState
34457>>>>>>>>>>>        Integer iRuntimeIndex
34457>>>>>>>>>>>        String sRegKey
34457>>>>>>>>>>>        If (iWebAppIndex<SizeOfArray(gaWebApplications)) Begin
34459>>>>>>>>>>>            Move gaWebApplications[iWebAppIndex].iRuntimeIndex to iRuntimeIndex
34460>>>>>>>>>>>            Move gaWebApplications[iWebAppIndex].sRegistryKey to sRegKey
34461>>>>>>>>>>>            Send WriteRegValue of oRegistryFunctions HKEY_LOCAL_MACHINE sRegKey "Disable" (If(bRunState,0,1)) rdDword
34462>>>>>>>>>>>        End
34462>>>>>>>>>>>>
34462>>>>>>>>>>>        Else Begin
34463>>>>>>>>>>>            Error 801 "Webapp index out of range"
34464>>>>>>>>>>>>
34464>>>>>>>>>>>        End
34464>>>>>>>>>>>>
34464>>>>>>>>>>>    End_Procedure
34465>>>>>>>>>>>    
34465>>>>>>>>>>>    Function WebAppRunState Integer iWebAppIndex Returns Boolean
34468>>>>>>>>>>>        tVdfWebApplication stWebApp
34468>>>>>>>>>>>        tVdfWebApplication stWebApp
34468>>>>>>>>>>>        Get WebApplication iWebAppIndex to stWebApp
34469>>>>>>>>>>>        Function_Return (not(stWebApp.bDisable))
34470>>>>>>>>>>>    End_Function
34471>>>>>>>>>>>    
34471>>>>>>>>>>>    //> Locate a webapplication in the global array gaWebApplications by the name (incl.
34471>>>>>>>>>>>    //> the full path of the applcation (F.x. "c:\apps\wasp2\programs\webapp.exe")
34471>>>>>>>>>>>    Function WebApplicationIndex String sProgramPath Returns Integer
34474>>>>>>>>>>>        Integer iIndex iMax
34474>>>>>>>>>>>
34474>>>>>>>>>>>        Move (Lowercase(sProgramPath)) to sProgramPath
34475>>>>>>>>>>>        If (Right(sProgramPath,4)<>".exe") Begin
34477>>>>>>>>>>>            Move (sProgramPath+".exe.") to sProgramPath
34478>>>>>>>>>>>        End
34478>>>>>>>>>>>>
34478>>>>>>>>>>>        Move (SizeOfArray(gaWebApplications)-1) to iMax
34479>>>>>>>>>>>        For iIndex from 0 to iMax
34485>>>>>>>>>>>>
34485>>>>>>>>>>>            If (sProgramPath=Lowercase(gaWebApplications[iIndex].sProgramPath)) Begin
34487>>>>>>>>>>>                Function_Return iIndex
34488>>>>>>>>>>>            End
34488>>>>>>>>>>>>
34488>>>>>>>>>>>        Loop
34489>>>>>>>>>>>>
34489>>>>>>>>>>>        Function_Return -1 // not found
34490>>>>>>>>>>>    End_Function
34491>>>>>>>>>>>    
34491>>>>>>>>>>>    // Index of the webapplication that we are (if we are a webapplication)
34491>>>>>>>>>>>    Function CurrentWebApplicationIndex Returns Integer
34494>>>>>>>>>>>        String sProgramPath
34494>>>>>>>>>>>        Get _psOriginalProgramPath to sProgramPath
34495>>>>>>>>>>>        Function_Return (WebApplicationIndex(Self,sProgramPath))
34496>>>>>>>>>>>    End_Function
34497>>>>>>>>>>>    
34497>>>>>>>>>>>    Function WebApplicationNameAndVersionToIndex String sName String sVdfVer Returns Integer
34500>>>>>>>>>>>        Integer iIndex iMax
34500>>>>>>>>>>>        Move (Lowercase(Trim(sName))) to sName
34501>>>>>>>>>>>        Move (Lowercase(Trim(sVdfVer))) to sVdfVer
34502>>>>>>>>>>>        Move (SizeOfArray(gaWebApplications)-1) to iMax
34503>>>>>>>>>>>        For iIndex from 0 to iMax
34509>>>>>>>>>>>>
34509>>>>>>>>>>>            If (sName=Lowercase(gaWebApplications[iIndex].sName) and sVdfVer=Lowercase(gaWebApplications[iIndex].sVdfVersion)) Begin
34511>>>>>>>>>>>                Function_Return iIndex
34512>>>>>>>>>>>            End
34512>>>>>>>>>>>>
34512>>>>>>>>>>>        Loop
34513>>>>>>>>>>>>
34513>>>>>>>>>>>        Function_Return -1
34514>>>>>>>>>>>    End_Function
34515>>>>>>>>>>>    
34515>>>>>>>>>>>    Function CurrentVdfVer Returns String
34518>>>>>>>>>>>        String sMajor sMinor
34518>>>>>>>>>>>        Move (String(FMAC_VERSION)) to sMajor
34519>>>>>>>>>>>        Move (String(FMAC_REVISION)) to sMinor
34520>>>>>>>>>>>        Function_Return (sMajor+"."+sMinor)
34521>>>>>>>>>>>    End_Function
34522>>>>>>>>>>>    
34522>>>>>>>>>>>    Function VdfVerStringToNumber String sVdfVer Returns Number
34525>>>>>>>>>>>        Integer iPos iMajor iMinor
34525>>>>>>>>>>>        Move (Pos(".",sVdfVer)) to iPos
34526>>>>>>>>>>>        Move (Left(sVdfVer,iPos-1)) to iMajor
34527>>>>>>>>>>>        Move (Right(sVdfVer,1)) to iMinor
34528>>>>>>>>>>>        Function_Return (Number(iMinor/10.0+iMajor))
34529>>>>>>>>>>>    End_Function
34530>>>>>>>>>>>    
34530>>>>>>>>>>>    Procedure _Initialize
34533>>>>>>>>>>>        String sFolder sModule sProgramPath
34533>>>>>>>>>>>        
34533>>>>>>>>>>>        Send RereadWebApplications // (and enumerate runtime)
34534>>>>>>>>>>>        Get VdfFolderPath of oFileFunctions VDF_PROGRAM to sFolder
34535>>>>>>>>>>>        Get Module_Name to sModule
34536>>>>>>>>>>>        Get AppendPath of oFileFunctions sFolder sModule to sProgramPath
34537>>>>>>>>>>>        Set _psOriginalProgramPath to sProgramPath
34538>>>>>>>>>>>    End_Procedure
34539>>>>>>>>>>>    
34539>>>>>>>>>>>    Send _Initialize
34540>>>>>>>>>>>
34540>>>>>>>>>>>// VDF License functions
34540>>>>>>>>>>>    
34540>>>>>>>>>>>    Function LicenseName Returns String
34543>>>>>>>>>>>        Integer iNumber
34543>>>>>>>>>>>        String sName
34543>>>>>>>>>>>        Registration sName iNumber
34544>>>>>>>>>>>>
34544>>>>>>>>>>>        Function_Return sName
34545>>>>>>>>>>>    End_Function
34546>>>>>>>>>>>    Function LicenseNumber Returns Integer
34549>>>>>>>>>>>        Integer iLicenseNumber
34549>>>>>>>>>>>        String sName
34549>>>>>>>>>>>        Registration sName iLicenseNumber
34550>>>>>>>>>>>>
34550>>>>>>>>>>>        Function_Return iLicenseNumber
34551>>>>>>>>>>>    End_Function
34552>>>>>>>>>>>    Function LicenseMaxUsers Returns Integer
34555>>>>>>>>>>>        Integer iMaxUsers
34555>>>>>>>>>>>        Get_Licensed_Max_Users to iMaxUsers
34556>>>>>>>>>>>        Function_Return iMaxUsers
34557>>>>>>>>>>>    End_Function
34558>>>>>>>>>>>    Function LicenseCurrentUsers Returns Integer
34561>>>>>>>>>>>        Integer iUserCount
34561>>>>>>>>>>>        Get_Current_User_Count to iUserCount
34562>>>>>>>>>>>        Function_Return iUserCount
34563>>>>>>>>>>>    End_Function
34564>>>>>>>>>>>    Function IsDebuggerActive Returns Boolean
34567>>>>>>>>>>>        Function_Return (IsDebuggerPresent())
34568>>>>>>>>>>>    End_Function
34569>>>>>>>>>>>End_Object // oVdfRuntimeFunctions
34570>>>>>>>>>
34570>>>>>>>>>Global_Variable Integer oIndexFunctions
34570>>>>>>>>>Object _oIndexFunctions is a cObject
34572>>>>>>>>>    Move Self to oIndexFunctions
34573>>>>>>>>>    
34573>>>>>>>>>    Property Integer _DeadlySecretSwitch False
34575>>>>>>>>>    Property Integer _piPrimKeyTable
34577>>>>>>>>>    
34577>>>>>>>>>    Procedure FlushReadCache
34580>>>>>>>>>        Send Reset of oOverlapColumnFunctions
34581>>>>>>>>>    End_Procedure
34582>>>>>>>>>    
34582>>>>>>>>>    Function IsIndexUnique Integer iTable Integer iIndex Returns Boolean
34585>>>>>>>>>        Boolean bIsUnique
34585>>>>>>>>>        Integer iMax
34585>>>>>>>>>        tocIndex strIndex
34585>>>>>>>>>        tocIndex strIndex
34585>>>>>>>>>        Get IndexDefinition of oOverlapColumnFunctions iTable iIndex to strIndex
34586>>>>>>>>>        Move (SizeOfArray(strIndex.aSegments)-1) to iMax
34587>>>>>>>>>        If (iMax>=0) Begin
34589>>>>>>>>>            Move (strIndex.aSegments[iMax].iColumn<>0) to bIsUnique
34590>>>>>>>>>        End
34590>>>>>>>>>>
34590>>>>>>>>>        Else Begin
34591>>>>>>>>>            Move False to bIsUnique
34592>>>>>>>>>        End
34592>>>>>>>>>>
34592>>>>>>>>>        Function_Return bIsUnique 
34593>>>>>>>>>    End_Function
34594>>>>>>>>>    
34594>>>>>>>>>    Function IndexDefinition Integer iTable Integer iIndex Returns tOCIndex
34597>>>>>>>>>        Function_Return (IndexDefinition(oOverlapColumnFunctions,iTable,iIndex))
34598>>>>>>>>>    End_Function
34599>>>>>>>>>    
34599>>>>>>>>>    Function IndexDefinitionColumnNumbers Integer iTable Integer iIndex Returns Integer[]
34602>>>>>>>>>        Function_Return (IndexDefinitionColumnNumbers(oOverlapColumnFunctions,iTable,iIndex))
34603>>>>>>>>>    End_Function
34604>>>>>>>>>    
34604>>>>>>>>>    Function IsIndexOnline Integer iTable Integer iIndex Returns Boolean
34607>>>>>>>>>        tocIndex strIndex
34607>>>>>>>>>        tocIndex strIndex
34607>>>>>>>>>        Get IndexDefinition of oOverlapColumnFunctions iTable iIndex to strIndex
34608>>>>>>>>>        Function_Return strIndex.bOnline
34609>>>>>>>>>    End_Function
34610>>>>>>>>>
34610>>>>>>>>>    //> iSelectCode: 0=All 1:Unique 2:Off-line 3:On-line
34610>>>>>>>>>    Function IndexSet Integer iTable Integer iSelectCode Returns Integer[]
34613>>>>>>>>>        Boolean bOnline
34613>>>>>>>>>        Integer iIndex 
34613>>>>>>>>>        Integer[] aIndices
34614>>>>>>>>>        tocIndex strIndex
34614>>>>>>>>>        tocIndex strIndex
34614>>>>>>>>>        For iIndex from 1 to 15
34620>>>>>>>>>>
34620>>>>>>>>>            Get IndexDefinition iTable iIndex to strIndex
34621>>>>>>>>>            If (SizeOfArray(strIndex.aSegments)>0) Begin
34623>>>>>>>>>                If (iSelectCode=0) Begin // All
34625>>>>>>>>>                    Move iIndex to aIndices[SizeOfArray(aIndices)]
34626>>>>>>>>>                End
34626>>>>>>>>>>
34626>>>>>>>>>                If (iSelectCode=1) Begin // Unique
34628>>>>>>>>>                    If (IsIndexUnique(Self,iTable,iIndex)) Begin
34630>>>>>>>>>                        Move iIndex to aIndices[SizeOfArray(aIndices)]
34631>>>>>>>>>                    End
34631>>>>>>>>>>
34631>>>>>>>>>                End
34631>>>>>>>>>>
34631>>>>>>>>>                If (iSelectCode=2) Begin // Off-line
34633>>>>>>>>>                    Get IsIndexOnline iTable iIndex to bOnline
34634>>>>>>>>>                    If (not(bOnline)) Begin
34636>>>>>>>>>                        Move iIndex to aIndices[SizeOfArray(aIndices)]
34637>>>>>>>>>                    End
34637>>>>>>>>>>
34637>>>>>>>>>                End
34637>>>>>>>>>>
34637>>>>>>>>>                If (iSelectCode=3) Begin // On-line
34639>>>>>>>>>                    Get IsIndexOnline iTable iIndex to bOnline
34640>>>>>>>>>                    If (bOnline) Begin
34642>>>>>>>>>                        Move iIndex to aIndices[SizeOfArray(aIndices)]
34643>>>>>>>>>                    End
34643>>>>>>>>>>
34643>>>>>>>>>                End
34643>>>>>>>>>>
34643>>>>>>>>>            End
34643>>>>>>>>>>
34643>>>>>>>>>        Loop
34644>>>>>>>>>>
34644>>>>>>>>>        Function_Return aIndices
34645>>>>>>>>>    End_Function
34646>>>>>>>>>    
34646>>>>>>>>>    Function FirstUniqueIndex Integer iTable Returns Integer
34649>>>>>>>>>        Integer iIndex iRecnumTable
34649>>>>>>>>>        tocIndex strIndex
34649>>>>>>>>>        tocIndex strIndex
34649>>>>>>>>>        For iIndex from 1 to 15
34655>>>>>>>>>>
34655>>>>>>>>>            Get IndexDefinition iTable iIndex to strIndex
34656>>>>>>>>>            If (SizeOfArray(strIndex.aSegments)>0) Begin
34658>>>>>>>>>                If (IsIndexUnique(Self,iTable,iIndex)) Begin
34660>>>>>>>>>                    Function_Return iIndex
34661>>>>>>>>>                End
34661>>>>>>>>>>
34661>>>>>>>>>            End
34661>>>>>>>>>>
34661>>>>>>>>>        Loop
34662>>>>>>>>>>
34662>>>>>>>>>        Get_Attribute DF_FILE_RECNUM_TABLE of iTable to iRecnumTable
34665>>>>>>>>>        If (iRecnumTable<>0) Begin
34667>>>>>>>>>            Function_Return 0 // Use Recnum for gods sake.
34668>>>>>>>>>        End
34668>>>>>>>>>>
34668>>>>>>>>>        Function_Return -1 // Sorry, no luck
34669>>>>>>>>>    End_Function
34670>>>>>>>>>    
34670>>>>>>>>>    Function ShortestUniqueIndex Integer iTable Returns Integer
34673>>>>>>>>>        tocTable strTable
34673>>>>>>>>>        tocTable strTable
34673>>>>>>>>>        Get TableDefinition of _oOverlapColumnFunctions iTable to strTable
34674>>>>>>>>>        Function_Return strTable.iShortestUniqueIndex
34675>>>>>>>>>    End_Function
34676>>>>>>>>>
34676>>>>>>>>>    Function KeyStateColumns Integer iTable Returns Integer[]
34679>>>>>>>>>        Integer hDDO iColumn
34679>>>>>>>>>        String sKeyStates
34679>>>>>>>>>        Integer[] aColumns
34680>>>>>>>>>        Get DDO_Object of oDataDictionaryFunctions iTable to hDDO
34681>>>>>>>>>        If (hDDO>0) Begin
34683>>>>>>>>>            Get Key_Fields of hDDO to sKeyStates
34684>>>>>>>>>            Repeat
34684>>>>>>>>>>
34684>>>>>>>>>                Move (Pos("X",sKeyStates)) to iColumn
34685>>>>>>>>>                If (iColumn>0) Begin
34687>>>>>>>>>                    Move iColumn to aColumns[SizeOfArray(aColumns)]
34688>>>>>>>>>                    Move (Overstrike(" ", sKeyStates, iColumn)) to sKeyStates
34689>>>>>>>>>                End
34689>>>>>>>>>>
34689>>>>>>>>>            Until (iColumn=0)
34691>>>>>>>>>
34691>>>>>>>>>        End
34691>>>>>>>>>>
34691>>>>>>>>>        Function_Return aColumns
34692>>>>>>>>>    End_Function
34693>>>>>>>>>    
34693>>>>>>>>>    // Calling this function only has meaning if all iTable members of
34693>>>>>>>>>    // aSegments AND aFields are identical. The function just assumes
34693>>>>>>>>>    // this is the case, but does not check for it.
34693>>>>>>>>>//  Function IndexSegmentsMatch tTableField[] aSegments tTableField[] aFields Returns Integer
34693>>>>>>>>>    Function _IndexSegmentMatchLength Integer iTable Integer iIndex Integer[] aColumns Returns Integer // returns the number of most-significant index-segments that may be seeded if we have aColumns at our disposal.
34696>>>>>>>>>        Integer iSegmentIndex iSegmentMax
34696>>>>>>>>>        Integer iColumnIndex iColumnMax
34696>>>>>>>>>        Integer iMatchLength
34696>>>>>>>>>        Integer[] aSegments
34697>>>>>>>>>        
34697>>>>>>>>>        Get IndexDefinitionColumnNumbers iTable iIndex to aSegments
34698>>>>>>>>>        Move (SizeOfArray(aSegments)-1) to iSegmentMax
34699>>>>>>>>>        Move (SizeOfArray(aColumns)-1) to iColumnMax
34700>>>>>>>>>
34700>>>>>>>>>        For iSegmentIndex from 0 to iSegmentMax
34706>>>>>>>>>>
34706>>>>>>>>>            For iColumnIndex from 0 to iColumnMax
34712>>>>>>>>>>
34712>>>>>>>>>                If (aSegments[iSegmentIndex]=aColumns[iColumnIndex]) Begin
34714>>>>>>>>>                    Move -1 to aSegments[iSegmentIndex] // Mark as matched
34715>>>>>>>>>                    Move iColumnMax to iColumnIndex // Break the loop.
34716>>>>>>>>>                End
34716>>>>>>>>>>
34716>>>>>>>>>            Loop
34717>>>>>>>>>>
34717>>>>>>>>>        Loop
34718>>>>>>>>>>
34718>>>>>>>>>
34718>>>>>>>>>        Move 0 to iMatchLength
34719>>>>>>>>>
34719>>>>>>>>>        For iSegmentIndex from 0 to iSegmentMax
34725>>>>>>>>>>
34725>>>>>>>>>            If (aSegments[iSegmentIndex]>-1) Begin
34727>>>>>>>>>                Function_Return iMatchLength
34728>>>>>>>>>            End
34728>>>>>>>>>>
34728>>>>>>>>>            Increment iMatchLength
34729>>>>>>>>>        Loop
34730>>>>>>>>>>
34730>>>>>>>>>
34730>>>>>>>>>        Function_Return iMatchLength // All segments matched
34731>>>>>>>>>    End_Function
34732>>>>>>>>>    
34732>>>>>>>>>    Function IndexFullySpecified Integer iTable Integer iIndex Integer[] aColumns Returns Boolean
34735>>>>>>>>>        Integer iMatchLength
34735>>>>>>>>>        Integer[] aSegments
34736>>>>>>>>>        Get IndexDefinitionColumnNumbers iTable iIndex to aSegments
34737>>>>>>>>>        Get _IndexSegmentMatchLength iTable iIndex aColumns to iMatchLength
34738>>>>>>>>>        Function_Return (SizeOfArray(aSegments)=iMatchLength)
34739>>>>>>>>>    End_Function
34740>>>>>>>>>    
34740>>>>>>>>>//    Function IndexSegmentMatchLengthX Integer iTable Integer iIndex tocIndexSegment[] aAvailableSegments Returns Integer 
34740>>>>>>>>>//        Integer iItem iItemMax
34740>>>>>>>>>//        tocIndexSegment[] aIndexSegments
34740>>>>>>>>>//        Get IndexDefinition iTable iIndex to aIndexSegments
34740>>>>>>>>>//        Move (SizeOfArray(aIndexSegments)-1) to iItemMax
34740>>>>>>>>>//        For iItem from 0 to iItemMax
34740>>>>>>>>>//        Loop
34740>>>>>>>>>//    End_Function
34740>>>>>>>>>
34740>>>>>>>>>    Function _CompareIndicesByLength Integer iIndex1 Integer iIndex2 Returns Integer
34743>>>>>>>>>        Integer iTable iLen1 iLen2
34743>>>>>>>>>        Get _piPrimKeyTable to iTable
34744>>>>>>>>>        Get_Attribute DF_INDEX_KEY_LENGTH of iTable iIndex1 to iLen1
34747>>>>>>>>>        Get_Attribute DF_INDEX_KEY_LENGTH of iTable iIndex2 to iLen2
34750>>>>>>>>>        If (iLen1<iLen2) Function_Return (LT)
34753>>>>>>>>>        If (iLen1>iLen2) Function_Return (GT)
34756>>>>>>>>>        // If two indices have the length, we prefer the one with the lowest number
34756>>>>>>>>>        If (iIndex1<iIndex2) Function_Return (LT)
34759>>>>>>>>>        If (iIndex1>iIndex2) Function_Return (GT)
34762>>>>>>>>>        Function_Return (EQ)
34763>>>>>>>>>    End_Function
34764>>>>>>>>>    
34764>>>>>>>>>    Function PrimaryKey Integer iTable Returns Integer
34767>>>>>>>>>        Integer iIndex hDDO iMatchLength iItem iMax
34767>>>>>>>>>        Integer[] aKeyColumns aUniqueIndices aIndexCandidates
34770>>>>>>>>>        Get_Attribute DF_FILE_PRIMARY_INDEX of iTable to iIndex
34773>>>>>>>>>        If (iIndex<=0) Begin // If DF_FILE_PRIMARY_INDEX wasn't set we'll try to see what can be deduced from Key_Field_State settings
34775>>>>>>>>>            // OK Primary key wasn't set. Therefore we see if we can get hold of a DD object.
34775>>>>>>>>>            Get KeyStateColumns iTable to aKeyColumns
34776>>>>>>>>>            Get IndexSet iTable 1 to aUniqueIndices
34777>>>>>>>>>            Move (SizeOfArray(aUniqueIndices)-1) to iMax
34778>>>>>>>>>            For iItem from 0 to iMax
34784>>>>>>>>>>
34784>>>>>>>>>                If (IndexFullySpecified(Self,iTable,aUniqueIndices[iItem],aKeyColumns)) Begin
34786>>>>>>>>>                    Function_Return aUniqueIndices[iItem]
34787>>>>>>>>>                End
34787>>>>>>>>>>
34787>>>>>>>>>            Loop
34788>>>>>>>>>>
34788>>>>>>>>>            // If we still haven't found an index we'll just use the unique index with whe shortest key:
34788>>>>>>>>>            If (iMax>=0) Begin
34790>>>>>>>>>                Set _piPrimKeyTable to iTable
34791>>>>>>>>>                Move (SortArray(aUniqueIndices,Self,GET__CompareIndicesByLength)) to aUniqueIndices
34792>>>>>>>>>                Function_Return aUniqueIndices[0]
34793>>>>>>>>>            End
34793>>>>>>>>>>
34793>>>>>>>>>        End
34793>>>>>>>>>>
34793>>>>>>>>>        Function_Return iIndex
34794>>>>>>>>>    End_Function
34795>>>>>>>>>    
34795>>>>>>>>>    //> Given that I have the value of the columns listed in aColumns, give me an index
34795>>>>>>>>>    //> to find EQ by in table iTable.
34795>>>>>>>>>    Function FindEQIndex Integer iTable Integer[] aColumns Returns Integer
34798>>>>>>>>>        Integer iIndex
34798>>>>>>>>>        Integer iIndexItem iIndexMax
34798>>>>>>>>>        Integer[] aIndices
34799>>>>>>>>>        Get IndexSet iTable 1 to aIndices
34800>>>>>>>>>        Move (SizeOfArray(aIndices)-1) to iIndexMax
34801>>>>>>>>>        For iIndexItem from 0 to iIndexMax
34807>>>>>>>>>>
34807>>>>>>>>>            Move aIndices[iIndexItem] to iIndex
34808>>>>>>>>>            If (IndexFullySpecified(Self,iTable,iIndex,aColumns)) Begin
34810>>>>>>>>>                Function_Return iIndex
34811>>>>>>>>>            End
34811>>>>>>>>>>
34811>>>>>>>>>        Loop
34812>>>>>>>>>>
34812>>>>>>>>>        Function_Return -1 // No index found
34813>>>>>>>>>    End_Function
34814>>>>>>>>>    
34814>>>>>>>>>    //> iTable must be open.
34814>>>>>>>>>    Function RecordIdentifierColumns Integer iTable Returns Integer[]
34817>>>>>>>>>        Integer iColumn iIndex
34817>>>>>>>>>        Integer[] aColumns
34818>>>>>>>>>
34818>>>>>>>>>        // First check if table has a DF_FILE_RECORD_IDENTITY column set for it.
34818>>>>>>>>>        Get_Attribute DF_FILE_RECORD_IDENTITY of iTable to iColumn
34821>>>>>>>>>        If (iColumn<>0) Begin // If it does, we'll go with that
34823>>>>>>>>>            Move iColumn to aColumns[0]
34824>>>>>>>>>        End
34824>>>>>>>>>>
34824>>>>>>>>>        Else Begin
34825>>>>>>>>>            // Then see if the table has a primary index.
34825>>>>>>>>>            Get_Attribute DF_FILE_PRIMARY_INDEX of iTable to iIndex
34828>>>>>>>>>            If (iIndex<>0) Begin // If it does, we'll go with that
34830>>>>>>>>>                Get IndexDefinitionColumnNumbers iTable iIndex to aColumns
34831>>>>>>>>>            End
34831>>>>>>>>>>
34831>>>>>>>>>            Else Begin
34832>>>>>>>>>                // Finally see if we can find an index ourselves.
34832>>>>>>>>>                Get ShortestUniqueIndex iTable to iIndex
34833>>>>>>>>>                If (iIndex>=0) Begin
34835>>>>>>>>>                    Get IndexDefinitionColumnNumbers iTable iIndex to aColumns
34836>>>>>>>>>                End
34836>>>>>>>>>>
34836>>>>>>>>>            End
34836>>>>>>>>>>
34836>>>>>>>>>        End
34836>>>>>>>>>>
34836>>>>>>>>>        Function_Return aColumns
34837>>>>>>>>>    End_Function
34838>>>>>>>>>    
34838>>>>>>>>>    Function ColumnSortValueFormat Integer iTable Integer iColumn String sValue Returns String
34841>>>>>>>>>        Integer iType iLen iPrecision 
34841>>>>>>>>>        Number nValue
34841>>>>>>>>>        Date dValue
34841>>>>>>>>>        Get_Attribute DF_FIELD_TYPE of iTable iColumn to iType
34844>>>>>>>>>        If (iType=DF_DATE) Begin
34846>>>>>>>>>            Move sValue to dValue
34847>>>>>>>>>            If (Integer(dValue)<>0) Begin
34849>>>>>>>>>                Get DateToString of oDateFunctions dValue DF_DATE_MILITARY True "" to sValue
34850>>>>>>>>>            End
34850>>>>>>>>>>
34850>>>>>>>>>            Else Begin
34851>>>>>>>>>                If (_DeadlySecretSwitch(Self)) Begin // Switched is used by 5-levels-out function IndexSortValueFileNameFormat. Makes sense?
34853>>>>>>>>>                    Move "00000000" to sValue // Null date
34854>>>>>>>>>                End
34854>>>>>>>>>>
34854>>>>>>>>>            End
34854>>>>>>>>>>
34854>>>>>>>>>        End 
34854>>>>>>>>>>
34854>>>>>>>>>        Else If (iType=DF_BCD) Begin
34857>>>>>>>>>            Get_Attribute DF_FIELD_LENGTH of iTable iColumn to iLen
34860>>>>>>>>>            Get_Attribute DF_FIELD_PRECISION of iTable iColumn to iPrecision
34863>>>>>>>>>            Move sValue to nValue
34864>>>>>>>>>            If (iPrecision<>0) Begin
34866>>>>>>>>>                Increment iLen // Make room for comma
34867>>>>>>>>>            End
34867>>>>>>>>>>
34867>>>>>>>>>            get NumberToStringR of oStringFunctions nValue iPrecision iLen to sValue
34868>>>>>>>>>            Move (Replaces(" ",sValue,"0")) to sValue // Zerofill
34869>>>>>>>>>        End
34869>>>>>>>>>>
34869>>>>>>>>>        Else If (iType=DF_DATETIME) Begin
34872>>>>>>>>>            // This will bite someday, it should be converted to millitary format (or maybe it is?)
34872>>>>>>>>>        End
34872>>>>>>>>>>
34872>>>>>>>>>        Else Begin
34873>>>>>>>>>            If (_DeadlySecretSwitch(Self)) Begin // Switched is used by 5-levels-out function IndexSortValueFileNameFormat. Makes sense?
34875>>>>>>>>>                Get StringToHex of oStringFunctions sValue to sValue
34876>>>>>>>>>            End
34876>>>>>>>>>>
34876>>>>>>>>>        End
34876>>>>>>>>>>
34876>>>>>>>>>        Function_Return sValue
34877>>>>>>>>>    End_Function
34878>>>>>>>>>    
34878>>>>>>>>>    //> The function returns a column value formattet according to its definition (i.e. a 8.4
34878>>>>>>>>>    //> numeric field is returned right aligned in a string 13 characters long while the value
34878>>>>>>>>>    //> of an ASCII field is returned as is.
34878>>>>>>>>>    Function ColumnSortValue Integer iTable Integer iColumn Returns String
34881>>>>>>>>>        String sValue
34881>>>>>>>>>        Get_Field_Value iTable iColumn to sValue
34884>>>>>>>>>        Function_Return (ColumnSortValueFormat(Self,iTable,iColumn,sValue))
34885>>>>>>>>>    End_Function
34886>>>>>>>>>    
34886>>>>>>>>>    //> The function returns the 
34886>>>>>>>>>    Function IndexSegmentSortValue Integer iTable tocIndexSegment stSegment Returns String 
34889>>>>>>>>>        String sValue
34889>>>>>>>>>        Get ColumnSortValue iTable stSegment.iColumn to sValue
34890>>>>>>>>>        If (stSegment.bUppercase) Begin
34892>>>>>>>>>            Move (Uppercase(sValue)) to sValue
34893>>>>>>>>>        End
34893>>>>>>>>>>
34893>>>>>>>>>        If (stSegment.bDescending) Begin
34895>>>>>>>>>            Get NegateString of oStringFunctions sValue to sValue
34896>>>>>>>>>        End
34896>>>>>>>>>>
34896>>>>>>>>>        Function_Return sValue
34897>>>>>>>>>    End_Function
34898>>>>>>>>>    
34898>>>>>>>>>    Function IndexSortValue Integer iTable Integer iIndex Returns String
34901>>>>>>>>>        Integer iSegment iSegments
34901>>>>>>>>>        String sValue
34901>>>>>>>>>        tocIndex strIndex
34901>>>>>>>>>        tocIndex strIndex
34901>>>>>>>>>        Get IndexDefinition iTable iIndex to strIndex
34902>>>>>>>>>        Move (SizeOfArray(strIndex.aSegments)-1) to iSegments
34903>>>>>>>>>        For iSegment from 0 to iSegments
34909>>>>>>>>>>
34909>>>>>>>>>            Move (sValue+IndexSegmentSortValue(Self,iTable,strIndex.aSegments[iSegment])) to sValue
34910>>>>>>>>>        Loop
34911>>>>>>>>>>
34911>>>>>>>>>        Function_Return sValue
34912>>>>>>>>>    End_Function
34913>>>>>>>>>
34913>>>>>>>>>    //> This functions performs the same as function IndexSortValue above, except that the
34913>>>>>>>>>    //> return value will be accepted by the OS as a valid component of a file name.
34913>>>>>>>>>    Function IndexSortValueFileNameFormat Integer iTable Integer iIndex Returns String
34916>>>>>>>>>        String sValue
34916>>>>>>>>>        Set _DeadlySecretSwitch to True
34917>>>>>>>>>        Get IndexSortValue iTable iIndex to sValue
34918>>>>>>>>>        Set _DeadlySecretSwitch to False
34919>>>>>>>>>        Function_Return sValue
34920>>>>>>>>>    End_Function
34921>>>>>>>>>    
34921>>>>>>>>>    
34921>>>>>>>>>    Function IndexValue Integer iTable Integer iIndex String sSep Returns String
34924>>>>>>>>>        Integer iSegment iSegments
34924>>>>>>>>>        String sValue sSegmentValue
34924>>>>>>>>>        tocIndex strIndex
34924>>>>>>>>>        tocIndex strIndex
34924>>>>>>>>>        Get IndexDefinition iTable iIndex to strIndex
34925>>>>>>>>>        Move (SizeOfArray(strIndex.aSegments)-1) to iSegments
34926>>>>>>>>>        For iSegment from 0 to iSegments
34932>>>>>>>>>>
34932>>>>>>>>>            Get ColumnSortValue iTable strIndex.aSegments[iSegment].iColumn to sSegmentValue
34933>>>>>>>>>            If (iSegment<>0) Begin
34935>>>>>>>>>                Move (sValue+sSep) to sValue
34936>>>>>>>>>            End
34936>>>>>>>>>>
34936>>>>>>>>>            Move (sValue+sSegmentValue) to sValue
34937>>>>>>>>>        Loop
34938>>>>>>>>>>
34938>>>>>>>>>        Function_Return sValue
34939>>>>>>>>>    End_Function
34940>>>>>>>>>    
34940>>>>>>>>>    Function IndexSegmentValueArray Integer iTable Integer iIndex Returns String[]
34943>>>>>>>>>        Integer iSegment iSegments
34943>>>>>>>>>        String sSegmentValue sValue
34943>>>>>>>>>        String[] aValues
34944>>>>>>>>>        tocIndex strIndex
34944>>>>>>>>>        tocIndex strIndex
34944>>>>>>>>>        Get IndexDefinition iTable iIndex to strIndex
34945>>>>>>>>>        Move (SizeOfArray(strIndex.aSegments)-1) to iSegments
34946>>>>>>>>>        For iSegment from 0 to iSegments
34952>>>>>>>>>>
34952>>>>>>>>>            Get_Field_Value iTable strIndex.aSegments[iSegment].iColumn to sValue
34955>>>>>>>>>            Move sValue to aValues[SizeOfArray(aValues)]
34956>>>>>>>>>        Loop
34957>>>>>>>>>>
34957>>>>>>>>>        Function_Return aValues
34958>>>>>>>>>    End_Function
34959>>>>>>>>>    
34959>>>>>>>>>    Function FindRecordByValueArray Integer iTable Integer iIndex String[] aValues Returns Boolean
34962>>>>>>>>>        Integer iSegment iSegments
34962>>>>>>>>>        String sSegmentValue sValue
34962>>>>>>>>>        tocIndex strIndex
34962>>>>>>>>>        tocIndex strIndex
34962>>>>>>>>>        Clear iTable
34963>>>>>>>>>        Get IndexDefinition iTable iIndex to strIndex
34964>>>>>>>>>        Move (SizeOfArray(strIndex.aSegments)-1) to iSegments
34965>>>>>>>>>        For iSegment from 0 to iSegments
34971>>>>>>>>>>
34971>>>>>>>>>            Set_Field_Value iTable strIndex.aSegments[iSegment].iColumn to aValues[iSegment]
34974>>>>>>>>>        Loop
34975>>>>>>>>>>
34975>>>>>>>>>        Vfind iTable iIndex EQ
34977>>>>>>>>>        Function_Return (Found)
34978>>>>>>>>>    End_Function
34979>>>>>>>>>    
34979>>>>>>>>>    // This function does the same as function IndexSortValue above, except that it gets it's
34979>>>>>>>>>    // column value from the array passed instead of the record buffer.
34979>>>>>>>>>    Function IndexSortValueFromArray Integer iTable Integer iIndex String[] aColumnValues Returns String
34982>>>>>>>>>        Integer iSegment iSegments iColumn
34982>>>>>>>>>        String sValue sSegmentValue
34982>>>>>>>>>        tocIndex strIndex
34982>>>>>>>>>        tocIndex strIndex
34982>>>>>>>>>        Get IndexDefinition iTable iIndex to strIndex
34983>>>>>>>>>        Move (SizeOfArray(strIndex.aSegments)-1) to iSegments
34984>>>>>>>>>        For iSegment from 0 to iSegments
34990>>>>>>>>>>
34990>>>>>>>>>            Move strIndex.aSegments[iSegment].iColumn to iColumn
34991>>>>>>>>>            Move aColumnValues[iColumn] to sSegmentValue
34992>>>>>>>>>            Get ColumnSortValueFormat iTable iColumn sSegmentValue to sSegmentValue
34993>>>>>>>>>            Move (sValue+sSegmentValue) to sValue
34994>>>>>>>>>        Loop
34995>>>>>>>>>>
34995>>>>>>>>>        Function_Return sValue
34996>>>>>>>>>    End_Function
34997>>>>>>>>>    
34997>>>>>>>>>    Function IndexValueFromArray Integer iTable Integer iIndex String sSep String[] aColumnValues Returns String
35000>>>>>>>>>        Integer iSegment iSegments iColumn
35000>>>>>>>>>        String sValue sSegmentValue
35000>>>>>>>>>        tocIndex strIndex
35000>>>>>>>>>        tocIndex strIndex
35000>>>>>>>>>        Get IndexDefinition iTable iIndex to strIndex
35001>>>>>>>>>        Move (SizeOfArray(strIndex.aSegments)-1) to iSegments
35002>>>>>>>>>        For iSegment from 0 to iSegments
35008>>>>>>>>>>
35008>>>>>>>>>            Move strIndex.aSegments[iSegment].iColumn to iColumn
35009>>>>>>>>>            Move aColumnValues[iColumn] to sSegmentValue
35010>>>>>>>>>            Get ColumnSortValueFormat iTable iColumn sSegmentValue to sSegmentValue
35011>>>>>>>>>            Move (sValue+sSegmentValue) to sValue
35012>>>>>>>>>            If (iSegment<>0) Begin
35014>>>>>>>>>                Move (sValue+sSep) to sValue
35015>>>>>>>>>            End
35015>>>>>>>>>>
35015>>>>>>>>>        Loop
35016>>>>>>>>>>
35016>>>>>>>>>        Function_Return sValue
35017>>>>>>>>>    End_Function
35018>>>>>>>>>    
35018>>>>>>>>>    Function RecordIDAsHumanReadableString Integer iTable Returns String
35021>>>>>>>>>        Integer iMax iItem
35021>>>>>>>>>        Integer[] aColumns
35022>>>>>>>>>        String sReturnValue sName sValue
35022>>>>>>>>>        Get RecordIdentifierColumns iTable to aColumns
35023>>>>>>>>>        Move (SizeOfArray(aColumns)-1) to iMax
35024>>>>>>>>>        For iItem from 0 to iMax
35030>>>>>>>>>>
35030>>>>>>>>>            Get_Attribute DF_FIELD_NAME of iTable aColumns[iItem] to sName
35033>>>>>>>>>            Get_Field_Value iTable aColumns[iItem] to sValue
35036>>>>>>>>>            Move (sReturnValue+sName+": "+Trim(sValue)) to sReturnValue
35037>>>>>>>>>            If (iItem<>iMax) Begin
35039>>>>>>>>>                Move (sReturnValue+";") to sReturnValue
35040>>>>>>>>>            End
35040>>>>>>>>>>
35040>>>>>>>>>        Loop
35041>>>>>>>>>>
35041>>>>>>>>>        Function_Return sReturnValue
35042>>>>>>>>>    End_Function
35043>>>>>>>>>    
35043>>>>>>>>>    Function SwitchIndicesOffline Integer iTable String sOpenAsName Returns Integer[]
35046>>>>>>>>>        Integer iItem iMax iIndex iOrgTableHandle
35046>>>>>>>>>        Integer[] aIndices
35047>>>>>>>>>        String sDriver
35047>>>>>>>>>        
35047>>>>>>>>>        Get_Attribute DF_FILE_DRIVER of iTable to sDriver
35050>>>>>>>>>
35050>>>>>>>>>        If (sDriver="DATAFLEX") Begin
35052>>>>>>>>>            Get IndexSet iTable 3 to aIndices // 3 means on-line indices
35053>>>>>>>>>            Move (SizeOfArray(aIndices)-1) to iMax
35054>>>>>>>>>            If (iMax>=0) Begin
35056>>>>>>>>>                Move iTable to iOrgTableHandle
35057>>>>>>>>>                Structure_Start iTable
35058>>>>>>>>>                    For iItem from 0 to iMax
35064>>>>>>>>>>
35064>>>>>>>>>                        Move aIndices[iItem] to iIndex
35065>>>>>>>>>                        Set_Attribute DF_INDEX_TYPE of iTable iIndex to DF_INDEX_TYPE_BATCH
35068>>>>>>>>>                    Loop
35069>>>>>>>>>>
35069>>>>>>>>>                Structure_End iTable DF_STRUCTEND_OPT_NONE "."
35071>>>>>>>>>                Move iOrgTableHandle to iTable
35072>>>>>>>>>                Close iTable // Close and re-open
35073>>>>>>>>>                If (sOpenAsName<>"") Begin
35075>>>>>>>>>                    Open sOpenAsName as iTable
35077>>>>>>>>>                End
35077>>>>>>>>>>
35077>>>>>>>>>                Else Begin
35078>>>>>>>>>                    Open iTable
35080>>>>>>>>>                End
35080>>>>>>>>>>
35080>>>>>>>>>            End
35080>>>>>>>>>>
35080>>>>>>>>>        End
35080>>>>>>>>>>
35080>>>>>>>>>        Function_Return aIndices
35081>>>>>>>>>    End_Function
35082>>>>>>>>>    
35082>>>>>>>>>    Procedure SwitchIndicesOnLine Integer iTable String sOpenAsName Integer[] aIndices
35085>>>>>>>>>        Integer iItem iMax iIndex iOrgTableHandle
35085>>>>>>>>>        String sDriver
35085>>>>>>>>>        
35085>>>>>>>>>        Get_Attribute DF_FILE_DRIVER of iTable to sDriver
35088>>>>>>>>>
35088>>>>>>>>>        If (sDriver="DATAFLEX") Begin
35090>>>>>>>>>            Move (SizeOfArray(aIndices)-1) to iMax
35091>>>>>>>>>            If (iMax>=0) Begin
35093>>>>>>>>>                Move iTable to iOrgTableHandle
35094>>>>>>>>>                Structure_Start iTable
35095>>>>>>>>>                    For iItem from 0 to iMax
35101>>>>>>>>>>
35101>>>>>>>>>                        Move aIndices[iItem] to iIndex
35102>>>>>>>>>                        Set_Attribute DF_INDEX_TYPE of iTable iIndex to DF_INDEX_TYPE_ONLINE
35105>>>>>>>>>                    Loop
35106>>>>>>>>>>
35106>>>>>>>>>                Structure_End iTable DF_STRUCTEND_OPT_NONE "." // This forces a re-index
35108>>>>>>>>>                Move iOrgTableHandle to iTable
35109>>>>>>>>>                Close iTable // Close and re-open
35110>>>>>>>>>                If (sOpenAsName<>"") Begin
35112>>>>>>>>>                    Open sOpenAsName as iTable
35114>>>>>>>>>                End
35114>>>>>>>>>>
35114>>>>>>>>>                Else Begin
35115>>>>>>>>>                    Open iTable
35117>>>>>>>>>                End
35117>>>>>>>>>>
35117>>>>>>>>>            End
35117>>>>>>>>>>
35117>>>>>>>>>        End
35117>>>>>>>>>>
35117>>>>>>>>>    End_Procedure
35118>>>>>>>>>    
35118>>>>>>>>>    Procedure SeedMinValue Integer iTable Integer iColumn Boolean bMax
35121>>>>>>>>>        Integer iType iLength iDecimals iCount
35121>>>>>>>>>        Number nValueInt nValueFrac
35121>>>>>>>>>        String sChar
35121>>>>>>>>>        Time tiNull
35121>>>>>>>>>        DateTime dtValue
35121>>>>>>>>>        
35121>>>>>>>>>        Get_Attribute DF_FIELD_TYPE of iTable iColumn to iType
35124>>>>>>>>>        If (iType=DF_BCD) Begin
35126>>>>>>>>>            Get_Attribute DF_FIELD_LENGTH of iTable iColumn to iLength
35129>>>>>>>>>            Get_Attribute DF_FIELD_PRECISION of iTable iColumn to iDecimals
35132>>>>>>>>>            // Calculate fraction part
35132>>>>>>>>>            Move 0 to nValueFrac
35133>>>>>>>>>            For iCount from 1 to iDecimals 
35139>>>>>>>>>>
35139>>>>>>>>>                Move (nValueFrac/10+0.9) to nValueFrac 
35140>>>>>>>>>            Loop
35141>>>>>>>>>>
35141>>>>>>>>>            // Calculate integer part
35141>>>>>>>>>            Move (iLength-iDecimals) to iLength 
35142>>>>>>>>>            Move 0 to nValueInt
35143>>>>>>>>>            If (bMax) Begin
35145>>>>>>>>>                For iCount from 1 to iLength
35151>>>>>>>>>>
35151>>>>>>>>>                    Move (nValueInt*10+9) to nValueInt
35152>>>>>>>>>                Loop
35153>>>>>>>>>>
35153>>>>>>>>>            End
35153>>>>>>>>>>
35153>>>>>>>>>            Else Begin
35154>>>>>>>>>                For iCount from 2 to iLength
35160>>>>>>>>>>
35160>>>>>>>>>                    Move (nValueInt*10+9) to nValueInt
35161>>>>>>>>>                Loop
35162>>>>>>>>>>
35162>>>>>>>>>                Move (-nValueInt) to nValueInt
35163>>>>>>>>>            End
35163>>>>>>>>>>
35163>>>>>>>>>            Set_Field_Value iTable iColumn to (nValueInt+nValueFrac)
35166>>>>>>>>>        End
35166>>>>>>>>>>
35166>>>>>>>>>        If (iType=DF_DATE) Begin
35168>>>>>>>>>            If (bMax) Begin
35170>>>>>>>>>                Set_Field_Value iTable iColumn to LargestPossibleDate
35173>>>>>>>>>            End
35173>>>>>>>>>>
35173>>>>>>>>>            Else Begin
35174>>>>>>>>>                Set_Field_Value iTable iColumn to 0
35177>>>>>>>>>            End
35177>>>>>>>>>>
35177>>>>>>>>>        End
35177>>>>>>>>>>
35177>>>>>>>>>        If (iType=DF_DATETIME) Begin
35179>>>>>>>>>            If (bMax) Begin
35181>>>>>>>>>                Get ComposeDateTime of oDateFunctions LargestPossibleDate tiNull to dtValue
35182>>>>>>>>>            End
35182>>>>>>>>>>
35182>>>>>>>>>            Else Begin
35183>>>>>>>>>                Get ComposeDateTime of oDateFunctions (Date(0)) tiNull to dtValue
35184>>>>>>>>>            End
35184>>>>>>>>>>
35184>>>>>>>>>            Set_Field_Value iTable iColumn to dtValue
35187>>>>>>>>>        End
35187>>>>>>>>>>
35187>>>>>>>>>        If (iType=DF_ASCII) Begin
35189>>>>>>>>>            Get_Attribute DF_FIELD_LENGTH of iTable iColumn to iLength
35192>>>>>>>>>            If (bMax) Begin
35194>>>>>>>>>                Get MaximumCollateCharacter of oVdfRuntimeFunctions to sChar
35195>>>>>>>>>            End
35195>>>>>>>>>>
35195>>>>>>>>>            Else Begin
35196>>>>>>>>>                Get MinimumCollateCharacter of oVdfRuntimeFunctions to sChar
35197>>>>>>>>>            End
35197>>>>>>>>>>
35197>>>>>>>>>            Set_Field_Value iTable iColumn to (Repeat(sChar,iLength))
35200>>>>>>>>>        End
35200>>>>>>>>>>
35200>>>>>>>>>        
35200>>>>>>>>>    End_Procedure
35201>>>>>>>>>    
35201>>>>>>>>>    Function MinimalIncrement Integer iTable Integer iColumn Boolean bDecrement Returns Boolean
35204>>>>>>>>>        Integer iType
35204>>>>>>>>>        Get_Attribute DF_FIELD_TYPE of iTable iColumn to iType
35207>>>>>>>>>        Send Info_Box "nao implementado" "Scusi"
35208>>>>>>>>>        If (iType=DF_BCD) Begin
35210>>>>>>>>>            
35210>>>>>>>>>        End
35210>>>>>>>>>>
35210>>>>>>>>>    End_Function
35211>>>>>>>>>
35211>>>>>>>>>End_Object
35212>>>>>>>Use StackFunctions.pkg  // oStackFunctions object
35212>>>>>>>Use FileFunctions.pkg   // oFileFunctions object
35212>>>>>>>Use TemporaryTables.pkg
Including file: TemporaryTables.pkg    (Z:\VmShare\Projects\WebQuery18-0\StureApsPublicLib\AppSrc\TemporaryTables.pkg)
35212>>>>>>>>>// Temporary tables are embedded tables!
35212>>>>>>>>>
35212>>>>>>>>>Use AttributeFunctions.pkg
Including file: AttributeFunctions.pkg    (Z:\VmShare\Projects\WebQuery18-0\StureApsPublicLib\AppSrc\AttributeFunctions.pkg)
35212>>>>>>>>>>>// Use AttributeFunctions.pkg // Database and global API attributes
35212>>>>>>>>>>>
35212>>>>>>>>>>>Use FileFunctions.pkg // Define oFileFunctions object
35212>>>>>>>>>>>Use TableAccessFunctions.pkg
Including file: TableAccessFunctions.pkg    (Z:\VmShare\Projects\WebQuery18-0\StureApsPublicLib\AppSrc\TableAccessFunctions.pkg)
35212>>>>>>>>>>>>>// Use TableAccess.pkg // Define oTableAccessFunctions object
35212>>>>>>>>>>>>>
35212>>>>>>>>>>>>>//> This package defines the tBasicFieldType type that is used throughout many of the other packages. It also
35212>>>>>>>>>>>>>//> contains methods for extracting meta data from a DD object.
35212>>>>>>>>>>>>>//> pkg.doc.end
35212>>>>>>>>>>>>>
35212>>>>>>>>>>>>>Use VdfBase.pkg // DAW package. Provides low level support expected of all VDF applications (windows and webapp)
35212>>>>>>>>>>>>>Use FileFunctions.pkg // Define oFileFunctions object
35212>>>>>>>>>>>>>Use TableDriverFunctions.pkg
Including file: TableDriverFunctions.pkg    (Z:\VmShare\Projects\WebQuery18-0\StureApsPublicLib\AppSrc\TableDriverFunctions.pkg)
35212>>>>>>>>>>>>>>>Use VdfBase.pkg
35212>>>>>>>>>>>>>>>
35212>>>>>>>>>>>>>>>Use cli.pkg // DAW package
35212>>>>>>>>>>>>>>>
35212>>>>>>>>>>>>>>>Enumeration_List // Driver ID's
35212>>>>>>>>>>>>>>>    Define TD_DRIVER_ERROR
35212>>>>>>>>>>>>>>>    Define TD_DRIVER_UNKNOWN
35212>>>>>>>>>>>>>>>    Define TD_DRIVER_DATAFLEX
35212>>>>>>>>>>>>>>>    Define TD_DRIVER_PERVASIVE
35212>>>>>>>>>>>>>>>    Define TD_DRIVER_ORACLE
35212>>>>>>>>>>>>>>>    Define TD_DRIVER_MS_SQL
35212>>>>>>>>>>>>>>>    Define TD_DRIVER_DB2
35212>>>>>>>>>>>>>>>    Define TD_DRIVER_ODBC
35212>>>>>>>>>>>>>>>    Define TD_DRIVER_MS_SQL_DAW
35212>>>>>>>>>>>>>>>    Define TD_DRIVER_MAX // Points to the highest known driver ID (as does (SizeOfArray(gaConnectivityDrivers))  )
35212>>>>>>>>>>>>>>>End_Enumeration_List
35212>>>>>>>>>>>>>>>
35212>>>>>>>>>>>>>>>Struct tConnectivityServer
35212>>>>>>>>>>>>>>>End_Struct
35212>>>>>>>>>>>>>>>
35212>>>>>>>>>>>>>>>Struct tConnectivityDriver
35212>>>>>>>>>>>>>>>    String sName
35212>>>>>>>>>>>>>>>    String sNameAbr
35212>>>>>>>>>>>>>>>    String sManufacturer
35212>>>>>>>>>>>>>>>    String sDll
35212>>>>>>>>>>>>>>>    Boolean bLoaded
35212>>>>>>>>>>>>>>>    tConnectivityServer[] aServers
35212>>>>>>>>>>>>>>>    tConnectivityServer[] aServers
35212>>>>>>>>>>>>>>>End_Struct
35212>>>>>>>>>>>>>>>
35212>>>>>>>>>>>>>>>Global_Variable tConnectivityDriver[] gaConnectivityDrivers
35212>>>>>>>>>>>>>>>
35212>>>>>>>>>>>>>>>Global_Variable Integer oTableDriverFunctions
35212>>>>>>>>>>>>>>>
35212>>>>>>>>>>>>>>>Object _oTableDriverFunctions is a cObject
35214>>>>>>>>>>>>>>>    Move Self to oTableDriverFunctions
35215>>>>>>>>>>>>>>>
35215>>>>>>>>>>>>>>>            Procedure _AddDriver tConnectivityDriver[] ByRef aDrivers Integer iDriver String sName String sDll String sManufacturer
35218>>>>>>>>>>>>>>>                Move sName to aDrivers[iDriver].sName
35219>>>>>>>>>>>>>>>                Move sDll to aDrivers[iDriver].sDll
35220>>>>>>>>>>>>>>>                Move sManufacturer to aDrivers[iDriver].sManufacturer
35221>>>>>>>>>>>>>>>            End_Procedure
35222>>>>>>>>>>>>>>>
35222>>>>>>>>>>>>>>>            Procedure _register_known_drivers
35225>>>>>>>>>>>>>>>                Send _AddDriver (&gaConnectivityDrivers) TD_DRIVER_ERROR      "(Error)"           ""         ""            ""
35226>>>>>>>>>>>>>>>                Send _AddDriver (&gaConnectivityDrivers) TD_DRIVER_UNKNOWN    "Unknown"           ""         ""            ""
35227>>>>>>>>>>>>>>>                Send _AddDriver (&gaConnectivityDrivers) TD_DRIVER_DATAFLEX   "Embedded"          "DATAFLEX" "Data Access" ""
35228>>>>>>>>>>>>>>>                Send _AddDriver (&gaConnectivityDrivers) TD_DRIVER_PERVASIVE  "Pervasive"         "DFBTRDRV" "Data Access" ""
35229>>>>>>>>>>>>>>>                Send _AddDriver (&gaConnectivityDrivers) TD_DRIVER_ORACLE     "Oracle"            "ORA_DRV"  "Mertech"     ""
35230>>>>>>>>>>>>>>>                Send _AddDriver (&gaConnectivityDrivers) TD_DRIVER_MS_SQL     "MS-SQL (MT)"       "SQL_DRV"  "Mertech"     ""
35231>>>>>>>>>>>>>>>                Send _AddDriver (&gaConnectivityDrivers) TD_DRIVER_DB2        "DB/2"              "DB2_DRV"  "Data Access" ""
35232>>>>>>>>>>>>>>>                Send _AddDriver (&gaConnectivityDrivers) TD_DRIVER_ODBC       "ODBC"              "ODBC_DRV" "Data Access" ""
35233>>>>>>>>>>>>>>>                Send _AddDriver (&gaConnectivityDrivers) TD_DRIVER_MS_SQL_DAW "MS-SQL (DAW)"      "MSSQLDRV" "Data Access" ""
35234>>>>>>>>>>>>>>>                // If any drivers are missing, let me know @ sture@stureaps.dk
35234>>>>>>>>>>>>>>>            End_Procedure
35235>>>>>>>>>>>>>>>            Send _register_known_drivers    
35236>>>>>>>>>>>>>>>    
35236>>>>>>>>>>>>>>>    Procedure CallBackDrivers Integer hMsg Integer hObj
35239>>>>>>>>>>>>>>>        Integer iMax iIndex
35239>>>>>>>>>>>>>>>        For iIndex from TD_DRIVER_DATAFLEX to (TD_DRIVER_MAX-1)
35245>>>>>>>>>>>>>>>>
35245>>>>>>>>>>>>>>>            Send hMsg of hObj gaConnectivityDrivers[iIndex]
35246>>>>>>>>>>>>>>>        Loop
35247>>>>>>>>>>>>>>>>
35247>>>>>>>>>>>>>>>    End_Procedure
35248>>>>>>>>>>>>>>>    
35248>>>>>>>>>>>>>>>    //> All known drivers except the embedded driver.
35248>>>>>>>>>>>>>>>    Function ForeignDriverArray Returns String[]
35251>>>>>>>>>>>>>>>        Integer iMax iIndex
35251>>>>>>>>>>>>>>>        String[] aDrivers
35252>>>>>>>>>>>>>>>        For iIndex from (TD_DRIVER_DATAFLEX+1) to (TD_DRIVER_MAX-1)
35258>>>>>>>>>>>>>>>>
35258>>>>>>>>>>>>>>>            Move gaConnectivityDrivers[iIndex].sDll to aDrivers[SizeOfArray(aDrivers)]
35259>>>>>>>>>>>>>>>        Loop
35260>>>>>>>>>>>>>>>>
35260>>>>>>>>>>>>>>>        Function_Return aDrivers
35261>>>>>>>>>>>>>>>    End_Function
35262>>>>>>>>>>>>>>>
35262>>>>>>>>>>>>>>>    Function DriverDllToId String sDll Returns Integer
35265>>>>>>>>>>>>>>>        Integer iSize iDriver
35265>>>>>>>>>>>>>>>        Move (trim(Uppercase(sDll))) to sDll
35266>>>>>>>>>>>>>>>        If (sDll<>"") Begin
35268>>>>>>>>>>>>>>>            Move (SizeOfArray(gaConnectivityDrivers)) to iSize
35269>>>>>>>>>>>>>>>            Decrement iSize
35270>>>>>>>>>>>>>>>            For iDriver from TD_DRIVER_DATAFLEX to iSize
35276>>>>>>>>>>>>>>>>
35276>>>>>>>>>>>>>>>                If (gaConnectivityDrivers[iDriver].sDll=sDll) Begin
35278>>>>>>>>>>>>>>>                    Function_Return iDriver
35279>>>>>>>>>>>>>>>                End
35279>>>>>>>>>>>>>>>>
35279>>>>>>>>>>>>>>>            Loop
35280>>>>>>>>>>>>>>>>
35280>>>>>>>>>>>>>>>        End
35280>>>>>>>>>>>>>>>>
35280>>>>>>>>>>>>>>>        Function_Return TD_DRIVER_UNKNOWN // Is not zero
35281>>>>>>>>>>>>>>>    End_Function
35282>>>>>>>>>>>>>>>
35282>>>>>>>>>>>>>>>    Function DriverIdToName Integer iDriver Returns String
35285>>>>>>>>>>>>>>>        Function_Return gaConnectivityDrivers[iDriver].sName
35286>>>>>>>>>>>>>>>    End_Function
35287>>>>>>>>>>>>>>>
35287>>>>>>>>>>>>>>>    Function DriverIdToDll Integer iDriver Returns String
35290>>>>>>>>>>>>>>>        Function_Return gaConnectivityDrivers[iDriver].sDll
35291>>>>>>>>>>>>>>>    End_Function
35292>>>>>>>>>>>>>>>
35292>>>>>>>>>>>>>>>    //> Retrieve driver index as used by driver atrributes setting's and getting's
35292>>>>>>>>>>>>>>>    Function DriverIndex String sDriver Returns Integer
35295>>>>>>>>>>>>>>>        Integer iNumberOfDrivers iDriverIndex
35295>>>>>>>>>>>>>>>        String sTest 
35295>>>>>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
35298>>>>>>>>>>>>>>>        Move (Uppercase(sDriver)) to sDriver
35299>>>>>>>>>>>>>>>        For iDriverIndex from 1 to iNumberOfDrivers
35305>>>>>>>>>>>>>>>>
35305>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriverIndex to sTest
35308>>>>>>>>>>>>>>>            If (Uppercase(sTest)=sDriver) Begin
35310>>>>>>>>>>>>>>>                Function_Return iDriverIndex
35311>>>>>>>>>>>>>>>            End
35311>>>>>>>>>>>>>>>>
35311>>>>>>>>>>>>>>>        Loop
35312>>>>>>>>>>>>>>>>
35312>>>>>>>>>>>>>>>        Function_Return 0 // Driver not loaded
35313>>>>>>>>>>>>>>>    End_Function
35314>>>>>>>>>>>>>>>    
35314>>>>>>>>>>>>>>>    Function DriverRevision String sDriver Returns String
35317>>>>>>>>>>>>>>>        Handle hoCLIHandler
35317>>>>>>>>>>>>>>>        String sVersion
35317>>>>>>>>>>>>>>>        Get Create U_cCLIHandler to hoCLIHandler
35318>>>>>>>>>>>>>>>        Set psDriverID of hoCLIHandler to sDriver
35319>>>>>>>>>>>>>>>        Get CKRevision of hoCLIHandler to sVersion
35320>>>>>>>>>>>>>>>        Send Destroy of hoCLIHandler
35321>>>>>>>>>>>>>>>        Function_Return sVersion
35322>>>>>>>>>>>>>>>    End_Function
35323>>>>>>>>>>>>>>>
35323>>>>>>>>>>>>>>>    Function TableDatabaseHandle Integer iTable Integer ByRef iDriverIndex Integer ByRef iServerIndex Returns Integer
35326>>>>>>>>>>>>>>>        String sDriver sServer sLogin
35326>>>>>>>>>>>>>>>        Integer hDatabase iNumServers
35326>>>>>>>>>>>>>>>        Integer iDriverIndexX iServerIndexX
35326>>>>>>>>>>>>>>>        Get_Attribute DF_FILE_DRIVER of iTable to sDriver
35329>>>>>>>>>>>>>>>        Get_Attribute DF_FILE_LOGIN of iTable to sLogin
35332>>>>>>>>>>>>>>>        Get DriverIndex sDriver to iDriverIndexX
35333>>>>>>>>>>>>>>>        If (iDriverIndexX>0) Begin
35335>>>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriverIndexX to iNumServers
35338>>>>>>>>>>>>>>>            For iServerIndexX from 1 to iNumServers
35344>>>>>>>>>>>>>>>>
35344>>>>>>>>>>>>>>>                Get_Attribute DF_DRIVER_SERVER_NAME of iDriverIndexX iServerIndexX to sServer
35347>>>>>>>>>>>>>>>                If (sServer=sLogin) Begin
35349>>>>>>>>>>>>>>>                    Get_Attribute DF_DATABASE_ID of iDriverIndexX iServerIndexX to hDatabase
35352>>>>>>>>>>>>>>>                    Move iDriverIndexX to iDriverIndex
35353>>>>>>>>>>>>>>>                    Move iServerIndexX to iServerIndex
35354>>>>>>>>>>>>>>>                    Function_Return hDatabase
35355>>>>>>>>>>>>>>>                End
35355>>>>>>>>>>>>>>>>
35355>>>>>>>>>>>>>>>            Loop
35356>>>>>>>>>>>>>>>>
35356>>>>>>>>>>>>>>>        End
35356>>>>>>>>>>>>>>>>
35356>>>>>>>>>>>>>>>        Function_Return 0
35357>>>>>>>>>>>>>>>    End_Function
35358>>>>>>>>>>>>>>>    
35358>>>>>>>>>>>>>>>    Function TableCacheTimeout Integer iTable Returns Integer
35361>>>>>>>>>>>>>>>        Integer hDatabaseHandle iDriverIndex iServerIndex iTimeOutMS
35361>>>>>>>>>>>>>>>        Get TableDatabaseHandle iTable (&iDriverIndex) (&iServerIndex) to hDatabaseHandle
35362>>>>>>>>>>>>>>>        If (hDatabaseHandle>0) Begin
35364>>>>>>>>>>>>>>>            Get_Attribute DF_DATABASE_FIND_CACHE_TIMEOUT of iDriverIndex hDatabaseHandle to iTimeOutMS
35367>>>>>>>>>>>>>>>        End
35367>>>>>>>>>>>>>>>>
35367>>>>>>>>>>>>>>>        Else Begin
35368>>>>>>>>>>>>>>>            Error 232 ("Could not get cache timeout for table "+String(iTable))
35369>>>>>>>>>>>>>>>>
35369>>>>>>>>>>>>>>>        End
35369>>>>>>>>>>>>>>>>
35369>>>>>>>>>>>>>>>        Function_Return iTimeOutMS
35370>>>>>>>>>>>>>>>    End_Function
35371>>>>>>>>>>>>>>>    
35371>>>>>>>>>>>>>>>    //> It actually influences all tables opened on the
35371>>>>>>>>>>>>>>>    Procedure Set TableCacheTimeout Integer iTable Integer iTimeOutMS
35374>>>>>>>>>>>>>>>        Integer hDatabaseHandle iDriverIndex iServerIndex
35374>>>>>>>>>>>>>>>        Get TableDatabaseHandle iTable (&iDriverIndex) (&iServerIndex) to hDatabaseHandle
35375>>>>>>>>>>>>>>>        If (hDatabaseHandle>0) Begin
35377>>>>>>>>>>>>>>>            Set_Attribute DF_DATABASE_FIND_CACHE_TIMEOUT of iDriverIndex hDatabaseHandle to iTimeOutMS
35380>>>>>>>>>>>>>>>        End
35380>>>>>>>>>>>>>>>>
35380>>>>>>>>>>>>>>>        Else Begin
35381>>>>>>>>>>>>>>>            Error 231 ("Could not set cache timeout for table "+String(iTable))
35382>>>>>>>>>>>>>>>>
35382>>>>>>>>>>>>>>>        End
35382>>>>>>>>>>>>>>>>
35382>>>>>>>>>>>>>>>    End_Procedure
35383>>>>>>>>>>>>>>>End_Object
35384>>>>>>>>>>>>>Use StringFunctions.pkg // Define oStringFunctions object
35384>>>>>>>>>>>>>Use WorkSpaceFunctions.pkg
Including file: WorkSpaceFunctions.pkg    (Z:\VmShare\Projects\WebQuery18-0\StureApsPublicLib\AppSrc\WorkSpaceFunctions.pkg)
35384>>>>>>>>>>>>>>>// Use WorkSpaceFunctions.pkg // Workspace functions encapsulated in WsFunctions object (StureApsPublicLib)
35384>>>>>>>>>>>>>>>
35384>>>>>>>>>>>>>>>Use VdfBase.pkg // DAW package, provides low level support expected of all VDF applications (windows and webapp)
35384>>>>>>>>>>>>>>>Use cRegistry.pkg // DAW package, provides access to the Windows system Registry
35384>>>>>>>>>>>>>>>Use Windows.pkg
35384>>>>>>>>>>>>>>>
35384>>>>>>>>>>>>>>>Use FileFunctions.pkg // Define oFileFunctions object
35384>>>>>>>>>>>>>>>Use StringFunctions.pkg // Define oStringFunctions object
35384>>>>>>>>>>>>>>>Use VdfRuntime.pkg
35384>>>>>>>>>>>>>>>Use RegistryFunctions.pkg
35384>>>>>>>>>>>>>>>
35384>>>>>>>>>>>>>>>Use cApplication.pkg
35384>>>>>>>>>>>>>>>Use cWorkspace.pkg
35384>>>>>>>>>>>>>>>
35384>>>>>>>>>>>>>>>Use cIniFile.pkg
35384>>>>>>>>>>>>>>>
35384>>>>>>>>>>>>>>>Global_Variable Integer oWsSelector
35384>>>>>>>>>>>>>>>Global_Variable Integer oWorkSpaceFunctions
35384>>>>>>>>>>>>>>>
35384>>>>>>>>>>>>>>>Struct tWorkSpaceFile // (.ws file)
35384>>>>>>>>>>>>>>>    String sAppSrcPath     
35384>>>>>>>>>>>>>>>    String sBitmapPath     
35384>>>>>>>>>>>>>>>    String sDataPath       
35384>>>>>>>>>>>>>>>    String sDdSrcPath      
35384>>>>>>>>>>>>>>>    String sDescription    
35384>>>>>>>>>>>>>>>    String sFileList       
35384>>>>>>>>>>>>>>>    String sHelpPath       
35384>>>>>>>>>>>>>>>    String sHome           
35384>>>>>>>>>>>>>>>    String sIdeSrcPath     
35384>>>>>>>>>>>>>>>    String sProgramPath    
35384>>>>>>>>>>>>>>>    String sAppHtmlPath    
35384>>>>>>>>>>>>>>>    String sWorkspaceName  
35384>>>>>>>>>>>>>>>    String sWorkspaceWSFile
35384>>>>>>>>>>>>>>>                           
35384>>>>>>>>>>>>>>>    String sSystemDfPath
35384>>>>>>>>>>>>>>>    String sSystemMakePath 
35384>>>>>>>>>>>>>>>    String sDfPath
35384>>>>>>>>>>>>>>>End_Struct
35384>>>>>>>>>>>>>>>
35384>>>>>>>>>>>>>>>Struct tStudioWorkSpaceFile // (.sws file)
35384>>>>>>>>>>>>>>>    String   sSwsFilePath
35384>>>>>>>>>>>>>>>    String   sVdfVersion
35384>>>>>>>>>>>>>>>    String   sConfigFile
35384>>>>>>>>>>>>>>>    String[] aProjects
35384>>>>>>>>>>>>>>>    String   sDataDictClass
35384>>>>>>>>>>>>>>>    String   sDataDictPkg
35384>>>>>>>>>>>>>>>    tWorkSpaceFile strWorkSpaceFile
35384>>>>>>>>>>>>>>>    tWorkSpaceFile strWorkSpaceFile
35384>>>>>>>>>>>>>>>    tStudioWorkSpaceFile[] aLibraries
35384>>>>>>>>>>>>>>>    tStudioWorkSpaceFile[] aLibraries
35384>>>>>>>>>>>>>>>End_Struct
35384>>>>>>>>>>>>>>>
35384>>>>>>>>>>>>>>>
35384>>>>>>>>>>>>>>>Object _oWorkSpaceFunctions is a cObject
35386>>>>>>>>>>>>>>>    Move Self to oWorkSpaceFunctions
35387>>>>>>>>>>>>>>>    
35387>>>>>>>>>>>>>>>    Object _oRecentWs is a cRegistry // Private
35389>>>>>>>>>>>>>>>//            Set pfAccessRights to (KEY_READ+KEY_ENUMERATE_SUB_KEYS)
35389>>>>>>>>>>>>>>>        Set phRootKey to HKEY_CURRENT_USER
35390>>>>>>>>>>>>>>>    End_Object
35391>>>>>>>>>>>>>>>    
35391>>>>>>>>>>>>>>>    // Reads data out of the .ws file and all of the included libraries recursively
35391>>>>>>>>>>>>>>>    Function WorkspaceStruct String sWorkspaceFile Returns tWorkSpaceFile
35394>>>>>>>>>>>>>>>        // Content of this function is largely stolen from function OpenWorkspaceFile in DAW
35394>>>>>>>>>>>>>>>        // package cWorkspace.pkg:
35394>>>>>>>>>>>>>>>        Handle hoIniFile
35394>>>>>>>>>>>>>>>        Pointer lpsApplicationStartPath
35394>>>>>>>>>>>>>>>        tWorkSpaceFile strWS
35394>>>>>>>>>>>>>>>        tWorkSpaceFile strWS
35394>>>>>>>>>>>>>>>        String sApplicationStartPath sWsName sOldDirectory
35394>>>>>>>>>>>>>>>        String sHome sAppSrcPath sBitmapPath sDataPath sDdSrcPath sDescription sAppHtmlPath
35394>>>>>>>>>>>>>>>        String sFileList sHelpPath sIdeSrcPath sProgramPath sWorkspaceName
35394>>>>>>>>>>>>>>>        String sPath
35394>>>>>>>>>>>>>>>
35394>>>>>>>>>>>>>>>        
35394>>>>>>>>>>>>>>>        If (FileExists(oFileFunctions,sWorkspaceFile)=1) Begin
35396>>>>>>>>>>>>>>>            
35396>>>>>>>>>>>>>>>            Get PathToFolder of oFileFunctions sWorkspaceFile to sPath
35397>>>>>>>>>>>>>>>        
35397>>>>>>>>>>>>>>>            Get Create U_cIniFile to hoIniFile
35398>>>>>>>>>>>>>>>            Set psFilename of hoIniFile to sWorkspaceFile
35399>>>>>>>>>>>>>>>    
35399>>>>>>>>>>>>>>>            Get ReadString of hoIniFile "Workspace" "Home" ""          to sHome
35400>>>>>>>>>>>>>>>            Get ReadString of hoIniFile "Workspace" "AppSrcPath" ""    to sAppSrcPath
35401>>>>>>>>>>>>>>>            Get ReadString of hoIniFile "Workspace" "AppHtmlPath" ""   to sAppHtmlPath
35402>>>>>>>>>>>>>>>            Get ReadString of hoIniFile "Workspace" "BitmapPath" ""    to sBitmapPath
35403>>>>>>>>>>>>>>>            Get ReadString of hoIniFile "Workspace" "DataPath" ""      to sDataPath
35404>>>>>>>>>>>>>>>            Get ReadString of hoIniFile "Workspace" "DdSrcPath" ""     to sDdSrcPath
35405>>>>>>>>>>>>>>>            Get ReadString of hoIniFile "Workspace" "FileList" ""      to sFileList
35406>>>>>>>>>>>>>>>            Get ReadString of hoIniFile "Workspace" "HelpPath" ""      to sHelpPath
35407>>>>>>>>>>>>>>>            Get ReadString of hoIniFile "Workspace" "IdeSrcPath" ""    to sIdeSrcPath
35408>>>>>>>>>>>>>>>            Get ReadString of hoIniFile "Workspace" "ProgramPath" ""   to sProgramPath
35409>>>>>>>>>>>>>>>            Move (Left(sWsName, Length(sWsName) -3))                   to sWorkspaceName
35410>>>>>>>>>>>>>>>    
35410>>>>>>>>>>>>>>>            Get AppendPath of oFileFunctions sPath sHome to strWS.sHome
35411>>>>>>>>>>>>>>>    
35411>>>>>>>>>>>>>>>            Get AppendPath of oFileFunctions strWS.sHome sAppSrcPath    to strWS.sAppSrcPath 
35412>>>>>>>>>>>>>>>            Get AppendPath of oFileFunctions strWS.sHome sAppHtmlPath   to strWS.sAppHtmlPath
35413>>>>>>>>>>>>>>>            Get AppendPath of oFileFunctions strWS.sHome sBitmapPath    to strWS.sBitmapPath 
35414>>>>>>>>>>>>>>>            Get AppendPath of oFileFunctions strWS.sHome sDataPath      to strWS.sDataPath   
35415>>>>>>>>>>>>>>>            Get AppendPath of oFileFunctions strWS.sHome sDdSrcPath     to strWS.sDdSrcPath  
35416>>>>>>>>>>>>>>>            Get AppendPath of oFileFunctions strWS.sHome sFileList      to strWS.sFileList   
35417>>>>>>>>>>>>>>>            Get AppendPath of oFileFunctions strWS.sHome sHelpPath      to strWS.sHelpPath   
35418>>>>>>>>>>>>>>>            Get AppendPath of oFileFunctions strWS.sHome sIdeSrcPath    to strWS.sIdeSrcPath 
35419>>>>>>>>>>>>>>>            Get AppendPath of oFileFunctions strWS.sHome sWorkspaceName to strWS.sWorkspaceName 
35420>>>>>>>>>>>>>>>            Get AppendPath of oFileFunctions strWS.sHome sProgramPath   to strWS.sProgramPath
35421>>>>>>>>>>>>>>>    
35421>>>>>>>>>>>>>>>            Send Destroy of hoIniFile // destroy dynaically created inifile object
35422>>>>>>>>>>>>>>>    
35422>>>>>>>>>>>>>>>        End
35422>>>>>>>>>>>>>>>>
35422>>>>>>>>>>>>>>>
35422>>>>>>>>>>>>>>>        Function_Return strWS
35423>>>>>>>>>>>>>>>    End_Function
35424>>>>>>>>>>>>>>>    
35424>>>>>>>>>>>>>>>    // Reads data out of the .sws file and all of the included libraries recursively
35424>>>>>>>>>>>>>>>    Function StudioWorkspaceStruct String sSwsPath Returns tStudioWorkSpaceFile
35427>>>>>>>>>>>>>>>        Integer hIniFile
35427>>>>>>>>>>>>>>>        Integer hArray iMax iIndex
35427>>>>>>>>>>>>>>>        tStudioWorkSpaceFile strWSfile
35427>>>>>>>>>>>>>>>        tStudioWorkSpaceFile strWSfile
35427>>>>>>>>>>>>>>>        String sValueName sFolder sValue sPath
35427>>>>>>>>>>>>>>>        
35427>>>>>>>>>>>>>>>        Get Create U_cIniFile to hIniFile
35428>>>>>>>>>>>>>>>        Get Create U_Array to hArray
35429>>>>>>>>>>>>>>>        
35429>>>>>>>>>>>>>>>        Set psFileName of hIniFile to sSwsPath
35430>>>>>>>>>>>>>>>        Move sSwsPath to strWSfile.sSwsFilePath
35431>>>>>>>>>>>>>>>        
35431>>>>>>>>>>>>>>>        Get ReadString of hIniFile "Properties" "Version" "" to strWSfile.sVdfVersion
35432>>>>>>>>>>>>>>>        Get ReadString of hIniFile "WorkspacePaths" "ConfigFile" "" to strWSfile.sConfigFile
35433>>>>>>>>>>>>>>>        
35433>>>>>>>>>>>>>>>        If (strWSfile.sConfigFile<>"") Begin // If a ws file is specified, we will read it
35435>>>>>>>>>>>>>>>            If (Left(strWSfile.sConfigFile,2)=".\") Begin
35437>>>>>>>>>>>>>>>                Get PathToFolder of oFileFunctions sSwsPath to sPath
35438>>>>>>>>>>>>>>>                Move (Replace(".",strWSfile.sConfigFile,sPath)) to strWSfile.sConfigFile
35439>>>>>>>>>>>>>>>            End
35439>>>>>>>>>>>>>>>>
35439>>>>>>>>>>>>>>>            Get WorkspaceStruct strWSfile.sConfigFile to strWSfile.strWorkSpaceFile
35440>>>>>>>>>>>>>>>        End
35440>>>>>>>>>>>>>>>>
35440>>>>>>>>>>>>>>>        
35440>>>>>>>>>>>>>>>        Send Delete_Data of hArray
35441>>>>>>>>>>>>>>>        Send ReadSection of hIniFile "Projects" hArray
35442>>>>>>>>>>>>>>>        Get Item_Count of hArray to iMax
35443>>>>>>>>>>>>>>>        Decrement iMax
35444>>>>>>>>>>>>>>>        For iIndex from 0 to iMax
35450>>>>>>>>>>>>>>>>
35450>>>>>>>>>>>>>>>            Get Value of hArray iIndex to sValueName 
35451>>>>>>>>>>>>>>>            Get ReadString of hIniFile "Projects" sValueName "" to strWSfile.aProjects[iIndex]
35452>>>>>>>>>>>>>>>        Loop
35453>>>>>>>>>>>>>>>>
35453>>>>>>>>>>>>>>>        
35453>>>>>>>>>>>>>>>        Get ReadString of hIniFile "DataDictionary" "class" "" to strWSfile.sDataDictClass
35454>>>>>>>>>>>>>>>        Get ReadString of hIniFile "DataDictionary" "file" "" to strWSfile.sDataDictPkg
35455>>>>>>>>>>>>>>>        
35455>>>>>>>>>>>>>>>        Get PathToFolder of oFileFunctions sSwsPath to sFolder
35456>>>>>>>>>>>>>>>        Send Delete_Data of hArray
35457>>>>>>>>>>>>>>>        Send ReadSection of hIniFile "Libraries" hArray
35458>>>>>>>>>>>>>>>        Get Item_Count of hArray to iMax
35459>>>>>>>>>>>>>>>        Decrement iMax
35460>>>>>>>>>>>>>>>        For iIndex from 0 to iMax
35466>>>>>>>>>>>>>>>>
35466>>>>>>>>>>>>>>>            Get Value of hArray iIndex to sValueName 
35467>>>>>>>>>>>>>>>            Get ReadString of hIniFile "Libraries" sValueName "" to sSwsPath
35468>>>>>>>>>>>>>>>
35468>>>>>>>>>>>>>>>            Get AppendPath of oFileFunctions sFolder sSwsPath to sSwsPath
35469>>>>>>>>>>>>>>>            Get StudioWorkspaceStruct sSwsPath to strWSfile.aLibraries[iIndex]
35470>>>>>>>>>>>>>>>        Loop
35471>>>>>>>>>>>>>>>>
35471>>>>>>>>>>>>>>>
35471>>>>>>>>>>>>>>>        Send Destroy of hArray
35472>>>>>>>>>>>>>>>        Send Destroy of hIniFile
35473>>>>>>>>>>>>>>>        Function_Return strWSfile
35474>>>>>>>>>>>>>>>    End_Function
35475>>>>>>>>>>>>>>>    
35475>>>>>>>>>>>>>>>    Function VdfRootFolder tStudioWorkSpaceFile strWorkspace Returns String
35478>>>>>>>>>>>>>>>        tVdfRuntime strRuntime
35478>>>>>>>>>>>>>>>        tVdfRuntime strRuntime
35478>>>>>>>>>>>>>>>        If (strWorkspace.sVdfVersion<>"") Begin
35480>>>>>>>>>>>>>>>            Get RuntimeStruct of oVdfRuntimeFunctions strWorkspace.sVdfVersion to strRuntime
35481>>>>>>>>>>>>>>>            Function_Return strRuntime.sRootFolder
35482>>>>>>>>>>>>>>>        End
35482>>>>>>>>>>>>>>>>
35482>>>>>>>>>>>>>>>        Function_Return "" 
35483>>>>>>>>>>>>>>>    End_Function
35484>>>>>>>>>>>>>>>    
35484>>>>>>>>>>>>>>>//        Function _AddWorkspace tStudioWorkSpaceFile strWS tStudioWorkSpaceFile[] ByRef aWS Returns Boolean
35484>>>>>>>>>>>>>>>//            Integer iItem iMax
35484>>>>>>>>>>>>>>>//            Move (SizeOfArray(aWS)-1) to iMax
35484>>>>>>>>>>>>>>>//            For iItem from 0 to iMax
35484>>>>>>>>>>>>>>>//                If (Lowercase(strWS.sSwsFilePath)=Lowercase(aWS[iItem].sSwsFilePath)) Begin
35484>>>>>>>>>>>>>>>//                    Function_Return False
35484>>>>>>>>>>>>>>>//                End
35484>>>>>>>>>>>>>>>//            Loop
35484>>>>>>>>>>>>>>>//            Move (ResizeArray(strWS.aLibraries,0)) to strWS.aLibraries
35484>>>>>>>>>>>>>>>//            Move strWS to aWS[iMax+1]
35484>>>>>>>>>>>>>>>//            Function_Return True
35484>>>>>>>>>>>>>>>//        End_Function
35484>>>>>>>>>>>>>>>//        
35484>>>>>>>>>>>>>>>//        Procedure _WorkspaceList tStudioWorkSpaceFile strWS tStudioWorkSpaceFile[] ByRef aWS 
35484>>>>>>>>>>>>>>>//            Integer iMax iItem
35484>>>>>>>>>>>>>>>//            If (_AddWorkspace(Self,strWS,&aWS)) Begin
35484>>>>>>>>>>>>>>>//                Move (SizeOfArray(strWS.aLibraries)-1) to iMax
35484>>>>>>>>>>>>>>>//                For iItem from 0 to iMax
35484>>>>>>>>>>>>>>>//                    Send _WorkspaceList strWS.aLibraries[iItem] (&aWS)
35484>>>>>>>>>>>>>>>//                Loop
35484>>>>>>>>>>>>>>>//            End
35484>>>>>>>>>>>>>>>//        End_Procedure
35484>>>>>>>>>>>>>>>//    
35484>>>>>>>>>>>>>>>//    Function WorkspaceLibraryList String sSwsPath Returns tStudioWorkSpaceFile[]
35484>>>>>>>>>>>>>>>//        tStudioWorkSpaceFile[] strWS
35484>>>>>>>>>>>>>>>//        tStudioWorkSpaceFile[] aWS
35484>>>>>>>>>>>>>>>//        Get StudioWorkspaceStruct sSwsPath to strWS
35484>>>>>>>>>>>>>>>//        Send _WorkspaceList strWS (&aWS)
35484>>>>>>>>>>>>>>>//        Function_Return aWS
35484>>>>>>>>>>>>>>>//    End_Function
35484>>>>>>>>>>>>>>>    
35484>>>>>>>>>>>>>>>        Procedure _AddFolder String sFolder String[] ByRef aFolders
35487>>>>>>>>>>>>>>>            Integer iMax iItem
35487>>>>>>>>>>>>>>>            Move (SizeOfArray(aFolders)-1) to iMax
35488>>>>>>>>>>>>>>>            For iItem from 0 to iMax
35494>>>>>>>>>>>>>>>>
35494>>>>>>>>>>>>>>>                If (Lowercase(sFolder)=Lowercase(aFolders[iItem])) Begin
35496>>>>>>>>>>>>>>>                    Procedure_Return
35497>>>>>>>>>>>>>>>                End
35497>>>>>>>>>>>>>>>>
35497>>>>>>>>>>>>>>>            Loop
35498>>>>>>>>>>>>>>>>
35498>>>>>>>>>>>>>>>            Move sFolder to aFolders[iMax+1]
35499>>>>>>>>>>>>>>>        End_Procedure
35500>>>>>>>>>>>>>>>        
35500>>>>>>>>>>>>>>>        Procedure _AddLibraryAppSrcFolder tStudioWorkSpaceFile strLibrary String[] ByRef aFolders
35503>>>>>>>>>>>>>>>            Integer iMax iItem
35503>>>>>>>>>>>>>>>            Send _AddFolder strLibrary.strWorkSpaceFile.sAppSrcPath (&aFolders)
35504>>>>>>>>>>>>>>>            Move (SizeOfArray(strLibrary.aLibraries)-1) to iMax
35505>>>>>>>>>>>>>>>            For iItem from 0 to iMax
35511>>>>>>>>>>>>>>>>
35511>>>>>>>>>>>>>>>                Send _AddLibraryAppSrcFolder strLibrary.aLibraries[iItem] (&aFolders)
35512>>>>>>>>>>>>>>>            Loop 
35513>>>>>>>>>>>>>>>>
35513>>>>>>>>>>>>>>>        End_Procedure
35514>>>>>>>>>>>>>>>    
35514>>>>>>>>>>>>>>>    Function WorkspaceSourceFolders String sSwsPath Boolean bIncludeVdfPkgFolder Returns String[]
35517>>>>>>>>>>>>>>>        Integer iMax iItem
35517>>>>>>>>>>>>>>>        String sFolder
35517>>>>>>>>>>>>>>>        String[] aFolders
35518>>>>>>>>>>>>>>>        tStudioWorkSpaceFile strCurrentWorkSpace
35518>>>>>>>>>>>>>>>        tStudioWorkSpaceFile strCurrentWorkSpace
35518>>>>>>>>>>>>>>>        tVdfRuntime strRuntime
35518>>>>>>>>>>>>>>>        tVdfRuntime strRuntime
35518>>>>>>>>>>>>>>>        
35518>>>>>>>>>>>>>>>        Get StudioWorkspaceStruct sSwsPath to strCurrentWorkSpace
35519>>>>>>>>>>>>>>>        Send _AddFolder strCurrentWorkSpace.strWorkSpaceFile.sAppSrcPath (&aFolders)
35520>>>>>>>>>>>>>>>        Send _AddFolder strCurrentWorkSpace.strWorkSpaceFile.sDdSrcPath (&aFolders)
35521>>>>>>>>>>>>>>>        
35521>>>>>>>>>>>>>>>        Move (SizeOfArray(strCurrentWorkSpace.aLibraries)-1) to iMax
35522>>>>>>>>>>>>>>>        For iItem from 0 to iMax
35528>>>>>>>>>>>>>>>>
35528>>>>>>>>>>>>>>>            Send _AddLibraryAppSrcFolder strCurrentWorkSpace.aLibraries[iItem] (&aFolders)
35529>>>>>>>>>>>>>>>        Loop
35530>>>>>>>>>>>>>>>>
35530>>>>>>>>>>>>>>>            
35530>>>>>>>>>>>>>>>        If (bIncludeVdfPkgFolder) Begin
35532>>>>>>>>>>>>>>>            Get RuntimeStruct of oVdfRuntimeFunctions strCurrentWorkSpace.sVdfVersion to strRuntime
35533>>>>>>>>>>>>>>>            
35533>>>>>>>>>>>>>>>            If (strRuntime.sRootFolder<>"") Begin
35535>>>>>>>>>>>>>>>                Get AppendPath of oFileFunctions strRuntime.sRootFolder "Pkg" to sFolder
35536>>>>>>>>>>>>>>>                Send _AddFolder sFolder (&aFolders)
35537>>>>>>>>>>>>>>>            End 
35537>>>>>>>>>>>>>>>>
35537>>>>>>>>>>>>>>>        End
35537>>>>>>>>>>>>>>>>
35537>>>>>>>>>>>>>>>        Function_Return aFolders
35538>>>>>>>>>>>>>>>    End_Function
35539>>>>>>>>>>>>>>>    
35539>>>>>>>>>>>>>>>    Procedure _ReadRegistryRecentWorkSpacesOfVdfVersion String sVdfVerDotRev String[] ByRef aValues
35542>>>>>>>>>>>>>>>        Boolean bOpen
35542>>>>>>>>>>>>>>>        Handle hoArray
35542>>>>>>>>>>>>>>>        Integer iMaxKey iKey iCount
35542>>>>>>>>>>>>>>>        String sKey sVdfKey sKeyValue
35542>>>>>>>>>>>>>>>        
35542>>>>>>>>>>>>>>>        Get OpenKey of _oRecentWs ("Software\Data Access Worldwide\Visual DataFlex Tools\"+sVdfVerDotRev+"\Studio\RecentWorkspaces") to bOpen
35543>>>>>>>>>>>>>>>        If (bOpen) Begin
35545>>>>>>>>>>>>>>>            Get Create U_Array to hoArray // Create an array object
35546>>>>>>>>>>>>>>>            Get GetValues of _oRecentWs hoArray to iMaxKey
35547>>>>>>>>>>>>>>>            Decrement iMaxKey
35548>>>>>>>>>>>>>>>            Move (SizeOfArray(aValues)) to iCount
35549>>>>>>>>>>>>>>>            For iKey from 0 to iMaxKey
35555>>>>>>>>>>>>>>>>
35555>>>>>>>>>>>>>>>                Get value of hoArray iKey to sKey
35556>>>>>>>>>>>>>>>                Get ReadString of _oRecentWs sKey to sKeyValue
35557>>>>>>>>>>>>>>>                If (sKeyValue<>"") Begin // Empty values may occur
35559>>>>>>>>>>>>>>>                    Move sKeyValue to aValues[iCount]
35560>>>>>>>>>>>>>>>                    Increment iCount
35561>>>>>>>>>>>>>>>                End
35561>>>>>>>>>>>>>>>>
35561>>>>>>>>>>>>>>>            Loop
35562>>>>>>>>>>>>>>>>
35562>>>>>>>>>>>>>>>            Send Destroy of hoArray // Remove the array object from memory.
35563>>>>>>>>>>>>>>>            Send CloseKey of _oRecentWs
35564>>>>>>>>>>>>>>>        End
35564>>>>>>>>>>>>>>>>
35564>>>>>>>>>>>>>>>    End_Procedure
35565>>>>>>>>>>>>>>>
35565>>>>>>>>>>>>>>>    Procedure ReadRegistryRecentWorkSpacesOfVdfVersion String sVdfVerDotRev String[] ByRef aValues
35568>>>>>>>>>>>>>>>        Move (ResizeArray(aValues,0)) to aValues
35569>>>>>>>>>>>>>>>        Send _ReadRegistryRecentWorkSpacesOfVdfVersion sVdfVerDotRev (&aValues)
35570>>>>>>>>>>>>>>>    End_Procedure
35571>>>>>>>>>>>>>>>
35571>>>>>>>>>>>>>>>    //> The VDF studio stores its "Recent Workspaces" list in the Windows registry. Use the ReadRegistryRecentWorkSpaces
35571>>>>>>>>>>>>>>>    //> procedure to dig them out.
35571>>>>>>>>>>>>>>>    Procedure ReadRegistryRecentWorkSpaces String[] ByRef aValues
35574>>>>>>>>>>>>>>>        String sVdfVer sVdfRev sVdfBuild sVdfVerDotRev
35574>>>>>>>>>>>>>>>        Version_Information sVdfVer sVdfRev sVdfBuild
35576>>>>>>>>>>>>>>>        Move (sVdfVer+"."+sVdfRev) to sVdfVerDotRev
35577>>>>>>>>>>>>>>>        Send ReadRegistryRecentWorkSpacesOfVdfVersion sVdfVerDotRev (&aValues)
35578>>>>>>>>>>>>>>>    End_Procedure
35579>>>>>>>>>>>>>>>    
35579>>>>>>>>>>>>>>>    Procedure ReadRegistryRecentWorkspacesAllVersions String[] ByRef aValues
35582>>>>>>>>>>>>>>>        Integer iMax iIndex
35582>>>>>>>>>>>>>>>        Move (ResizeArray(aValues,0)) to aValues
35583>>>>>>>>>>>>>>>        Move (SizeOfArray(gaRuntimes)-1) to iMax
35584>>>>>>>>>>>>>>>        For iIndex from 0 to iMax
35590>>>>>>>>>>>>>>>>
35590>>>>>>>>>>>>>>>            Send _ReadRegistryRecentWorkSpacesOfVdfVersion gaRuntimes[iIndex].sVdfVersion (&aValues)
35591>>>>>>>>>>>>>>>        Loop
35592>>>>>>>>>>>>>>>>
35592>>>>>>>>>>>>>>>    End_Procedure
35593>>>>>>>>>>>>>>>
35593>>>>>>>>>>>>>>>    //> Returns a handle to cWorkSpace object currently in action.
35593>>>>>>>>>>>>>>>    Function WorkSpaceObject Returns Handle
35596>>>>>>>>>>>>>>>        Handle hRval
35596>>>>>>>>>>>>>>>        Move 0 to hRval
35597>>>>>>>>>>>>>>>        If (ghoApplication>=0) Begin
35599>>>>>>>>>>>>>>>            Get phoWorkspace of ghoApplication to hRval
35600>>>>>>>>>>>>>>>        End
35600>>>>>>>>>>>>>>>>
35600>>>>>>>>>>>>>>>        Function_Return hRval
35601>>>>>>>>>>>>>>>    End_Function
35602>>>>>>>>>>>>>>>
35602>>>>>>>>>>>>>>>    //> Returns the name (incl. full path) of the .ws file currently used.
35602>>>>>>>>>>>>>>>    Function WorkSpaceFile Returns String
35605>>>>>>>>>>>>>>>        Handle hoWs
35605>>>>>>>>>>>>>>>        String sFile
35605>>>>>>>>>>>>>>>        Get WorkSpaceObject to hoWs
35606>>>>>>>>>>>>>>>        If (hoWs>0) Begin
35608>>>>>>>>>>>>>>>            Get psWorkspaceWSFile of hoWs to sFile
35609>>>>>>>>>>>>>>>        End
35609>>>>>>>>>>>>>>>>
35609>>>>>>>>>>>>>>>        Else Begin
35610>>>>>>>>>>>>>>>            Move "" to sFile
35611>>>>>>>>>>>>>>>        End
35611>>>>>>>>>>>>>>>>
35611>>>>>>>>>>>>>>>        Function_Return sFile
35612>>>>>>>>>>>>>>>    End_Function
35613>>>>>>>>>>>>>>>    
35613>>>>>>>>>>>>>>>    Function SwsFileVersion String sSws String ByRef sVdfVer Returns Boolean
35616>>>>>>>>>>>>>>>        Boolean bSeqEof
35616>>>>>>>>>>>>>>>        Integer iChannel
35616>>>>>>>>>>>>>>>        String sLine
35616>>>>>>>>>>>>>>>        Move "" to sVdfVer
35617>>>>>>>>>>>>>>>        Get DirectInput of oFileFunctions sSws to iChannel
35618>>>>>>>>>>>>>>>        If (iChannel>=0) Begin
35620>>>>>>>>>>>>>>>            Repeat
35620>>>>>>>>>>>>>>>>
35620>>>>>>>>>>>>>>>                Readln channel iChannel sLine
35622>>>>>>>>>>>>>>>                Move (SeqEof) to bSeqEof
35623>>>>>>>>>>>>>>>                If (not(bSeqEof)) Begin
35625>>>>>>>>>>>>>>>                    If (Left(sLine,8)="Version=") Begin
35627>>>>>>>>>>>>>>>                        Send CloseInput of oFileFunctions iChannel
35628>>>>>>>>>>>>>>>                        Move (Replace("Version=",sLine,"")) to sVdfVer
35629>>>>>>>>>>>>>>>                        Function_Return True
35630>>>>>>>>>>>>>>>                    End
35630>>>>>>>>>>>>>>>>
35630>>>>>>>>>>>>>>>                End
35630>>>>>>>>>>>>>>>>
35630>>>>>>>>>>>>>>>            Until (bSeqEof)
35632>>>>>>>>>>>>>>>            Send CloseInput of oFileFunctions iChannel
35633>>>>>>>>>>>>>>>        End
35633>>>>>>>>>>>>>>>>
35633>>>>>>>>>>>>>>>        Function_Return False
35634>>>>>>>>>>>>>>>    End_Function
35635>>>>>>>>>>>>>>>    
35635>>>>>>>>>>>>>>>    //> Use this function to calculate the absolute path of the .ws file corresponding to the abslute path of a .sws file given as parameter.
35635>>>>>>>>>>>>>>>    Function SwsFileToWsFile String sSwsFile Returns String
35638>>>>>>>>>>>>>>>        Boolean bStop
35638>>>>>>>>>>>>>>>        //Integer iChannel
35638>>>>>>>>>>>>>>>        Handle hoIniFile
35638>>>>>>>>>>>>>>>        String sWsFile sLine
35638>>>>>>>>>>>>>>>
35638>>>>>>>>>>>>>>>        Get Create U_cIniFile To hoIniFile
35639>>>>>>>>>>>>>>>
35639>>>>>>>>>>>>>>>        Set psFilename of hoIniFile To sSwsFile
35640>>>>>>>>>>>>>>>        Get ReadString of hoIniFile "WorkspacePaths" "ConfigFile" "" To sWsFile
35641>>>>>>>>>>>>>>>        Send Destroy of hoIniFile // destroy dynaically created inifile object
35642>>>>>>>>>>>>>>>
35642>>>>>>>>>>>>>>>        If (left(sWsFile,2)=".\") Begin // If that's not the case we assume that the path is absolute. (Maybe someday it is necessary to take "..\" into account also).
35644>>>>>>>>>>>>>>>            Move (Remove(swsFile,1,2)) to sWsFile // Remove the first two characters
35645>>>>>>>>>>>>>>>            Get PathToFolder of oFileFunctions sSwsFile to sSwsFile // "C:\Apps\FreeLib\FreeLib.sws" -> "C:\Apps\FreeLib"
35646>>>>>>>>>>>>>>>            Get AppendPath of oFileFunctions sSwsFile sWsFile to sWsFile
35647>>>>>>>>>>>>>>>        End
35647>>>>>>>>>>>>>>>>
35647>>>>>>>>>>>>>>>        Function_Return sWsFile
35648>>>>>>>>>>>>>>>    End_Function
35649>>>>>>>>>>>>>>>
35649>>>>>>>>>>>>>>>    //> Function OpenWorkspace takes a .sws or .ws file and calls the "OpenWorkSpaceFile" method of the current cWorkSpace object. The return
35649>>>>>>>>>>>>>>>    //> value is one of the following:
35649>>>>>>>>>>>>>>>    //>     -1                      : cWorkSpace object not found
35649>>>>>>>>>>>>>>>    //>     wsWorkspaceOpened       : WS opened ok
35649>>>>>>>>>>>>>>>    //>     wsWorkspaceNotFound     : the named WS was not found in the global list
35649>>>>>>>>>>>>>>>    //>     wsWorkspaceFileNotFound : the WS file was not found
35649>>>>>>>>>>>>>>>    //>     wsDataPathEmpty         : the DataPath entry was empty
35649>>>>>>>>>>>>>>>    //>     wsFileListEmpty         : The FileList entry was empty
35649>>>>>>>>>>>>>>>    //>     wsFileListNotExist      : The FileList.cfg file could not be found
35649>>>>>>>>>>>>>>>    //>
35649>>>>>>>>>>>>>>>    //> Most likely, you want to close all tables before calling this function.
35649>>>>>>>>>>>>>>>    //>
35649>>>>>>>>>>>>>>>    Function OpenWorkspace String sFile Returns Integer
35652>>>>>>>>>>>>>>>        Handle hoWs
35652>>>>>>>>>>>>>>>        Integer iRval
35652>>>>>>>>>>>>>>>        Get WorkSpaceObject to hoWs
35653>>>>>>>>>>>>>>>        If (hoWs>=0) Begin
35655>>>>>>>>>>>>>>>            If (Lowercase(PathToFileName(oFileFunctions,sFile))="filelist.cfg") Begin
35657>>>>>>>>>>>>>>>                // If this function is passed a filelist.cfg we have to give
35657>>>>>>>>>>>>>>>                // special treatment to the workspace object:
35657>>>>>>>>>>>>>>>                Send DoClearPaths of hoWs
35658>>>>>>>>>>>>>>>                Set psHome            of hoWs to (PathToFolder(oFileFunctions,sFile))
35659>>>>>>>>>>>>>>>                Set psWorkspaceName   of hoWs to ""
35660>>>>>>>>>>>>>>>                Set psAppSrcPath      of hoWs to ""
35661>>>>>>>>>>>>>>>                Set psAppHtmlPath     of hoWs to ""
35662>>>>>>>>>>>>>>>                Set psBitmapPath      of hoWs to ""
35663>>>>>>>>>>>>>>>                Set psDataPath        of hoWs to (PathToFolder(oFileFunctions,sFile))
35664>>>>>>>>>>>>>>>                Set psDdSrcPath       of hoWs to ""
35665>>>>>>>>>>>>>>>                Set psDescription     of hoWs to ""
35666>>>>>>>>>>>>>>>                Set psFileList        of hoWs to sFile
35667>>>>>>>>>>>>>>>                Set psHelpPath        of hoWs to ""
35668>>>>>>>>>>>>>>>                Set psIdeSrcPath      of hoWs to ""
35669>>>>>>>>>>>>>>>                Set psProgramPath     of hoWs to ""
35670>>>>>>>>>>>>>>>                Set psSystemDfPath    of hoWs to (VdfSystemDfPath(hoWs))
35671>>>>>>>>>>>>>>>                Set psSystemMakePath  of hoWs to (VdfSystemMakePath(hoWs))
35672>>>>>>>>>>>>>>>                Set psWorkspaceWSFile of hoWs to ""
35673>>>>>>>>>>>>>>>
35673>>>>>>>>>>>>>>>                Set psDfPath           of hoWS to (PathToFolder(oFileFunctions,sFile))
35674>>>>>>>>>>>>>>>                Set_Attribute DF_FILELIST_NAME to sFile
35677>>>>>>>>>>>>>>>                Set_Attribute DF_OPEN_PATH     to (PathToFolder(oFileFunctions,sFile))
35680>>>>>>>>>>>>>>>                Move wsWorkspaceOpened to iRval
35681>>>>>>>>>>>>>>>            End
35681>>>>>>>>>>>>>>>>
35681>>>>>>>>>>>>>>>            Else Begin
35682>>>>>>>>>>>>>>>                If (Lowercase(Right(sFile,4))=".sws") Begin
35684>>>>>>>>>>>>>>>                    Get SwsFileToWsFile sFile to sFile
35685>>>>>>>>>>>>>>>                End
35685>>>>>>>>>>>>>>>>
35685>>>>>>>>>>>>>>>                Send DoClearPaths of hoWs
35686>>>>>>>>>>>>>>>                Get OpenWorkspaceFile of hoWs sFile to iRval
35687>>>>>>>>>>>>>>>            End
35687>>>>>>>>>>>>>>>>
35687>>>>>>>>>>>>>>>        End
35687>>>>>>>>>>>>>>>>
35687>>>>>>>>>>>>>>>        Else Begin
35688>>>>>>>>>>>>>>>            Error 232 "Workspace object not found (WorkSpaceFunctions.pkg)"
35689>>>>>>>>>>>>>>>>
35689>>>>>>>>>>>>>>>        End
35689>>>>>>>>>>>>>>>>
35689>>>>>>>>>>>>>>>        Function_Return iRval
35690>>>>>>>>>>>>>>>    End_Function
35691>>>>>>>>>>>>>>>
35691>>>>>>>>>>>>>>>    Function OpenWorkspaceErrorText integer iReturnValue returns string
35694>>>>>>>>>>>>>>>        if (iReturnValue=-1)                      function_return "cWorkSpace object not found"
35697>>>>>>>>>>>>>>>        if (iReturnValue=wsWorkspaceOpened)       function_return "WS opened ok"
35700>>>>>>>>>>>>>>>        if (iReturnValue=wsWorkspaceNotFound)     function_return "The named WS was not found in the global list"
35703>>>>>>>>>>>>>>>        if (iReturnValue=wsWorkspaceFileNotFound) function_return "The WS file was not found"
35706>>>>>>>>>>>>>>>        if (iReturnValue=wsDataPathEmpty)         function_return "The DataPath entry was empty"
35709>>>>>>>>>>>>>>>        if (iReturnValue=wsFileListEmpty)         function_return "The FileList entry was empty"
35712>>>>>>>>>>>>>>>        if (iReturnValue=wsFileListNotExist)      function_return "'FileList.cfg' file could not be found"
35715>>>>>>>>>>>>>>>        function_return ""
35716>>>>>>>>>>>>>>>    End_Function
35717>>>>>>>>>>>>>>>
35717>>>>>>>>>>>>>>>    
35717>>>>>>>>>>>>>>>End_Object
35718>>>>>>>>>>>>>Use IntFileFunctions.pkg
Including file: IntFileFunctions.pkg    (Z:\VmShare\Projects\WebQuery18-0\StureApsPublicLib\AppSrc\IntFileFunctions.pkg)
35718>>>>>>>>>>>>>>>Use VdfBase.pkg
35718>>>>>>>>>>>>>>>Use FileFunctions.pkg // Define oFileFunctions object
35718>>>>>>>>>>>>>>>Use StringFunctions.pkg // Define oStringFunctions object
35718>>>>>>>>>>>>>>>
35718>>>>>>>>>>>>>>>Struct cIntFile
35718>>>>>>>>>>>>>>>    String  sDriverName
35718>>>>>>>>>>>>>>>    String  sDatabaseName
35718>>>>>>>>>>>>>>>    String  sSchemaName
35718>>>>>>>>>>>>>>>    Integer iNumberOfDfFields
35718>>>>>>>>>>>>>>>    Integer iPrimaryIndex
35718>>>>>>>>>>>>>>>    String  sOptimize
35718>>>>>>>>>>>>>>>    Integer iMaxRowsToQuery
35718>>>>>>>>>>>>>>>    String  sLocalCache    
35718>>>>>>>>>>>>>>>End_Struct
35718>>>>>>>>>>>>>>>
35718>>>>>>>>>>>>>>>Object oIntFileFunctions is a cObject
35720>>>>>>>>>>>>>>>        Function _ReadItem String sLine String sLead Returns String
35723>>>>>>>>>>>>>>>        End_Function
35724>>>>>>>>>>>>>>>        
35724>>>>>>>>>>>>>>>        Procedure _ReadItemString String sLine String sLead String ByRef sValue
35727>>>>>>>>>>>>>>>            If (BeginsWith(oStringFunctions,sLine,sLead)) Begin
35729>>>>>>>>>>>>>>>                Move (Trim(Replace(sLead,sLine,""))) to sValue
35730>>>>>>>>>>>>>>>            End
35730>>>>>>>>>>>>>>>>
35730>>>>>>>>>>>>>>>        End_Procedure
35731>>>>>>>>>>>>>>>
35731>>>>>>>>>>>>>>>        Procedure _ReadItemInteger String sLine String sLead Integer ByRef iValue
35734>>>>>>>>>>>>>>>            If (BeginsWith(oStringFunctions,sLine,sLead)) Begin
35736>>>>>>>>>>>>>>>                Move (Trim(Replace(sLead,sLine,""))) to iValue
35737>>>>>>>>>>>>>>>            End
35737>>>>>>>>>>>>>>>>
35737>>>>>>>>>>>>>>>        End_Procedure
35738>>>>>>>>>>>>>>>    
35738>>>>>>>>>>>>>>>    Function ReadIntFile String sFileName Returns cIntFile
35741>>>>>>>>>>>>>>>        Boolean bSeqEof
35741>>>>>>>>>>>>>>>        Integer iChannel
35741>>>>>>>>>>>>>>>        String sLine sValue
35741>>>>>>>>>>>>>>>        cIntFile stIntFile
35741>>>>>>>>>>>>>>>        cIntFile stIntFile
35741>>>>>>>>>>>>>>>        Get DirectInput of oFileFunctions sFileName to iChannel
35742>>>>>>>>>>>>>>>        If (iChannel>=0) Begin
35744>>>>>>>>>>>>>>>            Repeat
35744>>>>>>>>>>>>>>>>
35744>>>>>>>>>>>>>>>                Readln channel iChannel sLine
35746>>>>>>>>>>>>>>>                Move (SeqEof) to bSeqeof
35747>>>>>>>>>>>>>>>                If (not(bSeqEof)) Begin
35749>>>>>>>>>>>>>>>                    Send _ReadItemString  sLine "DRIVER_NAME "       (&stIntFile.sDriverName)
35750>>>>>>>>>>>>>>>                    Send _ReadItemString  sLine "DATABASE_NAME "     (&stIntFile.sDatabaseName)
35751>>>>>>>>>>>>>>>                    Send _ReadItemString  sLine "SCHEMA_NAME "       (&stIntFile.sSchemaName)
35752>>>>>>>>>>>>>>>                    Send _ReadItemInteger sLine "NUMBER_DF_FIELDS "  (&stIntFile.iNumberOfDfFields)
35753>>>>>>>>>>>>>>>                    Send _ReadItemInteger sLine "PRIMARY_INDEX "     (&stIntFile.iPrimaryIndex)
35754>>>>>>>>>>>>>>>                    Send _ReadItemString  sLine "OPTIMIZE "          (&stIntFile.sOptimize)
35755>>>>>>>>>>>>>>>                    Send _ReadItemInteger sLine "MAX_ROWS_TO_QUERY " (&stIntFile.iMaxRowsToQuery)
35756>>>>>>>>>>>>>>>                    Send _ReadItemString  sLine "LOCAL_CACHE "       (&stIntFile.sLocalCache)
35757>>>>>>>>>>>>>>>                End
35757>>>>>>>>>>>>>>>>
35757>>>>>>>>>>>>>>>            Until (SeqEof)
35759>>>>>>>>>>>>>>>            Send CloseInput of oFileFunctions iChannel
35760>>>>>>>>>>>>>>>        End
35760>>>>>>>>>>>>>>>>
35760>>>>>>>>>>>>>>>        Function_Return stIntFile    
35761>>>>>>>>>>>>>>>    End_Function
35762>>>>>>>>>>>>>>>End_Object
35763>>>>>>>>>>>>>Use StackFunctions.pkg // Define oStackFunctions object
35763>>>>>>>>>>>>>
35763>>>>>>>>>>>>>// Define the maximum number of records defined in an embedded table for other packages to utilize:
35763>>>>>>>>>>>>>Define C_MaxNumberOfRecordsInEmbeddedTable for 16711679
35763>>>>>>>>>>>>>Define C_MaxRecordSizeEmbeddedTable for 16384
35763>>>>>>>>>>>>>
35763>>>>>>>>>>>>>Struct tTableOpenState
35763>>>>>>>>>>>>>    Integer iTable
35763>>>>>>>>>>>>>    Boolean bOpen
35763>>>>>>>>>>>>>    Integer iDriver    // Rest of the members only hold meaningful values if this member is not TA_DRIVER_ERROR
35763>>>>>>>>>>>>>    Integer iShareMode // DF_SHARE, DF_EXCLUSIVE
35763>>>>>>>>>>>>>
35763>>>>>>>>>>>>>       // DF_FILEMODE_ORIGINAL    -1 // only valid for smart_filemode in data sets
35763>>>>>>>>>>>>>       // DF_FILEMODE_DEFAULT     0
35763>>>>>>>>>>>>>       // DF_FILEMODE_NO_REREAD   1
35763>>>>>>>>>>>>>       // DF_FILEMODE_NO_LOCKS    2
35763>>>>>>>>>>>>>       // DF_FILEMODE_NO_EDITS    8
35763>>>>>>>>>>>>>       // DF_FILEMODE_NO_DELETES  16
35763>>>>>>>>>>>>>       // DF_FILEMODE_NO_FINDS    32
35763>>>>>>>>>>>>>       // DF_FILEMODE_NO_CREATES  64
35763>>>>>>>>>>>>>       // DF_FILEMODE_READONLY    91
35763>>>>>>>>>>>>>       // DF_FILEMODE_SINGLE_USER 3
35763>>>>>>>>>>>>>
35763>>>>>>>>>>>>>    Integer iFileMode  // DF_FILEMODE_DEFAULT, DF_FILEMODE_NO_REREAD etc etc etc
35763>>>>>>>>>>>>>    Integer iAliasMode // DF_FILE_ALIAS_DEFAULT, DF_FILE_IS_MASTER, DF_FILE_IS_ALIAS
35763>>>>>>>>>>>>>    String  sPhysName  // Runtimes idea of the root name of the table
35763>>>>>>>>>>>>>End_Struct
35763>>>>>>>>>>>>>
35763>>>>>>>>>>>>>If (False) Begin
35765>>>>>>>>>>>>>    TableAccessOpenError: Move 0 to windowindex
35766>>>>>>>>>>>>>    return
35767>>>>>>>>>>>>>End
35767>>>>>>>>>>>>>>
35767>>>>>>>>>>>>>
35767>>>>>>>>>>>>>
35767>>>>>>>>>>>>>Global_Variable integer oTableAccessFunctions
35767>>>>>>>>>>>>>
35767>>>>>>>>>>>>>Object _oTableAccessFunctions is a cObject
35769>>>>>>>>>>>>>
35769>>>>>>>>>>>>>    Move Self to oTableAccessFunctions
35770>>>>>>>>>>>>>
35770>>>>>>>>>>>>>    //> This function is used to find out if a table is currently open. If not
35770>>>>>>>>>>>>>    //> it will return 0 (TA_DRIVER_ERROR)  and if it is opened a driver ID like
35770>>>>>>>>>>>>>    //> TA_DRIVER_DATAFLEX or TA_DRIVER_ORACLE will be returned.
35770>>>>>>>>>>>>>    Function TableDriver Integer iTable Returns Integer
35773>>>>>>>>>>>>>        Integer iRval iHandleType iPos iItem iItemMax
35773>>>>>>>>>>>>>        cIntFile stIntFile
35773>>>>>>>>>>>>>        cIntFile stIntFile
35773>>>>>>>>>>>>>        String[] aDrivers
35774>>>>>>>>>>>>>        String sDll
35774>>>>>>>>>>>>>        String sRootName
35774>>>>>>>>>>>>>
35774>>>>>>>>>>>>>        Move TD_DRIVER_UNKNOWN to iRval
35775>>>>>>>>>>>>>        
35775>>>>>>>>>>>>>        // If table is currently being restructured we stop here and return 'unknown driver'
35775>>>>>>>>>>>>>        Get_Attribute DF_FILE_HANDLE_TYPE of iTable to iHandleType
35778>>>>>>>>>>>>>        If (iHandleType=DF_FILE_HANDLE_EXISTING_RESTRUCTURE or iHandleType=DF_FILE_HANDLE_NEW_RESTRUCTURE) Function_Return TD_DRIVER_UNKNOWN
35781>>>>>>>>>>>>>        
35781>>>>>>>>>>>>>        Get_Attribute DF_FILE_OPENED of iTable to iRval
35784>>>>>>>>>>>>>        If (iRval<>0) Begin // If open
35786>>>>>>>>>>>>>            Get_Attribute DF_FILE_DRIVER of iTable to sDll
35789>>>>>>>>>>>>>            Get DriverDllToId of oTableDriverFunctions sDll to iRval
35790>>>>>>>>>>>>>        End
35790>>>>>>>>>>>>>>
35790>>>>>>>>>>>>>        Else Begin // If not open
35791>>>>>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of iTable to sRootName
35794>>>>>>>>>>>>>            Move (Trim(sRootName)) to sRootName
35795>>>>>>>>>>>>>            Move "" to sDll
35796>>>>>>>>>>>>>            If (Right(Lowercase(sRootName),4)=".int") Begin
35798>>>>>>>>>>>>>                Get ReadIntFile of oIntFileFunctions sRootName to stIntFile
35799>>>>>>>>>>>>>                Move stIntFile.sDriverName to sDll
35800>>>>>>>>>>>>>                Get DriverDllToId of oTableDriverFunctions sDll to iRval
35801>>>>>>>>>>>>>            End
35801>>>>>>>>>>>>>>
35801>>>>>>>>>>>>>            Else Begin
35802>>>>>>>>>>>>>                // Check if there's a driver prefix
35802>>>>>>>>>>>>>                Move (Uppercase(sRootName)) to sRootName
35803>>>>>>>>>>>>>                Move (Pos(":",sRootName)) to iPos
35804>>>>>>>>>>>>>                If (iPos>0) Begin
35806>>>>>>>>>>>>>                    Move (Left(sRootName,iPos-1)) to sDll
35807>>>>>>>>>>>>>                    Get ForeignDriverArray of oTableDriverFunctions to aDrivers 
35808>>>>>>>>>>>>>                    Move (SizeOfArray(aDrivers)-1) to iItemMax
35809>>>>>>>>>>>>>                    For iItem from 0 to iItemMax
35815>>>>>>>>>>>>>>
35815>>>>>>>>>>>>>                        If (sDll=aDrivers[iItem]) Begin
35817>>>>>>>>>>>>>                            Get DriverDllToId of oTableDriverFunctions sDll to iRval
35818>>>>>>>>>>>>>                        End
35818>>>>>>>>>>>>>>
35818>>>>>>>>>>>>>                    Loop
35819>>>>>>>>>>>>>>
35819>>>>>>>>>>>>>                End
35819>>>>>>>>>>>>>>
35819>>>>>>>>>>>>>            End
35819>>>>>>>>>>>>>>
35819>>>>>>>>>>>>>        End
35819>>>>>>>>>>>>>>
35819>>>>>>>>>>>>>        Function_Return iRval
35820>>>>>>>>>>>>>    End_Function
35821>>>>>>>>>>>>>
35821>>>>>>>>>>>>>    Function IsOpen Integer iTable Returns Boolean
35824>>>>>>>>>>>>>        Integer iHandleType
35824>>>>>>>>>>>>>        Boolean bOpen
35824>>>>>>>>>>>>>        Get_Attribute DF_FILE_HANDLE_TYPE of iTable to iHandleType
35827>>>>>>>>>>>>>        Move (iHandleType=DF_FILE_HANDLE_EXISTING_RESTRUCTURE or iHandleType=DF_FILE_HANDLE_NEW_RESTRUCTURE) to bOpen
35828>>>>>>>>>>>>>        If (not(bOpen)) Begin
35830>>>>>>>>>>>>>            Get_Attribute DF_FILE_OPENED of iTable to bOpen
35833>>>>>>>>>>>>>        End
35833>>>>>>>>>>>>>>
35833>>>>>>>>>>>>>        Function_Return bOpen
35834>>>>>>>>>>>>>    End_Function
35835>>>>>>>>>>>>>
35835>>>>>>>>>>>>>    Function IsOpenAs Integer iTable Returns Boolean
35838>>>>>>>>>>>>>        Boolean bOpen
35838>>>>>>>>>>>>>        String sPhysName sRootName
35838>>>>>>>>>>>>>        Get_Attribute DF_FILE_OPENED of iTable to bOpen
35841>>>>>>>>>>>>>        If (bOpen) Begin
35843>>>>>>>>>>>>>            Get_Attribute DF_FILE_PHYSICAL_NAME of iTable to sPhysName
35846>>>>>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of iTable to sRootName
35849>>>>>>>>>>>>>            If (uppercase(sPhysName)<>uppercase(sRootName)) Function_Return True
35852>>>>>>>>>>>>>        End
35852>>>>>>>>>>>>>>
35852>>>>>>>>>>>>>        Function_Return False
35853>>>>>>>>>>>>>    End_Function
35854>>>>>>>>>>>>>    
35854>>>>>>>>>>>>>    Property Boolean _pbRecursionStopper False
35856>>>>>>>>>>>>>    
35856>>>>>>>>>>>>>    //> The function returns True if the table could be opened. False otherwise.
35856>>>>>>>>>>>>>    Function OpenTable Integer iTable Integer iMode Integer iBufIndex Returns Boolean
35859>>>>>>>>>>>>>        Integer iWindowIndex   // *** VOODOO WARNING ***
35859>>>>>>>>>>>>>        Integer iDriverID
35859>>>>>>>>>>>>>        String sDll sRootName sRoot sDriver
35859>>>>>>>>>>>>>        String sFolder
35859>>>>>>>>>>>>>        Boolean bRval
35859>>>>>>>>>>>>>        Move WindowIndex to iWindowIndex // Preserve this obsolete global variable for old times sake.
35860>>>>>>>>>>>>>        Move |VI31 to |VI32 //copy ON ERROR label
35861>>>>>>>>>>>>>        On Error Gosub TableAccessOpenError
35862>>>>>>>>>>>>>        Indicate Err False
35863>>>>>>>>>>>>>        Move 1 to WindowIndex
35864>>>>>>>>>>>>>        If (iBufIndex<>0) Begin
35866>>>>>>>>>>>>>            Open iTable Mode iMode iBufIndex
35868>>>>>>>>>>>>>        End
35868>>>>>>>>>>>>>>
35868>>>>>>>>>>>>>        Else Begin
35869>>>>>>>>>>>>>            Open iTable Mode iMode
35871>>>>>>>>>>>>>        End
35871>>>>>>>>>>>>>>
35871>>>>>>>>>>>>>        Move |VI32 to |VI31 //restore original ON ERROR label
35872>>>>>>>>>>>>>        Move (WindowIndex<>0) to bRval // If an error was triggered the
35873>>>>>>>>>>>>>        Indicate Err False        // subroutine will have changed windowindex
35874>>>>>>>>>>>>>        Move iWindowIndex to WindowIndex
35875>>>>>>>>>>>>>        If (not(_pbRecursionStopper(Self)) and not(bRval)) Begin
35877>>>>>>>>>>>>>            Get TableDriver iTable to iDriverID
35878>>>>>>>>>>>>>            If (iDriverID<>TD_DRIVER_UNKNOWN and iDriverID<>TD_DRIVER_ERROR and iDriverID<>TD_DRIVER_DATAFLEX) Begin
35880>>>>>>>>>>>>>                Get DriverIdToDll of oTableDriverFunctions iDriverID to sDriver
35881>>>>>>>>>>>>>                Load_Driver sDriver
35882>>>>>>>>>>>>>                Set _pbRecursionStopper to True
35883>>>>>>>>>>>>>                Get OpenTable iTable iMode to bRval
35884>>>>>>>>>>>>>                Set _pbRecursionStopper to False
35885>>>>>>>>>>>>>            End
35885>>>>>>>>>>>>>>
35885>>>>>>>>>>>>>        End
35885>>>>>>>>>>>>>>
35885>>>>>>>>>>>>>        Function_Return bRval
35886>>>>>>>>>>>>>    End_Function
35887>>>>>>>>>>>>>    
35887>>>>>>>>>>>>>    Function OpenTables Integer[] aTables Integer iMode Returns Boolean
35890>>>>>>>>>>>>>        Boolean bOpen
35890>>>>>>>>>>>>>        Integer iTable iMax iItem
35890>>>>>>>>>>>>>        Move (SizeOfArray(aTables)-1) to iMax
35891>>>>>>>>>>>>>        For iItem from 0 to iMax
35897>>>>>>>>>>>>>>
35897>>>>>>>>>>>>>            Get OpenTable aTables[iItem] iMode 0 to bOpen
35898>>>>>>>>>>>>>            If (not(bOpen)) Begin
35900>>>>>>>>>>>>>                Function_Return False
35901>>>>>>>>>>>>>            End
35901>>>>>>>>>>>>>>
35901>>>>>>>>>>>>>        Loop
35902>>>>>>>>>>>>>>
35902>>>>>>>>>>>>>        Function_Return True
35903>>>>>>>>>>>>>    End_Function
35904>>>>>>>>>>>>>
35904>>>>>>>>>>>>>    Function OpenTableAs String sFileName Integer iTable Integer iMode Integer iBufIndex Returns Boolean
35907>>>>>>>>>>>>>        Integer iWindowIndex  // *** ALSO VOODOO WARNING ***
35907>>>>>>>>>>>>>        String sDll
35907>>>>>>>>>>>>>        Boolean bRval
35907>>>>>>>>>>>>>        If (IsOpen(Self,iTable)) Close iTable
35910>>>>>>>>>>>>>        Move (ToAnsi(sFileName)) to sFileName
35911>>>>>>>>>>>>>        If (sFileName="") Function_Return TD_DRIVER_ERROR
35914>>>>>>>>>>>>>        Move WindowIndex to iWindowIndex
35915>>>>>>>>>>>>>        Move |VI31 to |VI32 //copy ON ERROR label
35916>>>>>>>>>>>>>        On Error Gosub TableAccessOpenError
35917>>>>>>>>>>>>>        Indicate Err False
35918>>>>>>>>>>>>>        Move 1 to WindowIndex
35919>>>>>>>>>>>>>        If (iBufIndex<>0) Open sFileName as iTable Mode iMode iBufIndex
35923>>>>>>>>>>>>>        Else Open sFileName as iTable Mode iMode
35926>>>>>>>>>>>>>        Move |VI32 to |VI31 //restore original ON ERROR label
35927>>>>>>>>>>>>>        Move (WindowIndex<>0) to bRval // If an error was triggered the
35928>>>>>>>>>>>>>        Indicate Err False // subroutine will have changed windowindex
35929>>>>>>>>>>>>>        Move iWindowIndex to WindowIndex
35930>>>>>>>>>>>>>        Function_Return bRval
35931>>>>>>>>>>>>>    End_Function
35932>>>>>>>>>>>>>
35932>>>>>>>>>>>>>    Function OpenTableAsAutoHandle String sFileName Integer iMode Integer iBufIndex Returns Integer
35935>>>>>>>>>>>>>        Boolean bOpen
35935>>>>>>>>>>>>>        Integer iTable
35935>>>>>>>>>>>>>        Get TempFilelistEntry 500 to iTable // Start looking from 500
35936>>>>>>>>>>>>>        If (iTable<>0) Begin
35938>>>>>>>>>>>>>            Get OpenTableAs sFileName iTable iMode iBufIndex to bOpen
35939>>>>>>>>>>>>>            If (not(bOpen)) Begin
35941>>>>>>>>>>>>>                Move 0 to iTable // Failure
35942>>>>>>>>>>>>>            End
35942>>>>>>>>>>>>>>
35942>>>>>>>>>>>>>        End
35942>>>>>>>>>>>>>>
35942>>>>>>>>>>>>>        Else Begin
35943>>>>>>>>>>>>>            // The reason that the upper code failed may be that we're dealing
35943>>>>>>>>>>>>>            // with an old filelist.cfg with a maximum of 256 entries. We therefore
35943>>>>>>>>>>>>>            // try again starting from entry 1:
35943>>>>>>>>>>>>>            Get TempFilelistEntry 1 to iTable // Start looking from 1
35944>>>>>>>>>>>>>            If (iTable<>0) Begin
35946>>>>>>>>>>>>>                Get OpenTableAs sFileName iTable iMode iBufIndex to bOpen
35947>>>>>>>>>>>>>                If (not(bOpen)) Begin
35949>>>>>>>>>>>>>                    Move 0 to iTable // Failure
35950>>>>>>>>>>>>>                End
35950>>>>>>>>>>>>>>
35950>>>>>>>>>>>>>            End
35950>>>>>>>>>>>>>>
35950>>>>>>>>>>>>>        End
35950>>>>>>>>>>>>>>
35950>>>>>>>>>>>>>        Function_Return iTable
35951>>>>>>>>>>>>>    End_Function
35952>>>>>>>>>>>>>    
35952>>>>>>>>>>>>>    Function OpenShadowTable Integer iTable Boolean bReadOnly Returns Integer
35955>>>>>>>>>>>>>        Integer iShadowTable
35955>>>>>>>>>>>>>        String sTable
35955>>>>>>>>>>>>>        Get_Attribute DF_FILE_PHYSICAL_NAME of iTable to sTable
35958>>>>>>>>>>>>>        Get OpenTableAsAutoHandle sTable DF_SHARE 0 to iShadowTable
35959>>>>>>>>>>>>>        If (bReadOnly) Begin
35961>>>>>>>>>>>>>            Send FlagTableReadOnly iShadowTable
35962>>>>>>>>>>>>>        End
35962>>>>>>>>>>>>>>
35962>>>>>>>>>>>>>        Function_Return iShadowTable
35963>>>>>>>>>>>>>    End_Function
35964>>>>>>>>>>>>>
35964>>>>>>>>>>>>>    Procedure CloseTable Integer iTable
35967>>>>>>>>>>>>>        Boolean bOpen
35967>>>>>>>>>>>>>        If iTable Begin
35969>>>>>>>>>>>>>            Get_Attribute DF_FILE_OPENED of iTable to bOpen
35972>>>>>>>>>>>>>            If bOpen Close iTable
35975>>>>>>>>>>>>>        End
35975>>>>>>>>>>>>>>
35975>>>>>>>>>>>>>    End_Procedure
35976>>>>>>>>>>>>>
35976>>>>>>>>>>>>>    Procedure CloseAll
35979>>>>>>>>>>>>>        Close DF_ALL DF_PERMANENT
35980>>>>>>>>>>>>>    End_Procedure
35981>>>>>>>>>>>>>    
35981>>>>>>>>>>>>>    Function ZeroFileTable Integer iTable Returns Boolean
35984>>>>>>>>>>>>>        Integer iIndex
35984>>>>>>>>>>>>>        Boolean bFound bConnectionRestored
35984>>>>>>>>>>>>>        
35984>>>>>>>>>>>>>        tTableOpenState strState
35984>>>>>>>>>>>>>        tTableOpenState strState
35984>>>>>>>>>>>>>        Get TableOpenState iTable to strState
35985>>>>>>>>>>>>>        Close iTable
35986>>>>>>>>>>>>>        If (OpenTable(Self,iTable,DF_EXCLUSIVE,0)) Begin
35988>>>>>>>>>>>>>            ZeroFile iTable
35989>>>>>>>>>>>>>        End
35989>>>>>>>>>>>>>>
35989>>>>>>>>>>>>>        Else Begin
35990>>>>>>>>>>>>>            Open iTable
35992>>>>>>>>>>>>>            Clear iTable
35993>>>>>>>>>>>>>            Get PrimaryIndex iTable to iIndex
35994>>>>>>>>>>>>>            Repeat
35994>>>>>>>>>>>>>>
35994>>>>>>>>>>>>>                Vfind iTable iIndex (GT)
35996>>>>>>>>>>>>>                Move (Found) to bFound
35997>>>>>>>>>>>>>                If (bFound) Begin
35999>>>>>>>>>>>>>                    Delete iTable
36000>>>>>>>>>>>>>                End
36000>>>>>>>>>>>>>>
36000>>>>>>>>>>>>>            Until (not(bFound))
36002>>>>>>>>>>>>>        End
36002>>>>>>>>>>>>>>
36002>>>>>>>>>>>>>        
36002>>>>>>>>>>>>>        Get SetTableOpenState strState True False to bConnectionRestored
36003>>>>>>>>>>>>>        Function_Return bConnectionRestored
36004>>>>>>>>>>>>>    End_Function
36005>>>>>>>>>>>>>
36005>>>>>>>>>>>>>    Function TableIntegerArray Integer iFileListNavAttr Returns Integer[]
36008>>>>>>>>>>>>>        Integer iTable iIndex
36008>>>>>>>>>>>>>        Integer[] aTables
36009>>>>>>>>>>>>>        If (iFileListNavAttr=DF_FILE_NEXT_OPENED or iFileListNavAttr=DF_FILE_NEXT_USED or iFileListNavAttr=DF_FILE_NEXT_EMPTY) Begin
36011>>>>>>>>>>>>>            Move 0 to iTable
36012>>>>>>>>>>>>>            Move 0 to iIndex
36013>>>>>>>>>>>>>            Repeat
36013>>>>>>>>>>>>>>
36013>>>>>>>>>>>>>                Get_Attribute iFileListNavAttr of iTable to iTable
36016>>>>>>>>>>>>>                If (iTable<>0) Begin
36018>>>>>>>>>>>>>                    Move iTable to aTables[iIndex]
36019>>>>>>>>>>>>>                    Increment iIndex
36020>>>>>>>>>>>>>                End
36020>>>>>>>>>>>>>>
36020>>>>>>>>>>>>>            Until (iTable=0)
36022>>>>>>>>>>>>>        End
36022>>>>>>>>>>>>>>
36022>>>>>>>>>>>>>        Else Error 810 "Illegal attribute passed to TableIntegerArray function"
36024>>>>>>>>>>>>>        Function_Return aTables
36025>>>>>>>>>>>>>    End_Function
36026>>>>>>>>>>>>>    
36026>>>>>>>>>>>>>    Function TableArrayNameToNumber String[] aTableNames Returns Integer[]
36029>>>>>>>>>>>>>        Integer[] aTables
36030>>>>>>>>>>>>>        Integer iMax iItem
36030>>>>>>>>>>>>>        Move (SizeOfArray(aTableNames)-1) to iMax
36031>>>>>>>>>>>>>        For iItem from 0 to iMax
36037>>>>>>>>>>>>>>
36037>>>>>>>>>>>>>            Get TableNameToNumber aTableNames[iItem] to aTables[iItem]
36038>>>>>>>>>>>>>        Loop     
36039>>>>>>>>>>>>>>
36039>>>>>>>>>>>>>        Function_Return aTables
36040>>>>>>>>>>>>>    End_Function
36041>>>>>>>>>>>>>    
36041>>>>>>>>>>>>>    //> Function TempFilelistEntry returns the first table number larger than iTable that may be used to temporarily open a table.
36041>>>>>>>>>>>>>    Function TempFilelistEntry Integer iTable Returns Integer
36044>>>>>>>>>>>>>        Boolean bOpen
36044>>>>>>>>>>>>>        Repeat
36044>>>>>>>>>>>>>>
36044>>>>>>>>>>>>>            Get_Attribute DF_FILE_NEXT_EMPTY of iTable to iTable
36047>>>>>>>>>>>>>            If (iTable>0) Begin
36049>>>>>>>>>>>>>                Get_Attribute DF_FILE_OPENED of iTable to bOpen
36052>>>>>>>>>>>>>            End
36052>>>>>>>>>>>>>>
36052>>>>>>>>>>>>>        Until (iTable=0 or not(bOpen))
36054>>>>>>>>>>>>>        Function_Return iTable
36055>>>>>>>>>>>>>    End_Function
36056>>>>>>>>>>>>>
36056>>>>>>>>>>>>>    Function TableOpenState Integer iTable Returns tTableOpenState
36059>>>>>>>>>>>>>        Boolean bIsOpen
36059>>>>>>>>>>>>>        tTableOpenState stRval
36059>>>>>>>>>>>>>        tTableOpenState stRval
36059>>>>>>>>>>>>>        Move iTable to stRval.iTable
36060>>>>>>>>>>>>>        Get TableDriver iTable to stRval.iDriver
36061>>>>>>>>>>>>>        If (stRval.iDriver<>TD_DRIVER_ERROR) Begin
36063>>>>>>>>>>>>>            Move True to stRval.bOpen
36064>>>>>>>>>>>>>            Get_Attribute DF_FILE_OPEN_MODE     of iTable to stRval.iShareMode // DF_SHARE, DF_EXCLUSIVE
36067>>>>>>>>>>>>>            Get_Attribute DF_FILE_MODE          of iTable to stRval.iFileMode  // DF_FILE_ALIAS_DEFAULT, DF_FILE_IS_MASTER, DF_FILE_IS_ALIAS
36070>>>>>>>>>>>>>            Get_Attribute DF_FILE_ALIAS         of iTable to stRval.iAliasMode // DF_FILEMODE_DEFAULT, DF_FILEMODE_NO_REREAD etc etc etc
36073>>>>>>>>>>>>>            Get_Attribute DF_FILE_PHYSICAL_NAME of iTable to stRval.sPhysName  // Runtimes idea of the root name of the file
36076>>>>>>>>>>>>>        End
36076>>>>>>>>>>>>>>
36076>>>>>>>>>>>>>        Else Begin
36077>>>>>>>>>>>>>            Move False to stRval
36078>>>>>>>>>>>>>        End
36078>>>>>>>>>>>>>>
36078>>>>>>>>>>>>>        Function_Return stRval
36079>>>>>>>>>>>>>    End_Function
36080>>>>>>>>>>>>>
36080>>>>>>>>>>>>>    Function TableOpenStates Returns tTableOpenState[]
36083>>>>>>>>>>>>>        Integer iTable iItem
36083>>>>>>>>>>>>>        tTableOpenState[] aTables
36083>>>>>>>>>>>>>        tTableOpenState[] aTables
36084>>>>>>>>>>>>>        Move 0 to iTable
36085>>>>>>>>>>>>>        Move 0 to iItem
36086>>>>>>>>>>>>>        Repeat
36086>>>>>>>>>>>>>>
36086>>>>>>>>>>>>>            Get_Attribute DF_FILE_NEXT_OPENED of iTable to iTable
36089>>>>>>>>>>>>>            If (iTable<>0) Begin
36091>>>>>>>>>>>>>                Get TableOpenState iTable to aTables[iItem]
36092>>>>>>>>>>>>>                Increment iItem
36093>>>>>>>>>>>>>            End
36093>>>>>>>>>>>>>>
36093>>>>>>>>>>>>>        Until (iTable=0)
36095>>>>>>>>>>>>>        Function_Return aTables
36096>>>>>>>>>>>>>    End_Function
36097>>>>>>>>>>>>>
36097>>>>>>>>>>>>>//    Function IsTableEntryAvailable Integer iTable Returns Boolean
36097>>>>>>>>>>>>>//        Boolean bOpen bIsAvailable
36097>>>>>>>>>>>>>//        String sRoot
36097>>>>>>>>>>>>>//        Get_Attribute DF_FILE_OPENED of iTable to bOpen
36097>>>>>>>>>>>>>//        If (bOpen) Begin
36097>>>>>>>>>>>>>//            Move False to bIsAvailable
36097>>>>>>>>>>>>>//        End
36097>>>>>>>>>>>>>//        Else Begin
36097>>>>>>>>>>>>>//            Get_Attribute DF_FILE_ROOT_NAME of iTable to sRoot
36097>>>>>>>>>>>>>//            Move (sRoot="") to bIsAvailable
36097>>>>>>>>>>>>>//        End
36097>>>>>>>>>>>>>//        Function_Return bIsAvailable
36097>>>>>>>>>>>>>//    End_Function
36097>>>>>>>>>>>>>//
36097>>>>>>>>>>>>>
36097>>>>>>>>>>>>>    Function SetTableOpenState tTableOpenState stOpenState Boolean bQuiet Boolean bIgnorePhysicalName Returns Boolean
36100>>>>>>>>>>>>>        Boolean bOpen
36100>>>>>>>>>>>>>        Close stOpenState.iTable // Apparantly doesn't fail if table isn't open
36101>>>>>>>>>>>>>        If (stOpenState.bOpen) Begin
36103>>>>>>>>>>>>>            Get OpenTable of oTableAccessFunctions stOpenState.iTable stOpenState.iShareMode 0 to bOpen
36104>>>>>>>>>>>>>            If (bOpen) Begin
36106>>>>>>>>>>>>>                Set_Attribute DF_FILE_ALIAS of stOpenState.iTable to stOpenState.iAliasMode // DF_FILE_ALIAS_DEFAULT, DF_FILE_IS_MASTER, DF_FILE_IS_ALIAS
36109>>>>>>>>>>>>>                Set_Attribute DF_FILE_MODE  of stOpenState.iTable to stOpenState.iFileMode  // DF_FILEMODE_DEFAULT, DF_FILEMODE_NO_REREAD etc etc etc
36112>>>>>>>>>>>>>            End
36112>>>>>>>>>>>>>>
36112>>>>>>>>>>>>>            Function_Return bOpen
36113>>>>>>>>>>>>>        End
36113>>>>>>>>>>>>>>
36113>>>>>>>>>>>>>        Function_Return True
36114>>>>>>>>>>>>>    End_Function
36115>>>>>>>>>>>>>    
36115>>>>>>>>>>>>>    Function SetTableOpenStates tTableOpenState[] aOpenStates Boolean bQuiet Boolean bIgnorePhysicalName Returns Boolean
36118>>>>>>>>>>>>>        Integer iIndex iMax
36118>>>>>>>>>>>>>        Boolean bOpen bRval
36118>>>>>>>>>>>>>        Move True to bRval
36119>>>>>>>>>>>>>        Move (SizeOfArray(aOpenStates)-1) to iMax
36120>>>>>>>>>>>>>        For iIndex from 0 to iMax
36126>>>>>>>>>>>>>>
36126>>>>>>>>>>>>>            Get SetTableOpenState aOpenStates[iIndex] bQuiet bIgnorePhysicalName to bOpen
36127>>>>>>>>>>>>>            If (not(bOpen)) Begin
36129>>>>>>>>>>>>>                Move False to bRval
36130>>>>>>>>>>>>>            End
36130>>>>>>>>>>>>>>
36130>>>>>>>>>>>>>        Loop
36131>>>>>>>>>>>>>>
36131>>>>>>>>>>>>>        Function_Return bRval
36132>>>>>>>>>>>>>    End_Function
36133>>>>>>>>>>>>>
36133>>>>>>>>>>>>>    // FileModeSjov
36133>>>>>>>>>>>>>
36133>>>>>>>>>>>>>    Struct tTAFileMode
36133>>>>>>>>>>>>>        Integer iTable
36133>>>>>>>>>>>>>        Integer iFileMode
36133>>>>>>>>>>>>>    End_Struct
36133>>>>>>>>>>>>>
36133>>>>>>>>>>>>>    Function TableFileModesSetAll Integer iFileMode Integer[] aExceptTables Returns tTAFileMode[]
36136>>>>>>>>>>>>>        Integer iItem iMax iTable
36136>>>>>>>>>>>>>        Integer[] aOpenTables
36137>>>>>>>>>>>>>        Integer iCount
36137>>>>>>>>>>>>>        tTAFileMode[] aOriginalFileModes
36137>>>>>>>>>>>>>        tTAFileMode[] aOriginalFileModes
36138>>>>>>>>>>>>>        
36138>>>>>>>>>>>>>        Get TableIntegerArray DF_FILE_NEXT_OPENED to aOpenTables
36139>>>>>>>>>>>>>        Move 0 to iCount
36140>>>>>>>>>>>>>        Move (SizeOfArray(aOpenTables)-1) to iMax
36141>>>>>>>>>>>>>        For iItem from 0 to iMax
36147>>>>>>>>>>>>>>
36147>>>>>>>>>>>>>            Move aOpenTables[iItem] to iTable
36148>>>>>>>>>>>>>            If (not(IntegerIsOnStack(oStackFunctions,iTable,aExceptTables))) Begin
36150>>>>>>>>>>>>>                Move iTable to aOriginalFileModes[iCount].iTable
36151>>>>>>>>>>>>>                Get_Attribute DF_FILE_MODE of iTable to aOriginalFileModes[iCount].iFileMode
36154>>>>>>>>>>>>>                Increment iCount
36155>>>>>>>>>>>>>                Set_Attribute DF_FILE_MODE of iTable to iFileMode
36158>>>>>>>>>>>>>            End
36158>>>>>>>>>>>>>>
36158>>>>>>>>>>>>>        Loop
36159>>>>>>>>>>>>>>
36159>>>>>>>>>>>>>        
36159>>>>>>>>>>>>>        Function_Return aOriginalFileModes
36160>>>>>>>>>>>>>    End_Function
36161>>>>>>>>>>>>>    
36161>>>>>>>>>>>>>    Function TableFileModesSetAll2 Integer iFileMode Integer iExceptTable1 Integer iExceptTable2 Integer iExceptTable3 Integer iExceptTable4 Integer iExceptTable5 Returns tTAFileMode[]
36164>>>>>>>>>>>>>        Integer[] aExceptTables
36165>>>>>>>>>>>>>        
36165>>>>>>>>>>>>>        If (num_arguments>1) Move iExceptTable1 to aExceptTables[0]
36168>>>>>>>>>>>>>        If (num_arguments>2) Move iExceptTable2 to aExceptTables[1]
36171>>>>>>>>>>>>>        If (num_arguments>3) Move iExceptTable3 to aExceptTables[2]
36174>>>>>>>>>>>>>        If (num_arguments>4) Move iExceptTable4 to aExceptTables[3]
36177>>>>>>>>>>>>>        If (num_arguments>5) Move iExceptTable5 to aExceptTables[4]
36180>>>>>>>>>>>>>        
36180>>>>>>>>>>>>>        Function_Return (TableFileModesSetAll2(Self))
36181>>>>>>>>>>>>>    End_Function
36182>>>>>>>>>>>>>    
36182>>>>>>>>>>>>>    Procedure TableFileModesRestore tTAFileMode[] aOriginalFileModes
36185>>>>>>>>>>>>>        Integer iItem iMax iTable iFileMode
36185>>>>>>>>>>>>>        Move (SizeOfArray(aOriginalFileModes)-1) to iMax
36186>>>>>>>>>>>>>        for iItem from 0 to iMax
36192>>>>>>>>>>>>>>
36192>>>>>>>>>>>>>            Move aOriginalFileModes[iItem].iTable to iTable
36193>>>>>>>>>>>>>            Move aOriginalFileModes[iItem].iFileMode to iFileMode
36194>>>>>>>>>>>>>            Set_Attribute DF_FILE_MODE of iTable to iFileMode
36197>>>>>>>>>>>>>        Loop
36198>>>>>>>>>>>>>>
36198>>>>>>>>>>>>>    End_Procedure
36199>>>>>>>>>>>>>    
36199>>>>>>>>>>>>>    // End FileModeSjov
36199>>>>>>>>>>>>>    
36199>>>>>>>>>>>>>    //> The function returns true if the file passed in sFilelistPath is a valid filelist.cfg
36199>>>>>>>>>>>>>    Function FilelistOk String sFilelistPath Returns Boolean
36202>>>>>>>>>>>>>        Integer iChannel
36202>>>>>>>>>>>>>        Boolean bSuccess
36202>>>>>>>>>>>>>        String sTest
36202>>>>>>>>>>>>>        Move False to bSuccess
36203>>>>>>>>>>>>>        If (FileExists(oFileFunctions,sFilelistPath)=1) Begin // Must be a file!
36205>>>>>>>>>>>>>            Get DirectInput of oFileFunctions sFilelistPath to iChannel
36206>>>>>>>>>>>>>            If (iChannel>=0) Begin
36208>>>>>>>>>>>>>                Read_Block channel iChannel sTest 12
36210>>>>>>>>>>>>>                Send CloseInput of oFileFunctions iChannel
36211>>>>>>>>>>>>>                If (sTest="filelist.cfg") Begin // This has to be the first 12 characters
36213>>>>>>>>>>>>>                    Move True to bSuccess
36214>>>>>>>>>>>>>                End
36214>>>>>>>>>>>>>>
36214>>>>>>>>>>>>>            End
36214>>>>>>>>>>>>>>
36214>>>>>>>>>>>>>        End
36214>>>>>>>>>>>>>>
36214>>>>>>>>>>>>>        Function_Return bSuccess
36215>>>>>>>>>>>>>    End_Function
36216>>>>>>>>>>>>>
36216>>>>>>>>>>>>>    Function ChangeFilelist String sFilelistPath Returns Boolean
36219>>>>>>>>>>>>>        Boolean bSuccess
36219>>>>>>>>>>>>>        If (FilelistOk(Self,sFilelistPath)) Begin
36221>>>>>>>>>>>>>            Send CloseAll
36222>>>>>>>>>>>>>            Set_Attribute DF_FILELIST_NAME to sFilelistPath
36225>>>>>>>>>>>>>            Set_Attribute DF_OPEN_PATH to (PathToFolder(oFileFunctions,sFilelistPath))
36228>>>>>>>>>>>>>            Move True to bSuccess
36229>>>>>>>>>>>>>        End
36229>>>>>>>>>>>>>>
36229>>>>>>>>>>>>>        Else Begin
36230>>>>>>>>>>>>>            Move False to bSuccess
36231>>>>>>>>>>>>>        End
36231>>>>>>>>>>>>>>
36231>>>>>>>>>>>>>        Function_Return bSuccess
36232>>>>>>>>>>>>>    End_Function
36233>>>>>>>>>>>>>
36233>>>>>>>>>>>>>    Function ChangeDatabase String sNewDataFolder Returns Boolean
36236>>>>>>>>>>>>>        Integer hWS
36236>>>>>>>>>>>>>        Boolean bSuccess
36236>>>>>>>>>>>>>        tTableOpenState[] aOpenStates
36236>>>>>>>>>>>>>        tTableOpenState[] aOpenStates
36237>>>>>>>>>>>>>        Get TableOpenStates of oTableAccessFunctions to aOpenStates
36238>>>>>>>>>>>>>        Get WorkSpaceObject of oWorkSpaceFunctions to hWS
36239>>>>>>>>>>>>>        Close DF_ALL DF_PERMANENT
36240>>>>>>>>>>>>>        If (hWS<>"") Begin
36242>>>>>>>>>>>>>            Set psDataPath of hWS to sNewDataFolder
36243>>>>>>>>>>>>>            Set psFileList of hWS to sNewDataFolder
36244>>>>>>>>>>>>>            Send DoSetPaths of hWS
36245>>>>>>>>>>>>>        End
36245>>>>>>>>>>>>>>
36245>>>>>>>>>>>>>        Else Begin
36246>>>>>>>>>>>>>            Set_Attribute DF_FILELIST_NAME to sNewDataFolder
36249>>>>>>>>>>>>>            Set_Attribute DF_OPEN_PATH     to sNewDataFolder
36252>>>>>>>>>>>>>        End
36252>>>>>>>>>>>>>>
36252>>>>>>>>>>>>>        Get SetTableOpenStates of oTableAccessFunctions aOpenStates False True to bSuccess
36253>>>>>>>>>>>>>        Function_Return bSuccess
36254>>>>>>>>>>>>>    End_Function
36255>>>>>>>>>>>>>
36255>>>>>>>>>>>>>    Procedure FlagTableReadOnly Integer iTable
36258>>>>>>>>>>>>>        Move iTable to FileNumber
36259>>>>>>>>>>>>>        File_Mode Indirect_File READ_ONLY
36263>>>>>>>>>>>>>    End_Procedure
36264>>>>>>>>>>>>>
36264>>>>>>>>>>>>>    Procedure RunDbExplorer String sTableFilePath
36267>>>>>>>>>>>>>        String sDbExplorPath
36267>>>>>>>>>>>>>        Get VdfFolderPath of oFileFunctions VDF_ROOT to sDbExplorPath
36268>>>>>>>>>>>>>        Get AppendPath of oFileFunctions sDbExplorPath "Bin" to sDbExplorPath
36269>>>>>>>>>>>>>        Get AppendPath of oFileFunctions sDbExplorPath "DBExplor.exe" to sDbExplorPath
36270>>>>>>>>>>>>>        Runprogram Background (sDbExplorPath+' -t"'+sTableFilePath+'"')
36271>>>>>>>>>>>>>    End_Procedure
36272>>>>>>>>>>>>>
36272>>>>>>>>>>>>>    Procedure RunVDFXray String sTablePath Integer iTable Integer iColumn
36275>>>>>>>>>>>>>        Runprogram Background ("vdfxray -filelist "+sTablePath+" "+String(iTable)+" "+String(iColumn))
36276>>>>>>>>>>>>>    End_Procedure
36277>>>>>>>>>>>>>
36277>>>>>>>>>>>>>    Procedure RunVDFXrayCurrentFileList Integer iTable Integer iColumn
36280>>>>>>>>>>>>>        String sTablePath
36280>>>>>>>>>>>>>        Get_Attribute DF_FILELIST_NAME to sTablePath
36283>>>>>>>>>>>>>        Send RunVDFXray sTablePath iTable iColumn
36284>>>>>>>>>>>>>    End_Procedure
36285>>>>>>>>>>>>>    
36285>>>>>>>>>>>>>    Procedure RunNewVDFXRay
36288>>>>>>>>>>>>>        RunProgram Background "vdfxray"
36289>>>>>>>>>>>>>    End_Procedure
36290>>>>>>>>>>>>>    
36290>>>>>>>>>>>>>    //> Get "open as" path of filelist entry iTable
36290>>>>>>>>>>>>>    Function TableOpenAsPath Integer iTable Returns String
36293>>>>>>>>>>>>>        Boolean bResolved
36293>>>>>>>>>>>>>        Integer iPos
36293>>>>>>>>>>>>>        String sOpenPath sRootName sOpenAsPath sExt sFolder sDriver
36293>>>>>>>>>>>>>        String sTemp sDriverArray
36293>>>>>>>>>>>>>
36293>>>>>>>>>>>>>        If (iTable>0) Begin
36295>>>>>>>>>>>>>            Move False to bResolved
36296>>>>>>>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of iTable to sRootName
36299>>>>>>>>>>>>>
36299>>>>>>>>>>>>>            // Is root name prefixed by a driver id? (MSSQLDRV:Customer)
36299>>>>>>>>>>>>>            Move (Pos(":",sRootName)) to iPos
36300>>>>>>>>>>>>>            If (iPos>0) Begin
36302>>>>>>>>>>>>>                Move (Uppercase(Left(sRootName,iPos))) to sTemp
36303>>>>>>>>>>>>>                Get JoinString of oStringFunctions (ForeignDriverArray(oTableDriverFunctions)) ":" 0 0 to sDriver
36304>>>>>>>>>>>>>                Move (sDriver+":") to sDriver
36305>>>>>>>>>>>>>                If (Uppercase(sDriver) contains sTemp) Begin
36307>>>>>>>>>>>>>                    // There definately was a driver prefix
36307>>>>>>>>>>>>>                    Move (Left(sRootName,iPos-1)) to sDriver
36308>>>>>>>>>>>>>                    
36308>>>>>>>>>>>>>                    Move (Remove(sRootName,1,iPos)) to sRootName
36309>>>>>>>>>>>>>                    
36309>>>>>>>>>>>>>                    Get PathToType of oFileFunctions sRootName to sExt
36310>>>>>>>>>>>>>                    If (sExt="") Begin
36312>>>>>>>>>>>>>                        Move (sRootName+".int") to sRootName
36313>>>>>>>>>>>>>                    End
36313>>>>>>>>>>>>>>
36313>>>>>>>>>>>>>                    Move True to bResolved
36314>>>>>>>>>>>>>                End
36314>>>>>>>>>>>>>>
36314>>>>>>>>>>>>>            End
36314>>>>>>>>>>>>>>
36314>>>>>>>>>>>>>            
36314>>>>>>>>>>>>>            If (not(bResolved)) Begin
36316>>>>>>>>>>>>>                Get PathToType of oFileFunctions sRootName to sExt
36317>>>>>>>>>>>>>                If (sExt="") begin
36319>>>>>>>>>>>>>                    Move (sRootName+".dat") to sRootName
36320>>>>>>>>>>>>>                End
36320>>>>>>>>>>>>>>
36320>>>>>>>>>>>>>            End
36320>>>>>>>>>>>>>>
36320>>>>>>>>>>>>>
36320>>>>>>>>>>>>>            // Is absolute path included?
36320>>>>>>>>>>>>>            If (sRootName contains ":" or sRootName contains "\") Begin
36322>>>>>>>>>>>>>                // Yes! Don't do a thing. Other than:
36322>>>>>>>>>>>>>                Move sRootName to sOpenAsPath
36323>>>>>>>>>>>>>            End
36323>>>>>>>>>>>>>>
36323>>>>>>>>>>>>>            Else Begin
36324>>>>>>>>>>>>>                Get_Attribute DF_OPEN_PATH to sOpenPath
36327>>>>>>>>>>>>>                Get FindFile of oFileFunctions sRootName sOpenPath to sFolder
36328>>>>>>>>>>>>>                If (sFolder<>"") Begin
36330>>>>>>>>>>>>>                    Get AppendPath of oFileFunctions sFolder sRootName to sOpenAsPath
36331>>>>>>>>>>>>>                End
36331>>>>>>>>>>>>>>
36331>>>>>>>>>>>>>                Else Begin
36332>>>>>>>>>>>>>                    Move sRootName to sOpenAsPath
36333>>>>>>>>>>>>>                End
36333>>>>>>>>>>>>>>
36333>>>>>>>>>>>>>            End
36333>>>>>>>>>>>>>>
36333>>>>>>>>>>>>>        End
36333>>>>>>>>>>>>>>
36333>>>>>>>>>>>>>        Function_Return sOpenAsPath
36334>>>>>>>>>>>>>    End_Function
36335>>>>>>>>>>>>>
36335>>>>>>>>>>>>>    Function FieldNameToNumber Integer iTable String sName Returns Integer
36338>>>>>>>>>>>>>        Integer iMax iField
36338>>>>>>>>>>>>>        String sFieldName
36338>>>>>>>>>>>>>        Move (Lowercase(sName)) to sName
36339>>>>>>>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iTable to iMax
36342>>>>>>>>>>>>>        For iField from 1 to iMax
36348>>>>>>>>>>>>>>
36348>>>>>>>>>>>>>            Get_Attribute DF_FIELD_NAME of iTable iField to sFieldName
36351>>>>>>>>>>>>>            If (sName=Lowercase(sFieldName)) Begin
36353>>>>>>>>>>>>>                Function_Return iField
36354>>>>>>>>>>>>>            End
36354>>>>>>>>>>>>>>
36354>>>>>>>>>>>>>        Loop
36355>>>>>>>>>>>>>>
36355>>>>>>>>>>>>>        If (sName="recnum") Begin
36357>>>>>>>>>>>>>            Function_Return 0
36358>>>>>>>>>>>>>        End
36358>>>>>>>>>>>>>>
36358>>>>>>>>>>>>>        Function_Return -1 // not found
36359>>>>>>>>>>>>>    End_Function
36360>>>>>>>>>>>>>
36360>>>>>>>>>>>>>    Function TableNameToNumber String sLogicalName Returns Integer
36363>>>>>>>>>>>>>        Integer iTable
36363>>>>>>>>>>>>>        String sValue
36363>>>>>>>>>>>>>        Move (Uppercase(sLogicalName)) to sLogicalName
36364>>>>>>>>>>>>>        Move 0 to iTable
36365>>>>>>>>>>>>>        Repeat
36365>>>>>>>>>>>>>>
36365>>>>>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of iTable to iTable
36368>>>>>>>>>>>>>            If (iTable<>0) Begin
36370>>>>>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of iTable to sValue
36373>>>>>>>>>>>>>                If (sLogicalName=Uppercase(sValue)) Begin
36375>>>>>>>>>>>>>                    Function_Return iTable
36376>>>>>>>>>>>>>                End
36376>>>>>>>>>>>>>>
36376>>>>>>>>>>>>>            End
36376>>>>>>>>>>>>>>
36376>>>>>>>>>>>>>        Until (iTable=0)
36378>>>>>>>>>>>>>
36378>>>>>>>>>>>>>        Function_Return -1
36379>>>>>>>>>>>>>    End_Function
36380>>>>>>>>>>>>>    
36380>>>>>>>>>>>>>    Function FieldNumberMirror Integer iColumn Returns Integer // Get FieldNumberMirror of oTableAccessFunctions field Customer.Name to iFieldName
36383>>>>>>>>>>>>>        Function_Return iColumn
36384>>>>>>>>>>>>>    End_Function
36385>>>>>>>>>>>>>
36385>>>>>>>>>>>>>    Function FieldName Integer iTable Integer iField Boolean bInclTableName Returns String
36388>>>>>>>>>>>>>        String sColumnName sTableName
36388>>>>>>>>>>>>>        If (iField<0) Begin
36390>>>>>>>>>>>>>            Function_Return ""
36391>>>>>>>>>>>>>        End
36391>>>>>>>>>>>>>>
36391>>>>>>>>>>>>>        Get_Attribute DF_FIELD_NAME of iTable iField to sColumnName
36394>>>>>>>>>>>>>        If (iField=0 and sColumnName="") Begin
36396>>>>>>>>>>>>>            Move "Recnum" to sColumnName
36397>>>>>>>>>>>>>        End
36397>>>>>>>>>>>>>>
36397>>>>>>>>>>>>>        If (bInclTableName and sColumnName<>"") Begin
36399>>>>>>>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of iTable to sTableName
36402>>>>>>>>>>>>>            Move (sTableName+"."+sColumnName) to sColumnName
36403>>>>>>>>>>>>>        End
36403>>>>>>>>>>>>>>
36403>>>>>>>>>>>>>        Function_Return sColumnName
36404>>>>>>>>>>>>>    End_Function
36405>>>>>>>>>>>>>
36405>>>>>>>>>>>>>    Function FieldValue Integer iTable Integer iField Returns String
36408>>>>>>>>>>>>>        String sValue
36408>>>>>>>>>>>>>        If (iField>=1) Begin
36410>>>>>>>>>>>>>            Get_Field_Value iTable iField to sValue
36413>>>>>>>>>>>>>        End
36413>>>>>>>>>>>>>>
36413>>>>>>>>>>>>>        Else Begin
36414>>>>>>>>>>>>>            Move "Error" to sValue
36415>>>>>>>>>>>>>            Error 251 "Field index out of range"
36416>>>>>>>>>>>>>>
36416>>>>>>>>>>>>>        End
36416>>>>>>>>>>>>>>
36416>>>>>>>>>>>>>        Function_Return sValue
36417>>>>>>>>>>>>>    End_Function
36418>>>>>>>>>>>>>    
36418>>>>>>>>>>>>>    Function FieldNameValue Integer iTable String sName Returns String
36421>>>>>>>>>>>>>        Integer iField
36421>>>>>>>>>>>>>        Get FieldNameToNumber iTable sName to iField
36422>>>>>>>>>>>>>        Function_Return (FieldValue(Self,iTable,iField))
36423>>>>>>>>>>>>>    End_Function
36424>>>>>>>>>>>>>    
36424>>>>>>>>>>>>>    Procedure Set FieldNameValue Integer iTable String sName String sValue
36427>>>>>>>>>>>>>        Integer iField
36427>>>>>>>>>>>>>        Get FieldNameToNumber iTable sName to iField
36428>>>>>>>>>>>>>        Set_Field_Value iTable iField to sValue
36431>>>>>>>>>>>>>    End_Procedure
36432>>>>>>>>>>>>>
36432>>>>>>>>>>>>>    Function StripPathAndDriverFromTableRootName String sRoot Returns String
36435>>>>>>>>>>>>>        Integer iPos
36435>>>>>>>>>>>>>        Get rPos of oStringFunctions "\" sRoot to iPos
36436>>>>>>>>>>>>>        If (iPos>0) Begin
36438>>>>>>>>>>>>>            Move (Remove(sRoot,1,iPos)) to sRoot
36439>>>>>>>>>>>>>        End
36439>>>>>>>>>>>>>>
36439>>>>>>>>>>>>>        Get rPos of oStringFunctions ":" sRoot to iPos
36440>>>>>>>>>>>>>        If (iPos>0) Begin
36442>>>>>>>>>>>>>            Move (Remove(sRoot,1,iPos)) to sRoot
36443>>>>>>>>>>>>>        End
36443>>>>>>>>>>>>>>
36443>>>>>>>>>>>>>        Get PathStripType of oFileFunctions sRoot to sRoot
36444>>>>>>>>>>>>>        Function_Return sRoot
36445>>>>>>>>>>>>>    End_Function
36446>>>>>>>>>>>>>    
36446>>>>>>>>>>>>>//    Function TableDriver Integer iTable Returns String
36446>>>>>>>>>>>>>//        
36446>>>>>>>>>>>>>//    End_Function
36446>>>>>>>>>>>>>
36446>>>>>>>>>>>>>    Function FieldTypeText Integer iType Integer iTextType Returns String
36449>>>>>>>>>>>>>        If (iTextType=0) Begin
36451>>>>>>>>>>>>>            If (iType=DF_ASCII   ) Function_Return "ASCII"
36454>>>>>>>>>>>>>            If (iType=DF_BCD     ) Function_Return "Number"
36457>>>>>>>>>>>>>            If (iType=DF_DATE    ) Function_Return "Date"
36460>>>>>>>>>>>>>            If (iType=DF_DATETIME) Function_Return "DateTime"
36463>>>>>>>>>>>>>            If (iType=DF_OVERLAP ) Function_Return "Overlap"
36466>>>>>>>>>>>>>            If (iType=DF_TEXT    ) Function_Return "Text"
36469>>>>>>>>>>>>>            If (iType=DF_BINARY  ) Function_Return "Binary"
36472>>>>>>>>>>>>>            Function_Return "Type Unknown"
36473>>>>>>>>>>>>>        End
36473>>>>>>>>>>>>>>
36473>>>>>>>>>>>>>        If (iTextType=1) Begin
36475>>>>>>>>>>>>>            If (iType=DF_ASCII   ) Function_Return "ASC"
36478>>>>>>>>>>>>>            If (iType=DF_BCD     ) Function_Return "NUM"
36481>>>>>>>>>>>>>            If (iType=DF_DATE    ) Function_Return "DAT"
36484>>>>>>>>>>>>>            If (iType=DF_DATETIME) Function_Return "DT"
36487>>>>>>>>>>>>>            If (iType=DF_OVERLAP ) Function_Return "OVE"
36490>>>>>>>>>>>>>            If (iType=DF_TEXT    ) Function_Return "TXT"
36493>>>>>>>>>>>>>            If (iType=DF_BINARY  ) Function_Return "BIN"
36496>>>>>>>>>>>>>            Function_Return "???"
36497>>>>>>>>>>>>>        End
36497>>>>>>>>>>>>>>
36497>>>>>>>>>>>>>        If (iTextType=2) Begin
36499>>>>>>>>>>>>>            If (iType=DF_ASCII   ) Function_Return "DF_ASCII"
36502>>>>>>>>>>>>>            If (iType=DF_BCD     ) Function_Return "DF_BCD"
36505>>>>>>>>>>>>>            If (iType=DF_DATE    ) Function_Return "DF_DATE"
36508>>>>>>>>>>>>>            If (iType=DF_DATETIME) Function_Return "DF_DATETIME"
36511>>>>>>>>>>>>>            If (iType=DF_OVERLAP ) Function_Return "DF_OVERLAP"
36514>>>>>>>>>>>>>            If (iType=DF_TEXT    ) Function_Return "DF_TEXT"
36517>>>>>>>>>>>>>            If (iType=DF_BINARY  ) Function_Return "DF_BINARY"
36520>>>>>>>>>>>>>            Function_Return "Type Unknown"
36521>>>>>>>>>>>>>        End
36521>>>>>>>>>>>>>>
36521>>>>>>>>>>>>>    End_Function
36522>>>>>>>>>>>>>
36522>>>>>>>>>>>>>    Function FieldLengthText Integer iType Integer iLen Integer iPrec Returns String
36525>>>>>>>>>>>>>        String sRval
36525>>>>>>>>>>>>>        Move iLen to sRval
36526>>>>>>>>>>>>>        If (iType=DF_BCD) Begin
36528>>>>>>>>>>>>>            Move "#.#" to sRval
36529>>>>>>>>>>>>>            Move (Replace("#",sRval,iLen-iPrec)) to sRval
36530>>>>>>>>>>>>>            Move (Replace("#",sRval,iPrec)) to sRval
36531>>>>>>>>>>>>>        End
36531>>>>>>>>>>>>>>
36531>>>>>>>>>>>>>        Function_Return sRval
36532>>>>>>>>>>>>>    End_Function
36533>>>>>>>>>>>>>
36533>>>>>>>>>>>>>
36533>>>>>>>>>>>>>    Define C_LegalColumnNameFirstLetters      for "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
36533>>>>>>>>>>>>>    Define C_LegalColumnNameSucceedingLetters for "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_#@"
36533>>>>>>>>>>>>>
36533>>>>>>>>>>>>>    Function IsLegalColumnName String sName Returns Boolean
36536>>>>>>>>>>>>>        Integer iLen iPos
36536>>>>>>>>>>>>>        String sChar
36536>>>>>>>>>>>>>        Move (Trim(Uppercase(sName))) to sName
36537>>>>>>>>>>>>>        Move (Length(sName)) to iLen
36538>>>>>>>>>>>>>        If (iLen>0 and iLen<=15) Begin
36540>>>>>>>>>>>>>            For iPos from 1 to iLen
36546>>>>>>>>>>>>>>
36546>>>>>>>>>>>>>                Move (Mid(sName,1,iPos)) to sChar
36547>>>>>>>>>>>>>                If (iPos=1) Begin
36549>>>>>>>>>>>>>                    If (not(C_LegalColumnNameFirstLetters contains sChar)) Begin
36551>>>>>>>>>>>>>                        Function_Return False
36552>>>>>>>>>>>>>                    End
36552>>>>>>>>>>>>>>
36552>>>>>>>>>>>>>                End
36552>>>>>>>>>>>>>>
36552>>>>>>>>>>>>>                Else Begin
36553>>>>>>>>>>>>>                    If (not(C_LegalColumnNameSucceedingLetters contains sChar)) Begin
36555>>>>>>>>>>>>>                        Function_Return False
36556>>>>>>>>>>>>>                    End
36556>>>>>>>>>>>>>>
36556>>>>>>>>>>>>>                End
36556>>>>>>>>>>>>>>
36556>>>>>>>>>>>>>            Loop
36557>>>>>>>>>>>>>>
36557>>>>>>>>>>>>>            Function_Return True
36558>>>>>>>>>>>>>        End
36558>>>>>>>>>>>>>>
36558>>>>>>>>>>>>>        Function_Return False
36559>>>>>>>>>>>>>    End_Function
36560>>>>>>>>>>>>>    
36560>>>>>>>>>>>>>    //> Returns something that can be used with vfind command. -1 is returned of no index can me found
36560>>>>>>>>>>>>>    Function AnyIndex Integer iTable Returns Integer
36563>>>>>>>>>>>>>        Integer iTableIndex iTableIndexMax
36563>>>>>>>>>>>>>        Integer iSegments iIndexType
36563>>>>>>>>>>>>>        String sDriver
36563>>>>>>>>>>>>>        Boolean bEmbedded
36563>>>>>>>>>>>>>        
36563>>>>>>>>>>>>>        Get_Attribute DF_FILE_DRIVER of iTable to sDriver
36566>>>>>>>>>>>>>        Move (sDriver="DATAFLEX") to bEmbedded
36567>>>>>>>>>>>>>        If (bEmbedded) Begin
36569>>>>>>>>>>>>>            Function_Return 0
36570>>>>>>>>>>>>>        End
36570>>>>>>>>>>>>>>
36570>>>>>>>>>>>>>        
36570>>>>>>>>>>>>>        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of iTable to iTableIndexMax
36573>>>>>>>>>>>>>        For iTableIndex from 1 to iTableIndexMax
36579>>>>>>>>>>>>>>
36579>>>>>>>>>>>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of iTable iTableIndex to iSegments
36582>>>>>>>>>>>>>            If (iSegments>0) Begin
36584>>>>>>>>>>>>>                Get_Attribute DF_INDEX_TYPE of iTable iTableIndex to iIndexType
36587>>>>>>>>>>>>>                If (iIndexType<>DF_INDEX_TYPE_BATCH) Begin
36589>>>>>>>>>>>>>                    Function_Return iTableIndex
36590>>>>>>>>>>>>>                End
36590>>>>>>>>>>>>>>
36590>>>>>>>>>>>>>            End
36590>>>>>>>>>>>>>>
36590>>>>>>>>>>>>>        Loop
36591>>>>>>>>>>>>>>
36591>>>>>>>>>>>>>        Function_Return -1 // vfind can't be used with this table
36592>>>>>>>>>>>>>    End_Function
36593>>>>>>>>>>>>>
36593>>>>>>>>>>>>>    Function IndexColumns Integer iTable Integer iIndex Returns Integer[]
36596>>>>>>>>>>>>>        Integer iSegmentMax iSegmentIndex
36596>>>>>>>>>>>>>        Integer[] aColumns
36597>>>>>>>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of iTable iIndex to iSegmentMax
36600>>>>>>>>>>>>>        If (iSegmentIndex>=1) Begin
36602>>>>>>>>>>>>>            For iSegmentIndex from 1 to iSegmentMax
36608>>>>>>>>>>>>>>
36608>>>>>>>>>>>>>                Get_Attribute DF_INDEX_SEGMENT_FIELD of iTable iIndex iSegmentIndex to aColumns[SizeOfArray(aColumns)]
36611>>>>>>>>>>>>>            Loop
36612>>>>>>>>>>>>>>
36612>>>>>>>>>>>>>        End
36612>>>>>>>>>>>>>>
36612>>>>>>>>>>>>>        Function_Return aColumns
36613>>>>>>>>>>>>>    End_Function
36614>>>>>>>>>>>>>    
36614>>>>>>>>>>>>>    Function PrimaryIndex Integer iTable Returns Integer
36617>>>>>>>>>>>>>        Integer iIndex
36617>>>>>>>>>>>>>        Get_Attribute DF_FILE_PRIMARY_INDEX of iTable to iIndex
36620>>>>>>>>>>>>>        Function_Return iIndex
36621>>>>>>>>>>>>>    End_Function
36622>>>>>>>>>>>>>    
36622>>>>>>>>>>>>>    Function RecordIdentityColumns Integer iTable Returns Integer[]
36625>>>>>>>>>>>>>    End_Function
36626>>>>>>>>>>>>>    
36626>>>>>>>>>>>>>    Function ColumnValues Integer iTable Integer[] aColumns Returns String[]
36629>>>>>>>>>>>>>        Integer iMax iIndex iColumn
36629>>>>>>>>>>>>>        String sValue
36629>>>>>>>>>>>>>        String[] aValues
36630>>>>>>>>>>>>>        Move (SizeOfArray(aColumns)-1) to iMax
36631>>>>>>>>>>>>>        For iIndex from 0 to iMax
36637>>>>>>>>>>>>>>
36637>>>>>>>>>>>>>            Move aColumns[iIndex] to iColumn
36638>>>>>>>>>>>>>            Get_Field_Value iTable iColumn to sValue
36641>>>>>>>>>>>>>            Move (Rtrim(sValue)) to aValues[iIndex]
36642>>>>>>>>>>>>>        Loop
36643>>>>>>>>>>>>>>
36643>>>>>>>>>>>>>        Function_Return aValues
36644>>>>>>>>>>>>>    End_Function
36645>>>>>>>>>>>>>    
36645>>>>>>>>>>>>>    Function DriversLoaded Returns Integer[]
36648>>>>>>>>>>>>>        Integer iDriverIndex iDriverMax
36648>>>>>>>>>>>>>        Integer[] aDrivers
36649>>>>>>>>>>>>>        String sDll
36649>>>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iDriverMax
36652>>>>>>>>>>>>>        For iDriverIndex from 1 to iDriverMax
36658>>>>>>>>>>>>>>
36658>>>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriverIndex to sDll
36661>>>>>>>>>>>>>            Get DriverDllToId of oTableDriverFunctions sDll to aDrivers[iDriverIndex-1]
36662>>>>>>>>>>>>>        Loop
36663>>>>>>>>>>>>>>
36663>>>>>>>>>>>>>        Function_Return aDrivers
36664>>>>>>>>>>>>>    End_Function
36665>>>>>>>>>>>>>    
36665>>>>>>>>>>>>>    Function DriversListedInFilelistCfg Returns Integer[] 
36668>>>>>>>>>>>>>        Integer iMax iIndex iDriver
36668>>>>>>>>>>>>>        Integer[] aTables aDrivers 
36670>>>>>>>>>>>>>        Get TableIntegerArray DF_FILE_NEXT_USED to aTables
36671>>>>>>>>>>>>>        Move (SizeOfArray(aTables)-1) to iMax
36672>>>>>>>>>>>>>        for iIndex from 0 to iMax
36678>>>>>>>>>>>>>>
36678>>>>>>>>>>>>>            Get TableDriver aTables[iIndex] to iDriver
36679>>>>>>>>>>>>>            If (not(IntegerIsOnStack(oStackFunctions,iDriver,aDrivers))) Begin
36681>>>>>>>>>>>>>                Send IntegerPush of oStackFunctions iDriver (&aDrivers)
36682>>>>>>>>>>>>>            End
36682>>>>>>>>>>>>>>
36682>>>>>>>>>>>>>        Loop
36683>>>>>>>>>>>>>>
36683>>>>>>>>>>>>>        Function_Return aDrivers
36684>>>>>>>>>>>>>    End_Function
36685>>>>>>>>>>>>>    
36685>>>>>>>>>>>>>End_Object // oTableAccessFunctions
36686>>>>>>>>>>>Use StackFunctions.pkg // Define oStackFunctions object
36686>>>>>>>>>>>Use RelationMapStruct.pkg // tRelationsDrawingMapItem struct
36686>>>>>>>>>>>Use TableDriverFunctions.pkg
36686>>>>>>>>>>>Use StringFunctions.pkg // Define oStringFunctions object
36686>>>>>>>>>>>
36686>>>>>>>>>>>Use cli.pkg
36686>>>>>>>>>>>
36686>>>>>>>>>>>Enum_List // Attribute types
36686>>>>>>>>>>>    Define ATYPE_NONE      // Not an attribute type
36686>>>>>>>>>>>    Define ATYPE_GLOBAL    // No parameters
36686>>>>>>>>>>>    Define ATYPE_DRIVER    // 1: Driver number
36686>>>>>>>>>>>    Define ATYPE_DRVSRV    // 1: Driver number  2: Server number
36686>>>>>>>>>>>    Define ATYPE_FILELIST  // 1: File  (No record buffer access, filelist only)
36686>>>>>>>>>>>    Define ATYPE_FILE      // 1: File
36686>>>>>>>>>>>    Define ATYPE_FIELD     // 1: File   2: Field
36686>>>>>>>>>>>    Define ATYPE_INDEX     // 1: File   2: Index
36686>>>>>>>>>>>    Define ATYPE_IDXSEG    // 1: File   2: Index   3: Segment
36686>>>>>>>>>>>    Define ATYPE_SPECIAL   // 1: File 2/3: Field/Field  (overlap check)
36686>>>>>>>>>>>    Define ATYPE_FLSTNAV   // 1: File (for navigating filelist)
36686>>>>>>>>>>>End_Enum_List
36686>>>>>>>>>>>
36686>>>>>>>>>>>//Enum_List // Calculated table attributes
36686>>>>>>>>>>>//    Define CTA_HAS_UNIQUE_INDEX
36686>>>>>>>>>>>//    Define CTA_HAS_UNIQUE_ONE_COLUMN_INDEX
36686>>>>>>>>>>>//    Define CTA_RELATES_BY_RECNUM
36686>>>>>>>>>>>//    Define CTA_HAS_OVERLAP_COLUMNS
36686>>>>>>>>>>>//End_Enum_List
36686>>>>>>>>>>>
36686>>>>>>>>>>>Struct tAttributeType
36686>>>>>>>>>>>    String  sName
36686>>>>>>>>>>>    Integer iParamCount
36686>>>>>>>>>>>    Integer iAttrNextAvailableIndex // array index that is
36686>>>>>>>>>>>End_Struct
36686>>>>>>>>>>>
36686>>>>>>>>>>>Struct tAttributeDiscreteValue
36686>>>>>>>>>>>    Integer iValue       // Actual attribute value
36686>>>>>>>>>>>    String  sCodeValue   // Value as written in source code
36686>>>>>>>>>>>    String  sDisplayName // Value as presented to an unknowing user
36686>>>>>>>>>>>End_Struct
36686>>>>>>>>>>>
36686>>>>>>>>>>>Struct tAttributeDefinition
36686>>>>>>>>>>>    String sName
36686>>>>>>>>>>>    Integer iAttrType              // Attribute type
36686>>>>>>>>>>>    String sDisplayName            // Attribute display name
36686>>>>>>>>>>>    Boolean bWrite                 // Write access?
36686>>>>>>>>>>>    Boolean bDawOnly               // Internal DAW use
36686>>>>>>>>>>>    Integer iValueType             // DF_BCD or DF_ASCII
36686>>>>>>>>>>>    Boolean bRuntimeOnly           // Runtime only attribute (FILE attr)
36686>>>>>>>>>>>    Boolean bDriverOnly            // Only query this (table-) attribute when driver is in use
36686>>>>>>>>>>>    tAttributeDiscreteValue[] aLegalValues // Legal values
36686>>>>>>>>>>>    tAttributeDiscreteValue[] aLegalValues // Legal values
36686>>>>>>>>>>>End_Struct
36686>>>>>>>>>>>
36686>>>>>>>>>>>Struct tAttributeValue
36686>>>>>>>>>>>    String  sValue
36686>>>>>>>>>>>End_Struct
36686>>>>>>>>>>>
36686>>>>>>>>>>>Global_Variable tAttributeValue[] gaEmptyAttributes
36686>>>>>>>>>>>
36686>>>>>>>>>>>Struct tFieldAttributes
36686>>>>>>>>>>>    tAttributeValue[] aFieldAttributes
36686>>>>>>>>>>>    tAttributeValue[] aFieldAttributes
36686>>>>>>>>>>>End_Struct
36686>>>>>>>>>>>
36686>>>>>>>>>>>Struct tIndexSegmentAttributes
36686>>>>>>>>>>>    tAttributeValue[] aIndexSegmentAttributes
36686>>>>>>>>>>>    tAttributeValue[] aIndexSegmentAttributes
36686>>>>>>>>>>>End_Struct
36686>>>>>>>>>>>
36686>>>>>>>>>>>Struct tIndexAttributes
36686>>>>>>>>>>>    tAttributeValue[] aIndexAttributes
36686>>>>>>>>>>>    tAttributeValue[] aIndexAttributes
36686>>>>>>>>>>>    tIndexSegmentAttributes[] aSegments
36686>>>>>>>>>>>    tIndexSegmentAttributes[] aSegments
36686>>>>>>>>>>>End_Struct
36686>>>>>>>>>>>
36686>>>>>>>>>>>Struct tTableAttributes
36686>>>>>>>>>>>    Integer iReadFromFileListEntryNo
36686>>>>>>>>>>>    String  sOpenAsPath
36686>>>>>>>>>>>    tAttributeValue[] aTableAttributes
36686>>>>>>>>>>>    tAttributeValue[] aTableAttributes
36686>>>>>>>>>>>    tFieldAttributes[] aFields
36686>>>>>>>>>>>    tFieldAttributes[] aFields
36686>>>>>>>>>>>    tIndexAttributes[] aIndices
36686>>>>>>>>>>>    tIndexAttributes[] aIndices
36686>>>>>>>>>>>End_Struct
36686>>>>>>>>>>>
36686>>>>>>>>>>>Struct tDataBaseServer
36686>>>>>>>>>>>    tAttributeValue[] aServerAttributes
36686>>>>>>>>>>>    tAttributeValue[] aServerAttributes
36686>>>>>>>>>>>End_Struct
36686>>>>>>>>>>>
36686>>>>>>>>>>>Struct tDataBaseDriver
36686>>>>>>>>>>>    tAttributeValue[] aDriverAttributes
36686>>>>>>>>>>>    tAttributeValue[] aDriverAttributes
36686>>>>>>>>>>>    tDataBaseServer[] aServers
36686>>>>>>>>>>>    tDataBaseServer[] aServers
36686>>>>>>>>>>>End_Struct
36686>>>>>>>>>>>
36686>>>>>>>>>>>Struct tFileList
36686>>>>>>>>>>>    tAttributeValue[] aGlobalAttributes
36686>>>>>>>>>>>    tAttributeValue[] aGlobalAttributes
36686>>>>>>>>>>>    tDataBaseDriver[] aDrivers
36686>>>>>>>>>>>    tDataBaseDriver[] aDrivers
36686>>>>>>>>>>>    tTableAttributes[] aTables
36686>>>>>>>>>>>    tTableAttributes[] aTables
36686>>>>>>>>>>>End_Struct
36686>>>>>>>>>>>
36686>>>>>>>>>>>Struct tTableField // Arg! This should have been named tTableIndexColumn
36686>>>>>>>>>>>    Integer iTable
36686>>>>>>>>>>>    Integer iField
36686>>>>>>>>>>>    Boolean bCapslock
36686>>>>>>>>>>>    Boolean bDescending
36686>>>>>>>>>>>End_Struct
36686>>>>>>>>>>>
36686>>>>>>>>>>>Struct tTableRelation
36686>>>>>>>>>>>    Integer iFromTable
36686>>>>>>>>>>>    Integer iToTable
36686>>>>>>>>>>>    tTableField[] aFromFields
36686>>>>>>>>>>>    tTableField[] aFromFields
36686>>>>>>>>>>>    tTableField[] aToFields
36686>>>>>>>>>>>    tTableField[] aToFields
36686>>>>>>>>>>>    Boolean bFunctioning // Relation sufficient for finding parent record
36686>>>>>>>>>>>    Integer[] aChildIndices // Indices that may be used for querying the child table records filtered by this relation
36686>>>>>>>>>>>End_Struct
36686>>>>>>>>>>>
36686>>>>>>>>>>>Struct tTableFieldExplicit
36686>>>>>>>>>>>    Integer iPosition
36686>>>>>>>>>>>    String  sName
36686>>>>>>>>>>>    Integer iType
36686>>>>>>>>>>>    Integer iLen
36686>>>>>>>>>>>    Integer iPrecision
36686>>>>>>>>>>>    Integer iRelFile
36686>>>>>>>>>>>    Integer iRelField
36686>>>>>>>>>>>    Integer iMainIndex
36686>>>>>>>>>>>    Integer iOffset
36686>>>>>>>>>>>    Integer iNativeLength
36686>>>>>>>>>>>    Integer iOverlapFieldStart
36686>>>>>>>>>>>    Integer iOverlapFieldEnd
36686>>>>>>>>>>>End_Struct
36686>>>>>>>>>>>
36686>>>>>>>>>>>Struct tTableIndexExplicit
36686>>>>>>>>>>>    Integer iType
36686>>>>>>>>>>>    Boolean bUnique
36686>>>>>>>>>>>    Integer iLevels
36686>>>>>>>>>>>    Integer iKeyLength
36686>>>>>>>>>>>    Integer[] aFields
36686>>>>>>>>>>>    Boolean[] aDescending
36686>>>>>>>>>>>    Boolean[] aCaseInsensitive
36686>>>>>>>>>>>End_Struct
36686>>>>>>>>>>>
36686>>>>>>>>>>>Struct tTableExplicit
36686>>>>>>>>>>>    Integer iFileListEntry
36686>>>>>>>>>>>    String  sRootName
36686>>>>>>>>>>>    String  sLogicalName
36686>>>>>>>>>>>    String  sDisplayName
36686>>>>>>>>>>>    String  sDriver
36686>>>>>>>>>>>    Boolean bSystemFile
36686>>>>>>>>>>>    Number  nMaxRecords
36686>>>>>>>>>>>    Number  nRecordsUsed
36686>>>>>>>>>>>    String  sPhysicalName
36686>>>>>>>>>>>    Integer iRecordLength
36686>>>>>>>>>>>    Integer iRecordLengthUsed
36686>>>>>>>>>>>    Integer iLockType
36686>>>>>>>>>>>    Integer iIntegrityCheck
36686>>>>>>>>>>>    tTableFieldExplicit[] aFields
36686>>>>>>>>>>>    tTableFieldExplicit[] aFields
36686>>>>>>>>>>>    tTableIndexExplicit[] aIndices
36686>>>>>>>>>>>    tTableIndexExplicit[] aIndices
36686>>>>>>>>>>>End_Struct
36686>>>>>>>>>>>
36686>>>>>>>>>>>Global_Variable tAttributeType[]       gaAttributeTypes   // AttrType definitions
36686>>>>>>>>>>>Global_Variable tAttributeDefinition[] gaAttributes       // Attr definitions
36686>>>>>>>>>>>Global_Variable Integer[][]            gaAttributesByType // Lists attributes by type (for speed)
36686>>>>>>>>>>>Global_Variable Integer[]              gaCompressedAttributeIndices // Look up an attribute and see it's compressed index
36686>>>>>>>>>>>Global_Variable Integer[][]            gaInverseCompressedAttributeIndices // [AttrType,compressed-Attr-index]-> Attr
36686>>>>>>>>>>>
36686>>>>>>>>>>>Global_Variable Integer oAttributeFunctions
36686>>>>>>>>>>>
36686>>>>>>>>>>>Class _cAttributeFunctions is a cObject
36687>>>>>>>>>>>
36687>>>>>>>>>>>    Procedure Construct_Object
36689>>>>>>>>>>>        Forward Send Construct_Object
36691>>>>>>>>>>>        Property Integer[] _paTableCompressedIndices
36692>>>>>>>>>>>        Property Integer _phProgressCallbackMsg 0
36693>>>>>>>>>>>        Property Integer _phProgressCallbackObj 0
36694>>>>>>>>>>>        Property Integer[] _paTempTableFilter
36695>>>>>>>>>>>        Send _BuildAttributeTypesArray
36696>>>>>>>>>>>        Send _BuildAttributesArray
36697>>>>>>>>>>>    End_Procedure
36698>>>>>>>>>>>
36698>>>>>>>>>>>    // **** Initialization of the object ***************************************************
36698>>>>>>>>>>>        Procedure _AddAttributeType Integer iAttrType String sName Integer iParams
36700>>>>>>>>>>>            Move sName to gaAttributeTypes[iAttrType].sName
36701>>>>>>>>>>>            Move iParams to gaAttributeTypes[iAttrType].iParamCount
36702>>>>>>>>>>>        End_Procedure
36703>>>>>>>>>>>
36703>>>>>>>>>>>    Procedure _BuildAttributeTypesArray
36705>>>>>>>>>>>        Send _AddAttributeType ATYPE_NONE     ""                   -1
36706>>>>>>>>>>>        Send _AddAttributeType ATYPE_GLOBAL   "Global"              0
36707>>>>>>>>>>>        Send _AddAttributeType ATYPE_DRIVER   "Driver"              1
36708>>>>>>>>>>>        Send _AddAttributeType ATYPE_DRVSRV   "Server"              2
36709>>>>>>>>>>>        Send _AddAttributeType ATYPE_FILELIST "Filelist"            1
36710>>>>>>>>>>>        Send _AddAttributeType ATYPE_FILE     "File"                1
36711>>>>>>>>>>>        Send _AddAttributeType ATYPE_FIELD    "Field"               2
36712>>>>>>>>>>>        Send _AddAttributeType ATYPE_INDEX    "Index"               2
36713>>>>>>>>>>>        Send _AddAttributeType ATYPE_IDXSEG   "Index segment"       3
36714>>>>>>>>>>>        Send _AddAttributeType ATYPE_SPECIAL  "Special1"            3
36715>>>>>>>>>>>        Send _AddAttributeType ATYPE_FLSTNAV  "Filelist navigation" 1
36716>>>>>>>>>>>    End_Procedure
36717>>>>>>>>>>>
36717>>>>>>>>>>>    Function AttributeType Integer iAttr Returns Integer
36719>>>>>>>>>>>        Function_Return gaAttributes[iAttr].iAttrType
36720>>>>>>>>>>>    End_Function
36721>>>>>>>>>>>    
36721>>>>>>>>>>>    Function AttributeName Integer iAttr Returns String
36723>>>>>>>>>>>        Function_Return gaAttributes[iAttr].sDisplayName
36724>>>>>>>>>>>    End_Function
36725>>>>>>>>>>>
36725>>>>>>>>>>>        Procedure _AddAttribute Integer iAttr String sName Integer iAttrType String sDisplayName Boolean bWrite Boolean bDawOnly Integer iValueType Boolean bRuntimeOnly Boolean bDriverOnly
36727>>>>>>>>>>>            Integer iNextAvailIndex
36727>>>>>>>>>>>            // Update gaAttributes containing all attributes regardless of type in a 1-dimensional array
36727>>>>>>>>>>>            Move sName to gaAttributes[iAttr].sName
36728>>>>>>>>>>>            Move iAttrType to gaAttributes[iAttr].iAttrType
36729>>>>>>>>>>>            Move sDisplayName to gaAttributes[iAttr].sDisplayName
36730>>>>>>>>>>>            Move bWrite to gaAttributes[iAttr].bWrite
36731>>>>>>>>>>>            Move bDawOnly to gaAttributes[iAttr].bDawOnly
36732>>>>>>>>>>>            Move iValueType to gaAttributes[iAttr].iValueType
36733>>>>>>>>>>>            Move bRuntimeOnly to gaAttributes[iAttr].bRuntimeOnly
36734>>>>>>>>>>>            Move bDriverOnly to gaAttributes[iAttr].bDriverOnly
36735>>>>>>>>>>>
36735>>>>>>>>>>>            // gaAttributesByType groups attributes by type:
36735>>>>>>>>>>>            Move iAttr to gaAttributesByType[iAttrType][SizeOfArray(gaAttributesByType[iAttrType])]
36736>>>>>>>>>>>
36736>>>>>>>>>>>            If (iAttrType=ATYPE_FILELIST) Move ATYPE_FILE to iAttrType
36739>>>>>>>>>>>            Move gaAttributeTypes[iAttrType].iAttrNextAvailableIndex to iNextAvailIndex
36740>>>>>>>>>>>            Move (iNextAvailIndex+1) to gaAttributeTypes[iAttrType].iAttrNextAvailableIndex
36741>>>>>>>>>>>            Move iNextAvailIndex to gaCompressedAttributeIndices[iAttr]
36742>>>>>>>>>>>            Move iAttr to gaInverseCompressedAttributeIndices[iAttrType][iNextAvailIndex]
36743>>>>>>>>>>>        End_Procedure
36744>>>>>>>>>>>
36744>>>>>>>>>>>        Procedure _AddAttributeLegalValue Integer iAttr Integer iValue String sCodeName String sDisplayName
36746>>>>>>>>>>>            Integer iIndex
36746>>>>>>>>>>>            Move (SizeOfArray(gaAttributes[iAttr].aLegalValues)) to iIndex
36747>>>>>>>>>>>            Move iValue to gaAttributes[iAttr].aLegalValues[iIndex].iValue
36748>>>>>>>>>>>            Move sCodeName to gaAttributes[iAttr].aLegalValues[iIndex].sCodeValue
36749>>>>>>>>>>>            Move sDisplayName to gaAttributes[iAttr].aLegalValues[iIndex].sDisplayName
36750>>>>>>>>>>>        End_Procedure
36751>>>>>>>>>>>
36751>>>>>>>>>>>    Procedure _BuildAttributesArray
36753>>>>>>>>>>>        //                                                                                                               Can    Daw            RT    Driver
36753>>>>>>>>>>>        //                DF symbol                  As written in source code    Attr. Type     Display name           Write   Only  Type     only  only
36753>>>>>>>>>>>        Send _AddAttribute DF_LOCK_DELAY              "DF_LOCK_DELAY"              ATYPE_GLOBAL   "Lock delay"            True  False DF_BCD   False False
36754>>>>>>>>>>>        Send _AddAttribute DF_LOCK_TIMEOUT            "DF_LOCK_TIMEOUT"            ATYPE_GLOBAL   "Lock timeout"          True  False DF_BCD   False False
36755>>>>>>>>>>>        Send _AddAttribute DF_OPEN_PATH               "DF_OPEN_PATH"               ATYPE_GLOBAL   "Open path"             True  False DF_ASCII False False
36756>>>>>>>>>>>        Send _AddAttribute DF_DATE_FORMAT             "DF_DATE_FORMAT"             ATYPE_GLOBAL   "Date format"           True  False DF_BCD   False False
36757>>>>>>>>>>>             Send _AddAttributeLegalValue DF_DATE_FORMAT DF_DATE_USA      "DF_DATE_USA"      "USA (mm/dd/yyyy)"
36758>>>>>>>>>>>             Send _AddAttributeLegalValue DF_DATE_FORMAT DF_DATE_EUROPEAN "DF_DATE_EUROPEAN" "European (dd/mm/yyyy)"
36759>>>>>>>>>>>             Send _AddAttributeLegalValue DF_DATE_FORMAT DF_DATE_MILITARY "DF_DATE_MILITARY" "Military (yyyy/mm/dd)"
36760>>>>>>>>>>>        Send _AddAttribute DF_DATE_SEPARATOR          "DF_DATE_SEPARATOR"          ATYPE_GLOBAL   "Date separator"        True  False DF_BCD   False False
36761>>>>>>>>>>>        Send _AddAttribute DF_DECIMAL_SEPARATOR       "DF_DECIMAL_SEPARATOR"       ATYPE_GLOBAL   "Decimal sep."          True  False DF_BCD   False False
36762>>>>>>>>>>>        Send _AddAttribute DF_THOUSANDS_SEPARATOR     "DF_THOUSANDS_SEPARATOR"     ATYPE_GLOBAL   "Thousands sep."        True  False DF_BCD   False False
36763>>>>>>>>>>>        Send _AddAttribute DF_ALL_FILES_TOUCHED       "DF_ALL_FILES_TOUCHED"       ATYPE_GLOBAL   "All files touched"     False False DF_BCD   True  False
36764>>>>>>>>>>>        Send _AddAttribute DF_HIGH_DATA_INTEGRITY     "DF_HIGH_DATA_INTEGRITY"     ATYPE_GLOBAL   "High data integr,"     True  False DF_BCD   False False
36765>>>>>>>>>>>        Send _AddAttribute DF_TRAN_COUNT              "DF_TRAN_COUNT"              ATYPE_GLOBAL   "Transact. nest. lev"   False False DF_BCD   True  False
36766>>>>>>>>>>>        Send _AddAttribute DF_TRANSACTION_ABORT       "DF_TRANSACTION_ABORT"       ATYPE_GLOBAL   "Transaction abort"     False False DF_BCD   False False
36767>>>>>>>>>>>        Send _AddAttribute DF_REREAD_REQUIRED         "DF_REREAD_REQUIRED"         ATYPE_GLOBAL   "Reread required"       False False DF_BCD   False False
36768>>>>>>>>>>>        Send _AddAttribute DF_FILELIST_NAME           "DF_FILELIST_NAME"           ATYPE_GLOBAL   "Filelist name"         True  False DF_ASCII False False
36769>>>>>>>>>>>        Send _AddAttribute DF_REPORT_UNSUPPORTED_ATTRIBUTES ;                                                      "DF_REPORT_UNSUPPORTED_ATTRIBUTES" ;                                                                                   ATYPE_GLOBAL   "Report unsup. attr."   True  False DF_BCD   False False
36770>>>>>>>>>>>        Send _AddAttribute DF_STRICT_ATTRIBUTES       "DF_STRICT_ATTRIBUTES"       ATYPE_GLOBAL   "Strict attributes"     True  False DF_BCD   False False
36771>>>>>>>>>>>        Send _AddAttribute DF_NUMBER_DRIVERS          "DF_NUMBER_DRIVERS"          ATYPE_GLOBAL   "Number drivers"        False False DF_BCD   False False
36772>>>>>>>>>>>        Send _AddAttribute DF_DRIVER_NAME             "DF_DRIVER_NAME"             ATYPE_DRIVER   "Driver name"           False False DF_ASCII False False
36773>>>>>>>>>>>        Send _AddAttribute DF_DRIVER_NUMBER_SERVERS   "DF_DRIVER_NUMBER_SERVERS"   ATYPE_DRIVER   "Driver number servers" False False DF_BCD   False True
36774>>>>>>>>>>>        Send _AddAttribute DF_DRIVER_CONFORMANCE      "DF_DRIVER_CONFORMANCE"      ATYPE_DRIVER   "Driver conformance"    False False DF_BCD   False True
36775>>>>>>>>>>>        Send _AddAttribute DF_DRIVER_SERVER_NAME      "DF_DRIVER_SERVER_NAME"      ATYPE_DRVSRV   "Driver server name"    False False DF_ASCII False False
36776>>>>>>>>>>>        Send _AddAttribute DF_API_DISABLED            "DF_API_DISABLED"            ATYPE_GLOBAL   "API disabled"          False True  DF_BCD   False False
36777>>>>>>>>>>>        Send _AddAttribute DF_API_DISABLED_ERROR      "DF_API_DISABLED_ERROR"      ATYPE_GLOBAL   "API disabled error"    False True  DF_BCD   False False
36778>>>>>>>>>>>        Send _AddAttribute DF_TRANABORT_ONERROR       "DF_TRANABORT_ONERROR"       ATYPE_GLOBAL   "Abort trans on error"  False False DF_BCD   False False
36779>>>>>>>>>>>        Send _AddAttribute DF_OPEN_FILE_COUNT         "DF_OPEN_FILE_COUNT"         ATYPE_GLOBAL   "Open tables count"     False False DF_BCD   False False
36780>>>>>>>>>>>        Send _AddAttribute DF_DATE_4_STATE            "DF_DATE_4_STATE"            ATYPE_GLOBAL   "Date 4 state"          False False DF_BCD   False False
36781>>>>>>>>>>>        Send _AddAttribute DF_EPOCH_VALUE             "DF_EPOCH_VALUE"             ATYPE_GLOBAL   "Epoch value"           False False DF_BCD   False False
36782>>>>>>>>>>>        Send _AddAttribute DF_SYSDATE_4_STATE         "DF_SYSDATE_4_STATE"         ATYPE_GLOBAL   "Sysdate 4 state"       False False DF_BCD   False False
36783>>>>>>>>>>>        Send _AddAttribute DF_NUMBER_FILES_SUPPORTED  "DF_NUMBER_FILES_SUPPORTED"  ATYPE_GLOBAL   "Max open tables"       False False DF_BCD   False False
36784>>>>>>>>>>>
36784>>>>>>>>>>>        Send _AddAttribute DF_FILE_STATUS             "DF_FILE_STATUS"             ATYPE_FILE     "Status"                False False DF_BCD   True  False
36785>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_STATUS DF_FILE_INACTIVE       "DF_FILE_INACTIVE"       "Inactive"
36786>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_STATUS DF_FILE_ACTIVE         "DF_FILE_ACTIVE"         "Active"
36787>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_STATUS DF_FILE_ACTIVE_CHANGED "DF_FILE_ACTIVE_CHANGED" "Changed"
36788>>>>>>>>>>>        Send _AddAttribute DF_FILE_MODE               "DF_FILE_MODE"               ATYPE_FILE     "Mode"                  True  False DF_BCD   True  False
36789>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_MODE DF_FILE_ALIAS_DEFAULT "DF_FILE_ALIAS_DEFAULT" "Default"
36790>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_MODE DF_FILE_IS_MASTER     "DF_FILE_IS_MASTER"     "Master"
36791>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_MODE DF_FILE_IS_ALIAS      "DF_FILE_IS_ALIAS"      "Alias"
36792>>>>>>>>>>>        Send _AddAttribute DF_FILE_MAX_RECORDS        "DF_FILE_MAX_RECORDS"        ATYPE_FILE     "Max records"           True  False DF_BCD   False False
36793>>>>>>>>>>>        Send _AddAttribute DF_FILE_RECORDS_USED       "DF_FILE_RECORDS_USED"       ATYPE_FILE     "Record count"          False False DF_BCD   False False
36794>>>>>>>>>>>        Send _AddAttribute DF_FILE_TYPE               "DF_FILE_TYPE"               ATYPE_FILE     "Type"                  False False DF_BCD   False False
36795>>>>>>>>>>>        Send _AddAttribute DF_FILE_MULTIUSER          "DF_FILE_MULTIUSER"          ATYPE_FILE     "Multiuser"             True  False DF_BCD   False False
36796>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_MULTIUSER DF_FILE_USER_SINGLE "DF_FILE_USER_SINGLE" "Single user"
36797>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_MULTIUSER DF_FILE_USER_MULTI  "DF_FILE_USER_MULTI"  "Multi user"
36798>>>>>>>>>>>        Send _AddAttribute DF_FILE_REUSE_DELETED      "DF_FILE_REUSE_DELETED"      ATYPE_FILE     "Reuse deleted"         True  False DF_BCD   False False
36799>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_REUSE_DELETED DF_FILE_DELETED_NOREUSE "DF_FILE_DELETED_NOREUSE" "No reuse"
36800>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_REUSE_DELETED DF_FILE_DELETED_REUSE   "DF_FILE_DELETED_REUSE"   "Reuse"
36801>>>>>>>>>>>        Send _AddAttribute DF_FILE_NUMBER             "DF_FILE_NUMBER"             ATYPE_FILE     "Number"                False False DF_BCD   True  False
36802>>>>>>>>>>>        Send _AddAttribute DF_FILE_COMPRESSION        "DF_FILE_COMPRESSION"        ATYPE_FILE     "Compression"           True  False DF_BCD   False False
36803>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_COMPRESSION DF_FILE_COMPRESS_NONE     "DF_FILE_COMPRESS_NONE"     "None"
36804>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_COMPRESSION DF_FILE_COMPRESS_FAST     "DF_FILE_COMPRESS_FAST"     "Fast"
36805>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_COMPRESSION DF_FILE_COMPRESS_STANDARD "DF_FILE_COMPRESS_STANDARD" "Standard"
36806>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_COMPRESSION DF_FILE_COMPRESS_CUSTOM   "DF_FILE_COMPRESS_CUSTOM"   "Custom"
36807>>>>>>>>>>>        Send _AddAttribute DF_FILE_LAST_INDEX_NUMBER  "DF_FILE_LAST_INDEX_NUMBER"  ATYPE_FILE     "Highest index"         False False DF_BCD   False False
36808>>>>>>>>>>>        Send _AddAttribute DF_FILE_NUMBER_FIELDS      "DF_FILE_NUMBER_FIELDS"      ATYPE_FILE     "Number fields"         False False DF_BCD   False False
36809>>>>>>>>>>>        // Max 8 characters:
36809>>>>>>>>>>>        Send _AddAttribute DF_FILE_LOGICAL_NAME       "DF_FILE_LOGICAL_NAME"       ATYPE_FILELIST "Logical name"          True  False DF_ASCII False False
36810>>>>>>>>>>>        // Max 40 characters:
36810>>>>>>>>>>>        Send _AddAttribute DF_FILE_ROOT_NAME          "DF_FILE_ROOT_NAME"          ATYPE_FILELIST "Root name"             True  False DF_ASCII False False
36811>>>>>>>>>>>        Send _AddAttribute DF_FILE_CHANGED            "DF_FILE_CHANGED"            ATYPE_FILE     "Changed"               False False DF_BCD   True  False
36812>>>>>>>>>>>        Send _AddAttribute DF_FILE_ALIAS              "DF_FILE_ALIAS"              ATYPE_FILE     "Alias"                 True  False DF_BCD   True  False
36813>>>>>>>>>>>        //                                                                                                               Can    Daw            RT    Driver
36813>>>>>>>>>>>        //                DF symbol                  As written in source code    Attr. Type     Display name           Write   Only  Type     only  only
36813>>>>>>>>>>>        Send _AddAttribute DF_FILE_TOUCHED            "DF_FILE_TOUCHED"            ATYPE_FILE     "Touched"               False False DF_BCD   True  False
36814>>>>>>>>>>>        Send _AddAttribute DF_FILE_TRANSACTION        "DF_FILE_TRANSACTION"        ATYPE_FILE     "Transaction"           True  False DF_BCD   False False
36815>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_TRANSACTION DF_FILE_TRANSACTION_NONE          "DF_FILE_TRANSACTION_NONE"          "None"
36816>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_TRANSACTION DF_FILE_TRANSACTION_CLIENT_ATOMIC "DF_FILE_TRANSACTION_CLIENT_ATOMIC" "Client atomic"
36817>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_TRANSACTION DF_FILE_TRANSACTION_SERVER_ATOMIC "DF_FILE_TRANSACTION_SERVER_ATOMIC" "Server atomic"
36818>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_TRANSACTION DF_FILE_TRANSACTION_SERVER_LOGGED "DF_FILE_TRANSACTION_SERVER_LOGGED" "Server logged"
36819>>>>>>>>>>>        Send _AddAttribute DF_FILE_OPENED             "DF_FILE_OPENED"             ATYPE_FILE     "Opened"                False False DF_BCD   True  False
36820>>>>>>>>>>>        // Max 32 characters:
36820>>>>>>>>>>>        Send _AddAttribute DF_FILE_DISPLAY_NAME       "DF_FILE_DISPLAY_NAME"       ATYPE_FILELIST "Display name"          True  False DF_ASCII False False
36821>>>>>>>>>>>        Send _AddAttribute DF_FILE_PHYSICAL_NAME      "DF_FILE_PHYSICAL_NAME"      ATYPE_FILE     "Physical name"         False False DF_ASCII False False
36822>>>>>>>>>>>        Send _AddAttribute DF_FILE_NEXT_OPENED        "DF_FILE_NEXT_OPENED"        ATYPE_FLSTNAV  "Next opened"           False False DF_BCD   False False
36823>>>>>>>>>>>        Send _AddAttribute DF_FILE_NEXT_USED          "DF_FILE_NEXT_USED"          ATYPE_FLSTNAV  "Next used"             False False DF_BCD   False False
36824>>>>>>>>>>>        Send _AddAttribute DF_FILE_NEXT_EMPTY         "DF_FILE_NEXT_EMPTY"         ATYPE_FLSTNAV  "Next empty"            False False DF_BCD   False False
36825>>>>>>>>>>>        Send _AddAttribute DF_FILE_RECORD_LENGTH      "DF_FILE_RECORD_LENGTH"      ATYPE_FILE     "Record length"         True  False DF_BCD   False False
36826>>>>>>>>>>>        Send _AddAttribute DF_FILE_RESTRUCTURE        "DF_FILE_RESTRUCTURE"        ATYPE_FILE     "Restructure"           False False DF_BCD   True  False
36827>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_RESTRUCTURE DF_NO_RESTRUCTURE    "DF_NO_RESTRUCTURE"    "None"
36828>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_RESTRUCTURE DF_RESTRUCTURE_FILE  "DF_RESTRUCTURE_FILE"  "File"
36829>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_RESTRUCTURE DF_RESTRUCTURE_INDEX "DF_RESTRUCTURE_INDEX" "Index"
36830>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_RESTRUCTURE DF_RESTRUCTURE_BOTH  "DF_RESTRUCTURE_BOTH"  "File/Index"
36831>>>>>>>>>>>        Send _AddAttribute DF_FILE_OPEN_MODE          "DF_FILE_OPEN_MODE"          ATYPE_FILE     "Open mode"             False False DF_BCD   True  False
36832>>>>>>>>>>>              Send _AddAttributeLegalValue DF_FILE_OPEN_MODE DF_SHARE     "DF_SHARE"     "Share"
36833>>>>>>>>>>>              Send _AddAttributeLegalValue DF_FILE_OPEN_MODE DF_EXCLUSIVE "DF_EXCLUSIVE" "Exclusive"
36834>>>>>>>>>>>        Send _AddAttribute DF_FILE_INTEGRITY_CHECK    "DF_FILE_INTEGRITY_CHECK"    ATYPE_FILE     "Integrity check"       True  False DF_BCD   False False
36835>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_INTEGRITY_CHECK DFTRUE  "DFTRUE"  "True"
36836>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_INTEGRITY_CHECK DFFALSE "DFFALSE" "False"
36837>>>>>>>>>>>        Send _AddAttribute DF_FILE_OWNER              "DF_FILE_OWNER"              ATYPE_FILE     "Owner"                 False False DF_ASCII True  False
36838>>>>>>>>>>>        Send _AddAttribute DF_FILE_IS_SYSTEM_FILE     "DF_FILE_IS_SYSTEM_FILE"     ATYPE_FILE     "Is system file"        False False DF_BCD   False False
36839>>>>>>>>>>>        Send _AddAttribute DF_FILE_LOCK_TYPE          "DF_FILE_LOCK_TYPE"          ATYPE_FILE     "Lock type"             False False DF_BCD   False False
36840>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_LOCK_TYPE DF_LOCK_TYPE_NONE   "DF_LOCK_TYPE_NONE"   "None"
36841>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_LOCK_TYPE DF_LOCK_TYPE_FILE   "DF_LOCK_TYPE_FILE"   "File"
36842>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_LOCK_TYPE DF_LOCK_TYPE_RECORD "DF_LOCK_TYPE_RECORD" "Record"
36843>>>>>>>>>>>        Send _AddAttribute DF_FILE_COMMITTED          "DF_FILE_COMMITTED"          ATYPE_FILE     "Committed"             False False DF_BCD   True  False
36844>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_COMMITTED DFTRUE  "DFTRUE"  "True"
36845>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_COMMITTED DFFALSE "DFFALSE" "False"
36846>>>>>>>>>>>        Send _AddAttribute DF_FILE_DRIVER             "DF_FILE_DRIVER"             ATYPE_FILE     "Driver"                False False DF_ASCII False False
36847>>>>>>>>>>>        Send _AddAttribute DF_FILE_LOGIN              "DF_FILE_LOGIN"              ATYPE_FILE     "Driver login"          False False DF_ASCII False True
36848>>>>>>>>>>>        Send _AddAttribute DF_FILE_RECORD_LENGTH_USED "DF_FILE_RECORD_LENGTH_USED" ATYPE_FILE     "Record length used"    False False DF_BCD   False False
36849>>>>>>>>>>>        Send _AddAttribute DF_FILE_HANDLE_TYPE        "DF_FILE_HANDLE_TYPE"        ATYPE_FILE     "Handle type"           False True  DF_BCD   True  False
36850>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_HANDLE_TYPE DF_FILE_HANDLE_BAD                   "DF_FILE_HANDLE_BAD"                  "Bad"
36851>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_HANDLE_TYPE DF_FILE_HANDLE_CLOSED                "DF_FILE_HANDLE_CLOSED"               "Closed"
36852>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_HANDLE_TYPE DF_FILE_HANDLE_OPENED                "DF_FILE_HANDLE_OPENED"               "Opened"
36853>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_HANDLE_TYPE DF_FILE_HANDLE_EXISTING_RESTRUCTURE  "DF_FILE_HANDLE_EXISTING_RESTRUCTURE" "Existing restructure"
36854>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_HANDLE_TYPE DF_FILE_HANDLE_NEW_RESTRUCTURE       "DF_FILE_HANDLE_NEW_RESTRUCTURE"      "New restructure"
36855>>>>>>>>>>>        Send _AddAttribute DF_FILE_RECORD_IDENTITY    "DF_FILE_RECORD_IDENTITY"    ATYPE_FILE     "Record identity"       True  False DF_BCD   False False
36856>>>>>>>>>>>        //Send _AddAttribute DF_FILE_LOGIN              "DF_FILE_LOGIN"              ATYPE_FILE     "Login"                 True  False DF_ASCII True
36856>>>>>>>>>>>        Send _AddAttribute DF_FILE_RECORD_PRIVILEGE   "DF_FILE_RECORD_PRIVILEGE"   ATYPE_FILE     "Record privilege"      False True  DF_BCD   True  False
36857>>>>>>>>>>>        Send _AddAttribute DF_FILE_PRIVILEGE          "DF_FILE_PRIVILEGE"          ATYPE_FILE     "Privilege"             False True  DF_BCD   True  False
36858>>>>>>>>>>>        Send _AddAttribute DF_FILE_CREATION_SERIAL    "DF_FILE_CREATION_SERIAL"    ATYPE_FILE     "Creation serial"       False True  DF_BCD   True  False
36859>>>>>>>>>>>        Send _AddAttribute DF_FILE_REVISION           "DF_FILE_REVISION"           ATYPE_FILE     "Revision"              False False DF_ASCII False False
36860>>>>>>>>>>>        Send _AddAttribute DF_FILE_RELATED_COUNT      "DF_FILE_RELATED_COUNT"      ATYPE_FILE     "Related count"         False True  DF_BCD   True  False
36861>>>>>>>>>>>        Send _AddAttribute DF_FILE_RELATED_FIELDS     "DF_FILE_RELATED_FIELDS"     ATYPE_FILE     "Related fields"        False True  DF_BCD   True  False
36862>>>>>>>>>>>        Send _AddAttribute DF_FILE_SYSTEM_FILE        "DF_FILE_SYSTEM_FILE"        ATYPE_FILE     "System file"           False False DF_BCD   True  False
36863>>>>>>>>>>>        Send _AddAttribute DF_FILE_SYSTEM_FIELD       "DF_FILE_SYSTEM_FIELD"       ATYPE_FILE     "System field"          False False DF_BCD   True  False
36864>>>>>>>>>>>        Send _AddAttribute DF_FILE_RECORD_REREAD      "DF_FILE_RECORD_REREAD"      ATYPE_FILE     "Record reread"         False True  DF_BCD   True  False
36865>>>>>>>>>>>        Send _AddAttribute DF_FILE_RECNUM_TABLE       "DF_FILE_RECNUM_TABLE "      ATYPE_FILE     "Recnum table"          False False DF_BCD   False False
36866>>>>>>>>>>>        Send _AddAttribute DF_FILE_PRIMARY_INDEX      "DF_FILE_PRIMARY_INDEX"      ATYPE_FILE     "Primary index"         False False DF_BCD   False True
36867>>>>>>>>>>>        
36867>>>>>>>>>>>        //                                                                                                                Can    Daw           RT    Driver
36867>>>>>>>>>>>        //                 DF symbol                  As written in source code    Attr. Type     Display name            Write  Only  Type    only  only
36867>>>>>>>>>>>        Send _AddAttribute DF_FILE_REFIND_AFTER_SAVE  "DF_FILE_REFIND_AFTER_SAVE"  ATYPE_FILE     "Refind after save"     False False DF_BCD   False True
36868>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_REFIND_AFTER_SAVE DFTRUE  "DFTRUE"  "True"
36869>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_REFIND_AFTER_SAVE DFFALSE "DFFALSE" "False"
36870>>>>>>>>>>>        
36870>>>>>>>>>>>        Send _AddAttribute DF_FILE_GET_RID_AFTER_CREATE "DF_FILE_GET_RID_AFTER_CREATE" ATYPE_FILE "Get rid after create"  False False DF_BCD   False True
36871>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_GET_RID_AFTER_CREATE DFTRUE  "DFTRUE"  "True"
36872>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_GET_RID_AFTER_CREATE DFFALSE "DFFALSE" "False"
36873>>>>>>>>>>>             
36873>>>>>>>>>>>        Send _AddAttribute DF_FILE_JIT_BINDING "DF_FILE_JIT_BINDING" ATYPE_FILE "Get rid after create"  False False DF_BCD   False True
36874>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_JIT_BINDING DFTRUE  "DFTRUE"  "True"
36875>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FILE_JIT_BINDING DFFALSE "DFFALSE" "False"
36876>>>>>>>>>>>
36876>>>>>>>>>>>        // ToDo: Send _AddAttribute DF_FILE_JIT_BINDING       "DF_FILE_"      ATYPE_FILE     "Primary index"         False False DF_BCD   False True
36876>>>>>>>>>>>        //       Send _AddAttribute DF_DRIVER_JIT_TRESHOLD       "DF_FILE_"      ATYPE_FILE     "Primary index"         False False DF_BCD   False True
36876>>>>>>>>>>>        //       Send _AddAttribute DF_FILE_USE_DUMMY_ZERO_DATE
36876>>>>>>>>>>>
36876>>>>>>>>>>>        Send _AddAttribute DF_FIELD_NUMBER            "DF_FIELD_NUMBER"            ATYPE_FIELD    "Number"                False False DF_BCD   False False
36877>>>>>>>>>>>        Send _AddAttribute DF_FIELD_TYPE              "DF_FIELD_TYPE"              ATYPE_FIELD    "Type"                  True  False DF_BCD   False False
36878>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FIELD_TYPE DF_ASCII    "DF_ASCII"    "Ascii"
36879>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FIELD_TYPE DF_BCD      "DF_BCD"      "Number"
36880>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FIELD_TYPE DF_DATE     "DF_DATE"     "Date"
36881>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FIELD_TYPE DF_DATETIME "DF_DATETIME" "DateTime"
36882>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FIELD_TYPE DF_OVERLAP  "DF_OVERLAP"  "Overlap"
36883>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FIELD_TYPE DF_TEXT     "DF_TEXT"     "Text"
36884>>>>>>>>>>>             Send _AddAttributeLegalValue DF_FIELD_TYPE DF_BINARY   "DF_BINARY"  " Binary"
36885>>>>>>>>>>>        Send _AddAttribute DF_FIELD_LENGTH            "DF_FIELD_LENGTH"            ATYPE_FIELD    "Length"                True  False DF_BCD   False False
36886>>>>>>>>>>>        Send _AddAttribute DF_FIELD_PRECISION         "DF_FIELD_PRECISION"         ATYPE_FIELD    "Precision"             True  False DF_BCD   False False
36887>>>>>>>>>>>        Send _AddAttribute DF_FIELD_RELATED_FILE      "DF_FIELD_RELATED_FILE"      ATYPE_FIELD    "Related file"          True  False DF_BCD   False False
36888>>>>>>>>>>>        Send _AddAttribute DF_FIELD_RELATED_FIELD     "DF_FIELD_RELATED_FIELD"     ATYPE_FIELD    "Related field"         True  False DF_BCD   False False
36889>>>>>>>>>>>        Send _AddAttribute DF_FIELD_NAME              "DF_FIELD_NAME"              ATYPE_FIELD    "Name"                  True  False DF_ASCII False False
36890>>>>>>>>>>>        Send _AddAttribute DF_FIELD_INDEX             "DF_FIELD_INDEX"             ATYPE_FIELD    "Index"                 True  False DF_BCD   False False
36891>>>>>>>>>>>        Send _AddAttribute DF_FIELD_OFFSET            "DF_FIELD_OFFSET"            ATYPE_FIELD    "Offset"                True  False DF_BCD   False False
36892>>>>>>>>>>>        Send _AddAttribute DF_FIELD_OLD_NUMBER        "DF_FIELD_OLD_NUMBER"        ATYPE_FIELD    "Old number"            False True  DF_BCD   False False // Only during restruct!
36893>>>>>>>>>>>        Send _AddAttribute DF_FIELD_OVERLAP           "DF_FIELD_OVERLAP"           ATYPE_SPECIAL  "Overlap"               False False DF_BCD   False False
36894>>>>>>>>>>>        Send _AddAttribute DF_FIELD_NATIVE_LENGTH     "DF_FIELD_NATIVE_LENGTH"     ATYPE_FIELD    "Native length"         False False DF_BCD   False False
36895>>>>>>>>>>>
36895>>>>>>>>>>>        Send _AddAttribute DF_INDEX_NUMBER_SEGMENTS   "DF_INDEX_NUMBER_SEGMENTS"   ATYPE_INDEX    "Number segments"       True  False DF_BCD   False False
36896>>>>>>>>>>>        Send _AddAttribute DF_INDEX_NUMBER_BUFFERS    "DF_INDEX_NUMBER_BUFFERS"    ATYPE_INDEX    "Number buffers"        False False DF_BCD   False False
36897>>>>>>>>>>>        Send _AddAttribute DF_INDEX_TYPE              "DF_INDEX_TYPE"              ATYPE_INDEX    "Type"                  True  False DF_BCD   False False
36898>>>>>>>>>>>             Send _AddAttributeLegalValue DF_INDEX_TYPE DF_INDEX_TYPE_ONLINE "DF_INDEX_TYPE_ONLINE" "Online"
36899>>>>>>>>>>>             Send _AddAttributeLegalValue DF_INDEX_TYPE DF_INDEX_TYPE_BATCH  "DF_INDEX_TYPE_BATCH"  "Batch"
36900>>>>>>>>>>>        Send _AddAttribute DF_INDEX_LEVELS            "DF_INDEX_LEVELS"            ATYPE_INDEX    "Levels"                False False DF_BCD   False False
36901>>>>>>>>>>>        Send _AddAttribute DF_INDEX_KEY_LENGTH        "DF_INDEX_KEY_LENGTH"        ATYPE_INDEX    "Key length"            False False DF_BCD   False False
36902>>>>>>>>>>>
36902>>>>>>>>>>>        Send _AddAttribute DF_INDEX_SEGMENT_DIRECTION "DF_INDEX_SEGMENT_DIRECTION" ATYPE_IDXSEG   "Segment direction"     True  False DF_BCD   False False
36903>>>>>>>>>>>             Send _AddAttributeLegalValue DF_INDEX_SEGMENT_DIRECTION DF_ASCENDING  "DF_ASCENDING"  "Ascending"
36904>>>>>>>>>>>             Send _AddAttributeLegalValue DF_INDEX_SEGMENT_DIRECTION DF_DESCENDING "DF_DESCENDING" "Descending"
36905>>>>>>>>>>>        Send _AddAttribute DF_INDEX_SEGMENT_CASE      "DF_INDEX_SEGMENT_CASE"      ATYPE_IDXSEG   "Segment case"          True  False DF_BCD   False False
36906>>>>>>>>>>>             Send _AddAttributeLegalValue DF_INDEX_SEGMENT_CASE DF_CASE_USED    "DF_CASE_USED"    "Case used"
36907>>>>>>>>>>>             Send _AddAttributeLegalValue DF_INDEX_SEGMENT_CASE DF_CASE_IGNORED "DF_CASE_IGNORED" "Case ignored"
36908>>>>>>>>>>>        Send _AddAttribute DF_INDEX_SEGMENT_FIELD     "DF_INDEX_SEGMENT_FIELD"     ATYPE_IDXSEG   "Segment field"         True  False DF_BCD   False False
36909>>>>>>>>>>>    End_Procedure
36910>>>>>>>>>>>
36910>>>>>>>>>>>    // **** Functions for reading the attributes of a database *****************************************
36910>>>>>>>>>>>
36910>>>>>>>>>>>    Function _LegalValuesIndex Integer iAttr String sValue Returns Integer
36912>>>>>>>>>>>        Integer iMax iIndex
36912>>>>>>>>>>>        String sTest
36912>>>>>>>>>>>        Move (SizeOfArray(gaAttributes[iAttr].aLegalValues)-1) to iMax
36913>>>>>>>>>>>        For iIndex from 0 to iMax
36919>>>>>>>>>>>>
36919>>>>>>>>>>>            Move gaAttributes[iAttr].aLegalValues[iIndex].iValue to sTest
36920>>>>>>>>>>>            If (sValue=sTest) Function_Return iIndex
36923>>>>>>>>>>>            //If (sValue=gaAttributes[iAttr].aLegalValues[iIndex]) Function_Return iIndex
36923>>>>>>>>>>>        Loop
36924>>>>>>>>>>>>
36924>>>>>>>>>>>        Function_Return -1
36925>>>>>>>>>>>    End_Function
36926>>>>>>>>>>>
36926>>>>>>>>>>>    Function AttributeDisplayValue Integer iAttr String sValue Returns String
36928>>>>>>>>>>>        Integer iIndex
36928>>>>>>>>>>>        Get _LegalValuesIndex iAttr sValue to iIndex
36929>>>>>>>>>>>        If (iIndex=-1) Function_Return sValue
36932>>>>>>>>>>>        Function_Return gaAttributes[iAttr].aLegalValues[iIndex].sDisplayName // "European (dd/mm/yyyy)"
36933>>>>>>>>>>>    End_Function
36934>>>>>>>>>>>
36934>>>>>>>>>>>    Function AttributeSymbolicValue Integer iAttr String sValue Returns String
36936>>>>>>>>>>>        Integer iIndex
36936>>>>>>>>>>>        Get _LegalValuesIndex iAttr sValue to iIndex
36937>>>>>>>>>>>        If (iIndex=-1) Function_Return sValue
36940>>>>>>>>>>>        Function_Return gaAttributes[iAttr].aLegalValues[iIndex].sCodeValue // "DF_DATE_EUROPEAN"
36941>>>>>>>>>>>    End_Function
36942>>>>>>>>>>>    
36942>>>>>>>>>>>        Function _IsTableBufferAttributeType Integer iAttrType Returns Boolean
36944>>>>>>>>>>>            Function_Return (iAttrType=ATYPE_FILE or iAttrType=ATYPE_FIELD or ;                iAttrType=ATYPE_INDEX or iAttrType=ATYPE_INDEX or iAttrType=ATYPE_SPECIAL)
36945>>>>>>>>>>>        End_Function
36946>>>>>>>>>>>
36946>>>>>>>>>>>    Function _CanGetAttribute Integer hTable Integer iAttr Returns Boolean
36948>>>>>>>>>>>        Integer iHandleType iAttrType
36948>>>>>>>>>>>        Boolean bRestruct bOpen
36948>>>>>>>>>>>        String sDriver
36948>>>>>>>>>>>
36948>>>>>>>>>>>        //    Define ATYPE_GLOBAL    // No parameters
36948>>>>>>>>>>>        //    Define ATYPE_DRIVER    // 1: Driver number
36948>>>>>>>>>>>        //    Define ATYPE_DRVSRV    // 1: Driver number  2: Server number
36948>>>>>>>>>>>        //    Define ATYPE_FILELIST  // 1: File  (No record buffer access, filelist only)
36948>>>>>>>>>>>        //    Define ATYPE_FILE      // 1: File
36948>>>>>>>>>>>        //    Define ATYPE_FIELD     // 1: File   2: Field
36948>>>>>>>>>>>        //    Define ATYPE_INDEX     // 1: File   2: Index
36948>>>>>>>>>>>        //    Define ATYPE_IDXSEG    // 1: File   2: Index   3: Segment
36948>>>>>>>>>>>        //    Define ATYPE_SPECIAL   // 1: File 2/3: Field/Field  (overlap check)
36948>>>>>>>>>>>        //    Define ATYPE_FLSTNAV   // 1: File (for navigating filelist)
36948>>>>>>>>>>>
36948>>>>>>>>>>>        Move gaAttributes[iAttr].iAttrType to iAttrType
36949>>>>>>>>>>>        
36949>>>>>>>>>>>        If (_IsTableBufferAttributeType(Self,iAttrType) or iAttrType=ATYPE_FILELIST or iAttrType=ATYPE_FLSTNAV) Begin
36951>>>>>>>>>>>            Get_Attribute DF_FILE_HANDLE_TYPE of hTable to iHandleType
36954>>>>>>>>>>>
36954>>>>>>>>>>>                // Possible return values for iHandleType:
36954>>>>>>>>>>>                //   DF_FILE_HANDLE_BAD
36954>>>>>>>>>>>                //   DF_FILE_HANDLE_CLOSED
36954>>>>>>>>>>>                //   DF_FILE_HANDLE_OPENED
36954>>>>>>>>>>>                //   DF_FILE_HANDLE_EXISTING_RESTRUCTURE
36954>>>>>>>>>>>                //   DF_FILE_HANDLE_NEW_RESTRUCTURE
36954>>>>>>>>>>>
36954>>>>>>>>>>>            Move (iHandleType=DF_FILE_HANDLE_EXISTING_RESTRUCTURE or iHandleType=DF_FILE_HANDLE_NEW_RESTRUCTURE) to bRestruct
36955>>>>>>>>>>>
36955>>>>>>>>>>>            If (bRestruct and iAttrType=ATYPE_FILELIST) Begin
36957>>>>>>>>>>>                Function_Return False
36958>>>>>>>>>>>            End
36958>>>>>>>>>>>>
36958>>>>>>>>>>>    
36958>>>>>>>>>>>            If (not(bRestruct) and iAttr=DF_FIELD_OLD_NUMBER) Begin
36960>>>>>>>>>>>                Function_Return False
36961>>>>>>>>>>>            End
36961>>>>>>>>>>>>
36961>>>>>>>>>>>    
36961>>>>>>>>>>>            // Can't read those during a restructure
36961>>>>>>>>>>>            If (bRestruct and iAttr=DF_INDEX_NUMBER_BUFFERS or iAttr=DF_FILE_TOUCHED or iAttr=DF_FILE_OPENED) Begin
36963>>>>>>>>>>>                Function_Return False
36964>>>>>>>>>>>            End
36964>>>>>>>>>>>>
36964>>>>>>>>>>>
36964>>>>>>>>>>>            If (bRestruct or iHandleType=DF_FILE_OPENED) Begin
36966>>>>>>>>>>>                Get_Attribute DF_FILE_DRIVER of hTable to sDriver
36969>>>>>>>>>>>                If (sDriver="DFBTRDRV") Begin
36971>>>>>>>>>>>                    If (iAttr=DF_FILE_REFIND_AFTER_SAVE or ;                        iAttr=DF_FILE_GET_RID_AFTER_CREATE or ;                        iAttr=DF_FILE_JIT_BINDING) Begin
36973>>>>>>>>>>>                        Function_Return False
36974>>>>>>>>>>>                    End
36974>>>>>>>>>>>>
36974>>>>>>>>>>>                End
36974>>>>>>>>>>>>
36974>>>>>>>>>>>            End
36974>>>>>>>>>>>>
36974>>>>>>>>>>>        End
36974>>>>>>>>>>>>
36974>>>>>>>>>>>        Function_Return True
36975>>>>>>>>>>>    End_Function
36976>>>>>>>>>>>//
36976>>>>>>>>>>>//
36976>>>>>>>>>>>//        If (hTable>=1) Begin
36976>>>>>>>>>>>//            Get_Attribute DF_FILE_OPENED of hTable to bOpen
36976>>>>>>>>>>>//            If (bOpen) Begin
36976>>>>>>>>>>>//                Get_Attribute DF_FILE_DRIVER of hTable to sDriver
36976>>>>>>>>>>>//            End
36976>>>>>>>>>>>//            If (sDriver="DFBTRDRV") Begin
36976>>>>>>>>>>>//                If (iAttr=DF_FILE_REFIND_AFTER_SAVE or ;
36976>>>>>>>>>>>//                    iAttr=DF_FILE_GET_RID_AFTER_CREATE or ;
36976>>>>>>>>>>>//                    iAttr=DF_FILE_JIT_BINDING) Begin
36976>>>>>>>>>>>//                    Function_Return False
36976>>>>>>>>>>>//                End
36976>>>>>>>>>>>//            End
36976>>>>>>>>>>>//        End
36976>>>>>>>>>>>//
36976>>>>>>>>>>>//
36976>>>>>>>>>>>//        If (bRestruct and iAttrType=ATYPE_FILELIST) Begin
36976>>>>>>>>>>>//            Function_Return False
36976>>>>>>>>>>>//        End
36976>>>>>>>>>>>//
36976>>>>>>>>>>>//        If (not(bRestruct) and iAttr=DF_FIELD_OLD_NUMBER) Begin
36976>>>>>>>>>>>//            Function_Return False
36976>>>>>>>>>>>//        End
36976>>>>>>>>>>>//
36976>>>>>>>>>>>//        // Can't read those during a restructure
36976>>>>>>>>>>>//        If (bRestruct and iAttr=DF_INDEX_NUMBER_BUFFERS or iAttr=DF_FILE_TOUCHED or iAttr=DF_FILE_OPENED) Begin
36976>>>>>>>>>>>//            Function_Return False
36976>>>>>>>>>>>//        End
36976>>>>>>>>>>>//        Function_Return True
36976>>>>>>>>>>>
36976>>>>>>>>>>>//DF_FILE_HANDLE_OPENED
36976>>>>>>>>>>>//DF_FILE_HANDLE_EXISTING_RESTRUCTURE
36976>>>>>>>>>>>//DF_FILE_HANDLE_NEW_RESTRUCTURE
36976>>>>>>>>>>>
36976>>>>>>>>>>>
36976>>>>>>>>>>>
36976>>>>>>>>>>>        Procedure Set _AttributeValue tAttributeValue[] ByRef aAttributes Integer iAttr String sValue
36978>>>>>>>>>>>            Move sValue to aAttributes[gaCompressedAttributeIndices[iAttr]].sValue
36979>>>>>>>>>>>        End_Procedure
36980>>>>>>>>>>>
36980>>>>>>>>>>>        Function _AttributeValue tAttributeValue[] aAttributes Integer iAttr Returns String
36982>>>>>>>>>>>            Integer iIndex
36982>>>>>>>>>>>            If (SizeOfArray(aAttributes)<>0) Begin
36984>>>>>>>>>>>                Move gaCompressedAttributeIndices[iAttr] to iIndex
36985>>>>>>>>>>>                If (iIndex<SizeOfArray(aAttributes)) Function_Return aAttributes[iIndex].sValue
36988>>>>>>>>>>>            End
36988>>>>>>>>>>>>
36988>>>>>>>>>>>            Function_Return ""
36989>>>>>>>>>>>        End_Function
36990>>>>>>>>>>>
36990>>>>>>>>>>>        Procedure _GetAllAttributesOfType Integer iAttrType tAttributeValue[] ByRef aAttributes ;                                                            Integer iVal1 Integer iVal2 Integer iVal3
36992>>>>>>>>>>>            Boolean bOk bRestruct
36992>>>>>>>>>>>            Integer iIndex iMax iAttr iParams
36992>>>>>>>>>>>            String sValue sDriver
36992>>>>>>>>>>>            Move gaAttributeTypes[iAttrType].iParamCount to iParams
36993>>>>>>>>>>>            Move (SizeOfArray(gaAttributesByType[iAttrType])-1) to iMax
36994>>>>>>>>>>>            For iIndex from 0 to iMax
37000>>>>>>>>>>>>
37000>>>>>>>>>>>                Move gaAttributesByType[iAttrType][iIndex] to iAttr
37001>>>>>>>>>>>
37001>>>>>>>>>>>                If (not(gaAttributes[iAttr].bDawOnly)) Begin
37003>>>>>>>>>>>                    If (gaAttributes[iAttr].bDriverOnly) Begin
37005>>>>>>>>>>>                        If (iAttrType=ATYPE_DRIVER) Begin
37007>>>>>>>>>>>                            Get_Attribute DF_DRIVER_NAME of iVal1 to sDriver
37010>>>>>>>>>>>                            Move (sDriver<>"DATAFLEX") to bOk
37011>>>>>>>>>>>                        End
37011>>>>>>>>>>>>
37011>>>>>>>>>>>                        Else Begin
37012>>>>>>>>>>>                            Get_Attribute DF_FILE_DRIVER of iVal1 to sDriver
37015>>>>>>>>>>>                            Move (sDriver<>"DATAFLEX") to bOk
37016>>>>>>>>>>>                        End
37016>>>>>>>>>>>>
37016>>>>>>>>>>>                    End
37016>>>>>>>>>>>>
37016>>>>>>>>>>>                    Else begin
37017>>>>>>>>>>>                        Move True to bOk
37018>>>>>>>>>>>                    End
37018>>>>>>>>>>>>
37018>>>>>>>>>>>
37018>>>>>>>>>>>                    If (bOk) Begin
37020>>>>>>>>>>>                        If (iParams=0) Begin
37022>>>>>>>>>>>                            Get_Attribute iAttr to sValue
37025>>>>>>>>>>>                        End
37025>>>>>>>>>>>>
37025>>>>>>>>>>>                        Else Begin
37026>>>>>>>>>>>                            If (_CanGetAttribute(Self,iVal1,iAttr)) Begin
37028>>>>>>>>>>>                                If (iParams=1) Get_Attribute iAttr of iVal1 to sValue
37033>>>>>>>>>>>                                If (iParams=2) Get_Attribute iAttr of iVal1 iVal2 to sValue
37038>>>>>>>>>>>                                If (iParams=3) Get_Attribute iAttr of iVal1 iVal2 iVal3 to sValue
37043>>>>>>>>>>>                            End
37043>>>>>>>>>>>>
37043>>>>>>>>>>>                            Else Begin
37044>>>>>>>>>>>                                Move "" to sValue
37045>>>>>>>>>>>                            End
37045>>>>>>>>>>>>
37045>>>>>>>>>>>                        End
37045>>>>>>>>>>>>
37045>>>>>>>>>>>                        Set _AttributeValue (&aAttributes) iAttr to sValue
37046>>>>>>>>>>>                    End
37046>>>>>>>>>>>>
37046>>>>>>>>>>>                    Else begin
37047>>>>>>>>>>>                        Move "" to sValue
37048>>>>>>>>>>>                    End
37048>>>>>>>>>>>>
37048>>>>>>>>>>>                End
37048>>>>>>>>>>>>
37048>>>>>>>>>>>            Loop
37049>>>>>>>>>>>>
37049>>>>>>>>>>>        End_Procedure
37050>>>>>>>>>>>
37050>>>>>>>>>>>    Procedure _GetFieldAttributes tFieldAttributes ByRef strField Integer iTable Integer iField
37052>>>>>>>>>>>        // Make sure nothing lingers from a previous call
37052>>>>>>>>>>>        Move (ResizeArray(strField.aFieldAttributes,0)) to strField.aFieldAttributes
37053>>>>>>>>>>>        Send _GetAllAttributesOfType ATYPE_FIELD (&strField.aFieldAttributes) iTable iField
37054>>>>>>>>>>>    End_Procedure
37055>>>>>>>>>>>
37055>>>>>>>>>>>    Procedure _GetIndexSegmentAttributes tIndexSegmentAttributes ByRef strIndexSegment Integer iTable Integer iIndex Integer iSegment
37057>>>>>>>>>>>        // Make sure nothing lingers from a previous call
37057>>>>>>>>>>>        Move (ResizeArray(strIndexSegment.aIndexSegmentAttributes,0)) to strIndexSegment.aIndexSegmentAttributes
37058>>>>>>>>>>>        Send _GetAllAttributesOfType ATYPE_IDXSEG (&strIndexSegment.aIndexSegmentAttributes) iTable iIndex iSegment
37059>>>>>>>>>>>    End_Procedure
37060>>>>>>>>>>>
37060>>>>>>>>>>>    Procedure _GetIndexAttributes tIndexAttributes ByRef strIndex Integer iTable Integer iIndex
37062>>>>>>>>>>>        Integer iMaxSegment iSegment
37062>>>>>>>>>>>        tIndexSegmentAttributes strIndexSegment
37062>>>>>>>>>>>        tIndexSegmentAttributes strIndexSegment
37062>>>>>>>>>>>
37062>>>>>>>>>>>        // Make sure nothing lingers from a previous call
37062>>>>>>>>>>>        Move (ResizeArray(strIndex.aIndexAttributes,0)) to strIndex.aIndexAttributes
37063>>>>>>>>>>>        Move (ResizeArray(strIndex.aSegments,0)) to strIndex.aSegments
37064>>>>>>>>>>>
37064>>>>>>>>>>>        Get_Attribute DF_INDEX_NUMBER_SEGMENTS of iTable iIndex to iMaxSegment
37067>>>>>>>>>>>        If (iMaxSegment>=1) Begin
37069>>>>>>>>>>>            Send _GetAllAttributesOfType ATYPE_INDEX (&strIndex.aIndexAttributes) iTable iIndex
37070>>>>>>>>>>>            For iSegment from 1 to iMaxSegment
37076>>>>>>>>>>>>
37076>>>>>>>>>>>                Send _GetIndexSegmentAttributes (&strIndexSegment) iTable iIndex iSegment
37077>>>>>>>>>>>                Move strIndexSegment to strIndex.aSegments[iSegment]
37078>>>>>>>>>>>            Loop
37079>>>>>>>>>>>>
37079>>>>>>>>>>>        End
37079>>>>>>>>>>>>
37079>>>>>>>>>>>    End_Procedure
37080>>>>>>>>>>>
37080>>>>>>>>>>>    //> Get table attributes for one table (must be open)
37080>>>>>>>>>>>    Procedure GetTableAttributes tTableAttributes ByRef strTable Integer iTable // iFile must be open. If not, empty tables are returned
37082>>>>>>>>>>>        Boolean bOpen
37082>>>>>>>>>>>        Integer iMaxField iField iMaxIndex iIndex iHandleType
37082>>>>>>>>>>>        String sDriver
37082>>>>>>>>>>>        tFieldAttributes strField
37082>>>>>>>>>>>        tFieldAttributes strField
37082>>>>>>>>>>>        tIndexAttributes strIndex
37082>>>>>>>>>>>        tIndexAttributes strIndex
37082>>>>>>>>>>>
37082>>>>>>>>>>>        // Make sure nothing lingers from a previous call
37082>>>>>>>>>>>        Move (ResizeArray(strTable.aTableAttributes,0)) to strTable.aTableAttributes
37083>>>>>>>>>>>        Move (ResizeArray(strTable.aFields,0)) to strTable.aFields
37084>>>>>>>>>>>        Move (ResizeArray(strTable.aIndices,0)) to strTable.aIndices
37085>>>>>>>>>>>
37085>>>>>>>>>>>        If (iTable<>0) Begin
37087>>>>>>>>>>>
37087>>>>>>>>>>>            Get_Attribute DF_FILE_HANDLE_TYPE of iTable to iHandleType
37090>>>>>>>>>>>            If (iHandleType=DF_FILE_HANDLE_EXISTING_RESTRUCTURE or iHandleType=DF_FILE_HANDLE_NEW_RESTRUCTURE) Begin
37092>>>>>>>>>>>                Move True to bOpen
37093>>>>>>>>>>>            End
37093>>>>>>>>>>>>
37093>>>>>>>>>>>            Else Begin
37094>>>>>>>>>>>                If (iHandleType=DF_FILE_HANDLE_BAD) Begin
37096>>>>>>>>>>>                    Move False to bOpen
37097>>>>>>>>>>>                End
37097>>>>>>>>>>>>
37097>>>>>>>>>>>                Else Begin
37098>>>>>>>>>>>                    Get_Attribute DF_FILE_OPENED of iTable to bOpen
37101>>>>>>>>>>>                End
37101>>>>>>>>>>>>
37101>>>>>>>>>>>            End
37101>>>>>>>>>>>>
37101>>>>>>>>>>>
37101>>>>>>>>>>>            Move iTable to strTable.iReadFromFileListEntryNo
37102>>>>>>>>>>>            Send _GetAllAttributesOfType ATYPE_FILELIST (&strTable.aTableAttributes) iTable
37103>>>>>>>>>>>            If (bOpen) Begin
37105>>>>>>>>>>>                Get TableOpenAsPath of oTableAccessFunctions iTable to strTable.sOpenAsPath
37106>>>>>>>>>>>
37106>>>>>>>>>>>                Send _GetAllAttributesOfType ATYPE_FILE (&strTable.aTableAttributes) iTable
37107>>>>>>>>>>>    
37107>>>>>>>>>>>                Get_Attribute DF_FILE_NUMBER_FIELDS of iTable to iMaxField
37110>>>>>>>>>>>                For iField from 1 to iMaxField
37116>>>>>>>>>>>>
37116>>>>>>>>>>>                    Send _GetFieldAttributes (&strField) iTable iField
37117>>>>>>>>>>>                    Move strField to strTable.aFields[iField]
37118>>>>>>>>>>>                Loop
37119>>>>>>>>>>>>
37119>>>>>>>>>>>    
37119>>>>>>>>>>>                Get_Attribute DF_FILE_LAST_INDEX_NUMBER of iTable to iMaxIndex
37122>>>>>>>>>>>                For iIndex from 1 to iMaxIndex
37128>>>>>>>>>>>>
37128>>>>>>>>>>>                    Send _GetIndexAttributes (&strIndex) iTable iIndex
37129>>>>>>>>>>>                    Move strIndex to strTable.aIndices[iIndex]
37130>>>>>>>>>>>                Loop
37131>>>>>>>>>>>>
37131>>>>>>>>>>>            End
37131>>>>>>>>>>>>
37131>>>>>>>>>>>            Else Begin
37132>>>>>>>>>>>                Move "" to strTable.sOpenAsPath
37133>>>>>>>>>>>                // Even if the table isn't opened, we can still try to figure
37133>>>>>>>>>>>                // out which driver is supposed to be used
37133>>>>>>>>>>>                Get TableDriver of oTableAccessFunctions iTable to sDriver
37134>>>>>>>>>>>                Get DriverIdToDll of oTableDriverFunctions sDriver to sDriver
37135>>>>>>>>>>>                Set _AttributeValue (&strTable.aTableAttributes) DF_FILE_DRIVER to sDriver
37136>>>>>>>>>>>            End
37136>>>>>>>>>>>>
37136>>>>>>>>>>>        End
37136>>>>>>>>>>>>
37136>>>>>>>>>>>    End_Procedure
37137>>>>>>>>>>>
37137>>>>>>>>>>>            Function TableIndex tTableAttributes[] astTables Integer iTable Returns Integer
37139>>>>>>>>>>>                Integer iMax iIndex
37139>>>>>>>>>>>                Integer[] aTableCompressedIndices
37140>>>>>>>>>>>                Get _paTableCompressedIndices to aTableCompressedIndices
37141>>>>>>>>>>>                If (SizeOfArray(aTableCompressedIndices)>0) Begin
37143>>>>>>>>>>>                    If (iTable<=SizeOfArray(aTableCompressedIndices)) Begin
37145>>>>>>>>>>>                        Function_Return aTableCompressedIndices[iTable]
37146>>>>>>>>>>>                    End
37146>>>>>>>>>>>>
37146>>>>>>>>>>>                    Function_Return 0 // This should never happen
37147>>>>>>>>>>>                End
37147>>>>>>>>>>>>
37147>>>>>>>>>>>                Else Begin
37148>>>>>>>>>>>                    Move (SizeOfArray(astTables)-1) to iMax
37149>>>>>>>>>>>                    For iIndex from 0 to iMax
37155>>>>>>>>>>>>
37155>>>>>>>>>>>                        If (iTable=astTables[iIndex].iReadFromFileListEntryNo) Function_Return iIndex
37158>>>>>>>>>>>                    Loop
37159>>>>>>>>>>>>
37159>>>>>>>>>>>                End
37159>>>>>>>>>>>>
37159>>>>>>>>>>>                Function_Return -1
37160>>>>>>>>>>>            End_Function
37161>>>>>>>>>>>
37161>>>>>>>>>>>    //> Get table attributes for an array of tables
37161>>>>>>>>>>>    Procedure GetTablesAttributes tTableAttributes[] ByRef astTables Integer[] aSetOfTabels Boolean bAttemptOpen
37163>>>>>>>>>>>        Boolean bCanOpen bOpen bCloseAgain bIsOpen
37163>>>>>>>>>>>        Integer iTable iMax iIndex iTableIndex
37163>>>>>>>>>>>        Integer hProgressMsg hProgressObj
37163>>>>>>>>>>>        String sLogicalName
37163>>>>>>>>>>>        tTableAttributes strTable
37163>>>>>>>>>>>        tTableAttributes strTable
37163>>>>>>>>>>>        
37163>>>>>>>>>>>        Get _phProgressCallbackMsg to hProgressMsg
37164>>>>>>>>>>>        Get _phProgressCallbackObj to hProgressObj
37165>>>>>>>>>>>        
37165>>>>>>>>>>>        Move (ResizeArray(astTables,0)) to astTables
37166>>>>>>>>>>>        Move (SizeOfArray(aSetOfTabels)-1) to iMax
37167>>>>>>>>>>>        For iIndex from 0 to iMax
37173>>>>>>>>>>>>
37173>>>>>>>>>>>            Move aSetOfTabels[iIndex] to iTable
37174>>>>>>>>>>>
37174>>>>>>>>>>>            Move False to bCloseAgain
37175>>>>>>>>>>>            Get IsOpen of oTableAccessFunctions iTable to bIsOpen
37176>>>>>>>>>>>            If (not(bIsOpen) and bAttemptOpen) Begin
37178>>>>>>>>>>>                Get OpenTable of oTableAccessFunctions iTable DF_SHARE 0 to bCloseAgain
37179>>>>>>>>>>>            End
37179>>>>>>>>>>>>
37179>>>>>>>>>>>
37179>>>>>>>>>>>            If (hProgressMsg<>0) Begin
37181>>>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of iTable to sLogicalName
37184>>>>>>>>>>>                Send hProgressMsg of hProgressObj ("Reading "+sLogicalName) (iIndex+1) (iMax+1)
37185>>>>>>>>>>>            End
37185>>>>>>>>>>>>
37185>>>>>>>>>>>            Send GetTableAttributes (&strTable) iTable // Whether its actually open or not we call _GetTableAttributes. If it's not open we will simply store an empty tTableAttributes value in our array (signaling that we actually tried to read the attributes)
37186>>>>>>>>>>>
37186>>>>>>>>>>>            Get TableIndex aSetOfTabels iTable to iTableIndex
37187>>>>>>>>>>>            If (iTableIndex=-1) Begin
37189>>>>>>>>>>>                Move (SizeOfArray(astTables)) to iTableIndex
37190>>>>>>>>>>>            End
37190>>>>>>>>>>>>
37190>>>>>>>>>>>            Move strTable to astTables[iTableIndex]
37191>>>>>>>>>>>
37191>>>>>>>>>>>            If bCloseAgain Begin
37193>>>>>>>>>>>                Close iTable
37194>>>>>>>>>>>            End
37194>>>>>>>>>>>>
37194>>>>>>>>>>>        Loop
37195>>>>>>>>>>>>
37195>>>>>>>>>>>    End_Procedure
37196>>>>>>>>>>>
37196>>>>>>>>>>>    Procedure _GetDrivers tDataBaseDriver[] ByRef aDrivers
37198>>>>>>>>>>>        Integer iDriverMax iDriverIndex iServerMax iServerIndex
37198>>>>>>>>>>>        String sName
37198>>>>>>>>>>>        tAttributeValue[] aAttributeValues
37198>>>>>>>>>>>        tAttributeValue[] aAttributeValues
37199>>>>>>>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iDriverMax
37202>>>>>>>>>>>        For iDriverIndex from 1 to iDriverMax
37208>>>>>>>>>>>>
37208>>>>>>>>>>>            Send _GetAllAttributesOfType ATYPE_DRIVER (&aDrivers[iDriverIndex].aDriverAttributes) iDriverIndex
37209>>>>>>>>>>>            Get_Attribute DF_DRIVER_NAME of iDriverIndex to sName
37212>>>>>>>>>>>            If (sName<>"DATAFLEX") Begin
37214>>>>>>>>>>>                Get_Attribute DF_DRIVER_NUMBER_SERVERS of iDriverIndex to iServerMax
37217>>>>>>>>>>>                For iServerIndex from 1 to iServerMax
37223>>>>>>>>>>>>
37223>>>>>>>>>>>//                    Send _GetAllAttributesOfType ATYPE_DRVSRV (&aDrivers[iDriverIndex].aServers[iServerIndex].aServerAttributes) iDriverIndex iServerIndex 0
37223>>>>>>>>>>>                    Send _GetAllAttributesOfType ATYPE_DRVSRV (&aAttributeValues) iDriverIndex iServerIndex 0
37224>>>>>>>>>>>                    Move aAttributeValues to aDrivers[iDriverIndex].aServers[iServerIndex].aServerAttributes
37225>>>>>>>>>>>                Loop
37226>>>>>>>>>>>>
37226>>>>>>>>>>>            End
37226>>>>>>>>>>>>
37226>>>>>>>>>>>        Loop
37227>>>>>>>>>>>>
37227>>>>>>>>>>>    End_Procedure
37228>>>>>>>>>>>
37228>>>>>>>>>>>    Procedure _GetGlobals tAttributeValue[] ByRef aGlobals
37230>>>>>>>>>>>        Send _GetAllAttributesOfType ATYPE_GLOBAL (&aGlobals)
37231>>>>>>>>>>>    End_Procedure
37232>>>>>>>>>>>
37232>>>>>>>>>>>    Procedure GetAllAttributes tFileList ByRef strFilelist
37234>>>>>>>>>>>        Integer[] aTables
37235>>>>>>>>>>>        Get _paTempTableFilter to aTables
37236>>>>>>>>>>>        If (SizeOfArray(aTables)=0) Begin
37238>>>>>>>>>>>            Get TableIntegerArray of oTableAccessFunctions DF_FILE_NEXT_USED to aTables
37239>>>>>>>>>>>        End
37239>>>>>>>>>>>>
37239>>>>>>>>>>>        Send _GetGlobals (&strFilelist.aGlobalAttributes)
37240>>>>>>>>>>>        Send GetTablesAttributes (&strFilelist.aTables) aTables True
37241>>>>>>>>>>>        Send _GetDrivers (&strFilelist.aDrivers)
37242>>>>>>>>>>>    End_Procedure
37243>>>>>>>>>>>
37243>>>>>>>>>>>    Procedure GetAllAttributesProgressCallback tFileList ByRef strFilelist Integer hMsg Integer hObj
37245>>>>>>>>>>>        Set _phProgressCallbackMsg to hMsg
37246>>>>>>>>>>>        Set _phProgressCallbackObj to hObj
37247>>>>>>>>>>>        Send GetAllAttributes (&strFilelist)
37248>>>>>>>>>>>        Set _phProgressCallbackMsg to 0
37249>>>>>>>>>>>        Set _phProgressCallbackObj to 0
37250>>>>>>>>>>>    End_Procedure
37251>>>>>>>>>>>
37251>>>>>>>>>>>    Function FilelistNavigationTableArray tTableAttributes[] astTables Integer iFileListNavAttr Returns Integer[]
37253>>>>>>>>>>>        Integer iTable iIndex
37253>>>>>>>>>>>        Integer[] aTables
37254>>>>>>>>>>>        If (iFileListNavAttr=DF_FILE_NEXT_OPENED or iFileListNavAttr=DF_FILE_NEXT_USED or iFileListNavAttr=DF_FILE_NEXT_EMPTY) Begin
37256>>>>>>>>>>>            Move 0 to iTable
37257>>>>>>>>>>>            Move 0 to iIndex
37258>>>>>>>>>>>            Repeat
37258>>>>>>>>>>>>
37258>>>>>>>>>>>                Get TableAttribute astTables iFileListNavAttr iTable 0 0 to iTable
37259>>>>>>>>>>>                If (iTable<>0) Begin
37261>>>>>>>>>>>                    Move iTable to aTables[iIndex]
37262>>>>>>>>>>>                    Increment iIndex
37263>>>>>>>>>>>                End
37263>>>>>>>>>>>>
37263>>>>>>>>>>>            Until (iTable=0)
37265>>>>>>>>>>>        End
37265>>>>>>>>>>>>
37265>>>>>>>>>>>        Function_Return aTables
37266>>>>>>>>>>>    End_Function
37267>>>>>>>>>>>
37267>>>>>>>>>>>    // iAttr=DF_FILE_NEXT_USED|DF_FILE_NEXT_EMPTY
37267>>>>>>>>>>>//    Function FilelistNavigation Integer iAttr Integer iTable Boolean bAscending Returns Integer
37267>>>>>>>>>>>//        If (iAttr=DF_FILE_NEXT_USED)
37267>>>>>>>>>>>//    End_Function
37267>>>>>>>>>>>
37267>>>>>>>>>>>    Function TableAttribute tTableAttributes[] astTables Integer iAttr Integer iTable Integer iVal1 Integer iVal2 Returns String
37269>>>>>>>>>>>        Integer iTableIndex iAttrType
37269>>>>>>>>>>>        Integer iStart1 iEnd1 iStart2 iEnd2 iRecordLength
37269>>>>>>>>>>>        String sRval
37269>>>>>>>>>>>
37269>>>>>>>>>>>        Move "" to sRval
37270>>>>>>>>>>>        Move gaAttributes[iAttr].iAttrType to iAttrType
37271>>>>>>>>>>>
37271>>>>>>>>>>>        If (iAttrType=ATYPE_FLSTNAV) Begin
37273>>>>>>>>>>>            Repeat
37273>>>>>>>>>>>>
37273>>>>>>>>>>>                Increment iTable
37274>>>>>>>>>>>                Get TableIndex astTables iTable to iTableIndex
37275>>>>>>>>>>>                If (iAttr=DF_FILE_NEXT_OPENED) Begin
37277>>>>>>>>>>>                    // This makes no sense except that of course the table was open at the time its definition was recorded.
37277>>>>>>>>>>>                    If (iTableIndex<>-1) Move iTable to sRval
37280>>>>>>>>>>>                End
37280>>>>>>>>>>>>
37280>>>>>>>>>>>                If (iAttr=DF_FILE_NEXT_USED) Begin
37282>>>>>>>>>>>                    If (iTableIndex<>-1) Move iTable to sRval
37285>>>>>>>>>>>                End
37285>>>>>>>>>>>>
37285>>>>>>>>>>>                If (iAttr=DF_FILE_NEXT_EMPTY) Begin
37287>>>>>>>>>>>                    If (iTableIndex=-1) Move iTable to sRval
37290>>>>>>>>>>>                End
37290>>>>>>>>>>>>
37290>>>>>>>>>>>            Until (sRval<>"" or iTable>4096)
37292>>>>>>>>>>>        End
37292>>>>>>>>>>>>
37292>>>>>>>>>>>        Else Begin
37293>>>>>>>>>>>            Get TableIndex astTables iTable to iTableIndex
37294>>>>>>>>>>>            If (iTableIndex<>-1) Begin
37296>>>>>>>>>>>                If (iAttrType=ATYPE_FILELIST or iAttrType=ATYPE_FILE) Begin
37298>>>>>>>>>>>                    If (iAttr=DF_FILE_OPENED) Begin // If table can be found => it's open
37300>>>>>>>>>>>                        Get _AttributeValue astTables[iTableIndex].aTableAttributes DF_FILE_RECORD_LENGTH to iRecordLength
37301>>>>>>>>>>>                        If (iRecordLength<>0) Begin
37303>>>>>>>>>>>                            Move 1 to sRval
37304>>>>>>>>>>>                        End
37304>>>>>>>>>>>>
37304>>>>>>>>>>>                    End
37304>>>>>>>>>>>>
37304>>>>>>>>>>>                    Else Begin
37305>>>>>>>>>>>                        Get _AttributeValue astTables[iTableIndex].aTableAttributes iAttr to sRval
37306>>>>>>>>>>>                    End
37306>>>>>>>>>>>>
37306>>>>>>>>>>>                End
37306>>>>>>>>>>>>
37306>>>>>>>>>>>                Else If (iAttrType=ATYPE_FIELD) Begin
37309>>>>>>>>>>>                    If (SizeOfArray(astTables[iTableIndex].aFields)>0) Begin
37311>>>>>>>>>>>                        Get _AttributeValue astTables[iTableIndex].aFields[iVal1].aFieldAttributes iAttr to sRval
37312>>>>>>>>>>>                    End
37312>>>>>>>>>>>>
37312>>>>>>>>>>>                End
37312>>>>>>>>>>>>
37312>>>>>>>>>>>                Else If (iAttrType=ATYPE_INDEX) Begin
37315>>>>>>>>>>>                    If (iVal1>=SizeOfArray(astTables[iTableIndex].aIndices)) Begin
37317>>>>>>>>>>>                        Move "" to sRval
37318>>>>>>>>>>>                    End
37318>>>>>>>>>>>>
37318>>>>>>>>>>>                    Else Begin
37319>>>>>>>>>>>                        Get _AttributeValue astTables[iTableIndex].aIndices[iVal1].aIndexAttributes iAttr to sRval
37320>>>>>>>>>>>                    End
37320>>>>>>>>>>>>
37320>>>>>>>>>>>                End
37320>>>>>>>>>>>>
37320>>>>>>>>>>>                Else If (iAttrType=ATYPE_IDXSEG) Begin
37323>>>>>>>>>>>                    Get _AttributeValue astTables[iTableIndex].aIndices[iVal1].aSegments[iVal2].aIndexSegmentAttributes iAttr to sRval
37324>>>>>>>>>>>                End
37324>>>>>>>>>>>>
37324>>>>>>>>>>>                Else If (iAttrType=ATYPE_SPECIAL) Begin
37327>>>>>>>>>>>                    If (iAttr=DF_FIELD_OVERLAP) Begin // Must be calculated
37329>>>>>>>>>>>                        Get _AttributeValue astTables[iTableIndex].aFields[iVal1].aFieldAttributes DF_FIELD_OFFSET to iStart1
37330>>>>>>>>>>>                        Get _AttributeValue astTables[iTableIndex].aFields[iVal2].aFieldAttributes DF_FIELD_OFFSET to iStart2
37331>>>>>>>>>>>                        Get _AttributeValue astTables[iTableIndex].aFields[iVal1].aFieldAttributes DF_FIELD_NATIVE_LENGTH to iEnd1
37332>>>>>>>>>>>                        Get _AttributeValue astTables[iTableIndex].aFields[iVal2].aFieldAttributes DF_FIELD_NATIVE_LENGTH to iEnd2
37333>>>>>>>>>>>                        Move (iStart1+iEnd1-1) to iEnd1
37334>>>>>>>>>>>                        Move (iStart2+iEnd2-1) to iEnd2
37335>>>>>>>>>>>                        Move (iStart1<=iEnd2 and iStart2<=iEnd1) to sRval
37336>>>>>>>>>>>                    End
37336>>>>>>>>>>>>
37336>>>>>>>>>>>                End
37336>>>>>>>>>>>>
37336>>>>>>>>>>>            End
37336>>>>>>>>>>>>
37336>>>>>>>>>>>        End
37336>>>>>>>>>>>>
37336>>>>>>>>>>>        Function_Return sRval
37337>>>>>>>>>>>    End_Function
37338>>>>>>>>>>>
37338>>>>>>>>>>>    Procedure Set TableAttribute tTableAttributes[] ByRef astTables Integer iAttr Integer iTable Integer iVal1 Integer iVal2 String sValue 
37340>>>>>>>>>>>        Integer iTableIndex iAttrType
37340>>>>>>>>>>>        Move gaAttributes[iAttr].iAttrType to iAttrType
37341>>>>>>>>>>>        Get TableIndex astTables iTable to iTableIndex
37342>>>>>>>>>>>        If (iTableIndex<>-1) Begin
37344>>>>>>>>>>>            If (iAttrType=ATYPE_FILELIST or iAttrType=ATYPE_FILE) Begin
37346>>>>>>>>>>>                Set _AttributeValue astTables[iTableIndex].aTableAttributes iAttr to sValue
37347>>>>>>>>>>>            End
37347>>>>>>>>>>>>
37347>>>>>>>>>>>            Else If (iAttrType=ATYPE_FIELD) Begin
37350>>>>>>>>>>>                Set _AttributeValue astTables[iTableIndex].aFields[iVal1].aFieldAttributes iAttr to sValue
37351>>>>>>>>>>>            End
37351>>>>>>>>>>>>
37351>>>>>>>>>>>            Else If (iAttrType=ATYPE_INDEX) Begin
37354>>>>>>>>>>>                Set _AttributeValue astTables[iTableIndex].aIndices[iVal1].aIndexAttributes iAttr to sValue
37355>>>>>>>>>>>            End
37355>>>>>>>>>>>>
37355>>>>>>>>>>>            Else If (iAttrType=ATYPE_IDXSEG) Begin
37358>>>>>>>>>>>                Set _AttributeValue astTables[iTableIndex].aIndices[iVal1].aSegments[iVal2].aIndexSegmentAttributes iAttr to sValue
37359>>>>>>>>>>>            End
37359>>>>>>>>>>>>
37359>>>>>>>>>>>            Else If (iAttrType=ATYPE_SPECIAL) Begin
37362>>>>>>>>>>>                // It's an overlap calculation to be done when neeeded sometime
37362>>>>>>>>>>>                Error 811 "Read only attributes"
37363>>>>>>>>>>>>
37363>>>>>>>>>>>            End
37363>>>>>>>>>>>>
37363>>>>>>>>>>>        End
37363>>>>>>>>>>>>
37363>>>>>>>>>>>    End_Procedure
37364>>>>>>>>>>>
37364>>>>>>>>>>>    Function DriverAttribute tDataBaseDriver[] aDrivers Integer iAttr Integer iDriverIndex Integer iServerIndex Returns String
37366>>>>>>>>>>>        Integer iAttrType
37366>>>>>>>>>>>        String sRval
37366>>>>>>>>>>>        Move gaAttributes[iAttr].iAttrType to iAttrType
37367>>>>>>>>>>>        If (iAttrType=ATYPE_DRIVER) Begin
37369>>>>>>>>>>>            Get _AttributeValue aDrivers[iDriverIndex].aDriverAttributes iAttr to sRval
37370>>>>>>>>>>>        End
37370>>>>>>>>>>>>
37370>>>>>>>>>>>        Else If (iAttrType=ATYPE_DRVSRV) Begin
37373>>>>>>>>>>>            Get _AttributeValue aDrivers[iDriverIndex].aServers[iServerIndex].aServerAttributes iAttr to sRval
37374>>>>>>>>>>>        End
37374>>>>>>>>>>>>
37374>>>>>>>>>>>        Function_Return sRval
37375>>>>>>>>>>>    End_Function
37376>>>>>>>>>>>
37376>>>>>>>>>>>    Procedure Set DriverAttribute tDataBaseDriver[] aDrivers Integer iAttr Integer iDriverIndex Integer iServerIndex String sValue
37378>>>>>>>>>>>        Integer iAttrType
37378>>>>>>>>>>>        Move gaAttributes[iAttr].iAttrType to iAttrType
37379>>>>>>>>>>>        If (iAttrType=ATYPE_DRIVER) Begin
37381>>>>>>>>>>>            Set _AttributeValue aDrivers[iDriverIndex].aDriverAttributes iAttr to sValue
37382>>>>>>>>>>>        End
37382>>>>>>>>>>>>
37382>>>>>>>>>>>        Else If (iAttrType=ATYPE_DRVSRV) Begin
37385>>>>>>>>>>>            Set _AttributeValue aDrivers[iDriverIndex].aServers[iServerIndex].aServerAttributes iAttr to sValue
37386>>>>>>>>>>>        End
37386>>>>>>>>>>>>
37386>>>>>>>>>>>    End_Procedure
37387>>>>>>>>>>>
37387>>>>>>>>>>>    Function Attrib tFileList strFilelist Integer iAttr Integer iVal1 Integer iVal2 Integer iVal3 Returns String
37389>>>>>>>>>>>        Integer iAttrType
37389>>>>>>>>>>>        String sRval
37389>>>>>>>>>>>        Move gaAttributes[iAttr].iAttrType to iAttrType
37390>>>>>>>>>>>        If (iAttrType=ATYPE_GLOBAL) begin
37392>>>>>>>>>>>            Get _AttributeValue strFilelist.aGlobalAttributes iAttr to sRval
37393>>>>>>>>>>>        End
37393>>>>>>>>>>>>
37393>>>>>>>>>>>        Else If (iAttrType=ATYPE_DRIVER or iAttrType=ATYPE_DRVSRV) begin
37396>>>>>>>>>>>            Get DriverAttribute strFilelist.aDrivers iAttr iVal1 iVal2 to sRval
37397>>>>>>>>>>>        End
37397>>>>>>>>>>>>
37397>>>>>>>>>>>        Else Begin
37398>>>>>>>>>>>            Get TableAttribute strFilelist.aTables iAttr iVal1 iVal2 iVal3 to sRval
37399>>>>>>>>>>>        End
37399>>>>>>>>>>>>
37399>>>>>>>>>>>        Function_Return sRval
37400>>>>>>>>>>>    End_Function
37401>>>>>>>>>>>
37401>>>>>>>>>>>    Procedure Set Attrib tFileList ByRef strFilelist Integer iAttr Integer iVal1 Integer iVal2 Integer iVal3 String sValue
37403>>>>>>>>>>>        Integer iAttrType
37403>>>>>>>>>>>        Move gaAttributes[iAttr].iAttrType to iAttrType
37404>>>>>>>>>>>        If (iAttrType=ATYPE_GLOBAL) Begin
37406>>>>>>>>>>>            Set _AttributeValue (&strFilelist.aGlobalAttributes) iAttr to sValue
37407>>>>>>>>>>>        End
37407>>>>>>>>>>>>
37407>>>>>>>>>>>        Else If (iAttrType=ATYPE_DRIVER or iAttrType=ATYPE_DRVSRV) Begin
37410>>>>>>>>>>>            Set DriverAttribute (&strFilelist.aDrivers) iAttr iVal1 iVal2 to sValue
37411>>>>>>>>>>>        End
37411>>>>>>>>>>>>
37411>>>>>>>>>>>        Else Begin
37412>>>>>>>>>>>            Set TableAttribute (&strFilelist.aTables) iAttr iVal1 iVal2 iVal3 to sValue
37413>>>>>>>>>>>        End
37413>>>>>>>>>>>>
37413>>>>>>>>>>>    End_Procedure
37414>>>>>>>>>>>
37414>>>>>>>>>>>    // Procedure _HandleAttribute tTableAttributes[] astTables integer iAttr integer iTable integer iVal1 integer iVal2 string sValue String sDisplayValue
37414>>>>>>>>>>>    Procedure CallBackAttributeValues Integer hMsg Integer hObj tFileList strFilelist Integer iAttrType Integer iTable Integer iVal1 Integer iVal2
37416>>>>>>>>>>>        Integer iMax iIndex iAttr
37416>>>>>>>>>>>        String sValue
37416>>>>>>>>>>>        String sDisplayValue
37416>>>>>>>>>>>        Move (SizeOfArray(gaAttributesByType[iAttrType])-1) to iMax
37417>>>>>>>>>>>        For iIndex from 0 to iMax
37423>>>>>>>>>>>>
37423>>>>>>>>>>>            Move gaAttributesByType[iAttrType][iIndex] to iAttr
37424>>>>>>>>>>>            Get Attrib strFilelist iAttr iTable iVal1 iVal2 to sValue
37425>>>>>>>>>>>            Get AttributeDisplayValue iAttr sValue to sDisplayValue
37426>>>>>>>>>>>            Send hMsg of hObj strFilelist iAttr iTable iVal1 iVal2 sValue sDisplayValue
37427>>>>>>>>>>>        Loop
37428>>>>>>>>>>>>
37428>>>>>>>>>>>    End_Procedure
37429>>>>>>>>>>>
37429>>>>>>>>>>>    // Procedure HandleAttribute integer iAttr tAttributeDefinition stAttrDef
37429>>>>>>>>>>>    Procedure CallBackAttributes Integer hMsg Integer hObj Integer iAttrType
37431>>>>>>>>>>>        Integer iMax iIndex iAttr
37431>>>>>>>>>>>        Move (SizeOfArray(gaAttributesByType[iAttrType])-1) to iMax
37432>>>>>>>>>>>        For iIndex from 0 to iMax
37438>>>>>>>>>>>>
37438>>>>>>>>>>>            Move gaAttributesByType[iAttrType][iIndex] to iAttr
37439>>>>>>>>>>>            Send hMsg of hObj iAttr gaAttributes[iAttr]
37440>>>>>>>>>>>        Loop
37441>>>>>>>>>>>>
37441>>>>>>>>>>>    End_Procedure
37442>>>>>>>>>>>
37442>>>>>>>>>>>    Function FieldAttributesToExplicit tFieldAttributes strField Returns tTableFieldExplicit
37444>>>>>>>>>>>        tTableFieldExplicit stFieldExplicit
37444>>>>>>>>>>>        tTableFieldExplicit stFieldExplicit
37444>>>>>>>>>>>
37444>>>>>>>>>>>        Get _AttributeValue strField.aFieldAttributes DF_FIELD_NUMBER to stFieldExplicit.iPosition
37445>>>>>>>>>>>        Get _AttributeValue strField.aFieldAttributes DF_FIELD_NAME to stFieldExplicit.sName
37446>>>>>>>>>>>        Get _AttributeValue strField.aFieldAttributes DF_FIELD_TYPE to stFieldExplicit.iType
37447>>>>>>>>>>>        Get _AttributeValue strField.aFieldAttributes DF_FIELD_LENGTH to stFieldExplicit.iLen
37448>>>>>>>>>>>        Get _AttributeValue strField.aFieldAttributes DF_FIELD_PRECISION to stFieldExplicit.iPrecision
37449>>>>>>>>>>>        Get _AttributeValue strField.aFieldAttributes DF_FIELD_RELATED_FILE to stFieldExplicit.iRelFile
37450>>>>>>>>>>>        Get _AttributeValue strField.aFieldAttributes DF_FIELD_RELATED_FIELD to stFieldExplicit.iRelField
37451>>>>>>>>>>>        Get _AttributeValue strField.aFieldAttributes DF_FIELD_INDEX to stFieldExplicit.iMainIndex
37452>>>>>>>>>>>        Get _AttributeValue strField.aFieldAttributes DF_FIELD_OFFSET to stFieldExplicit.iOffset
37453>>>>>>>>>>>        Get _AttributeValue strField.aFieldAttributes DF_FIELD_NATIVE_LENGTH to stFieldExplicit.iNativeLength
37454>>>>>>>>>>>
37454>>>>>>>>>>>        Function_Return stFieldExplicit
37455>>>>>>>>>>>    End_Function
37456>>>>>>>>>>>
37456>>>>>>>>>>>    Function IndexAttributesToExplicit tIndexAttributes strIndex Returns tTableIndexExplicit
37458>>>>>>>>>>>        Integer iSegmentIndex iSegmentMax
37458>>>>>>>>>>>        Integer iDirection iCase
37458>>>>>>>>>>>        tTableIndexExplicit stIndexExplicit
37458>>>>>>>>>>>        tTableIndexExplicit stIndexExplicit
37458>>>>>>>>>>>
37458>>>>>>>>>>>        Move (SizeOfArray(strIndex.aSegments)-1) to iSegmentMax
37459>>>>>>>>>>>        If (iSegmentMax>=0) Begin
37461>>>>>>>>>>>            Get _AttributeValue strIndex.aIndexAttributes DF_INDEX_TYPE to stIndexExplicit.iType
37462>>>>>>>>>>>            Get _AttributeValue strIndex.aIndexAttributes DF_INDEX_LEVELS to stIndexExplicit.iLevels
37463>>>>>>>>>>>            Get _AttributeValue strIndex.aIndexAttributes DF_INDEX_KEY_LENGTH to stIndexExplicit.iKeyLength
37464>>>>>>>>>>>            For iSegmentIndex from 0 to iSegmentMax
37470>>>>>>>>>>>>
37470>>>>>>>>>>>                Get _AttributeValue strIndex.aSegments[iSegmentIndex].aIndexSegmentAttributes DF_INDEX_SEGMENT_FIELD to stIndexExplicit.aFields[iSegmentIndex]
37471>>>>>>>>>>>                Get _AttributeValue strIndex.aSegments[iSegmentIndex].aIndexSegmentAttributes DF_INDEX_SEGMENT_DIRECTION to iDirection
37472>>>>>>>>>>>                Move (iDirection=DF_DESCENDING) to stIndexExplicit.aDescending[iSegmentIndex]
37473>>>>>>>>>>>                Get _AttributeValue strIndex.aSegments[iSegmentIndex].aIndexSegmentAttributes DF_INDEX_SEGMENT_CASE to iCase
37474>>>>>>>>>>>                Move (iCase=DF_CASE_IGNORED) to stIndexExplicit.aCaseInsensitive[iSegmentIndex]
37475>>>>>>>>>>>            Loop
37476>>>>>>>>>>>>
37476>>>>>>>>>>>            Move (stIndexExplicit.aFields[iSegmentMax]<>0) to stIndexExplicit.bUnique
37477>>>>>>>>>>>        End
37477>>>>>>>>>>>>
37477>>>>>>>>>>>        Function_Return stIndexExplicit
37478>>>>>>>>>>>    End_Function
37479>>>>>>>>>>>    
37479>>>>>>>>>>>    Function TableAttributesToExplicit tTableAttributes strTable Returns tTableExplicit
37481>>>>>>>>>>>        Integer iFieldIndex iFieldMax
37481>>>>>>>>>>>        Integer iIndexIndex iIndexMax
37481>>>>>>>>>>>        Integer iValue
37481>>>>>>>>>>>        Integer[] aOverlappedFields
37482>>>>>>>>>>>        tTableExplicit strTableExplicit
37482>>>>>>>>>>>        tTableExplicit strTableExplicit
37482>>>>>>>>>>>        Move strTable.iReadFromFileListEntryNo                              to strTableExplicit.iFileListEntry   
37483>>>>>>>>>>>        Get _AttributeValue strTable.aTableAttributes DF_FILE_DRIVER        to strTableExplicit.sDriver
37484>>>>>>>>>>>        Get _AttributeValue strTable.aTableAttributes DF_FILE_MAX_RECORDS   to strTableExplicit.nMaxRecords      
37485>>>>>>>>>>>        Get _AttributeValue strTable.aTableAttributes DF_FILE_RECORDS_USED  to strTableExplicit.nRecordsUsed     
37486>>>>>>>>>>>        Get _AttributeValue strTable.aTableAttributes DF_FILE_PHYSICAL_NAME to strTableExplicit.sPhysicalName    
37487>>>>>>>>>>>        Get _AttributeValue strTable.aTableAttributes DF_FILE_RECORD_LENGTH to strTableExplicit.iRecordLength    
37488>>>>>>>>>>>        Get _AttributeValue strTable.aTableAttributes DF_FILE_RECORD_LENGTH_USED to strTableExplicit.iRecordLengthUsed
37489>>>>>>>>>>>        Get _AttributeValue strTable.aTableAttributes DF_FILE_LOCK_TYPE     to strTableExplicit.iLockType
37490>>>>>>>>>>>        Get _AttributeValue strTable.aTableAttributes DF_FILE_INTEGRITY_CHECK to strTableExplicit.iIntegrityCheck
37491>>>>>>>>>>>        Get _AttributeValue strTable.aTableAttributes DF_FILE_IS_SYSTEM_FILE to iValue
37492>>>>>>>>>>>        Move (iValue<>0) to strTableExplicit.bSystemFile
37493>>>>>>>>>>>        
37493>>>>>>>>>>>        // Columns:
37493>>>>>>>>>>>        Move (SizeOfArray(strTable.aFields)-1) to iFieldMax
37494>>>>>>>>>>>        For iFieldIndex from 0 to iFieldMax
37500>>>>>>>>>>>>
37500>>>>>>>>>>>            Get FieldAttributesToExplicit strTable.aFields[iFieldIndex] to strTableExplicit.aFields[iFieldIndex]
37501>>>>>>>>>>>            If (strTableExplicit.aFields[iFieldIndex].iType=DF_OVERLAP) Begin
37503>>>>>>>>>>>                Get OverlapToColumns strTable iFieldIndex to aOverlappedFields
37504>>>>>>>>>>>                If (SizeOfArray(aOverlappedFields)<>0) Begin // We need this condition because an overlap field may defined to overlap nothing at all (length 0, for example)
37506>>>>>>>>>>>                    Move aOverlappedFields[0] to strTableExplicit.aFields[iFieldIndex].iOverlapFieldStart
37507>>>>>>>>>>>                    Move aOverlappedFields[SizeOfArray(aOverlappedFields)-1] to strTableExplicit.aFields[iFieldIndex].iOverlapFieldEnd
37508>>>>>>>>>>>                End
37508>>>>>>>>>>>>
37508>>>>>>>>>>>            End
37508>>>>>>>>>>>>
37508>>>>>>>>>>>        Loop
37509>>>>>>>>>>>>
37509>>>>>>>>>>>
37509>>>>>>>>>>>        // Indices:
37509>>>>>>>>>>>        Move (SizeOfArray(strTable.aIndices)-1) to iIndexMax
37510>>>>>>>>>>>        For iIndexIndex from 0 to iIndexMax
37516>>>>>>>>>>>>
37516>>>>>>>>>>>            Get IndexAttributesToExplicit strTable.aIndices[iIndexIndex] to strTableExplicit.aIndices[iIndexIndex]
37517>>>>>>>>>>>        Loop
37518>>>>>>>>>>>>
37518>>>>>>>>>>>
37518>>>>>>>>>>>        Function_Return strTableExplicit
37519>>>>>>>>>>>    End_Function
37520>>>>>>>>>>>    
37520>>>>>>>>>>>    Function FilelistEntryToExplicit tFileList strFilelist Integer iTable Returns tTableExplicit
37522>>>>>>>>>>>        tTableAttributes strTable
37522>>>>>>>>>>>        tTableAttributes strTable
37522>>>>>>>>>>>        String sValue
37522>>>>>>>>>>>        tTableExplicit strTableExplicit
37522>>>>>>>>>>>        tTableExplicit strTableExplicit
37522>>>>>>>>>>>        
37522>>>>>>>>>>>        Move iTable to strTableExplicit.iFileListEntry
37523>>>>>>>>>>>        // Convert to array index:
37523>>>>>>>>>>>        Get TableIndex strFilelist.aTables iTable to iTable 
37524>>>>>>>>>>>        
37524>>>>>>>>>>>        Move strFilelist.aTables[iTable] to strTable
37525>>>>>>>>>>>        Get TableAttributesToExplicit strTable to strTableExplicit
37526>>>>>>>>>>>        
37526>>>>>>>>>>>        Get _AttributeValue strTable.aTableAttributes DF_FILE_ROOT_NAME to strTableExplicit.sRootName   
37527>>>>>>>>>>>        Get _AttributeValue strTable.aTableAttributes DF_FILE_LOGICAL_NAME to strTableExplicit.sLogicalName
37528>>>>>>>>>>>        Get _AttributeValue strTable.aTableAttributes DF_FILE_DISPLAY_NAME to strTableExplicit.sDisplayName
37529>>>>>>>>>>>        
37529>>>>>>>>>>>        Function_Return strTableExplicit
37530>>>>>>>>>>>    End_Function
37531>>>>>>>>>>>    
37531>>>>>>>>>>>    Function FilelistToExplicitArray tFileList strFilelist Returns tTableExplicit[]
37533>>>>>>>>>>>        Integer iItem iMax iTable 
37533>>>>>>>>>>>        Integer[] aTables
37534>>>>>>>>>>>        tTableExplicit[] aTableExplicits
37534>>>>>>>>>>>        tTableExplicit[] aTableExplicits
37535>>>>>>>>>>>        
37535>>>>>>>>>>>        Get FilelistNavigationTableArray strFilelist.aTables DF_FILE_NEXT_USED to aTables
37536>>>>>>>>>>>        Move (SizeOfArray(aTables)-1) to iMax
37537>>>>>>>>>>>        For iItem from 0 to iMax
37543>>>>>>>>>>>>
37543>>>>>>>>>>>            Get FilelistEntryToExplicit strFilelist aTables[iItem] to aTableExplicits[iItem]
37544>>>>>>>>>>>        Loop
37545>>>>>>>>>>>>
37545>>>>>>>>>>>        
37545>>>>>>>>>>>        Function_Return aTableExplicits
37546>>>>>>>>>>>    End_Function
37547>>>>>>>>>>>    
37547>>>>>>>>>>>    Procedure CallBackTableAttributes Integer hMsg Integer hObj tTableAttributes strTable
37549>>>>>>>>>>>        Integer iMax iIndex iAttr
37549>>>>>>>>>>>        String sValue
37549>>>>>>>>>>>        Move (SizeOfArray(gaAttributesByType[ATYPE_FILE])-1) to iMax
37550>>>>>>>>>>>        For iIndex from 0 to iMax
37556>>>>>>>>>>>>
37556>>>>>>>>>>>            Move gaAttributesByType[ATYPE_FILE][iIndex] to iAttr
37557>>>>>>>>>>>            Get _AttributeValue strTable.aTableAttributes iAttr to sValue
37558>>>>>>>>>>>            Send hMsg of hObj strTable iAttr sValue
37559>>>>>>>>>>>        Loop
37560>>>>>>>>>>>>
37560>>>>>>>>>>>    End_Procedure
37561>>>>>>>>>>>    
37561>>>>>>>>>>>    Procedure AppendArrays Variant[] ByRef aArray1 Variant[] aArray2
37563>>>>>>>>>>>        Integer iIndex1 iIndex2 iMax2
37563>>>>>>>>>>>        Move (SizeOfArray(aArray1)) to iIndex1
37564>>>>>>>>>>>        Move (SizeOfArray(aArray2)-1) to iMax2
37565>>>>>>>>>>>        For iIndex2 from 0 to iMax2
37571>>>>>>>>>>>>
37571>>>>>>>>>>>            Move aArray2[iIndex2] to aArray1[iIndex1]
37572>>>>>>>>>>>            Increment iIndex1
37573>>>>>>>>>>>        Loop
37574>>>>>>>>>>>>
37574>>>>>>>>>>>    End_Procedure
37575>>>>>>>>>>>
37575>>>>>>>>>>>    Function FieldArrayReplaceOverlap tTableAttributes[] astTables tTableField strField Returns tTableField[]
37577>>>>>>>>>>>        Boolean bOverlaps
37577>>>>>>>>>>>        Integer iTableIndex iResultIndex iFieldType
37577>>>>>>>>>>>        Integer iFieldMax iFieldIndex
37577>>>>>>>>>>>        tTableField[] aResultFields
37577>>>>>>>>>>>        tTableField[] aResultFields
37578>>>>>>>>>>>        tFieldAttributes[] aFields
37578>>>>>>>>>>>        tFieldAttributes[] aFields
37579>>>>>>>>>>>
37579>>>>>>>>>>>        Move 0 to iResultIndex
37580>>>>>>>>>>>
37580>>>>>>>>>>>        Get TableIndex astTables strField.iTable to iTableIndex
37581>>>>>>>>>>>        If (iTableIndex<>-1) Begin
37583>>>>>>>>>>>            Get TableAttribute astTables DF_FIELD_TYPE strField.iTable strField.iField to iFieldType
37584>>>>>>>>>>>            If (iFieldType=DF_OVERLAP) Begin
37586>>>>>>>>>>>                Move astTables[iTableIndex].aFields to aFields
37587>>>>>>>>>>>                Move (SizeOfArray(aFields)-1) to iFieldMax
37588>>>>>>>>>>>                For iFieldIndex from 1 to iFieldMax
37594>>>>>>>>>>>>
37594>>>>>>>>>>>                    Get TableAttribute astTables DF_FIELD_TYPE strField.iTable iFieldIndex to iFieldType
37595>>>>>>>>>>>                    If (iFieldIndex<>strField.iField and iFieldType<>DF_OVERLAP) Begin
37597>>>>>>>>>>>                        Get TableAttribute astTables DF_FIELD_OVERLAP strField.iTable strField.iField iFieldIndex to bOverlaps
37598>>>>>>>>>>>                        If (bOverlaps) Begin
37600>>>>>>>>>>>                            Move strField.iTable to aResultFields[iResultIndex].iTable
37601>>>>>>>>>>>                            Move iFieldIndex to aResultFields[iResultIndex].iField
37602>>>>>>>>>>>                            Move strField.bCapslock to aResultFields[iResultIndex].bCapslock
37603>>>>>>>>>>>                            Move strField.bDescending to aResultFields[iResultIndex].bDescending
37604>>>>>>>>>>>                            Increment iResultIndex
37605>>>>>>>>>>>                        End
37605>>>>>>>>>>>>
37605>>>>>>>>>>>                    End
37605>>>>>>>>>>>>
37605>>>>>>>>>>>                Loop
37606>>>>>>>>>>>>
37606>>>>>>>>>>>            End
37606>>>>>>>>>>>>
37606>>>>>>>>>>>            Else Move strField to aResultFields[0] // If it's not an overlap field we just return the field itself
37608>>>>>>>>>>>        End
37608>>>>>>>>>>>>
37608>>>>>>>>>>>        Else Move strField to aResultFields[0] // This is pointless. If iTable is not in astTable we are in an error condition anyway.
37610>>>>>>>>>>>        Function_Return aResultFields
37611>>>>>>>>>>>    End_Function
37612>>>>>>>>>>>    
37612>>>>>>>>>>>    Function FieldArrayReplaceOverlaps tTableAttributes[] astTables tTableField[] aFields Returns tTableField[]
37614>>>>>>>>>>>        Integer iFieldIndex iFieldMax
37614>>>>>>>>>>>        tTableField[] aTemp
37614>>>>>>>>>>>        tTableField[] aTemp
37615>>>>>>>>>>>        tTableField[] aResultFields
37615>>>>>>>>>>>        tTableField[] aResultFields
37616>>>>>>>>>>>        Move (SizeOfArray(aFields)-1) to iFieldMax
37617>>>>>>>>>>>        For iFieldIndex from 0 to iFieldMax
37623>>>>>>>>>>>>
37623>>>>>>>>>>>            Get FieldArrayReplaceOverlap astTables aFields[iFieldIndex] to aTemp
37624>>>>>>>>>>>            Send AppendArrays (&aResultFields) aTemp
37625>>>>>>>>>>>        Loop
37626>>>>>>>>>>>>
37626>>>>>>>>>>>        Function_Return aResultFields
37627>>>>>>>>>>>    End_Function
37628>>>>>>>>>>>    
37628>>>>>>>>>>>    Function OverlapToColumns tTableAttributes strTable Integer iField Returns Integer[]
37630>>>>>>>>>>>        Integer iMax iIndex
37630>>>>>>>>>>>        Integer[] aFields
37631>>>>>>>>>>>        tTableAttributes[] astTables
37631>>>>>>>>>>>        tTableAttributes[] astTables
37632>>>>>>>>>>>        tTableField strField
37632>>>>>>>>>>>        tTableField strField
37632>>>>>>>>>>>        tTableField[] astFields
37632>>>>>>>>>>>        tTableField[] astFields
37633>>>>>>>>>>>        
37633>>>>>>>>>>>        Move strTable to astTables[0]
37634>>>>>>>>>>>        Move strTable.iReadFromFileListEntryNo to strField.iTable
37635>>>>>>>>>>>        Move iField to strField.iField
37636>>>>>>>>>>>        Get FieldArrayReplaceOverlap astTables strField to astFields
37637>>>>>>>>>>>        Move (SizeOfArray(astFields)-1) to iMax
37638>>>>>>>>>>>        
37638>>>>>>>>>>>        For iIndex from 0 to iMax
37644>>>>>>>>>>>>
37644>>>>>>>>>>>            Move astFields[iIndex].iField to aFields[iIndex]
37645>>>>>>>>>>>        Loop
37646>>>>>>>>>>>>
37646>>>>>>>>>>>        Function_Return aFields
37647>>>>>>>>>>>    End_Function
37648>>>>>>>>>>>
37648>>>>>>>>>>>    Procedure OverlapColumnBoundaries tTableAttributes[] astTables Integer iTable Integer iColumn Integer ByRef iStartColumn Integer ByRef iEndColumn
37650>>>>>>>>>>>        tTableField strField 
37650>>>>>>>>>>>        tTableField strField 
37650>>>>>>>>>>>        tTableField[] aFields
37650>>>>>>>>>>>        tTableField[] aFields
37651>>>>>>>>>>>        Move iTable to strField.iTable
37652>>>>>>>>>>>        Move iColumn to strField.iField
37653>>>>>>>>>>>        Get FieldArrayReplaceOverlap astTables strField to aFields
37654>>>>>>>>>>>        Move aFields[0].iField to iStartColumn
37655>>>>>>>>>>>        Move aFields[SizeOfArray(aFields)-1] to iEndColumn
37656>>>>>>>>>>>    End_Procedure
37657>>>>>>>>>>>    
37657>>>>>>>>>>>// **** Procedure for reading and writing to sequential files
37657>>>>>>>>>>>
37657>>>>>>>>>>>    Procedure Write_Attributes Integer iChannel Integer iAttrType tAttributeValue[] aAttributes
37659>>>>>>>>>>>        Integer iIndex iMax iAttr
37659>>>>>>>>>>>        Move (SizeOfArray(aAttributes)-1) to iMax
37660>>>>>>>>>>>        Writeln channel iChannel iMax
37663>>>>>>>>>>>        For iIndex from 0 to iMax
37669>>>>>>>>>>>>
37669>>>>>>>>>>>            Move gaInverseCompressedAttributeIndices[iAttrType][iIndex] to iAttr
37670>>>>>>>>>>>            Writeln iAttr
37672>>>>>>>>>>>            Writeln (Length(aAttributes[iIndex].sValue))
37674>>>>>>>>>>>            Write aAttributes[iIndex].sValue
37675>>>>>>>>>>>        Loop
37676>>>>>>>>>>>>
37676>>>>>>>>>>>    End_Procedure
37677>>>>>>>>>>>    
37677>>>>>>>>>>>    Procedure Read_Attributes Integer iChannel Integer iAttrType tAttributeValue[] ByRef aAttributes
37679>>>>>>>>>>>        Integer iIndex iMax iAttr iLen
37679>>>>>>>>>>>        String sValue
37679>>>>>>>>>>>        Move (ResizeArray(aAttributes,0)) to aAttributes
37680>>>>>>>>>>>        Readln channel iChannel iMax
37682>>>>>>>>>>>        For iIndex from 0 to iMax
37688>>>>>>>>>>>>
37688>>>>>>>>>>>           Readln iAttr
37689>>>>>>>>>>>           Readln iLen
37690>>>>>>>>>>>           Read_Block sValue iLen
37691>>>>>>>>>>>           Set _AttributeValue (&aAttributes) iAttr to sValue
37692>>>>>>>>>>>        Loop
37693>>>>>>>>>>>>
37693>>>>>>>>>>>    End_Procedure
37694>>>>>>>>>>>    
37694>>>>>>>>>>>    Procedure Write_TableAttributes Integer iChannel tTableAttributes astTableAttributes
37696>>>>>>>>>>>        Integer iMax iIndex iSegmentMax iSegmentIndex
37696>>>>>>>>>>>        Writeln channel iChannel astTableAttributes.iReadFromFileListEntryNo
37699>>>>>>>>>>>        Writeln channel iChannel astTableAttributes.sOpenAsPath
37702>>>>>>>>>>>        Send Write_Attributes iChannel ATYPE_FILE astTableAttributes.aTableAttributes
37703>>>>>>>>>>>        
37703>>>>>>>>>>>        Move (SizeOfArray(astTableAttributes.aFields)-1) to iMax
37704>>>>>>>>>>>        Writeln iMax
37706>>>>>>>>>>>        For iIndex from 0 to iMax
37712>>>>>>>>>>>>
37712>>>>>>>>>>>            Send Write_Attributes iChannel ATYPE_FIELD astTableAttributes.aFields[iIndex].aFieldAttributes
37713>>>>>>>>>>>        Loop
37714>>>>>>>>>>>>
37714>>>>>>>>>>>        
37714>>>>>>>>>>>        Move (SizeOfArray(astTableAttributes.aIndices)-1) to iMax
37715>>>>>>>>>>>        Writeln iMax
37717>>>>>>>>>>>        For iIndex from 0 to iMax
37723>>>>>>>>>>>>
37723>>>>>>>>>>>            Send Write_Attributes iChannel ATYPE_INDEX astTableAttributes.aIndices[iIndex].aIndexAttributes
37724>>>>>>>>>>>            Move (SizeOfArray(astTableAttributes.aIndices[iIndex].aSegments)-1) to iSegmentMax
37725>>>>>>>>>>>            Writeln iSegmentMax
37727>>>>>>>>>>>            For iSegmentIndex from 0 to iSegmentMax
37733>>>>>>>>>>>>
37733>>>>>>>>>>>                Send Write_Attributes iChannel ATYPE_IDXSEG astTableAttributes.aIndices[iIndex].aSegments[iSegmentIndex].aIndexSegmentAttributes
37734>>>>>>>>>>>            Loop
37735>>>>>>>>>>>>
37735>>>>>>>>>>>        Loop    
37736>>>>>>>>>>>>
37736>>>>>>>>>>>    End_Procedure
37737>>>>>>>>>>>    
37737>>>>>>>>>>>    Procedure Read_TableAttributes Integer iChannel tTableAttributes ByRef astTableAttributes
37739>>>>>>>>>>>        Integer iMax iIndex iSegmentMax iSegmentIndex
37739>>>>>>>>>>>        Readln channel iChannel astTableAttributes.iReadFromFileListEntryNo
37741>>>>>>>>>>>        Readln channel iChannel astTableAttributes.sOpenAsPath
37743>>>>>>>>>>>        Send Read_Attributes iChannel ATYPE_FILE (&astTableAttributes.aTableAttributes)
37744>>>>>>>>>>>        
37744>>>>>>>>>>>        Readln iMax
37745>>>>>>>>>>>        For iIndex from 0 to iMax
37751>>>>>>>>>>>>
37751>>>>>>>>>>>            Move gaEmptyAttributes to astTableAttributes.aFields[iIndex].aFieldAttributes
37752>>>>>>>>>>>            Send Read_Attributes iChannel ATYPE_FIELD (&astTableAttributes.aFields[iIndex].aFieldAttributes)
37753>>>>>>>>>>>        Loop
37754>>>>>>>>>>>>
37754>>>>>>>>>>>        
37754>>>>>>>>>>>        Readln iMax
37755>>>>>>>>>>>        For iIndex from 0 to iMax
37761>>>>>>>>>>>>
37761>>>>>>>>>>>            Move gaEmptyAttributes to astTableAttributes.aIndices[iIndex].aIndexAttributes
37762>>>>>>>>>>>            Send Read_Attributes iChannel ATYPE_INDEX (&astTableAttributes.aIndices[iIndex].aIndexAttributes)
37763>>>>>>>>>>>            Readln iSegmentMax
37764>>>>>>>>>>>            For iSegmentIndex from 0 to iSegmentMax
37770>>>>>>>>>>>>
37770>>>>>>>>>>>                Move gaEmptyAttributes to astTableAttributes.aIndices[iIndex].aSegments[iSegmentIndex].aIndexSegmentAttributes
37771>>>>>>>>>>>                Send Read_Attributes iChannel ATYPE_IDXSEG (&astTableAttributes.aIndices[iIndex].aSegments[iSegmentIndex].aIndexSegmentAttributes)
37772>>>>>>>>>>>            Loop
37773>>>>>>>>>>>>
37773>>>>>>>>>>>        Loop
37774>>>>>>>>>>>>
37774>>>>>>>>>>>    End_Procedure
37775>>>>>>>>>>>    
37775>>>>>>>>>>>    Procedure Write_TablesAttributes Integer iChannel tTableAttributes[] aTables
37777>>>>>>>>>>>        Integer iMax iIndex
37777>>>>>>>>>>>        Move (SizeOfArray(aTables)-1) to iMax
37778>>>>>>>>>>>        Writeln channel iChannel iMax
37781>>>>>>>>>>>        For iIndex from 0 to iMax
37787>>>>>>>>>>>>
37787>>>>>>>>>>>            Send Write_TableAttributes iChannel aTables[iIndex]
37788>>>>>>>>>>>        Loop 
37789>>>>>>>>>>>>
37789>>>>>>>>>>>    End_Procedure
37790>>>>>>>>>>>    
37790>>>>>>>>>>>    Procedure Read_TablesAttributes Integer iChannel tTableAttributes[] ByRef aTables
37792>>>>>>>>>>>        Integer iMax iIndex
37792>>>>>>>>>>>        Move (ResizeArray(aTables,0)) to aTables
37793>>>>>>>>>>>        Readln channel iChannel iMax
37795>>>>>>>>>>>        For iIndex from 0 to iMax
37801>>>>>>>>>>>>
37801>>>>>>>>>>>            Send Read_TableAttributes iChannel (&aTables[iIndex])
37802>>>>>>>>>>>        Loop
37803>>>>>>>>>>>>
37803>>>>>>>>>>>    End_Procedure
37804>>>>>>>>>>>                                                     
37804>>>>>>>>>>>    Procedure Write_ServerAttributes Integer iChannel tDataBaseServer stServer
37806>>>>>>>>>>>        Send Write_Attributes iChannel ATYPE_DRVSRV stServer.aServerAttributes
37807>>>>>>>>>>>    End_Procedure
37808>>>>>>>>>>>    
37808>>>>>>>>>>>    Procedure Read_ServerAttributes Integer iChannel tDataBaseServer ByRef stServer
37810>>>>>>>>>>>        Send Read_Attributes iChannel ATYPE_DRVSRV (&stServer.aServerAttributes)
37811>>>>>>>>>>>    End_Procedure
37812>>>>>>>>>>>                                                     
37812>>>>>>>>>>>    Procedure Write_DriverAttributes Integer iChannel tDataBaseDriver[] aDrivers
37814>>>>>>>>>>>        Integer iDriverMax iDriverIndex iServerMax iServerIndex
37814>>>>>>>>>>>        
37814>>>>>>>>>>>        Move (SizeOfArray(aDrivers)-1) to iDriverMax
37815>>>>>>>>>>>        Writeln channel iChannel iDriverMax
37818>>>>>>>>>>>        
37818>>>>>>>>>>>        For iDriverIndex from 0 to iDriverMax
37824>>>>>>>>>>>>
37824>>>>>>>>>>>            Send Write_Attributes iChannel ATYPE_DRIVER aDrivers[iDriverIndex].aDriverAttributes
37825>>>>>>>>>>>            Move (SizeOfArray(aDrivers[iDriverIndex].aServers)-1) to iServerMax
37826>>>>>>>>>>>            Writeln iServerMax
37828>>>>>>>>>>>            For iServerIndex from 0 to iServerMax
37834>>>>>>>>>>>>
37834>>>>>>>>>>>                Send Write_Attributes iChannel ATYPE_IDXSEG aDrivers[iDriverIndex].aServers[iServerIndex].aServerAttributes
37835>>>>>>>>>>>            Loop
37836>>>>>>>>>>>>
37836>>>>>>>>>>>        Loop
37837>>>>>>>>>>>>
37837>>>>>>>>>>>    End_Procedure
37838>>>>>>>>>>>    
37838>>>>>>>>>>>    Procedure Read_DriverAttributes Integer iChannel tDataBaseDriver[] ByRef aDrivers
37840>>>>>>>>>>>        Integer iDriverMax iDriverIndex iServerMax iServerIndex
37840>>>>>>>>>>>        Readln channel iChannel iDriverMax
37842>>>>>>>>>>>        For iDriverIndex from 0 to iDriverMax
37848>>>>>>>>>>>>
37848>>>>>>>>>>>            Move gaEmptyAttributes to aDrivers[iDriverIndex].aDriverAttributes
37849>>>>>>>>>>>            Send Read_Attributes iChannel ATYPE_DRIVER (&aDrivers[iDriverIndex].aDriverAttributes)
37850>>>>>>>>>>>            Readln iServerMax 
37851>>>>>>>>>>>            For iServerIndex from 0 to iServerMax
37857>>>>>>>>>>>>
37857>>>>>>>>>>>                Move gaEmptyAttributes to aDrivers[iDriverIndex].aServers[iServerIndex]
37858>>>>>>>>>>>                Send Read_Attributes iChannel ATYPE_IDXSEG (&aDrivers[iDriverIndex].aServers[iServerIndex].aServerAttributes)
37859>>>>>>>>>>>            Loop
37860>>>>>>>>>>>>
37860>>>>>>>>>>>        Loop
37861>>>>>>>>>>>>
37861>>>>>>>>>>>    End_Procedure
37862>>>>>>>>>>>    
37862>>>>>>>>>>>    //> Write tFileList variable to sequential channel iChannel
37862>>>>>>>>>>>    Procedure WriteChannel_FilelistAttributes Integer iChannel tFileList strFilelist
37864>>>>>>>>>>>        Send Write_Attributes iChannel ATYPE_GLOBAL strFilelist.aGlobalAttributes
37865>>>>>>>>>>>        Send Write_DriverAttributes iChannel strFilelist.aDrivers
37866>>>>>>>>>>>        Send Write_TablesAttributes iChannel strFilelist.aTables
37867>>>>>>>>>>>    End_Procedure
37868>>>>>>>>>>>
37868>>>>>>>>>>>    //> Read tFileList variable from sequential channel iChannel
37868>>>>>>>>>>>    Procedure ReadChannel_FilelistAttributes Integer iChannel tFileList ByRef strFilelist
37870>>>>>>>>>>>        Send Read_Attributes iChannel ATYPE_GLOBAL (&strFilelist.aGlobalAttributes)
37871>>>>>>>>>>>        Send Read_DriverAttributes iChannel (&strFilelist.aDrivers)
37872>>>>>>>>>>>        Send Read_TablesAttributes iChannel (&strFilelist.aTables)
37873>>>>>>>>>>>    End_Procedure
37874>>>>>>>>>>>
37874>>>>>>>>>>>    //> Write tFileList variable to sequential file with filename sFilename
37874>>>>>>>>>>>    Procedure WriteFile_FileListAttributes String sFilename tFileList strFilelist
37876>>>>>>>>>>>        Integer iChannel
37876>>>>>>>>>>>        Get DirectOutput of oFileFunctions sFilename to iChannel
37877>>>>>>>>>>>        If (iChannel>=0) Begin
37879>>>>>>>>>>>            Send WriteChannel_FilelistAttributes iChannel strFilelist
37880>>>>>>>>>>>            Send CloseOutput of oFileFunctions iChannel
37881>>>>>>>>>>>        End
37881>>>>>>>>>>>>
37881>>>>>>>>>>>    End_Procedure
37882>>>>>>>>>>>
37882>>>>>>>>>>>    //> Read tFileList variable from sequential file with filename sFilename
37882>>>>>>>>>>>    Procedure ReadFile_FileListAttributes String sFilename tFileList ByRef strFilelist
37884>>>>>>>>>>>        Integer iChannel
37884>>>>>>>>>>>        Get DirectInput of oFileFunctions sFilename to iChannel
37885>>>>>>>>>>>        If (iChannel>=0) Begin
37887>>>>>>>>>>>            Send ReadChannel_FilelistAttributes iChannel (&strFilelist)
37888>>>>>>>>>>>            Send CloseInput of oFileFunctions iChannel
37889>>>>>>>>>>>        End
37889>>>>>>>>>>>>
37889>>>>>>>>>>>    End_Procedure
37890>>>>>>>>>>>    
37890>>>>>>>>>>>// **** Utility function TableRelations that extracts all the relations within a tTableAttributes array and return them as a tTableRelation array. ****
37890>>>>>>>>>>>
37890>>>>>>>>>>>            Function RelationIndex tTableRelation[] aRelations Integer iFromTable Integer iToTable Returns Integer
37892>>>>>>>>>>>                Integer iRelMax iRelIndex
37892>>>>>>>>>>>                Move (SizeOfArray(aRelations)-1) to iRelMax
37893>>>>>>>>>>>                For iRelIndex from 0 to iRelMax
37899>>>>>>>>>>>>
37899>>>>>>>>>>>                    If (aRelations[iRelIndex].iFromTable=iFromTable and aRelations[iRelIndex].iToTable=iToTable) Function_Return iRelIndex
37902>>>>>>>>>>>                Loop
37903>>>>>>>>>>>>
37903>>>>>>>>>>>                Function_Return -1
37904>>>>>>>>>>>            End_Function
37905>>>>>>>>>>>
37905>>>>>>>>>>>    Procedure AddRelationSegment tTableRelation[] ByRef aRelations Integer iFromTable Integer iFromField Integer iToTable Integer iToField
37907>>>>>>>>>>>        Integer iRelIndex iRelSegmentIndex
37907>>>>>>>>>>>        Get RelationIndex aRelations iFromTable iToTable to iRelIndex
37908>>>>>>>>>>>        If (iRelIndex=-1) Begin
37910>>>>>>>>>>>            Move (SizeOfArray(aRelations)) to iRelIndex
37911>>>>>>>>>>>            Move iFromTable to aRelations[iRelIndex].iFromTable
37912>>>>>>>>>>>            Move iToTable to aRelations[iRelIndex].iToTable
37913>>>>>>>>>>>        End
37913>>>>>>>>>>>>
37913>>>>>>>>>>>        Move (SizeOfArray(aRelations[iRelIndex].aFromFields)) to iRelSegmentIndex
37914>>>>>>>>>>>        Move iFromTable to aRelations[iRelIndex].aFromFields[iRelSegmentIndex].iTable
37915>>>>>>>>>>>        Move iFromField to aRelations[iRelIndex].aFromFields[iRelSegmentIndex].iField
37916>>>>>>>>>>>        Move iToTable to aRelations[iRelIndex].aToFields[iRelSegmentIndex].iTable
37917>>>>>>>>>>>        Move iToField to aRelations[iRelIndex].aToFields[iRelSegmentIndex].iField
37918>>>>>>>>>>>    End_Procedure
37919>>>>>>>>>>>    
37919>>>>>>>>>>>            Procedure _ValidateRelations tTableAttributes[] astTables tTableRelation[] ByRef aRelations
37921>>>>>>>>>>>                Integer iRelIndex iRelMax iIndex
37921>>>>>>>>>>>                Move (SizeOfArray(aRelations)-1) to iRelMax
37922>>>>>>>>>>>                For iRelIndex from 0 to iRelMax
37928>>>>>>>>>>>>
37928>>>>>>>>>>>                    // In this place it should be checked that the fields in the relation makes up
37928>>>>>>>>>>>                    // sufficient information to look up a record in the parent table.
37928>>>>>>>>>>>                    // Futhermore it should be checked whether the index could be used for header-detail like queries.
37928>>>>>>>>>>>                    // But for now I'll just stamp them all with an OK.
37928>>>>>>>>>>>                    Move -1 to iIndex
37929>>>>>>>>>>>                    If (Integer(TableAttribute(Self,astTables,DF_FILE_NUMBER_FIELDS,aRelations[iRelIndex].iToTable))>0) Begin // Was it opened?
37931>>>>>>>>>>>                        Get FindIndexUnique astTables aRelations[iRelIndex].iToTable aRelations[iRelIndex].aToFields to iIndex
37932>>>>>>>>>>>                    End
37932>>>>>>>>>>>>
37932>>>>>>>>>>>                    Move (iIndex<>-1) to aRelations[iRelIndex].bFunctioning
37933>>>>>>>>>>>                    Get ConstrainIndexArray astTables aRelations[iRelIndex].iFromTable aRelations[iRelIndex].aFromFields to aRelations[iRelIndex].aChildIndices
37934>>>>>>>>>>>                Loop
37935>>>>>>>>>>>>
37935>>>>>>>>>>>            End_Procedure
37936>>>>>>>>>>>            
37936>>>>>>>>>>>            Procedure _SetTableCompressedIndices tTableAttributes[] astTables
37938>>>>>>>>>>>                Integer iItem iMax
37938>>>>>>>>>>>                Integer[] aCompressedIndices
37939>>>>>>>>>>>                Move (SizeOfArray(astTables)-1) to iMax
37940>>>>>>>>>>>                For iItem from 0 to iMax
37946>>>>>>>>>>>>
37946>>>>>>>>>>>                    Move iItem to aCompressedIndices[astTables[iItem].iReadFromFileListEntryNo]
37947>>>>>>>>>>>                Loop
37948>>>>>>>>>>>>
37948>>>>>>>>>>>                Set _paTableCompressedIndices to aCompressedIndices
37949>>>>>>>>>>>            End_Procedure
37950>>>>>>>>>>>            
37950>>>>>>>>>>>            Procedure _ClearTableCompressedIndices 
37952>>>>>>>>>>>                Integer[] aCompressedIndices
37953>>>>>>>>>>>                Set _paTableCompressedIndices to aCompressedIndices
37954>>>>>>>>>>>            End_Procedure
37955>>>>>>>>>>>
37955>>>>>>>>>>>    Function TableRelations tTableAttributes[] astTables Returns tTableRelation[]
37957>>>>>>>>>>>        Integer iTableMax iTableIndex iTable
37957>>>>>>>>>>>        Integer iFieldMax iField
37957>>>>>>>>>>>        Integer iRelTable iRelField
37957>>>>>>>>>>>        Integer iRelIndex
37957>>>>>>>>>>>        tTableRelation[] aRelations
37957>>>>>>>>>>>        tTableRelation[] aRelations
37958>>>>>>>>>>>        
37958>>>>>>>>>>>        Send _SetTableCompressedIndices astTables
37959>>>>>>>>>>>
37959>>>>>>>>>>>        Move (SizeOfArray(astTables)-1) to iTableMax
37960>>>>>>>>>>>        For iTableIndex from 0 to iTableMax
37966>>>>>>>>>>>>
37966>>>>>>>>>>>            Move astTables[iTableIndex].iReadFromFileListEntryNo to iTable
37967>>>>>>>>>>>            Move (SizeOfArray(astTables[iTableIndex].aFields)-1) to iFieldMax
37968>>>>>>>>>>>            For iField from 1 to iFieldMax
37974>>>>>>>>>>>>
37974>>>>>>>>>>>                Get TableAttribute astTables DF_FIELD_RELATED_FILE iTable iField to iRelTable
37975>>>>>>>>>>>                If (iRelTable<>0) Begin
37977>>>>>>>>>>>                    Get TableAttribute astTables DF_FIELD_RELATED_FIELD iTable iField to iRelField
37978>>>>>>>>>>>                    Send AddRelationSegment (&aRelations) iTable iField iRelTable iRelField
37979>>>>>>>>>>>                End
37979>>>>>>>>>>>>
37979>>>>>>>>>>>            Loop
37980>>>>>>>>>>>>
37980>>>>>>>>>>>        Loop
37981>>>>>>>>>>>>
37981>>>>>>>>>>>        Send _ValidateRelations astTables (&aRelations)
37982>>>>>>>>>>>        Send _ClearTableCompressedIndices
37983>>>>>>>>>>>        Function_Return aRelations
37984>>>>>>>>>>>    End_Function
37985>>>>>>>>>>>
37985>>>>>>>>>>>    // Define call back procedure like this: Procedure HandleTableRelation integer iFromTable integer iToTable tTableRelation stRelation
37985>>>>>>>>>>>    Procedure CallBackTableRelations Integer hMsg Integer hObj Boolean bFrom Integer iTable tTableRelation[] aRelations
37987>>>>>>>>>>>        Integer iRelMax iRelIndex
37987>>>>>>>>>>>        Move (SizeOfArray(aRelations)-1) to iRelMax
37988>>>>>>>>>>>         
37988>>>>>>>>>>>        If (bFrom) Begin // Parent tables
37990>>>>>>>>>>>            For iRelIndex from 0 to iRelMax
37996>>>>>>>>>>>>
37996>>>>>>>>>>>                If (aRelations[iRelIndex].iFromTable=iTable) Begin
37998>>>>>>>>>>>                    Send hMsg of hObj iTable aRelations[iRelIndex].iToTable aRelations[iRelIndex]  
37999>>>>>>>>>>>                End
37999>>>>>>>>>>>>
37999>>>>>>>>>>>            Loop
38000>>>>>>>>>>>>
38000>>>>>>>>>>>        End
38000>>>>>>>>>>>>
38000>>>>>>>>>>>        Else Begin // Child tables
38001>>>>>>>>>>>            For iRelIndex from 0 to iRelMax
38007>>>>>>>>>>>>
38007>>>>>>>>>>>                If (aRelations[iRelIndex].iToTable=iTable) Begin
38009>>>>>>>>>>>                    Send hMsg of hObj aRelations[iRelIndex].iFromTable iTable aRelations[iRelIndex]  
38010>>>>>>>>>>>                End
38010>>>>>>>>>>>>
38010>>>>>>>>>>>            Loop
38011>>>>>>>>>>>>
38011>>>>>>>>>>>        End
38011>>>>>>>>>>>>
38011>>>>>>>>>>>    End_Procedure
38012>>>>>>>>>>>    
38012>>>>>>>>>>>//    Procedure CallBackTableRelations2 Integer hMsg Integer hObj Integer iFromTable Integer iToTable tTableRelation[] aRelations
38012>>>>>>>>>>>//    End_Procedure
38012>>>>>>>>>>>    
38012>>>>>>>>>>>        Function _IntegerRemoveDublettes Integer[] aValues Returns Integer[]
38014>>>>>>>>>>>            Integer iMax iIndex iResultItem iPrevValue
38014>>>>>>>>>>>            Integer[] aResult
38015>>>>>>>>>>>            Move 0 to iResultItem
38016>>>>>>>>>>>            Move (SortArray(aValues)) to aValues
38017>>>>>>>>>>>            Move (SizeOfArray(aValues)-1) to iMax
38018>>>>>>>>>>>            For iIndex from 0 to iMax
38024>>>>>>>>>>>>
38024>>>>>>>>>>>                If (iIndex=0 or aValues[iIndex]<>iPrevValue) Begin
38026>>>>>>>>>>>                    Move aValues[iIndex] to aResult[iResultItem]
38027>>>>>>>>>>>                    Increment iResultItem
38028>>>>>>>>>>>                    Move aValues[iIndex] to iPrevValue
38029>>>>>>>>>>>                End
38029>>>>>>>>>>>>
38029>>>>>>>>>>>            Loop
38030>>>>>>>>>>>>
38030>>>>>>>>>>>            Function_Return aResult
38031>>>>>>>>>>>        End_Function
38032>>>>>>>>>>>
38032>>>>>>>>>>>    //> 
38032>>>>>>>>>>>    Function ParentTableArray tTableRelation[] astRelations Integer iTable Returns Integer[]
38034>>>>>>>>>>>        Integer iRelMax iRelIndex iParentTableIndex
38034>>>>>>>>>>>        Integer[] aParentTable
38035>>>>>>>>>>>
38035>>>>>>>>>>>        Move 0 to iParentTableIndex
38036>>>>>>>>>>>
38036>>>>>>>>>>>        Move (SizeOfArray(astRelations)-1) to iRelMax
38037>>>>>>>>>>>        For iRelIndex from 0 to iRelMax
38043>>>>>>>>>>>>
38043>>>>>>>>>>>            If (astRelations[iRelIndex].iFromTable=iTable) Begin
38045>>>>>>>>>>>                Move astRelations[iRelIndex].iToTable to aParentTable[iParentTableIndex]
38046>>>>>>>>>>>                Increment iParentTableIndex
38047>>>>>>>>>>>            End
38047>>>>>>>>>>>>
38047>>>>>>>>>>>        Loop
38048>>>>>>>>>>>>
38048>>>>>>>>>>>        Function_Return (_IntegerRemoveDublettes(Self,aParentTable))
38049>>>>>>>>>>>    End_Function
38050>>>>>>>>>>>    
38050>>>>>>>>>>>    //> 
38050>>>>>>>>>>>    Function ChildTableArray tTableRelation[] astRelations Integer iTable Returns Integer[]
38052>>>>>>>>>>>        Integer iRelMax iRelIndex iChildTableIndex
38052>>>>>>>>>>>        Integer[] aChildTable
38053>>>>>>>>>>>
38053>>>>>>>>>>>        Move 0 to iChildTableIndex
38054>>>>>>>>>>>
38054>>>>>>>>>>>        Move (SizeOfArray(astRelations)-1) to iRelMax
38055>>>>>>>>>>>        For iRelIndex from 0 to iRelMax
38061>>>>>>>>>>>>
38061>>>>>>>>>>>            If (astRelations[iRelIndex].iToTable=iTable) Begin
38063>>>>>>>>>>>                Move astRelations[iRelIndex].iFromTable to aChildTable[iChildTableIndex]
38064>>>>>>>>>>>                Increment iChildTableIndex
38065>>>>>>>>>>>            End
38065>>>>>>>>>>>>
38065>>>>>>>>>>>        Loop
38066>>>>>>>>>>>>
38066>>>>>>>>>>>        Function_Return (_IntegerRemoveDublettes(Self,aChildTable))
38067>>>>>>>>>>>    End_Function
38068>>>>>>>>>>>    
38068>>>>>>>>>>>    //> Returns a sorted array of tables numbers that has the same physical name (a.k.a. root-name) as the
38068>>>>>>>>>>>    //> one passed in parameter iTable. The result array will return the iTable itself
38068>>>>>>>>>>>    Function AliasTableArray tTableAttributes[] astTables Integer iTable Returns Integer[]
38070>>>>>>>>>>>        Integer iTableMax iTableIndex iResultIndex
38070>>>>>>>>>>>        Integer[] aRval
38071>>>>>>>>>>>        String sRootName
38071>>>>>>>>>>>        Move 0 to iResultIndex
38072>>>>>>>>>>>        Get TableAttribute astTables DF_FILE_ROOT_NAME iTable to sRootName
38073>>>>>>>>>>>        If (sRootName<>"") Begin
38075>>>>>>>>>>>            Move (SizeOfArray(astTables)-1) to iTableMax
38076>>>>>>>>>>>            For iTableIndex from 0 to iTableMax
38082>>>>>>>>>>>>
38082>>>>>>>>>>>                If (Uppercase(TableAttribute(Self,astTables,DF_FILE_ROOT_NAME,astTables[iTableIndex].iReadFromFileListEntryNo))=Uppercase(sRootName)) Begin
38084>>>>>>>>>>>                    Move astTables[iTableIndex].iReadFromFileListEntryNo to aRval[iResultIndex]
38085>>>>>>>>>>>                    Increment iResultIndex
38086>>>>>>>>>>>                End
38086>>>>>>>>>>>>
38086>>>>>>>>>>>            Loop
38087>>>>>>>>>>>>
38087>>>>>>>>>>>            Move (SortArray(aRval)) to aRval
38088>>>>>>>>>>>        End
38088>>>>>>>>>>>>
38088>>>>>>>>>>>        Function_Return aRval
38089>>>>>>>>>>>    End_Function
38090>>>>>>>>>>>    
38090>>>>>>>>>>>    Function IsAlias tTableAttributes[] astTables Integer iTable Returns Boolean
38092>>>>>>>>>>>        Boolean bAlias
38092>>>>>>>>>>>        Integer[] aLogicalTables
38093>>>>>>>>>>>        Move False to bAlias
38094>>>>>>>>>>>        Get AliasTableArray astTables iTable to aLogicalTables
38095>>>>>>>>>>>        If (SizeOfArray(aLogicalTables)>0) Begin
38097>>>>>>>>>>>            Move (iTable<>aLogicalTables[0]) to bAlias // An ad-hoc definition of 'aliasness' that may do for many purposes
38098>>>>>>>>>>>        End
38098>>>>>>>>>>>>
38098>>>>>>>>>>>        Function_Return bAlias
38099>>>>>>>>>>>    End_Function
38100>>>>>>>>>>>    
38100>>>>>>>>>>>    Function TableDefinitionOk tTableAttributes[] astTables Integer iTable Returns Boolean
38102>>>>>>>>>>>        Get TableIndex astTables iTable to iTable
38103>>>>>>>>>>>        Function_Return (SizeOfArray(astTables[iTable].aFields)<>0)
38104>>>>>>>>>>>    End_Function
38105>>>>>>>>>>>    
38105>>>>>>>>>>>    Function RemoveAliasesFromTableArray tTableAttributes[] astTables Integer[] aTables Returns Integer[]
38107>>>>>>>>>>>        Integer iMax iIndex iTable
38107>>>>>>>>>>>        Integer[] aResult
38108>>>>>>>>>>>        String[] aMaster
38109>>>>>>>>>>>        String sRootName
38109>>>>>>>>>>>
38109>>>>>>>>>>>        Move (SizeOfArray(aTables)-1) to iMax
38110>>>>>>>>>>>        For iIndex from 0 to iMax
38116>>>>>>>>>>>>
38116>>>>>>>>>>>            Move aTables[iIndex] to iTable
38117>>>>>>>>>>>            Get TableAttribute astTables DF_FILE_ROOT_NAME iTable to sRootName
38118>>>>>>>>>>>            If (StringAddToSet(oStackFunctions,&aMaster,Lowercase(sRootName))) Begin
38120>>>>>>>>>>>                Move iTable to aResult[SizeOfArray(aResult)]
38121>>>>>>>>>>>            End
38121>>>>>>>>>>>>
38121>>>>>>>>>>>        Loop
38122>>>>>>>>>>>>
38122>>>>>>>>>>>        Function_Return aResult
38123>>>>>>>>>>>    End_Function
38124>>>>>>>>>>>
38124>>>>>>>>>>>    // Removes "flexerrs", "codemast" and "codetype" from aTables array
38124>>>>>>>>>>>    Function RemoveUtilityTablesFromArray tTableAttributes[] astTables Integer[] aTables Returns Integer[]
38126>>>>>>>>>>>        Integer iMax iIndex iTable
38126>>>>>>>>>>>        Integer[] aResult
38127>>>>>>>>>>>        String sRootName
38127>>>>>>>>>>>        Move (SizeOfArray(aTables)-1) to iMax
38128>>>>>>>>>>>        For iIndex from 0 to iMax
38134>>>>>>>>>>>>
38134>>>>>>>>>>>            Move aTables[iIndex] to iTable
38135>>>>>>>>>>>            Get TableAttribute astTables DF_FILE_ROOT_NAME iTable 0 0 to sRootName
38136>>>>>>>>>>>            Move (Lowercase(sRootName)) to sRootName
38137>>>>>>>>>>>            If (not(sRootName contains "flexerrs") and not(sRootName contains "codemast") and not(sRootName contains "codetype")) Begin
38139>>>>>>>>>>>                Move iTable to aResult[SizeOfArray(aResult)]
38140>>>>>>>>>>>            End
38140>>>>>>>>>>>>
38140>>>>>>>>>>>        Loop
38141>>>>>>>>>>>>
38141>>>>>>>>>>>        Function_Return aResult
38142>>>>>>>>>>>    End_Function
38143>>>>>>>>>>>    
38143>>>>>>>>>>>    Function RemoveSystemTablesFromArray tTableAttributes[] astTables Integer[] aTables Returns Integer[]
38145>>>>>>>>>>>        Integer iMax iIndex iTable iIsSystem
38145>>>>>>>>>>>        Integer[] aResult
38146>>>>>>>>>>>        Move (SizeOfArray(aTables)-1) to iMax
38147>>>>>>>>>>>        For iIndex from 0 to iMax
38153>>>>>>>>>>>>
38153>>>>>>>>>>>            Move aTables[iIndex] to iTable
38154>>>>>>>>>>>            Get TableAttribute of oAttributeFunctions astTables DF_FILE_IS_SYSTEM_FILE iTable to iIsSystem
38155>>>>>>>>>>>            If (iIsSystem=0) Begin
38157>>>>>>>>>>>                Move iTable to aResult[SizeOfArray(aResult)]
38158>>>>>>>>>>>            End
38158>>>>>>>>>>>>
38158>>>>>>>>>>>        Loop
38159>>>>>>>>>>>>
38159>>>>>>>>>>>        Function_Return aResult
38160>>>>>>>>>>>    End_Function
38161>>>>>>>>>>>    
38161>>>>>>>>>>>            Function TableFieldIndex tTableField[] astFields tTableField strField Returns Integer
38163>>>>>>>>>>>                Integer iFieldIndex iFieldMax
38163>>>>>>>>>>>                Move (SizeOfArray(astFields)-1) to iFieldMax
38164>>>>>>>>>>>                For iFieldIndex from 0 to iFieldMax
38170>>>>>>>>>>>>
38170>>>>>>>>>>>                    If (strField.iTable=astFields[iFieldIndex].iTable and strField.iField=astFields[iFieldIndex].iField) Function_Return iFieldIndex
38173>>>>>>>>>>>                Loop
38174>>>>>>>>>>>>
38174>>>>>>>>>>>                Function_Return -1
38175>>>>>>>>>>>            End_Function
38176>>>>>>>>>>>            
38176>>>>>>>>>>>            Function FindFieldWithOffset tTableAttributes[] astTables Integer iTable Integer iOffset Returns Integer
38178>>>>>>>>>>>                Integer iField iFieldMax iFieldType iFieldOffset
38178>>>>>>>>>>>                Get TableAttribute astTables DF_FILE_NUMBER_FIELDS iTable to iFieldMax
38179>>>>>>>>>>>                For iField from 1 to iFieldMax
38185>>>>>>>>>>>>
38185>>>>>>>>>>>                    Get TableAttribute astTables DF_FIELD_OFFSET iTable iField to iFieldOffset
38186>>>>>>>>>>>                    If (iFieldOffset=iOffset) begin
38188>>>>>>>>>>>                        Get TableAttribute astTables DF_FIELD_TYPE iTable iField to iFieldType
38189>>>>>>>>>>>                        If (iFieldType<>DF_OVERLAP) Function_Return iField
38192>>>>>>>>>>>                    End
38192>>>>>>>>>>>>
38192>>>>>>>>>>>                Loop
38193>>>>>>>>>>>>
38193>>>>>>>>>>>                Function_Return -1
38194>>>>>>>>>>>            End_Function 
38195>>>>>>>>>>>
38195>>>>>>>>>>>            Procedure BuildTableRelationsConnectedFieldsChildren tTableAttributes[] astTables tTableRelation[] astRelations tTableField stRelField tTableField[] ByRef astConnectedFields Integer[] aChildTables
38197>>>>>>>>>>>                Integer iMaxField iField
38197>>>>>>>>>>>                Integer iRelationMax iRelationIndex
38197>>>>>>>>>>>                Integer iRelationSegmentMax iRelationSegmentIndex
38197>>>>>>>>>>>                Integer iFieldOffSet iOverlapFieldOffset iRelFieldOffset
38197>>>>>>>>>>>                Integer iChildTableMax iChildTableIndex
38197>>>>>>>>>>>                tTableField strField
38197>>>>>>>>>>>                tTableField strField
38197>>>>>>>>>>>            
38197>>>>>>>>>>>                Get TableAttribute astTables DF_FIELD_OFFSET stRelField.iTable stRelField.iField to iRelFieldOffset
38198>>>>>>>>>>>                
38198>>>>>>>>>>>                Move (SizeOfArray(aChildTables)-1) to iChildTableMax
38199>>>>>>>>>>>                For iChildTableIndex from 0 to iChildTableMax
38205>>>>>>>>>>>>
38205>>>>>>>>>>>
38205>>>>>>>>>>>                    // Now go through astRelations to find connected fields (rather than going through the table fields themselves)
38205>>>>>>>>>>>                    Move (SizeOfArray(astRelations)-1) to iRelationMax
38206>>>>>>>>>>>                    For iRelationIndex from 0 to iRelationMax
38212>>>>>>>>>>>>
38212>>>>>>>>>>>                        If (astRelations[iRelationIndex].iToTable=stRelField.iTable) Begin
38214>>>>>>>>>>>                            
38214>>>>>>>>>>>                            // Fact: this is a relation to the table that we are currently examining (stRelField.iTable)
38214>>>>>>>>>>>                            Move (SizeOfArray(astRelations[iRelationIndex].aToFields)-1) to iRelationSegmentMax
38215>>>>>>>>>>>                            For iRelationSegmentIndex from 0 to iRelationSegmentMax
38221>>>>>>>>>>>>
38221>>>>>>>>>>>                                If (astRelations[iRelationIndex].aToFields[iRelationSegmentIndex].iField=stRelField.iField) Begin
38223>>>>>>>>>>>                                    Move astRelations[iRelationIndex].aFromFields[iRelationSegmentIndex].iTable to strField.iTable
38224>>>>>>>>>>>                                    Move astRelations[iRelationIndex].aFromFields[iRelationSegmentIndex].iField to strField.iField
38225>>>>>>>>>>>                                    Send BuildTableRelationsConnectedFields astTables astRelations strField (&astConnectedFields)  
38226>>>>>>>>>>>                                End
38226>>>>>>>>>>>>
38226>>>>>>>>>>>                            Loop
38227>>>>>>>>>>>>
38227>>>>>>>>>>>                            
38227>>>>>>>>>>>                        End
38227>>>>>>>>>>>>
38227>>>>>>>>>>>                    Loop
38228>>>>>>>>>>>>
38228>>>>>>>>>>>                    
38228>>>>>>>>>>>                    // Now we will go through all the fields of strField.iTable to see if we are overlapped by fields
38228>>>>>>>>>>>                    // that relates themselves (and thereby indirectly may link strField to something)
38228>>>>>>>>>>>                    Get TableAttribute astTables DF_FILE_NUMBER_FIELDS strField.iTable to iMaxField
38229>>>>>>>>>>>                    For iField from 1 to iMaxField
38235>>>>>>>>>>>>
38235>>>>>>>>>>>                        If (iField<>strField.iField) Begin // We will skip ourself
38237>>>>>>>>>>>                            If (TableAttribute(Self,astTables,DF_FIELD_TYPE,strField.iTable,iField)=DF_OVERLAP) Begin
38239>>>>>>>>>>>                                Get TableAttribute astTables DF_FIELD_RELATED_FILE strField.iTable iField to stRelField.iTable
38240>>>>>>>>>>>                                If (stRelField.iTable<>0) Begin
38242>>>>>>>>>>>                                    Get TableAttribute astTables DF_FIELD_RELATED_FIELD strField.iTable iField to stRelField.iField
38243>>>>>>>>>>>                                
38243>>>>>>>>>>>                                    // It's an overlap field! Does it overlap strField?
38243>>>>>>>>>>>                                    If (Integer(TableAttribute(Self,astTables,DF_FIELD_OVERLAP,strField.iTable,strField.iField,iField))) Begin
38245>>>>>>>>>>>                                        // OK! We know that they overlap. Now we have to figure out
38245>>>>>>>>>>>                                        // which field in the related file corresponds to our strField
38245>>>>>>>>>>>                                        Get TableAttribute astTables DF_FIELD_OFFSET strField.iTable iField to iOverlapFieldOffset
38246>>>>>>>>>>>
38246>>>>>>>>>>>                                        // Now we calculate the offset of our strField clone (remember: it's NOT the overlap
38246>>>>>>>>>>>                                        // field that we currently have in our hand).
38246>>>>>>>>>>>                                        Move (iRelFieldOffset-iOverlapFieldOffset+iFieldOffSet) to iRelFieldOffset
38247>>>>>>>>>>>                                        Get FindFieldWithOffset astTables stRelField.iTable iRelFieldOffset to stRelField.iField
38248>>>>>>>>>>>                                        If (iRelFieldOffset>0) begin
38250>>>>>>>>>>>                                            Send BuildTableRelationsConnectedFields astTables astRelations stRelField (&astConnectedFields)
38251>>>>>>>>>>>                                        End
38251>>>>>>>>>>>>
38251>>>>>>>>>>>                                        Else begin
38252>>>>>>>>>>>                                            Error 813 "Overlap structure mis-match"
38253>>>>>>>>>>>>
38253>>>>>>>>>>>                                        End
38253>>>>>>>>>>>>
38253>>>>>>>>>>>                                    End
38253>>>>>>>>>>>>
38253>>>>>>>>>>>                                End
38253>>>>>>>>>>>>
38253>>>>>>>>>>>                            End
38253>>>>>>>>>>>>
38253>>>>>>>>>>>                        End
38253>>>>>>>>>>>>
38253>>>>>>>>>>>                    Loop
38254>>>>>>>>>>>>
38254>>>>>>>>>>>                Loop
38255>>>>>>>>>>>>
38255>>>>>>>>>>>            End_Procedure
38256>>>>>>>>>>>
38256>>>>>>>>>>>    Procedure BuildTableRelationsConnectedFields tTableAttributes[] astTables ;                                                 tTableRelation[] astRelations ;                                                 tTableField strField ;                                                 tTableField[] ByRef astConnectedFields
38258>>>>>>>>>>>        Integer iMaxField iField
38258>>>>>>>>>>>        Integer iRelationMax iRelationIndex
38258>>>>>>>>>>>        Integer iRelationSegmentMax iRelationSegmentIndex
38258>>>>>>>>>>>        Integer iFieldOffSet iOverlapFieldOffset iRelFieldOffset
38258>>>>>>>>>>>        Integer iAliasMax iAliasIndex
38258>>>>>>>>>>>        Integer[] aChildTables aAliasTables
38260>>>>>>>>>>>        tTableField strRelField
38260>>>>>>>>>>>        tTableField strRelField
38260>>>>>>>>>>>
38260>>>>>>>>>>>        Get TableAttribute astTables DF_FIELD_OFFSET strField.iTable strField.iField to iFieldOffSet // We *may* need it later
38261>>>>>>>>>>>        If (TableFieldIndex(Self,astConnectedFields,strField)=-1) Begin
38263>>>>>>>>>>>            Move strField to astConnectedFields[SizeOfArray(astConnectedFields)] // Add field to result set
38264>>>>>>>>>>>            
38264>>>>>>>>>>>            // Now go through astRelations to find connected fields (rather than going through the table fields themselves)
38264>>>>>>>>>>>            Move (SizeOfArray(astRelations)-1) to iRelationMax
38265>>>>>>>>>>>            For iRelationIndex from 0 to iRelationMax
38271>>>>>>>>>>>>
38271>>>>>>>>>>>                If (astRelations[iRelationIndex].iFromTable=strField.iTable) Begin
38273>>>>>>>>>>>                    
38273>>>>>>>>>>>                    // Fact: this is a relation from the table that we are currently examining (strField.iTable)
38273>>>>>>>>>>>                    Move (SizeOfArray(astRelations[iRelationIndex].aFromFields)-1) to iRelationSegmentMax
38274>>>>>>>>>>>                    For iRelationSegmentIndex from 0 to iRelationSegmentMax
38280>>>>>>>>>>>>
38280>>>>>>>>>>>                        If (astRelations[iRelationIndex].aFromFields[iRelationSegmentIndex].iField=strField.iField) Begin
38282>>>>>>>>>>>                            Move astRelations[iRelationIndex].aFromFields[iRelationSegmentIndex].iTable to strRelField.iTable
38283>>>>>>>>>>>                            Move astRelations[iRelationIndex].aFromFields[iRelationSegmentIndex].iField to strRelField.iField
38284>>>>>>>>>>>                            Send BuildTableRelationsConnectedFields astTables astRelations strRelField (&astConnectedFields)  
38285>>>>>>>>>>>                        End
38285>>>>>>>>>>>>
38285>>>>>>>>>>>                    Loop
38286>>>>>>>>>>>>
38286>>>>>>>>>>>                    
38286>>>>>>>>>>>                End
38286>>>>>>>>>>>>
38286>>>>>>>>>>>            Loop
38287>>>>>>>>>>>>
38287>>>>>>>>>>>            
38287>>>>>>>>>>>            // Now we will go through all the fields of strField.iTable to see if we are overlapped by fields
38287>>>>>>>>>>>            // that relates themselves (and thereby indirectly may link strField to something)
38287>>>>>>>>>>>            Get TableAttribute astTables DF_FILE_NUMBER_FIELDS strField.iTable to iMaxField
38288>>>>>>>>>>>            For iField from 1 to iMaxField
38294>>>>>>>>>>>>
38294>>>>>>>>>>>                If (iField<>strField.iField) Begin // We will skip ourself
38296>>>>>>>>>>>                    If (TableAttribute(Self,astTables,DF_FIELD_TYPE,strField.iTable,iField)=DF_OVERLAP) Begin
38298>>>>>>>>>>>                        Get TableAttribute astTables DF_FIELD_RELATED_FILE strField.iTable iField to strRelField.iTable
38299>>>>>>>>>>>                        If (strRelField.iTable<>0) Begin
38301>>>>>>>>>>>                            Get TableAttribute astTables DF_FIELD_RELATED_FIELD strField.iTable iField to strRelField.iField
38302>>>>>>>>>>>                        
38302>>>>>>>>>>>                            // It's an overlap field! Does it overlap strField?
38302>>>>>>>>>>>                            If (Integer(TableAttribute(Self,astTables,DF_FIELD_OVERLAP,strField.iTable,strField.iField,iField))) Begin
38304>>>>>>>>>>>                                // OK! We know that they overlap. Now we have to figure out
38304>>>>>>>>>>>                                // which field in the related file corresponds to our strField
38304>>>>>>>>>>>                                Get TableAttribute astTables DF_FIELD_OFFSET strField.iTable iField to iOverlapFieldOffset
38305>>>>>>>>>>>                                Get TableAttribute astTables DF_FIELD_OFFSET strRelField.iTable strRelField.iField to iRelFieldOffset
38306>>>>>>>>>>>                                
38306>>>>>>>>>>>                                // Now we calculate the offset of our strField clone (remember: it's NOT the overlap
38306>>>>>>>>>>>                                // field that we currently have in our hand).
38306>>>>>>>>>>>                                Move (iRelFieldOffset-iOverlapFieldOffset+iFieldOffSet) to iRelFieldOffset
38307>>>>>>>>>>>                                Get FindFieldWithOffset astTables strRelField.iTable iRelFieldOffset to strRelField.iField
38308>>>>>>>>>>>                                If (iRelFieldOffset>0) Send BuildTableRelationsConnectedFields astTables astRelations strRelField (&astConnectedFields)
38311>>>>>>>>>>>                                Else Error 812 "Overlap structure mis-match"
38313>>>>>>>>>>>                            End
38313>>>>>>>>>>>>
38313>>>>>>>>>>>                        End
38313>>>>>>>>>>>>
38313>>>>>>>>>>>                    End
38313>>>>>>>>>>>>
38313>>>>>>>>>>>                End
38313>>>>>>>>>>>>
38313>>>>>>>>>>>            Loop                     
38314>>>>>>>>>>>>
38314>>>>>>>>>>>            
38314>>>>>>>>>>>            // Here comes the branch that takes care of searching for connected field in child direction:
38314>>>>>>>>>>>            Get ChildTableArray astRelations strField.iTable to aChildTables
38315>>>>>>>>>>>            Send BuildTableRelationsConnectedFieldsChildren astTables astRelations strField (&astConnectedFields) aChildTables
38316>>>>>>>>>>>            
38316>>>>>>>>>>>            Get AliasTableArray astTables strField.iTable to aAliasTables
38317>>>>>>>>>>>            Move (SizeOfArray(aAliasTables)-1) to iAliasMax
38318>>>>>>>>>>>            For iAliasIndex from 0 to iAliasMax
38324>>>>>>>>>>>>
38324>>>>>>>>>>>                Move aAliasTables[iAliasMax] to strField.iTable
38325>>>>>>>>>>>                Send BuildTableRelationsConnectedFields astTables astRelations strField (&astConnectedFields)
38326>>>>>>>>>>>            Loop
38327>>>>>>>>>>>>
38327>>>>>>>>>>>
38327>>>>>>>>>>>        End
38327>>>>>>>>>>>>
38327>>>>>>>>>>>    End_Procedure
38328>>>>>>>>>>>    
38328>>>>>>>>>>>    // -------------------------------------------------------------------------------------------------
38328>>>>>>>>>>>    
38328>>>>>>>>>>>    // Returns an integer value representing the driver used for iTable as 
38328>>>>>>>>>>>    // enumerated in TableDriverFunctions.pkg
38328>>>>>>>>>>>    Function TableDriverIntegerId tTableAttributes[] astTables Integer iTable Returns Integer
38330>>>>>>>>>>>        Integer iDriver
38330>>>>>>>>>>>        String sDriver
38330>>>>>>>>>>>        Get TableAttribute astTables DF_FILE_DRIVER iTable 0 0 to sDriver
38331>>>>>>>>>>>        Get DriverDllToId of oTableDriverFunctions sDriver to iDriver
38332>>>>>>>>>>>        Function_Return iDriver
38333>>>>>>>>>>>    End_Function
38334>>>>>>>>>>>
38334>>>>>>>>>>>    // Filters away all tables that do not use the driver passed in the iDriver argument.
38334>>>>>>>>>>>    Function TableArrayFilterDriver tTableAttributes[] astTables Integer[] aTables Integer iDriver Returns Integer[]
38336>>>>>>>>>>>        Integer iTableDriver iTable iMax iIndex
38336>>>>>>>>>>>        Integer[] aResult
38337>>>>>>>>>>>        Move (SizeOfArray(aTables)-1) to iMax
38338>>>>>>>>>>>        For iIndex from 0 to iMax
38344>>>>>>>>>>>>
38344>>>>>>>>>>>            Move aTables[iIndex] to iTable
38345>>>>>>>>>>>            Get TableDriverIntegerId astTables iTable to iTableDriver
38346>>>>>>>>>>>            If (iTableDriver=iDriver) Begin
38348>>>>>>>>>>>                Move iTable to aResult[SizeOfArray(aResult)]
38349>>>>>>>>>>>            End
38349>>>>>>>>>>>>
38349>>>>>>>>>>>        Loop
38350>>>>>>>>>>>>
38350>>>>>>>>>>>        Function_Return aResult
38351>>>>>>>>>>>    End_Function
38352>>>>>>>>>>>    
38352>>>>>>>>>>>    Function TableRootNameStripDriver String sRootName Returns String
38354>>>>>>>>>>>        Integer iPos
38354>>>>>>>>>>>        Move (Pos(":",sRootName)) to iPos
38355>>>>>>>>>>>        If (iPos>2) Begin
38357>>>>>>>>>>>            Move (Remove(sRootName,1,iPos)) to sRootName
38358>>>>>>>>>>>        End
38358>>>>>>>>>>>>
38358>>>>>>>>>>>        Function_Return sRootName
38359>>>>>>>>>>>    End_Function
38360>>>>>>>>>>>    
38360>>>>>>>>>>>    Function TableRootNameStripAll String sRootName Returns String
38362>>>>>>>>>>>        Get TableRootNameStripDriver sRootName to sRootName
38363>>>>>>>>>>>        Get PathToFileRootName of oFileFunctions sRootName to sRootName
38364>>>>>>>>>>>        Function_Return sRootName
38365>>>>>>>>>>>    End_Function
38366>>>>>>>>>>>    
38366>>>>>>>>>>>    Function TableColumnName tTableAttributes[] astTables Integer iTable Integer iColumn Boolean bInclTableName Returns String
38368>>>>>>>>>>>        String sColumnName sTableName
38368>>>>>>>>>>>        If (iColumn<0) Begin
38370>>>>>>>>>>>            Function_Return ""
38371>>>>>>>>>>>        End
38371>>>>>>>>>>>>
38371>>>>>>>>>>>        Get TableAttribute astTables DF_FIELD_NAME iTable iColumn 0 to sColumnName
38372>>>>>>>>>>>
38372>>>>>>>>>>>        If (sColumnName="") Begin
38374>>>>>>>>>>>            If (iColumn=0) Begin
38376>>>>>>>>>>>                Move "Recnum" to sColumnName
38377>>>>>>>>>>>            End
38377>>>>>>>>>>>>
38377>>>>>>>>>>>            Else Begin
38378>>>>>>>>>>>                Move ("Column"+IntegerToStringRzf(oStringFunctions,iColumn,3)) to sColumnName
38379>>>>>>>>>>>            End
38379>>>>>>>>>>>>
38379>>>>>>>>>>>        End
38379>>>>>>>>>>>>
38379>>>>>>>>>>>        If (bInclTableName and sColumnName<>"") Begin
38381>>>>>>>>>>>            Get TableAttribute astTables DF_FILE_LOGICAL_NAME iTable to sTableName
38382>>>>>>>>>>>            If (sTableName="") Begin
38384>>>>>>>>>>>                Move ("Table"+String(iTable)) to sTableName
38385>>>>>>>>>>>            End
38385>>>>>>>>>>>>
38385>>>>>>>>>>>            Move (sTableName+"."+sColumnName) to sColumnName
38386>>>>>>>>>>>        End
38386>>>>>>>>>>>>
38386>>>>>>>>>>>        Function_Return sColumnName
38387>>>>>>>>>>>    End_Function
38388>>>>>>>>>>>    
38388>>>>>>>>>>>    Function TableColumnNameToNumber tTableAttributes[] astTables Integer iTable String sColumnName Returns Integer
38390>>>>>>>>>>>        Integer iFieldMax iFieldIndex
38390>>>>>>>>>>>        String sTest
38390>>>>>>>>>>>        
38390>>>>>>>>>>>        Move (Uppercase(sColumnName)) to sColumnName
38391>>>>>>>>>>>        If (sColumnName="RECNUM") Begin
38393>>>>>>>>>>>            Function_Return 0
38394>>>>>>>>>>>        End
38394>>>>>>>>>>>>
38394>>>>>>>>>>>        
38394>>>>>>>>>>>        Get TableAttribute astTables DF_FILE_NUMBER_FIELDS iTable to iFieldMax
38395>>>>>>>>>>>        
38395>>>>>>>>>>>        For iFieldIndex from 1 to iFieldMax
38401>>>>>>>>>>>>
38401>>>>>>>>>>>            Get TableAttribute astTables DF_FIELD_NAME iTable iFieldIndex to sTest
38402>>>>>>>>>>>            If (sColumnName=Uppercase(sTest)) Begin
38404>>>>>>>>>>>                Function_Return iFieldIndex
38405>>>>>>>>>>>            End
38405>>>>>>>>>>>>
38405>>>>>>>>>>>        Loop
38406>>>>>>>>>>>>
38406>>>>>>>>>>>        
38406>>>>>>>>>>>        Function_Return -1 // Not Found
38407>>>>>>>>>>>    End_Function
38408>>>>>>>>>>>    
38408>>>>>>>>>>>    Function TableColumnTypeAndLength tTableAttributes[] astTables Integer iTable Integer iColumn Returns String
38410>>>>>>>>>>>        Integer iColumnType iLen iPrecision
38410>>>>>>>>>>>        String sRval
38410>>>>>>>>>>>        Get TableAttribute astTables DF_FIELD_TYPE iTable iColumn to iColumnType
38411>>>>>>>>>>>        Get AttributeDisplayValue DF_FIELD_TYPE iColumnType to sRval
38412>>>>>>>>>>>        Get TableAttribute astTables DF_FIELD_LENGTH iTable iColumn to iLen
38413>>>>>>>>>>>        Get TableAttribute astTables DF_FIELD_PRECISION iTable iColumn to iPrecision
38414>>>>>>>>>>>        If (iColumnType=DF_BCD) Begin
38416>>>>>>>>>>>            Move (sRval+", "+String(iLen)+"."+String(iPrecision)) to sRval
38417>>>>>>>>>>>        End 
38417>>>>>>>>>>>>
38417>>>>>>>>>>>        Else Begin
38418>>>>>>>>>>>            Move (sRval+", "+String(iLen)) to sRval
38419>>>>>>>>>>>        End
38419>>>>>>>>>>>>
38419>>>>>>>>>>>        Function_Return sRval
38420>>>>>>>>>>>    End_Function
38421>>>>>>>>>>>    
38421>>>>>>>>>>>    Function TableNameToNumber tTableAttributes[] astTables String sLogicalName Returns Integer
38423>>>>>>>>>>>        Integer iTableMax iTableIndex
38423>>>>>>>>>>>        String sTest
38423>>>>>>>>>>>        Move (Uppercase(sLogicalName)) to sLogicalName
38424>>>>>>>>>>>        Move (SizeOfArray(astTables)-1) to iTableMax
38425>>>>>>>>>>>        For iTableIndex from 0 to iTableMax
38431>>>>>>>>>>>>
38431>>>>>>>>>>>            Get TableAttribute astTables DF_FILE_LOGICAL_NAME astTables[iTableIndex].iReadFromFileListEntryNo to sTest
38432>>>>>>>>>>>            If (sLogicalName=Uppercase(sTest)) Begin
38434>>>>>>>>>>>                Function_Return astTables[iTableIndex].iReadFromFileListEntryNo
38435>>>>>>>>>>>            End
38435>>>>>>>>>>>>
38435>>>>>>>>>>>        Loop
38436>>>>>>>>>>>>
38436>>>>>>>>>>>        Function_Return -1
38437>>>>>>>>>>>    End_Function
38438>>>>>>>>>>>
38438>>>>>>>>>>>        Procedure _TablesCallbackRelatingUpwards Boolean[] aVisitedTables tTableAttributes[] astTables Integer iRootTable Integer hMsg Integer hObj
38440>>>>>>>>>>>            Integer iColumn iColumnMax iRelTable
38440>>>>>>>>>>>
38440>>>>>>>>>>>            If (SizeOfArray(aVisitedTables)<=iRootTable or aVisitedTables[iRootTable]=False) Begin
38442>>>>>>>>>>>                Move True to aVisitedTables[iRootTable]
38443>>>>>>>>>>>                Send hMsg of hObj iRootTable
38444>>>>>>>>>>>
38444>>>>>>>>>>>                Get TableAttribute astTables DF_FILE_NUMBER_FIELDS iRootTable 0 0 to iColumnMax
38445>>>>>>>>>>>                For iColumn from 1 to iColumnMax
38451>>>>>>>>>>>>
38451>>>>>>>>>>>                    Get TableAttribute astTables DF_FIELD_RELATED_FILE iRootTable iColumn 0 to iRelTable
38452>>>>>>>>>>>                    If (iRelTable<>0) Begin
38454>>>>>>>>>>>                        Send _TablesCallbackRelatingUpwards aVisitedTables astTables iRelTable hMsg hObj
38455>>>>>>>>>>>                    End
38455>>>>>>>>>>>>
38455>>>>>>>>>>>                Loop
38456>>>>>>>>>>>>
38456>>>>>>>>>>>
38456>>>>>>>>>>>            End
38456>>>>>>>>>>>>
38456>>>>>>>>>>>        End_Procedure
38457>>>>>>>>>>>    
38457>>>>>>>>>>>    Procedure TablesCallbackRelatingUpwards tTableAttributes[] astTables Integer iRootTable Integer hMsg Integer hObj
38459>>>>>>>>>>>        Boolean[] aVisitedTables
38460>>>>>>>>>>>        Send _TablesCallbackRelatingUpwards aVisitedTables astTables iRootTable hMsg hObj
38461>>>>>>>>>>>    End_Procedure
38462>>>>>>>>>>>    
38462>>>>>>>>>>>    // -- Index functions -----------------------------------------------------------------------------
38462>>>>>>>>>>>    
38462>>>>>>>>>>>    Function IsIndexUnique tTableAttributes[] astTables Integer iTable Integer iIndex Returns Boolean
38464>>>>>>>>>>>        Integer iSegmentMax iField
38464>>>>>>>>>>>        Get TableAttribute astTables DF_INDEX_NUMBER_SEGMENTS iTable iIndex 0 0 to iSegmentMax
38465>>>>>>>>>>>        If (iSegmentMax>0) Begin
38467>>>>>>>>>>>            Get TableAttribute astTables DF_INDEX_SEGMENT_FIELD iTable iIndex iSegmentMax to iField
38468>>>>>>>>>>>            Function_Return (iField<>0)
38469>>>>>>>>>>>        End                                                                                                          
38469>>>>>>>>>>>>
38469>>>>>>>>>>>        Function_Return False
38470>>>>>>>>>>>    End_Function
38471>>>>>>>>>>>    
38471>>>>>>>>>>>    Function IsIndexOnline tTableAttributes[] astTables Integer iTable Integer iIndex Returns Boolean
38473>>>>>>>>>>>        Integer iSegmentMax iType
38473>>>>>>>>>>>        Get TableAttribute astTables DF_INDEX_NUMBER_SEGMENTS iTable iIndex 0 0 to iSegmentMax
38474>>>>>>>>>>>        If (iSegmentMax>0) Begin
38476>>>>>>>>>>>            Get TableAttribute astTables DF_INDEX_TYPE iTable iIndex 0 to iType
38477>>>>>>>>>>>            Function_Return (iType=DF_INDEX_TYPE_ONLINE)
38478>>>>>>>>>>>        End                                                                                                          
38478>>>>>>>>>>>>
38478>>>>>>>>>>>        Function_Return False
38479>>>>>>>>>>>    End_Function
38480>>>>>>>>>>>    
38480>>>>>>>>>>>    // Code: 0=All 1:Unique 2:Off-line 3:On-line
38480>>>>>>>>>>>    Function IndexArray tTableAttributes[] astTables Integer iTable Integer iCode Returns Integer[]
38482>>>>>>>>>>>        Integer iIndex iSegments
38482>>>>>>>>>>>        Integer[] aIndices
38483>>>>>>>>>>>        Boolean bOnLine
38483>>>>>>>>>>>        For iIndex from 1 to 15
38489>>>>>>>>>>>>
38489>>>>>>>>>>>            Get TableAttribute astTables DF_INDEX_NUMBER_SEGMENTS iTable iIndex 0 to iSegments
38490>>>>>>>>>>>            If (iSegments>0) Begin
38492>>>>>>>>>>>                If (iCode=0) Begin // All
38494>>>>>>>>>>>                    Move iIndex to aIndices[SizeOfArray(aIndices)]
38495>>>>>>>>>>>                End
38495>>>>>>>>>>>>
38495>>>>>>>>>>>                If (iCode=1) Begin // Unique
38497>>>>>>>>>>>                    If (IsIndexUnique(Self,astTables,iTable,iIndex)) Begin
38499>>>>>>>>>>>                        Move iIndex to aIndices[SizeOfArray(aIndices)]
38500>>>>>>>>>>>                    End
38500>>>>>>>>>>>>
38500>>>>>>>>>>>                End
38500>>>>>>>>>>>>
38500>>>>>>>>>>>                If (iCode=2) Begin // Off-line
38502>>>>>>>>>>>                    If (not(IsIndexOnline(Self,astTables,iTable,iIndex))) Begin
38504>>>>>>>>>>>                        Move iIndex to aIndices[SizeOfArray(aIndices)]
38505>>>>>>>>>>>                    End
38505>>>>>>>>>>>>
38505>>>>>>>>>>>                End
38505>>>>>>>>>>>>
38505>>>>>>>>>>>                If (iCode=3) Begin // On-line
38507>>>>>>>>>>>                    If (IsIndexOnline(Self,astTables,iTable,iIndex)) Begin
38509>>>>>>>>>>>                        Move iIndex to aIndices[SizeOfArray(aIndices)]
38510>>>>>>>>>>>                    End
38510>>>>>>>>>>>>
38510>>>>>>>>>>>                End
38510>>>>>>>>>>>>
38510>>>>>>>>>>>            End
38510>>>>>>>>>>>>
38510>>>>>>>>>>>        Loop
38511>>>>>>>>>>>>
38511>>>>>>>>>>>        Function_Return aIndices
38512>>>>>>>>>>>    End_Function
38513>>>>>>>>>>>    
38513>>>>>>>>>>>    Function IndexAsSegments tTableAttributes[] astTables Integer iTable Integer iIndex Returns tTableField[]
38515>>>>>>>>>>>        Integer iSegmentIndex iSegmentMax iVal
38515>>>>>>>>>>>        tTableField[] aSegments
38515>>>>>>>>>>>        tTableField[] aSegments
38516>>>>>>>>>>>        Get TableAttribute astTables DF_INDEX_NUMBER_SEGMENTS iTable iIndex 0 0 to iSegmentMax
38517>>>>>>>>>>>        If (iSegmentMax>0) Begin
38519>>>>>>>>>>>            For iSegmentIndex from 1 to iSegmentMax
38525>>>>>>>>>>>>
38525>>>>>>>>>>>                Move iTable to aSegments[iSegmentIndex-1].iTable
38526>>>>>>>>>>>                Get TableAttribute astTables DF_INDEX_SEGMENT_FIELD iTable iIndex iSegmentIndex to aSegments[iSegmentIndex-1].iField
38527>>>>>>>>>>>                Get TableAttribute astTables DF_INDEX_SEGMENT_CASE iTable iIndex iSegmentIndex to iVal
38528>>>>>>>>>>>                Move (iVal=DF_CASE_IGNORED) to aSegments[iSegmentIndex-1].bCapslock
38529>>>>>>>>>>>                Get TableAttribute astTables DF_INDEX_SEGMENT_DIRECTION iTable iIndex iSegmentIndex to iVal
38530>>>>>>>>>>>                Move (iVal=DF_DESCENDING) to aSegments[iSegmentIndex-1].bDescending
38531>>>>>>>>>>>            Loop
38532>>>>>>>>>>>>
38532>>>>>>>>>>>        End
38532>>>>>>>>>>>>
38532>>>>>>>>>>>        Function_Return aSegments
38533>>>>>>>>>>>    End_Function
38534>>>>>>>>>>>    
38534>>>>>>>>>>>    // Calling this function only has meaning if all iTable members of aSegments AND aFields are identical. The
38534>>>>>>>>>>>    // function just assumes this is the case, but does not check for it.
38534>>>>>>>>>>>    Function IndexSegmentsMatch tTableField[] aSegments tTableField[] aFields Returns Integer
38536>>>>>>>>>>>        Integer iSegmentIndex iSegmentMax
38536>>>>>>>>>>>        Integer iFieldIndex iFieldMax
38536>>>>>>>>>>>        Integer iRval
38536>>>>>>>>>>>        Move (SizeOfArray(aSegments)-1) to iSegmentMax
38537>>>>>>>>>>>        Move (SizeOfArray(aFields)-1) to iFieldMax
38538>>>>>>>>>>>        
38538>>>>>>>>>>>        For iSegmentIndex from 0 to iSegmentMax
38544>>>>>>>>>>>>
38544>>>>>>>>>>>            For iFieldIndex from 0 to iFieldMax
38550>>>>>>>>>>>>
38550>>>>>>>>>>>                If (aSegments[iSegmentIndex].iField=aFields[iFieldIndex].iField) Begin
38552>>>>>>>>>>>                    Move -1 to aSegments[iSegmentIndex].iTable // Mark as matched
38553>>>>>>>>>>>                    Move iFieldMax to iFieldIndex // Break the loop.
38554>>>>>>>>>>>                End
38554>>>>>>>>>>>>
38554>>>>>>>>>>>            Loop
38555>>>>>>>>>>>>
38555>>>>>>>>>>>        Loop
38556>>>>>>>>>>>>
38556>>>>>>>>>>>        
38556>>>>>>>>>>>        Move 0 to iRval
38557>>>>>>>>>>>        
38557>>>>>>>>>>>        For iSegmentIndex from 0 to iSegmentMax
38563>>>>>>>>>>>>
38563>>>>>>>>>>>            If (aSegments[iSegmentIndex].iTable>-1) Begin
38565>>>>>>>>>>>                Function_Return iRval
38566>>>>>>>>>>>            End
38566>>>>>>>>>>>>
38566>>>>>>>>>>>            Increment iRval
38567>>>>>>>>>>>        Loop
38568>>>>>>>>>>>>
38568>>>>>>>>>>>        
38568>>>>>>>>>>>        Function_Return iRval // All segments matched
38569>>>>>>>>>>>    End_Function
38570>>>>>>>>>>>    
38570>>>>>>>>>>>    // This function returns the number of the an index that is fully specified by the fields listed in the 
38570>>>>>>>>>>>    // aFields parameter.
38570>>>>>>>>>>>    Function FindIndexUnique tTableAttributes[] astTables Integer iTable tTableField[] aFields Returns Integer
38572>>>>>>>>>>>        Integer iIndexIndex iIndexMax iMatchCount
38572>>>>>>>>>>>        Integer[] aIndices
38573>>>>>>>>>>>        tTableField[] aSegments 
38573>>>>>>>>>>>        tTableField[] aSegments 
38574>>>>>>>>>>>        
38574>>>>>>>>>>>        Get FieldArrayReplaceOverlaps astTables aFields to aFields
38575>>>>>>>>>>>
38575>>>>>>>>>>>        Get IndexArray astTables iTable 1 to aIndices // Get array of unique indices on table iTable
38576>>>>>>>>>>>        Move (SizeOfArray(aIndices)-1) to iIndexMax
38577>>>>>>>>>>>        For iIndexIndex from 0 to iIndexMax
38583>>>>>>>>>>>>
38583>>>>>>>>>>>            Get IndexAsSegments astTables iTable aIndices[iIndexIndex] to aSegments
38584>>>>>>>>>>>            Get FieldArrayReplaceOverlaps astTables aSegments to aSegments
38585>>>>>>>>>>>            Get IndexSegmentsMatch aSegments aFields to iMatchCount
38586>>>>>>>>>>>            If (iMatchCount=SizeOfArray(aSegments)) Begin
38588>>>>>>>>>>>                Function_Return aIndices[iIndexIndex]
38589>>>>>>>>>>>            End
38589>>>>>>>>>>>>
38589>>>>>>>>>>>        Loop
38590>>>>>>>>>>>>
38590>>>>>>>>>>>        Function_Return -1 // No index found
38591>>>>>>>>>>>    End_Function
38592>>>>>>>>>>>    
38592>>>>>>>>>>>    Function ConstrainIndexArray tTableAttributes[] astTables Integer iTable tTableField[] aConstrainFields Returns Integer[]
38594>>>>>>>>>>>        Integer[] aIndices aRval
38596>>>>>>>>>>>        Integer iIndexIndex iIndexMax iMatchCount
38596>>>>>>>>>>>        tTableField[] aSegments
38596>>>>>>>>>>>        tTableField[] aSegments
38597>>>>>>>>>>>
38597>>>>>>>>>>>        Get FieldArrayReplaceOverlaps astTables aConstrainFields to aConstrainFields
38598>>>>>>>>>>>        Get IndexArray astTables iTable 0 to aIndices // Get array of all indices on table iTable
38599>>>>>>>>>>>
38599>>>>>>>>>>>        Move (SizeOfArray(aIndices)-1) to iIndexMax
38600>>>>>>>>>>>        For iIndexIndex from 0 to iIndexMax
38606>>>>>>>>>>>>
38606>>>>>>>>>>>            Get IndexAsSegments astTables iTable aIndices[iIndexIndex] to aSegments
38607>>>>>>>>>>>            Get FieldArrayReplaceOverlaps astTables aSegments to aSegments
38608>>>>>>>>>>>            Get IndexSegmentsMatch aSegments aConstrainFields to iMatchCount
38609>>>>>>>>>>>            If (iMatchCount=SizeOfArray(aConstrainFields)) Begin
38611>>>>>>>>>>>                Move aIndices[iIndexIndex] to aRval[SizeOfArray(aRval)]
38612>>>>>>>>>>>            End
38612>>>>>>>>>>>>
38612>>>>>>>>>>>        Loop
38613>>>>>>>>>>>>
38613>>>>>>>>>>>
38613>>>>>>>>>>>        Function_Return aRval
38614>>>>>>>>>>>    End_Function
38615>>>>>>>>>>>    
38615>>>>>>>>>>>    Function IndexColumnNames tFileList strFilelist Integer iTable Integer iIndex Boolean bMinusOnDescending String sSep Returns String
38617>>>>>>>>>>>        Integer iMax iSegment iDir iColumn
38617>>>>>>>>>>>        Boolean bDesc
38617>>>>>>>>>>>        String sColumnName sRval
38617>>>>>>>>>>>        Get Attrib strFilelist DF_INDEX_NUMBER_SEGMENTS iTable iIndex 0 to iMax
38618>>>>>>>>>>>        For iSegment from 1 to iMax
38624>>>>>>>>>>>>
38624>>>>>>>>>>>            Get Attrib strFilelist DF_INDEX_SEGMENT_FIELD iTable iIndex iSegment to iColumn
38625>>>>>>>>>>>            Get Attrib strFilelist DF_FIELD_NAME iTable iColumn 0 to sColumnName
38626>>>>>>>>>>>            If (sColumnName="" and iColumn=0) Begin
38628>>>>>>>>>>>                Move "Recnum" to sColumnName
38629>>>>>>>>>>>            End
38629>>>>>>>>>>>>
38629>>>>>>>>>>>            If (bMinusOnDescending) Begin
38631>>>>>>>>>>>                Get Attrib strFilelist DF_INDEX_SEGMENT_DIRECTION iTable iIndex iSegment to iDir
38632>>>>>>>>>>>                If (iDir=DF_DESCENDING) Begin
38634>>>>>>>>>>>                    Move ("-"+sColumnName) to sColumnName
38635>>>>>>>>>>>                End
38635>>>>>>>>>>>>
38635>>>>>>>>>>>            End
38635>>>>>>>>>>>>
38635>>>>>>>>>>>            If (iSegment<>1) Begin
38637>>>>>>>>>>>                Move (sRval+sSep) to sRval
38638>>>>>>>>>>>            End
38638>>>>>>>>>>>>
38638>>>>>>>>>>>            Move (sRval+sColumnName) to sRval
38639>>>>>>>>>>>        Loop
38640>>>>>>>>>>>>
38640>>>>>>>>>>>        Function_Return sRval
38641>>>>>>>>>>>    End_Function
38642>>>>>>>>>>>
38642>>>>>>>>>>>// -------------- Build "character graphical" representation of table relationships -----------------
38642>>>>>>>>>>>
38642>>>>>>>>>>>                Global_Variable Integer[]          __gaTablesVisited
38642>>>>>>>>>>>                Global_Variable tTableRelation[]   __gaRelations
38642>>>>>>>>>>>                Global_Variable Boolean[]          __gaVerticalLines
38642>>>>>>>>>>>
38642>>>>>>>>>>>                Function _AlreadyMappedAtRow Integer iTable tRelationsDrawingMapItem[] aMap Returns Integer
38644>>>>>>>>>>>                    Integer iMax iIndex
38644>>>>>>>>>>>                    Move (SizeOfArray(aMap)-1) to iMax
38645>>>>>>>>>>>                    For iIndex from 0 to iMax
38651>>>>>>>>>>>>
38651>>>>>>>>>>>                        If (iTable=aMap[iIndex].iItemId) Begin
38653>>>>>>>>>>>                            Function_Return iIndex // hDDO already mapped at row iIndex
38654>>>>>>>>>>>                        End
38654>>>>>>>>>>>>
38654>>>>>>>>>>>                    Loop
38655>>>>>>>>>>>>
38655>>>>>>>>>>>                    Function_Return -1 // not mapped
38656>>>>>>>>>>>                End_Function
38657>>>>>>>>>>>
38657>>>>>>>>>>>                Function _RemoveValueFromArray Integer iValue Integer[] aValues Returns Integer[]
38659>>>>>>>>>>>                    Integer iMax iIndex
38659>>>>>>>>>>>                    Integer[] aRval
38660>>>>>>>>>>>                    Move (SizeOfArray(aValues)-1) to iMax
38661>>>>>>>>>>>                    For iIndex from 0 to iMax
38667>>>>>>>>>>>>
38667>>>>>>>>>>>                        If (iValue<>aValues[iIndex]) Begin
38669>>>>>>>>>>>                            Move aValues[iIndex] to aRval[SizeOfArray(aRval)]
38670>>>>>>>>>>>                        End
38670>>>>>>>>>>>>
38670>>>>>>>>>>>                    Loop
38671>>>>>>>>>>>>
38671>>>>>>>>>>>                    Function_Return aRval
38672>>>>>>>>>>>                End_Function
38673>>>>>>>>>>>
38673>>>>>>>>>>>                Procedure _DmrAddToVisited Integer iTable
38675>>>>>>>>>>>                    Move iTable to __gaTablesVisited[SizeOfArray(__gaTablesVisited)]
38676>>>>>>>>>>>                End_Procedure
38677>>>>>>>>>>>
38677>>>>>>>>>>>                Function _DmrAlreadyVisited Integer iTable Returns Boolean
38679>>>>>>>>>>>                    Integer iMax iIndex
38679>>>>>>>>>>>                    Move (SizeOfArray(__gaTablesVisited)-1) to iMax
38680>>>>>>>>>>>                    For iIndex from 0 to iMax
38686>>>>>>>>>>>>
38686>>>>>>>>>>>                        If (iTable=__gaTablesVisited[iIndex]) Begin
38688>>>>>>>>>>>                            Function_Return True
38689>>>>>>>>>>>                        End
38689>>>>>>>>>>>>
38689>>>>>>>>>>>                    Loop
38690>>>>>>>>>>>>
38690>>>>>>>>>>>                    Function_Return False
38691>>>>>>>>>>>                End_Function
38692>>>>>>>>>>>
38692>>>>>>>>>>>        Procedure _doTableRelationsMap Integer iTable Integer iIgnoreTable Integer iLevel tRelationsDrawingMapItem[] ByRef aMap Boolean bFirst Boolean bLast Boolean bParent Boolean bChild
38694>>>>>>>>>>>            Integer iMax iIndex
38694>>>>>>>>>>>            Integer iAlreadyMappedAtRow
38694>>>>>>>>>>>            Boolean bUp bDown bLeft bRight
38694>>>>>>>>>>>            Integer[] aParentTables aChildTables
38696>>>>>>>>>>>            String sValue
38696>>>>>>>>>>>            Boolean bAlreadyVisited
38696>>>>>>>>>>>
38696>>>>>>>>>>>            Get _AlreadyMappedAtRow iTable aMap to iAlreadyMappedAtRow //Has the DDO already been mapped?
38697>>>>>>>>>>>
38697>>>>>>>>>>>            Get _DmrAlreadyVisited iTable to bAlreadyVisited
38698>>>>>>>>>>>            If (not(bAlreadyVisited)) Begin
38700>>>>>>>>>>>                Send _DmrAddToVisited iTable
38701>>>>>>>>>>>            End
38701>>>>>>>>>>>>
38701>>>>>>>>>>>
38701>>>>>>>>>>>            If (not(bAlreadyVisited)) Begin
38703>>>>>>>>>>>                Get ParentTableArray __gaRelations iTable to aParentTables              // If not already visited we get the relations
38704>>>>>>>>>>>                Get ChildTableArray __gaRelations iTable to aChildTables                // to and from this table (iTable)
38705>>>>>>>>>>>                Get _RemoveValueFromArray iIgnoreTable aParentTables to aParentTables   // We should remove the table that sent us here (iIgnoreTable)
38706>>>>>>>>>>>                Get _RemoveValueFromArray iIgnoreTable aChildTables to aChildTables
38707>>>>>>>>>>>            End
38707>>>>>>>>>>>>
38707>>>>>>>>>>>
38707>>>>>>>>>>>            Move (SizeOfArray(aMap)-1) to iIndex
38708>>>>>>>>>>>            
38708>>>>>>>>>>>            Move False to __gaVerticalLines[iLevel]   // <-----------------------------------------------------------
38709>>>>>>>>>>>            
38709>>>>>>>>>>>            If (not(bAlreadyVisited)) Begin
38711>>>>>>>>>>>                Move (SizeOfArray(aParentTables)-1) to iMax
38712>>>>>>>>>>>                For iIndex from 0 to iMax
38718>>>>>>>>>>>>
38718>>>>>>>>>>>                    Send _doTableRelationsMap aParentTables[iIndex] iTable (iLevel+1) (&aMap) (iIndex=0) (iIndex=iMax) True False
38719>>>>>>>>>>>                Loop
38720>>>>>>>>>>>>
38720>>>>>>>>>>>            End
38720>>>>>>>>>>>>
38720>>>>>>>>>>>            If (bParent and bFirst and iLevel>0) Begin
38722>>>>>>>>>>>                Move True to __gaVerticalLines[iLevel-1] // Turn on parent vertical line
38723>>>>>>>>>>>            End
38723>>>>>>>>>>>>
38723>>>>>>>>>>>            
38723>>>>>>>>>>>            Send BooleanDrop of oStackFunctions (&__gaVerticalLines) // <----------------------------------------
38724>>>>>>>>>>>
38724>>>>>>>>>>>            Move (SizeOfArray(aMap)) to iIndex // Point to next available entry in aMap array.
38725>>>>>>>>>>>            Move iTable to aMap[iIndex].iItemId
38726>>>>>>>>>>>            Move iLevel to aMap[iIndex].iLevel
38727>>>>>>>>>>>            Move __gaVerticalLines to aMap[iIndex].aVerticalLines
38728>>>>>>>>>>>            
38728>>>>>>>>>>>            If (iAlreadyMappedAtRow=-1 and bAlreadyVisited) Begin
38730>>>>>>>>>>>                Move -2 to iAlreadyMappedAtRow // Means that we don't yet know in what row the it "was" mapped in (may be fixed in a second pass)
38731>>>>>>>>>>>            End
38731>>>>>>>>>>>>
38731>>>>>>>>>>>
38731>>>>>>>>>>>            Move iAlreadyMappedAtRow to aMap[iIndex].iAlreadyMappedAtRow
38732>>>>>>>>>>>            Move bFirst  to aMap[iIndex].bFirst
38733>>>>>>>>>>>            Move bLast   to aMap[iIndex].bLast
38734>>>>>>>>>>>            Move bParent to aMap[iIndex].bParent
38735>>>>>>>>>>>            Move bChild  to aMap[iIndex].bChild
38736>>>>>>>>>>>
38736>>>>>>>>>>>            If (bChild and bLast and iLevel>0) Begin
38738>>>>>>>>>>>                Move False to __gaVerticalLines[iLevel-1]
38739>>>>>>>>>>>            End
38739>>>>>>>>>>>>
38739>>>>>>>>>>>
38739>>>>>>>>>>>            If (not(bAlreadyVisited)) Begin
38741>>>>>>>>>>>                Move True to __gaVerticalLines[iLevel] // <-----------------------------------------------------------------
38742>>>>>>>>>>>                Move (SizeOfArray(aChildTables)-1) to iMax
38743>>>>>>>>>>>                For iIndex from 0 to iMax
38749>>>>>>>>>>>>
38749>>>>>>>>>>>                    Send _doTableRelationsMap aChildTables[iIndex] iTable (iLevel+1) (&aMap) (iIndex=0) (iIndex=iMax) False True
38750>>>>>>>>>>>                Loop
38751>>>>>>>>>>>>
38751>>>>>>>>>>>                Send BooleanDrop of oStackFunctions (&__gaVerticalLines) // <----------------------------------------
38752>>>>>>>>>>>            End
38752>>>>>>>>>>>>
38752>>>>>>>>>>>       End_Procedure // _doTableRelationsMap
38753>>>>>>>>>>>
38753>>>>>>>>>>>
38753>>>>>>>>>>>    Function TableRelationsDrawingMap tTableRelation[] aRelations Integer iTable Returns tRelationsDrawingMapItem[]
38755>>>>>>>>>>>        tRelationsDrawingMapItem[] aMap
38755>>>>>>>>>>>        tRelationsDrawingMapItem[] aMap
38756>>>>>>>>>>>        Move aRelations to __gaRelations
38757>>>>>>>>>>>        Move (ResizeArray(__gaTablesVisited,0)) to __gaTablesVisited
38758>>>>>>>>>>>        Move (ResizeArray(__gaVerticalLines,0)) to __gaVerticalLines
38759>>>>>>>>>>>        Send _doTableRelationsMap iTable 0 0 (&aMap) False False False False
38760>>>>>>>>>>>        Function_Return aMap
38761>>>>>>>>>>>    End_Function
38762>>>>>>>>>>>
38762>>>>>>>>>>>// -------------------- Aux functions ----------------------------------------------------------------------------
38762>>>>>>>>>>>
38762>>>>>>>>>>>    Function DriversListedInFilelistCfg tFileList strFilelist Returns Integer[]
38764>>>>>>>>>>>        Integer iMax iIndex iDriver
38764>>>>>>>>>>>        Integer[] aTables aDrivers
38766>>>>>>>>>>>        String sDriver
38766>>>>>>>>>>>        Get FilelistNavigationTableArray strFilelist.aTables DF_FILE_NEXT_USED to aTables
38767>>>>>>>>>>>        Move (SizeOfArray(aTables)-1) to iMax
38768>>>>>>>>>>>        For iIndex from 0 to iMax
38774>>>>>>>>>>>>
38774>>>>>>>>>>>            Get Attrib strFilelist DF_FILE_DRIVER aTables[iIndex] 0 0 to sDriver
38775>>>>>>>>>>>            Get DriverDllToId of oTableDriverFunctions sDriver to iDriver
38776>>>>>>>>>>>            If (not(IntegerIsOnStack(oStackFunctions,iDriver,aDrivers))) Begin
38778>>>>>>>>>>>                Send IntegerPush of oStackFunctions iDriver (&aDrivers)
38779>>>>>>>>>>>            End
38779>>>>>>>>>>>>
38779>>>>>>>>>>>        Loop
38780>>>>>>>>>>>>
38780>>>>>>>>>>>        Function_Return aDrivers
38781>>>>>>>>>>>    End_Function
38782>>>>>>>>>>>
38782>>>>>>>>>>>    Function AttributeNameToID Integer iAttrType String sName Boolean bDisplayName Returns Integer
38784>>>>>>>>>>>        Integer iAttrMax iAttr
38784>>>>>>>>>>>        Move (SizeOfArray(gaAttributes)-1) to iAttrMax
38785>>>>>>>>>>>        For iAttr from 0 to iAttrMax
38791>>>>>>>>>>>>
38791>>>>>>>>>>>            If (iAttrType=gaAttributes[iAttr].iAttrType) Begin
38793>>>>>>>>>>>                If ((bDisplayName and sName=gaAttributes[iAttr].sDisplayName) or ;                    (not(bDisplayName) and sName=gaAttributes[iAttr].sName)) Begin
38795>>>>>>>>>>>                        Function_Return iAttr   
38796>>>>>>>>>>>                    End
38796>>>>>>>>>>>>
38796>>>>>>>>>>>            End
38796>>>>>>>>>>>>
38796>>>>>>>>>>>        Loop
38797>>>>>>>>>>>>
38797>>>>>>>>>>>        Function_Return -1
38798>>>>>>>>>>>    End_Function
38799>>>>>>>>>>>
38799>>>>>>>>>>>End_Class // _cAttributeFunctions
38800>>>>>>>>>>>
38800>>>>>>>>>>>Object _oAttributeFunctions is a _cAttributeFunctions
38802>>>>>>>>>>>    Move Self to oAttributeFunctions
38803>>>>>>>>>>>End_Object
38804>>>>>>>>>>>
38804>>>>>>>>>>>
38804>>>>>>>>>Use TableStructure.pkg
Including file: TableStructure.pkg    (Z:\VmShare\Projects\WebQuery18-0\StureApsPublicLib\AppSrc\TableStructure.pkg)
38804>>>>>>>>>>>Use ErrorEventHandlerClass.pkg //
Including file: ErrorEventHandlerClass.pkg    (Z:\VmShare\Projects\WebQuery18-0\StureApsPublicLib\AppSrc\ErrorEventHandlerClass.pkg)
38804>>>>>>>>>>>>>// Use ErrorEventHandlerClass.pkg // cErrorEventHandler class and oErrorSilence object
38804>>>>>>>>>>>>>
38804>>>>>>>>>>>>>Use VdfBase.pkg // DAW package. Provides low level support expected of all VDF applications (windows and webapp)
38804>>>>>>>>>>>>>
38804>>>>>>>>>>>>>Struct tErrorEvent
38804>>>>>>>>>>>>>    Integer iError
38804>>>>>>>>>>>>>    Integer iErrorLine
38804>>>>>>>>>>>>>    String sErrorText
38804>>>>>>>>>>>>>End_Struct
38804>>>>>>>>>>>>>
38804>>>>>>>>>>>>>Class cErrorEventHandler is a cObject
38805>>>>>>>>>>>>>    Procedure Construct_Object
38807>>>>>>>>>>>>>        Forward Send Construct_Object
38809>>>>>>>>>>>>>
38809>>>>>>>>>>>>>        Property Integer _phPreviousErrorHandler public -1
38810>>>>>>>>>>>>>        Property Integer _error_processing_state public False
38811>>>>>>>>>>>>>
38811>>>>>>>>>>>>>        // These properties are used internally to enable forwarding of errors to the previous error handler.
38811>>>>>>>>>>>>>        Property Integer _piError
38812>>>>>>>>>>>>>        Property Integer _piErrorLine
38813>>>>>>>>>>>>>        Property String  _psErrMsg
38814>>>>>>>>>>>>>        
38814>>>>>>>>>>>>>        Property tErrorEvent[] paErrors
38815>>>>>>>>>>>>>    End_Procedure
38816>>>>>>>>>>>>>    
38816>>>>>>>>>>>>>    Function Error_Processing_State Returns Integer
38818>>>>>>>>>>>>>        Function_Return (_error_processing_state(Self))
38819>>>>>>>>>>>>>    End_Function
38820>>>>>>>>>>>>>
38820>>>>>>>>>>>>>    //> Forwards the error event to the previous errorhandler
38820>>>>>>>>>>>>>    Procedure Forward_Error_Report
38822>>>>>>>>>>>>>        Integer hPreviousErrorHandler
38822>>>>>>>>>>>>>        Get _phPreviousErrorHandler to hPreviousErrorHandler
38823>>>>>>>>>>>>>        If (hPreviousErrorHandler<>-1) Send error_report to hPreviousErrorHandler (_piError(Self)) (_piErrorLine(Self)) (_psErrMsg(Self))
38826>>>>>>>>>>>>>    End_Procedure
38827>>>>>>>>>>>>>    
38827>>>>>>>>>>>>>    Function ErrorEventCount Returns Integer
38829>>>>>>>>>>>>>        tErrorEvent[] aErrors
38829>>>>>>>>>>>>>        tErrorEvent[] aErrors
38830>>>>>>>>>>>>>        Get paErrors to aErrors
38831>>>>>>>>>>>>>        Function_Return (SizeOfArray(aErrors))
38832>>>>>>>>>>>>>    End_Function
38833>>>>>>>>>>>>>    
38833>>>>>>>>>>>>>    Function ErrorEvent Integer iIndex Returns tErrorEvent
38835>>>>>>>>>>>>>        tErrorEvent[] aErrors
38835>>>>>>>>>>>>>        tErrorEvent[] aErrors
38836>>>>>>>>>>>>>        Get paErrors to aErrors
38837>>>>>>>>>>>>>        Function_Return aErrors[iIndex]
38838>>>>>>>>>>>>>    End_Function
38839>>>>>>>>>>>>>
38839>>>>>>>>>>>>>    Procedure OnError Integer iError String sErrorText Integer iErrorLine
38841>>>>>>>>>>>>>        Integer iErrIndex
38841>>>>>>>>>>>>>        tErrorEvent[] aErrors
38841>>>>>>>>>>>>>        tErrorEvent[] aErrors
38842>>>>>>>>>>>>>        Get paErrors to aErrors
38843>>>>>>>>>>>>>        Move (SizeOfArray(aErrors)) to iErrIndex
38844>>>>>>>>>>>>>        Move iError to aErrors[iErrIndex].iError
38845>>>>>>>>>>>>>        Move sErrorText to aErrors[iErrIndex].sErrorText
38846>>>>>>>>>>>>>        Move iErrorLine to aErrors[iErrIndex].iErrorLine
38847>>>>>>>>>>>>>        Set paErrors to aErrors
38848>>>>>>>>>>>>>    End_Procedure
38849>>>>>>>>>>>>>
38849>>>>>>>>>>>>>    Procedure DoReset
38851>>>>>>>>>>>>>        tErrorEvent[] aErrors
38851>>>>>>>>>>>>>        tErrorEvent[] aErrors
38852>>>>>>>>>>>>>        Set paErrors to (ResizeArray(aErrors,0))
38853>>>>>>>>>>>>>    End_Procedure
38854>>>>>>>>>>>>>
38854>>>>>>>>>>>>>    Procedure Activate
38856>>>>>>>>>>>>>        Send DoReset
38857>>>>>>>>>>>>>        If (_phPreviousErrorHandler(Self)=-1) Begin
38859>>>>>>>>>>>>>            Set _phPreviousErrorHandler to Error_Object_Id
38860>>>>>>>>>>>>>            Move Self to Error_Object_Id
38861>>>>>>>>>>>>>        End
38861>>>>>>>>>>>>>>
38861>>>>>>>>>>>>>    End_Procedure
38862>>>>>>>>>>>>>    
38862>>>>>>>>>>>>>    Procedure Deactivate
38864>>>>>>>>>>>>>        If (_phPreviousErrorHandler(Self)<>-1) Begin
38866>>>>>>>>>>>>>            Get _phPreviousErrorHandler to Error_Object_Id
38867>>>>>>>>>>>>>            Set _phPreviousErrorHandler to -1
38868>>>>>>>>>>>>>        End
38868>>>>>>>>>>>>>>
38868>>>>>>>>>>>>>    End_Procedure
38869>>>>>>>>>>>>>    
38869>>>>>>>>>>>>>    Function Error_Description Integer iError String sErrorText Returns String
38871>>>>>>>>>>>>>        Integer hPreviousErrorHandler
38871>>>>>>>>>>>>>        Get _phPreviousErrorHandler to hPreviousErrorHandler
38872>>>>>>>>>>>>>        If (hPreviousErrorHandler<>-1) Get Error_Description of hPreviousErrorHandler iError sErrorText to sErrorText
38875>>>>>>>>>>>>>        Function_Return sErrorText
38876>>>>>>>>>>>>>    End_Function
38877>>>>>>>>>>>>>
38877>>>>>>>>>>>>>    Procedure Error_Report Integer iError Integer iErrorLine String sErrMsg
38879>>>>>>>>>>>>>        String  sErrorText
38879>>>>>>>>>>>>>        Integer hPrevErrHandler
38879>>>>>>>>>>>>>
38879>>>>>>>>>>>>>        If (_error_processing_state(Self)) Procedure_Return // this prevents recursion
38882>>>>>>>>>>>>>        Set _error_processing_state to True
38883>>>>>>>>>>>>>
38883>>>>>>>>>>>>>        Set _piError     to iError
38884>>>>>>>>>>>>>        Set _piErrorLine to iErrorLine
38885>>>>>>>>>>>>>        Set _psErrMsg    to sErrMsg
38886>>>>>>>>>>>>>
38886>>>>>>>>>>>>>        Get _phPreviousErrorHandler to hPrevErrHandler
38887>>>>>>>>>>>>>
38887>>>>>>>>>>>>>        Move (Error_Description(hPrevErrHandler,iError,sErrMsg)) to sErrorText
38888>>>>>>>>>>>>>        Send OnError iError sErrorText iErrorLine
38889>>>>>>>>>>>>>        Set _error_processing_state to False
38890>>>>>>>>>>>>>    End_Procedure
38891>>>>>>>>>>>>>End_Class // cErrorEventHandler
38892>>>>>>>>>>>>>
38892>>>>>>>>>>>>>Global_Variable Integer oErrorSilence
38892>>>>>>>>>>>>>
38892>>>>>>>>>>>>>Object _oErrorSilence is a cErrorEventHandler
38894>>>>>>>>>>>>>    Move Self to oErrorSilence
38895>>>>>>>>>>>>>End_Object
38896>>>>>>>>>>>Use AttributeFunctions.pkg
38896>>>>>>>>>>>Use TableAccessFunctions.pkg
38896>>>>>>>>>>>Use FileFunctions.pkg // Define oFileFunctions object
38896>>>>>>>>>>>Use TableDriverFunctions.pkg
38896>>>>>>>>>>>Use TableExplicitFunctions.pkg
Including file: TableExplicitFunctions.pkg    (Z:\VmShare\Projects\WebQuery18-0\StureApsPublicLib\AppSrc\TableExplicitFunctions.pkg)
38896>>>>>>>>>>>>>Use AttributeFunctions.pkg
38896>>>>>>>>>>>>>Use StackFunctions.pkg // Define oStackFunctions object
38896>>>>>>>>>>>>>Use StringFunctions.pkg // Define oStringFunctions object
38896>>>>>>>>>>>>>Use TableAccessFunctions.pkg
38896>>>>>>>>>>>>>
38896>>>>>>>>>>>>>Object oTableExplicitFunctions is a cObject
38898>>>>>>>>>>>>>    Function TrimTableDefinitionToEmbedded tTableExplicit ByRef strTable Returns Boolean
38901>>>>>>>>>>>>>        Boolean bSucces
38901>>>>>>>>>>>>>        Integer iColumnMax iColumnIndex
38901>>>>>>>>>>>>>        String sColumnName
38901>>>>>>>>>>>>>        String[] aCheckDublettes
38902>>>>>>>>>>>>>        
38902>>>>>>>>>>>>>        Move True to bSucces
38903>>>>>>>>>>>>>        
38903>>>>>>>>>>>>>        Move (SizeOfArray(strTable.aFields)-1) to iColumnMax
38904>>>>>>>>>>>>>        For iColumnIndex from 1 to iColumnMax
38910>>>>>>>>>>>>>>
38910>>>>>>>>>>>>>            
38910>>>>>>>>>>>>>            // Embedded driver does not support DateTime type columns. We convert to ASCII: YYYY-MM-DD HH:MM:SS.nnn
38910>>>>>>>>>>>>>            If (strTable.aFields[iColumnIndex].iType=DF_DATETIME) Begin
38912>>>>>>>>>>>>>                Move DF_ASCII to strTable.aFields[iColumnIndex].iType
38913>>>>>>>>>>>>>                Move 23 to strTable.aFields[iColumnIndex].iLen
38914>>>>>>>>>>>>>            End
38914>>>>>>>>>>>>>>
38914>>>>>>>>>>>>>            
38914>>>>>>>>>>>>>            Move strTable.aFields[iColumnIndex].sName to sColumnName
38915>>>>>>>>>>>>>            If (Length(sColumnName)>32) Begin
38917>>>>>>>>>>>>>                Move (Left(sColumnName,32)) to strTable.aFields[iColumnIndex].sName
38918>>>>>>>>>>>>>            End
38918>>>>>>>>>>>>>>
38918>>>>>>>>>>>>>            If (not(StringAddToSet(oStackFunctions,&aCheckDublettes,strTable.aFields[iColumnIndex].sName))) Begin
38920>>>>>>>>>>>>>                Move False to bSucces
38921>>>>>>>>>>>>>            End
38921>>>>>>>>>>>>>>
38921>>>>>>>>>>>>>        Loop
38922>>>>>>>>>>>>>>
38922>>>>>>>>>>>>>        
38922>>>>>>>>>>>>>        If (strTable.bSystemFile) Begin
38924>>>>>>>>>>>>>            Move 1 to strTable.nMaxRecords
38925>>>>>>>>>>>>>        End
38925>>>>>>>>>>>>>>
38925>>>>>>>>>>>>>        Else If (strTable.nMaxRecords>C_MaxNumberOfRecordsInEmbeddedTable) Begin
38928>>>>>>>>>>>>>            Move C_MaxNumberOfRecordsInEmbeddedTable to strTable.nMaxRecords
38929>>>>>>>>>>>>>        End
38929>>>>>>>>>>>>>>
38929>>>>>>>>>>>>>        
38929>>>>>>>>>>>>>        Move "DATAFLEX" to strTable.sDriver
38930>>>>>>>>>>>>>        
38930>>>>>>>>>>>>>        Function_Return bSucces
38931>>>>>>>>>>>>>    End_Function
38932>>>>>>>>>>>>>    
38932>>>>>>>>>>>>>    Function TrimTableDefinitionToDriver tTableExplicit ByRef strTable Returns Boolean
38935>>>>>>>>>>>>>        Boolean bSucces
38935>>>>>>>>>>>>>        Integer iDriver
38935>>>>>>>>>>>>>        Get DriverDllToId of oTableDriverFunctions strTable.sDriver to iDriver
38936>>>>>>>>>>>>>        If (iDriver=TD_DRIVER_DATAFLEX) Get TrimTableDefinitionToEmbedded (&strTable) to bSucces
38939>>>>>>>>>>>>>        Function_Return bSucces
38940>>>>>>>>>>>>>    End_Function
38941>>>>>>>>>>>>>
38941>>>>>>>>>>>>>    Function ExplicitTabelToStringArray tTableExplicit strTable Returns String[]
38944>>>>>>>>>>>>>        tTableFieldExplicit strField
38944>>>>>>>>>>>>>        tTableFieldExplicit strField
38944>>>>>>>>>>>>>        tTableIndexExplicit strIndex
38944>>>>>>>>>>>>>        tTableIndexExplicit strIndex
38944>>>>>>>>>>>>>        Integer iField iFieldMax
38944>>>>>>>>>>>>>        Integer iIndex iIndexMax
38944>>>>>>>>>>>>>        Integer iSegment iSegmentMax
38944>>>>>>>>>>>>>        String sValue sFieldName
38944>>>>>>>>>>>>>        String[] aValues
38945>>>>>>>>>>>>>        Send StringPush of oStackFunctions ("Table definition for "+strTable.sDriver+" table, file handle: "+String(strTable.iFileListEntry)) (&aValues)
38946>>>>>>>>>>>>>        Send StringPush of oStackFunctions ("Root name: "+strTable.sRootName) (&aValues)
38947>>>>>>>>>>>>>        Send StringPush of oStackFunctions ("Logical name: "+strTable.sLogicalName) (&aValues)
38948>>>>>>>>>>>>>        Send StringPush of oStackFunctions ("Display name: "+strTable.sDisplayName) (&aValues)
38949>>>>>>>>>>>>>        Send StringPush of oStackFunctions ("Physical name: "+strTable.sPhysicalName) (&aValues)
38950>>>>>>>>>>>>>        Send StringPush of oStackFunctions ("SystemFile: "+String(strTable.bSystemFile)) (&aValues)
38951>>>>>>>>>>>>>        Send StringPush of oStackFunctions ("MaxRecords: "+String(strTable.nMaxRecords)) (&aValues)
38952>>>>>>>>>>>>>        Send StringPush of oStackFunctions ("RecordsUsed: "+String(strTable.nRecordsUsed)) (&aValues)
38953>>>>>>>>>>>>>        Send StringPush of oStackFunctions ("RecordLength: "+String(strTable.iRecordLength)) (&aValues)
38954>>>>>>>>>>>>>        Send StringPush of oStackFunctions ("RecordLengthUsed: "+String(strTable.iRecordLengthUsed)) (&aValues)
38955>>>>>>>>>>>>>        Send StringPush of oStackFunctions ("LockType: "+String(strTable.iLockType)) (&aValues)
38956>>>>>>>>>>>>>        Send StringPush of oStackFunctions ("IntegrityCheck: "+String(strTable.iIntegrityCheck)) (&aValues)
38957>>>>>>>>>>>>>        Send StringPush of oStackFunctions "" (&aValues)
38958>>>>>>>>>>>>>        Send StringPush of oStackFunctions "Columns: " (&aValues)
38959>>>>>>>>>>>>>        
38959>>>>>>>>>>>>>        Move (SizeOfArray(strTable.aFields)-1) to iFieldMax
38960>>>>>>>>>>>>>        For iField from 1 to iFieldMax
38966>>>>>>>>>>>>>>
38966>>>>>>>>>>>>>            Move strTable.aFields[iField] to strField
38967>>>>>>>>>>>>>            Move (String(iField)+": "+pad(strField.sName,15)+" "+FieldTypeText(oTableAccessFunctions,strField.iType,1)+" ") to sValue
38968>>>>>>>>>>>>>            Move (sValue+String(strField.iLen)+"."+String(strField.iPrecision)+" Offset/Native len: "+String(strField.iOffset)+"/"+String(strField.iNativeLength)+" ") to sValue
38969>>>>>>>>>>>>>            If (strField.iMainIndex<>0) Begin
38971>>>>>>>>>>>>>                Move (sValue+"Index: "+String(strField.iMainIndex)+" ") to sValue
38972>>>>>>>>>>>>>            End
38972>>>>>>>>>>>>>>
38972>>>>>>>>>>>>>            If (strField.iRelFile<>0) Begin
38974>>>>>>>>>>>>>                Move (sValue+"Relation: "+String(strField.iRelFile)+"."+String(strField.iRelField)+" ") to sValue
38975>>>>>>>>>>>>>            End
38975>>>>>>>>>>>>>>
38975>>>>>>>>>>>>>            Send StringPush of oStackFunctions sValue (&aValues)
38976>>>>>>>>>>>>>        Loop
38977>>>>>>>>>>>>>>
38977>>>>>>>>>>>>>        
38977>>>>>>>>>>>>>        Send StringPush of oStackFunctions "" (&aValues)
38978>>>>>>>>>>>>>        Send StringPush of oStackFunctions "Indices: " (&aValues)
38979>>>>>>>>>>>>>        Move (SizeOfArray(strTable.aIndices)-1) to iIndexMax
38980>>>>>>>>>>>>>        For iIndex from 1 to iIndexMax
38986>>>>>>>>>>>>>>
38986>>>>>>>>>>>>>            Move (SizeOfArray(strTable.aIndices[iIndex].aFields)-1) to iSegmentMax
38987>>>>>>>>>>>>>            If (iSegmentMax>=1) Begin
38989>>>>>>>>>>>>>                Move strTable.aIndices[iIndex] to strIndex
38990>>>>>>>>>>>>>                Send StringPush of oStackFunctions ("  Index: "+String(iIndex)) (&aValues)
38991>>>>>>>>>>>>>                For iSegment from 1 to iSegmentMax
38997>>>>>>>>>>>>>>
38997>>>>>>>>>>>>>                    If (strIndex.aFields[iSegment]<>0) Begin
38999>>>>>>>>>>>>>                        Move strTable.aFields[strIndex.aFields[iSegment]].sName to sFieldName
39000>>>>>>>>>>>>>                    End
39000>>>>>>>>>>>>>>
39000>>>>>>>>>>>>>                    Else Begin
39001>>>>>>>>>>>>>                        Move "Recnum" to sFieldName
39002>>>>>>>>>>>>>                    End
39002>>>>>>>>>>>>>>
39002>>>>>>>>>>>>>                    Send StringPush of oStackFunctions ("    "+sFieldName+" "+If(strIndex.aCaseInsensitive[iSegment],"UC","")+" "+If(strIndex.aDescending[iSegment],"desc","")) (&aValues)
39003>>>>>>>>>>>>>                Loop
39004>>>>>>>>>>>>>>
39004>>>>>>>>>>>>>            End
39004>>>>>>>>>>>>>>
39004>>>>>>>>>>>>>        Loop
39005>>>>>>>>>>>>>>
39005>>>>>>>>>>>>>        Function_Return aValues
39006>>>>>>>>>>>>>    End_Function
39007>>>>>>>>>>>>>    
39007>>>>>>>>>>>>>    Function ExplicitTabelToString tTableExplicit strTable Returns String
39010>>>>>>>>>>>>>        String[] aValues
39011>>>>>>>>>>>>>        Get ExplicitTabelToStringArray strTable to aValues
39012>>>>>>>>>>>>>        Function_Return (JoinString(oStringFunctions,aValues,Character(10),0,0))
39013>>>>>>>>>>>>>    End_Function
39014>>>>>>>>>>>>>    
39014>>>>>>>>>>>>>End_Object
39015>>>>>>>>>>>>>
39015>>>>>>>>>>>Use FilelistFunctions.pkg
Including file: FilelistFunctions.pkg    (Z:\VmShare\Projects\WebQuery18-0\StureApsPublicLib\AppSrc\FilelistFunctions.pkg)
39015>>>>>>>>>>>>>Use VdfBase.pkg // DAW package. Provides low level support expected of all VDF applications (windows and webapp)
39015>>>>>>>>>>>>>Use FileFunctions.pkg // Define oFileFunctions object
39015>>>>>>>>>>>>>Use StackFunctions.pkg
39015>>>>>>>>>>>>>
39015>>>>>>>>>>>>>
39015>>>>>>>>>>>>>Use TableAccessFunctions.pkg
39015>>>>>>>>>>>>>
39015>>>>>>>>>>>>>Global_Variable Integer oFilelistFunctions
39015>>>>>>>>>>>>>
39015>>>>>>>>>>>>>Object _oFilelistFunctions is a cObject
39017>>>>>>>>>>>>>    Move Self to oFilelistFunctions
39018>>>>>>>>>>>>>    
39018>>>>>>>>>>>>>    Property String[] _paFilelistStack
39020>>>>>>>>>>>>>    
39020>>>>>>>>>>>>>    Procedure PushAndSetFilelist String sFileListName
39023>>>>>>>>>>>>>        String sFilelistPush
39023>>>>>>>>>>>>>        String[] aFilelistStack
39024>>>>>>>>>>>>>        
39024>>>>>>>>>>>>>        Get_Attribute DF_FILELIST_NAME to sFilelistPush
39027>>>>>>>>>>>>>        Set_Attribute DF_FILELIST_NAME to (ToAnsi(sFileListName))
39030>>>>>>>>>>>>>        
39030>>>>>>>>>>>>>        Get _paFilelistStack to aFilelistStack
39031>>>>>>>>>>>>>        Send StringPush of oStackFunctions sFilelistPush (&aFilelistStack)
39032>>>>>>>>>>>>>        Set _paFilelistStack to aFilelistStack
39033>>>>>>>>>>>>>    End_Procedure
39034>>>>>>>>>>>>>    
39034>>>>>>>>>>>>>    Procedure PopFilelist
39037>>>>>>>>>>>>>        String sFilelistPush
39037>>>>>>>>>>>>>        String[] aFilelistStack
39038>>>>>>>>>>>>>
39038>>>>>>>>>>>>>        Get _paFilelistStack to aFilelistStack
39039>>>>>>>>>>>>>        Get StringPop of oStackFunctions (&aFilelistStack) to sFilelistPush 
39040>>>>>>>>>>>>>        Set _paFilelistStack to aFilelistStack
39041>>>>>>>>>>>>>
39041>>>>>>>>>>>>>        Set_Attribute DF_FILELIST_NAME to (ToAnsi(sFilelistPush))
39044>>>>>>>>>>>>>    End_Procedure
39045>>>>>>>>>>>>>
39045>>>>>>>>>>>>>    Function CreateEmptyFilelist String sFilename Returns Boolean
39048>>>>>>>>>>>>>        Integer liCount liOrg liChannel
39048>>>>>>>>>>>>>        String lsFiller sFilelistPush
39048>>>>>>>>>>>>>
39048>>>>>>>>>>>>>        Get_Attribute DF_FILELIST_NAME to sFilelistPush // Remember who we were
39051>>>>>>>>>>>>>
39051>>>>>>>>>>>>>        Get DirectOutput of oFileFunctions ("binary:"+sFilename) to liChannel
39052>>>>>>>>>>>>>
39052>>>>>>>>>>>>>        If (liChannel>=0) Begin
39054>>>>>>>>>>>>>            Get_Argument_Size to liOrg      // Create the filelist. It has to be of size
39055>>>>>>>>>>>>>            Set_Argument_Size 524277        // 32128, if it is any smaller errors occur
39056>>>>>>>>>>>>>>
39056>>>>>>>>>>>>>            pad "" to lsFiller 524277       // when setting the filelist attributes.
39058>>>>>>>>>>>>>>
39058>>>>>>>>>>>>>            Move (Repeat(character(0),524277)) to lsFiller
39059>>>>>>>>>>>>>            Write channel liChannel "filelist.cfg"            // This has to be the first 12 characters
39061>>>>>>>>>>>>>            Write lsFiller                  //
39062>>>>>>>>>>>>>            Send CloseOutput of oFileFunctions liChannel
39063>>>>>>>>>>>>>            Set_Argument_Size liOrg         // Restore max argument size.
39064>>>>>>>>>>>>>>
39064>>>>>>>>>>>>>            //      set_attribute DF_FILELIST_NAME To lsFileListPathAndName // Setup the file list for DataFlex.
39064>>>>>>>>>>>>>            Set_Attribute DF_FILELIST_NAME to (ToAnsi(sFilename))
39067>>>>>>>>>>>>>
39067>>>>>>>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of 4095 to "temp"
39070>>>>>>>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of 4095 to "temp"
39073>>>>>>>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of 4095 to "temp"
39076>>>>>>>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of 4095 to ""
39079>>>>>>>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of 4095 to ""
39082>>>>>>>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of 4095 to ""
39085>>>>>>>>>>>>>
39085>>>>>>>>>>>>>            Set_Attribute DF_FILE_ROOT_NAME    of 50 to "flexerrs"
39088>>>>>>>>>>>>>            Set_Attribute DF_FILE_LOGICAL_NAME of 50 to "FLEXERRS"
39091>>>>>>>>>>>>>            Set_Attribute DF_FILE_DISPLAY_NAME of 50 to "@DataFlex Error File"
39094>>>>>>>>>>>>>
39094>>>>>>>>>>>>>            //for liCount from 1 to 250                               // Fill the filelist.
39094>>>>>>>>>>>>>            //  set_attribute DF_FILE_ROOT_NAME    of liCount to ""   // Every slot must be
39094>>>>>>>>>>>>>            //  set_attribute DF_FILE_LOGICAL_NAME of liCount to ""   // emptied out. Otherwise
39094>>>>>>>>>>>>>            //  set_attribute DF_FILE_DISPLAY_NAME of liCount to ""   // the API thinks some of
39094>>>>>>>>>>>>>            //loop                                                    // the slots are used.
39094>>>>>>>>>>>>>//            Set_Attribute DF_FILELIST_NAME to sFilelistPush
39094>>>>>>>>>>>>>            Function_Return (FileExists(oFileFunctions,sFilename)=1)
39095>>>>>>>>>>>>>        End
39095>>>>>>>>>>>>>>
39095>>>>>>>>>>>>>        Function_Return False
39096>>>>>>>>>>>>>    End_Function
39097>>>>>>>>>>>>>
39097>>>>>>>>>>>>>    Function FindEntryByRootname Integer iStartEntry String sTableRootName Returns Integer
39100>>>>>>>>>>>>>        Integer iTable
39100>>>>>>>>>>>>>        String sValue
39100>>>>>>>>>>>>>        Move iStartEntry to iTable
39101>>>>>>>>>>>>>        Repeat
39101>>>>>>>>>>>>>>
39101>>>>>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of iTable to iTable
39104>>>>>>>>>>>>>            If (iTable<>0) Begin
39106>>>>>>>>>>>>>                Get_Attribute DF_FILE_ROOT_NAME of iTable to sValue
39109>>>>>>>>>>>>>                If (Uppercase(sValue)=Uppercase(sTableRootName)) Begin
39111>>>>>>>>>>>>>                    Function_Return iTable
39112>>>>>>>>>>>>>                End
39112>>>>>>>>>>>>>>
39112>>>>>>>>>>>>>            End
39112>>>>>>>>>>>>>>
39112>>>>>>>>>>>>>        Until (iTable=0)
39114>>>>>>>>>>>>>        Function_Return 0
39115>>>>>>>>>>>>>    End_Function
39116>>>>>>>>>>>>>
39116>>>>>>>>>>>>>    Function FindEntryByLogicalName Integer iStartEntry String sLogicalName Returns Integer
39119>>>>>>>>>>>>>        Integer iTable
39119>>>>>>>>>>>>>        String sValue
39119>>>>>>>>>>>>>        Move iStartEntry to iTable
39120>>>>>>>>>>>>>        Repeat
39120>>>>>>>>>>>>>>
39120>>>>>>>>>>>>>            Get_Attribute DF_FILE_NEXT_USED of iTable to iTable
39123>>>>>>>>>>>>>            If (iTable<>0) Begin
39125>>>>>>>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of iTable to sValue
39128>>>>>>>>>>>>>                If (Uppercase(sValue)=Uppercase(sLogicalName)) Begin
39130>>>>>>>>>>>>>                    Function_Return iTable
39131>>>>>>>>>>>>>                End
39131>>>>>>>>>>>>>>
39131>>>>>>>>>>>>>            End
39131>>>>>>>>>>>>>>
39131>>>>>>>>>>>>>        Until (iTable=0)
39133>>>>>>>>>>>>>        Function_Return 0
39134>>>>>>>>>>>>>    End_Function
39135>>>>>>>>>>>>>
39135>>>>>>>>>>>>>    Procedure UpdateEntry Integer iTable String sRoot String sLogical String sDisplay
39138>>>>>>>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME    of iTable to sRoot
39141>>>>>>>>>>>>>        Set_Attribute DF_FILE_LOGICAL_NAME of iTable to sLogical
39144>>>>>>>>>>>>>        Set_Attribute DF_FILE_DISPLAY_NAME of iTable to sDisplay
39147>>>>>>>>>>>>>    End_Procedure
39148>>>>>>>>>>>>>
39148>>>>>>>>>>>>>    Function EntryInUse Integer iTable Returns Boolean
39151>>>>>>>>>>>>>        String sRoot
39151>>>>>>>>>>>>>        Set_Attribute DF_FILE_ROOT_NAME of iTable to sRoot
39154>>>>>>>>>>>>>        Function_Return (sRoot<>"")
39155>>>>>>>>>>>>>    End_Function
39156>>>>>>>>>>>>>
39156>>>>>>>>>>>>>    Function TableEntryArray Integer iFileListNavAttr Returns Integer[]
39159>>>>>>>>>>>>>        Integer iTable iIndex
39159>>>>>>>>>>>>>        Integer[] aTables
39160>>>>>>>>>>>>>        If (iFileListNavAttr=DF_FILE_NEXT_OPENED or iFileListNavAttr=DF_FILE_NEXT_USED or iFileListNavAttr=DF_FILE_NEXT_EMPTY) Begin
39162>>>>>>>>>>>>>            Move 0 to iTable
39163>>>>>>>>>>>>>            Move 0 to iIndex
39164>>>>>>>>>>>>>            Repeat
39164>>>>>>>>>>>>>>
39164>>>>>>>>>>>>>                Get_Attribute iFileListNavAttr of iTable to iTable
39167>>>>>>>>>>>>>                If (iTable<>0) Begin
39169>>>>>>>>>>>>>                    Move iTable to aTables[iIndex]
39170>>>>>>>>>>>>>                    Increment iIndex
39171>>>>>>>>>>>>>                End
39171>>>>>>>>>>>>>>
39171>>>>>>>>>>>>>            Until (iTable=0)
39173>>>>>>>>>>>>>        End
39173>>>>>>>>>>>>>>
39173>>>>>>>>>>>>>        Else begin
39174>>>>>>>>>>>>>            Error 810 "Illegal attribute passed to TableIntegerArray function"
39175>>>>>>>>>>>>>>
39175>>>>>>>>>>>>>        End
39175>>>>>>>>>>>>>>
39175>>>>>>>>>>>>>        Function_Return aTables
39176>>>>>>>>>>>>>    End_Function
39177>>>>>>>>>>>>>    
39177>>>>>>>>>>>>>End_Object
39178>>>>>>>>>>>Use StackFunctions.pkg // Define oStackFunctions object
39178>>>>>>>>>>>//Use Win\TableStructureErrorPanel.dg
39178>>>>>>>>>>>
39178>>>>>>>>>>>Use TableStructureErrorStruct.pkg
Including file: TableStructureErrorStruct.pkg    (Z:\VmShare\Projects\WebQuery18-0\StureApsPublicLib\AppSrc\TableStructureErrorStruct.pkg)
39178>>>>>>>>>>>>>Use ErrorEventHandlerClass.pkg // cErrorEventHandler class and oErrorSilence object
39178>>>>>>>>>>>>>
39178>>>>>>>>>>>>>Struct tRestructureError
39178>>>>>>>>>>>>>    String           sOperation         // While executing this instruction
39178>>>>>>>>>>>>>    tErrorEvent      stError            // this error occured
39178>>>>>>>>>>>>>    tErrorEvent      stError            // this error occured
39178>>>>>>>>>>>>>    tTableExplicit stTableDefInitial  //
39178>>>>>>>>>>>>>    tTableExplicit stTableDefInitial  //
39178>>>>>>>>>>>>>End_Struct
39178>>>>>>>>>>>>>
39178>>>>>>>>>>>>>Global_Variable tRestructureError _gstTempRestructureError
39178>>>>>>>>>>>>>Global_Variable Integer oTableStructureFunctions
39178>>>>>>>>>>>>>
39178>>>>>>>>>>>
39178>>>>>>>>>>>Class _cTableStructureFunctionsErrorHandler is a cErrorEventHandler
39179>>>>>>>>>>>    Procedure DoReset // Prevent each activation from resetting the error data
39181>>>>>>>>>>>    End_Procedure
39182>>>>>>>>>>>    Procedure _NewDoReset // Sent by function Structure_Start of cTableStructure class
39184>>>>>>>>>>>        tErrorEvent[] aEvents
39184>>>>>>>>>>>        tErrorEvent[] aEvents
39185>>>>>>>>>>>        tRestructureError[] aErrorLog
39185>>>>>>>>>>>        tRestructureError[] aErrorLog
39186>>>>>>>>>>>        Set paErrors to (ResizeArray(aEvents,0))
39187>>>>>>>>>>>        Set paErrorLog to (ResizeArray(aErrorLog,0))
39188>>>>>>>>>>>    End_Procedure
39189>>>>>>>>>>>    Procedure OnError Integer iError String sErrorText Integer iErrorLine
39191>>>>>>>>>>>        Forward Send OnError iError sErrorText iErrorLine
39193>>>>>>>>>>>        Move iError to _gstTempRestructureError.stError.iError
39194>>>>>>>>>>>        Move sErrorText to _gstTempRestructureError.stError.sErrorText
39195>>>>>>>>>>>        Move iErrorLine to _gstTempRestructureError.stError.iErrorLine
39196>>>>>>>>>>>        Set _pbWasError to True
39197>>>>>>>>>>>//        Send Popup of oTableStructureErrorPanel // Du'r desvrre ikke
39197>>>>>>>>>>>        Send Info_Box (_gstTempRestructureError.sOperation+Character(10)+ExplicitTabelToString(oTableExplicitFunctions,_gstTempRestructureError.stTableDefInitial)) "Structure error"
39198>>>>>>>>>>>    End_Procedure
39199>>>>>>>>>>>End_Class
39200>>>>>>>>>>>
39200>>>>>>>>>>>Class cTableStructure is a cObject
39201>>>>>>>>>>>
39201>>>>>>>>>>>    Procedure Construct_Object
39203>>>>>>>>>>>        Forward send Construct_Object
39205>>>>>>>>>>>        Property tRestructureError[] paErrorLog
39206>>>>>>>>>>>
39206>>>>>>>>>>>        Property Integer _phTable      // Private
39207>>>>>>>>>>>        Property Boolean _pbWasError  // Private
39208>>>>>>>>>>>
39208>>>>>>>>>>>        Property Integer piStructureEndOptions DF_STRUCTEND_OPT_NONE
39209>>>>>>>>>>>
39209>>>>>>>>>>>        Object _oErrorHandler is a _cTableStructureFunctionsErrorHandler
39211>>>>>>>>>>>        End_Object
39212>>>>>>>>>>>
39212>>>>>>>>>>>        Property Integer _piWriteSourceChannel
39213>>>>>>>>>>>        Property Boolean[] _paWriteSourceSuspended
39214>>>>>>>>>>>        Property Integer _piSourceIndent
39215>>>>>>>>>>>    End_Procedure
39216>>>>>>>>>>>
39216>>>>>>>>>>>    Function _IsSuspended Returns Boolean
39218>>>>>>>>>>>        Boolean bWriteSuspend
39218>>>>>>>>>>>        Boolean[] aWriteSourceSuspended
39219>>>>>>>>>>>        Get _paWriteSourceSuspended to aWriteSourceSuspended
39220>>>>>>>>>>>        If (BooleanIsEmpty(oStackFunctions,aWriteSourceSuspended)) Begin
39222>>>>>>>>>>>            Function_Return False
39223>>>>>>>>>>>        End
39223>>>>>>>>>>>>
39223>>>>>>>>>>>        Get BooleanCopy of oStackFunctions aWriteSourceSuspended to bWriteSuspend
39224>>>>>>>>>>>        Function_Return bWriteSuspend
39225>>>>>>>>>>>    End_Function
39226>>>>>>>>>>>    
39226>>>>>>>>>>>    Procedure WriteSource String sValue
39228>>>>>>>>>>>        Integer iChannel
39228>>>>>>>>>>>        If (not(_IsSuspended(Self))) Begin
39230>>>>>>>>>>>            Get _piWriteSourceChannel to iChannel
39231>>>>>>>>>>>            If (iChannel>=0) Begin
39233>>>>>>>>>>>                Write channel iChannel (Repeat("    ",_piSourceIndent(Self)))
39235>>>>>>>>>>>                Writeln sValue
39237>>>>>>>>>>>            End
39237>>>>>>>>>>>>
39237>>>>>>>>>>>        End
39237>>>>>>>>>>>>
39237>>>>>>>>>>>    End_Procedure
39238>>>>>>>>>>>    
39238>>>>>>>>>>>    Procedure SuspendWriteSource
39240>>>>>>>>>>>        Boolean[] aWriteSourceSuspended
39241>>>>>>>>>>>        Get _paWriteSourceSuspended to aWriteSourceSuspended
39242>>>>>>>>>>>        Send BooleanPush of oStackFunctions True (&aWriteSourceSuspended)
39243>>>>>>>>>>>        Set _paWriteSourceSuspended to aWriteSourceSuspended
39244>>>>>>>>>>>    End_Procedure
39245>>>>>>>>>>>    
39245>>>>>>>>>>>    Procedure UnsuspendWriteSource 
39247>>>>>>>>>>>        Boolean[] aWriteSourceSuspended
39248>>>>>>>>>>>        Get _paWriteSourceSuspended to aWriteSourceSuspended
39249>>>>>>>>>>>        Send BooleanDrop of oStackFunctions (&aWriteSourceSuspended)
39250>>>>>>>>>>>        Set _paWriteSourceSuspended to aWriteSourceSuspended
39251>>>>>>>>>>>    End_Procedure 
39252>>>>>>>>>>>    
39252>>>>>>>>>>>    Procedure IndentSource
39254>>>>>>>>>>>        Set _piSourceIndent to (_piSourceIndent(Self)+1)
39255>>>>>>>>>>>    End_Procedure
39256>>>>>>>>>>>
39256>>>>>>>>>>>    Procedure UnindentSource
39258>>>>>>>>>>>        Set _piSourceIndent to (_piSourceIndent(Self)-1)
39259>>>>>>>>>>>    End_Procedure
39260>>>>>>>>>>>
39260>>>>>>>>>>>    Procedure OnOperationBegin String sOperation // called before each modification of the structure (for each changing of an attribute value)
39262>>>>>>>>>>>        tTableAttributes strTable
39262>>>>>>>>>>>        tTableAttributes strTable
39262>>>>>>>>>>>        Set _pbWasError to False
39263>>>>>>>>>>>        Move sOperation to _gstTempRestructureError.sOperation
39264>>>>>>>>>>>        Send GetTableAttributes of oAttributeFunctions (&strTable) (_phTable(Self))
39265>>>>>>>>>>>        Get TableAttributesToExplicit of oAttributeFunctions strTable to _gstTempRestructureError.stTableDefInitial
39266>>>>>>>>>>>        Send Activate of _oErrorHandler
39267>>>>>>>>>>>      //If (Left(sOperation,5)<>"Struc") Begin
39267>>>>>>>>>>>      //    Error 789 "Tudse i suppen"
39267>>>>>>>>>>>      //End
39267>>>>>>>>>>>    End_Procedure
39268>>>>>>>>>>>
39268>>>>>>>>>>>    Procedure OnOperationEnd // Called immediately after each modification
39270>>>>>>>>>>>        Boolean bWasSuspended
39270>>>>>>>>>>>        Integer iMax iIndex
39270>>>>>>>>>>>        String[] aValues
39271>>>>>>>>>>>        tRestructureError[] aErrorLog
39271>>>>>>>>>>>        tRestructureError[] aErrorLog
39272>>>>>>>>>>>        Send Deactivate of _oErrorHandler
39273>>>>>>>>>>>        If (_pbWasError(Self)) Begin
39275>>>>>>>>>>>
39275>>>>>>>>>>>//            Send GetTableAttributes of oAttributeFunctions (&_gstTempRestructureError.stTableDefResult) (_phTable(Self))
39275>>>>>>>>>>>            Get paErrorLog to aErrorLog
39276>>>>>>>>>>>            Move _gstTempRestructureError to aErrorLog[SizeOfArray(aErrorLog)]
39277>>>>>>>>>>>            Set paErrorLog to aErrorLog
39278>>>>>>>>>>>            
39278>>>>>>>>>>>            Get _IsSuspended to bWasSuspended
39279>>>>>>>>>>>            If (bWasSuspended) Begin
39281>>>>>>>>>>>                Send UnsuspendWriteSource
39282>>>>>>>>>>>            End
39282>>>>>>>>>>>>
39282>>>>>>>>>>>
39282>>>>>>>>>>>            Send WriteSource ("// ERROR: "+String(_gstTempRestructureError.stError.iError)+" "+_gstTempRestructureError.stError.sErrorText+" on line "+String(_gstTempRestructureError.stError.iErrorLine))
39283>>>>>>>>>>>            Send WriteSource ("// Occurred while executing this instruction on the definition below: "+_gstTempRestructureError.sOperation)
39284>>>>>>>>>>>            Get ExplicitTabelToStringArray of oTableExplicitFunctions _gstTempRestructureError.stTableDefInitial to aValues
39285>>>>>>>>>>>            Move (SizeOfArray(aValues)-1) to iMax
39286>>>>>>>>>>>            For iIndex from 0 to iMax
39292>>>>>>>>>>>>
39292>>>>>>>>>>>                Send WriteSource ("// "+aValues[iIndex])
39293>>>>>>>>>>>            Loop
39294>>>>>>>>>>>>
39294>>>>>>>>>>>            
39294>>>>>>>>>>>            If (bWasSuspended) Begin
39296>>>>>>>>>>>                Send SuspendWriteSource
39297>>>>>>>>>>>            End
39297>>>>>>>>>>>>
39297>>>>>>>>>>>
39297>>>>>>>>>>>        End
39297>>>>>>>>>>>>
39297>>>>>>>>>>>    End_Procedure
39298>>>>>>>>>>>    
39298>>>>>>>>>>>        Procedure _MakeFinalLogEntry String sFinalRemark
39300>>>>>>>>>>>            tRestructureError[] aErrorLog
39300>>>>>>>>>>>            tRestructureError[] aErrorLog
39301>>>>>>>>>>>          
39301>>>>>>>>>>>            Get paErrorLog to aErrorLog
39302>>>>>>>>>>>            
39302>>>>>>>>>>>//            Send GetTableAttributes of oAttributeFunctions (&_gstTempRestructureError.stTableDefResult) (_phTable(Self))
39302>>>>>>>>>>>            Move "Structure on exit" to _gstTempRestructureError.sOperation
39303>>>>>>>>>>>            Move 0 to _gstTempRestructureError.stError.iError
39304>>>>>>>>>>>            Move 0 to _gstTempRestructureError.stError.iErrorLine
39305>>>>>>>>>>>            Move sFinalRemark to _gstTempRestructureError.stError.sErrorText
39306>>>>>>>>>>> 
39306>>>>>>>>>>>            Move _gstTempRestructureError to aErrorLog[SizeOfArray(aErrorLog)]
39307>>>>>>>>>>>            Set paErrorLog to aErrorLog
39308>>>>>>>>>>>        End_Procedure
39309>>>>>>>>>>>    
39309>>>>>>>>>>>    Function ErrorCount Returns Integer
39311>>>>>>>>>>>        Function_Return (SizeOfArray(paErrors(_oErrorHandler)))
39312>>>>>>>>>>>    End_Function
39313>>>>>>>>>>>    
39313>>>>>>>>>>>    Function ErrorEventArray Returns tErrorEvent[]
39315>>>>>>>>>>>        Function_Return (paErrors(_oErrorHandler))
39316>>>>>>>>>>>    End_Function
39317>>>>>>>>>>>
39317>>>>>>>>>>>    Function Structure_Start Integer hTable String sDriver Returns Boolean
39319>>>>>>>>>>>        Send _NewDoReset of _oErrorHandler
39320>>>>>>>>>>>        If (sDriver<>"") Begin
39322>>>>>>>>>>>            Send WriteSource ('Get Structure_Start hTable "'+sDriver+'" to bSucces')
39323>>>>>>>>>>>            Send OnOperationBegin ("Structure_Start hTable: "+String(hTable)+" driver: "+sDriver)
39324>>>>>>>>>>>            Structure_Start hTable sDriver
39325>>>>>>>>>>>        End
39325>>>>>>>>>>>>
39325>>>>>>>>>>>        Else Begin
39326>>>>>>>>>>>            Send WriteSource ("Get Structure_Start "+hTable+" to bSucces")
39327>>>>>>>>>>>            Send OnOperationBegin ("Get Structure_Start "+String(hTable)+" to bSucces")
39328>>>>>>>>>>>            Structure_Start hTable
39329>>>>>>>>>>>        End
39329>>>>>>>>>>>>
39329>>>>>>>>>>>        Send OnOperationEnd
39330>>>>>>>>>>>        Set _phTable to hTable
39331>>>>>>>>>>>        Function_Return (ErrorCount(Self)=0)
39332>>>>>>>>>>>    End_Function
39333>>>>>>>>>>>
39333>>>>>>>>>>>    Function Structure_Start_New_Table String sTableName String sFolder String sDriver Returns Boolean
39335>>>>>>>>>>>        Integer hTable
39335>>>>>>>>>>>        Boolean bSuccess
39335>>>>>>>>>>>
39335>>>>>>>>>>>        If (sFolder="") Begin // If folder is not specified, we will use the data folder (where filelist.cfg most likely resides)
39337>>>>>>>>>>>            Get VdfFolderPath of oFileFunctions VDF_FILELIST to sFolder
39338>>>>>>>>>>>        End
39338>>>>>>>>>>>>
39338>>>>>>>>>>>
39338>>>>>>>>>>>        Move 0 to hTable // This is a signal to the Structure_Start command to create a new table.
39339>>>>>>>>>>>
39339>>>>>>>>>>>        Get Structure_Start hTable sDriver to bSuccess
39340>>>>>>>>>>>        If (bSuccess) Begin
39342>>>>>>>>>>>            Set Table_Attribute DF_FILE_MULTIUSER     to DF_FILE_USER_MULTI
39343>>>>>>>>>>>            Set Table_Attribute DF_FILE_REUSE_DELETED to DF_FILE_DELETED_REUSE
39344>>>>>>>>>>>            Send SuspendWriteSource
39345>>>>>>>>>>>            Set Table_Attribute DF_FILE_PHYSICAL_NAME to (ToAnsi(AppendPath(oFileFunctions,sFolder,sTableName)))
39346>>>>>>>>>>>            Send UnsuspendWriteSource
39347>>>>>>>>>>>//            Send WriteSource ('Set_Attribute DF_FILE_PHYSICAL_NAME of hTable to (ToAnsi(AppendPath(oFileFunctions,sFolder,"'+sTableName+'")))')
39347>>>>>>>>>>>            Send WriteSource ('Set Table_Attribute DF_FILE_PHYSICAL_NAME to (ToAnsi(AppendPath(oFileFunctions,sFolder,"'+sTableName+'")))')
39348>>>>>>>>>>>        End
39348>>>>>>>>>>>>
39348>>>>>>>>>>>        Function_Return bSuccess
39349>>>>>>>>>>>    End_Function
39350>>>>>>>>>>>
39350>>>>>>>>>>>    //> Table can be opened or closed on call
39350>>>>>>>>>>>    Function Structure_Start_Filelist_Table Integer iFilelistNumber Returns Boolean
39352>>>>>>>>>>>        Integer hTable
39352>>>>>>>>>>>        Boolean bSuccess bOpen
39352>>>>>>>>>>>
39352>>>>>>>>>>>        Get_Attribute DF_FILE_OPENED of iFilelistNumber to bOpen
39355>>>>>>>>>>>        If (not(bOpen)) Begin
39357>>>>>>>>>>>            Get OpenTable of oTableAccessFunctions iFilelistNumber DF_SHARE 0 to bSuccess
39358>>>>>>>>>>>        End
39358>>>>>>>>>>>>
39358>>>>>>>>>>>
39358>>>>>>>>>>>        Move iFilelistNumber to hTable
39359>>>>>>>>>>>
39359>>>>>>>>>>>        Get Structure_Start hTable "" to bSuccess
39360>>>>>>>>>>>        Function_Return bSuccess
39361>>>>>>>>>>>    End_Function
39362>>>>>>>>>>>
39362>>>>>>>>>>>    //> Table must be closed on call
39362>>>>>>>>>>>    Function Structure_Start_Existing_Table String sAbsoluteFileName Returns Boolean
39364>>>>>>>>>>>        Integer hTable
39364>>>>>>>>>>>        Boolean bSuccess
39364>>>>>>>>>>>
39364>>>>>>>>>>>        Get TempFilelistEntry of oTableAccessFunctions 2000 to hTable // First available entry GE 2000
39365>>>>>>>>>>>        Get OpenTableAs of oTableAccessFunctions sAbsoluteFileName hTable DF_SHARE 0 to bSuccess
39366>>>>>>>>>>>
39366>>>>>>>>>>>        If (bSuccess) Begin
39368>>>>>>>>>>>            Get Structure_Start hTable to bSuccess
39369>>>>>>>>>>>        End
39369>>>>>>>>>>>>
39369>>>>>>>>>>>
39369>>>>>>>>>>>        Function_Return bSuccess
39370>>>>>>>>>>>    End_Function
39371>>>>>>>>>>>    
39371>>>>>>>>>>>    Function Structure_End Returns Boolean
39373>>>>>>>>>>>        Boolean bSuccess
39373>>>>>>>>>>>        Integer hTable iHandleType
39373>>>>>>>>>>>        String sValue
39373>>>>>>>>>>>        tErrorEvent[] aErrors
39373>>>>>>>>>>>        tErrorEvent[] aErrors
39374>>>>>>>>>>>        
39374>>>>>>>>>>>        Get _phTable to hTable
39375>>>>>>>>>>>        Send WriteSource ("Get Structure_End to bSucces")
39376>>>>>>>>>>>        Send OnOperationBegin ("Structure_End options: "+String(piStructureEndOptions(Self)))
39377>>>>>>>>>>>            Structure_End hTable (piStructureEndOptions(Self)) "."
39379>>>>>>>>>>>        Send OnOperationEnd
39380>>>>>>>>>>>        
39380>>>>>>>>>>>         
39380>>>>>>>>>>>        Move (ErrorCount(Self)=0) to bSuccess
39381>>>>>>>>>>>        
39381>>>>>>>>>>>        Move "Exiting" to sValue
39382>>>>>>>>>>>        
39382>>>>>>>>>>>        If (not(bSuccess)) Begin
39384>>>>>>>>>>>            Get ErrorEventArray to aErrors
39385>>>>>>>>>>>            Move (sValue+" (errors occurred)") to sValue
39386>>>>>>>>>>>        End
39386>>>>>>>>>>>>
39386>>>>>>>>>>>        
39386>>>>>>>>>>>        Send _MakeFinalLogEntry sValue
39387>>>>>>>>>>>        Set _phTable to 0 //hTable
39388>>>>>>>>>>>        Get_Attribute DF_FILE_HANDLE_TYPE of hTable to iHandleType
39391>>>>>>>>>>>        If (iHandleType<>DF_FILE_HANDLE_BAD) Begin
39393>>>>>>>>>>>            Close hTable
39394>>>>>>>>>>>        End
39394>>>>>>>>>>>>
39394>>>>>>>>>>>        Function_Return bSuccess
39395>>>>>>>>>>>    End_Function
39396>>>>>>>>>>>    
39396>>>>>>>>>>>    Procedure Structure_Abort
39398>>>>>>>>>>>        Integer hTable
39398>>>>>>>>>>>        Get _phTable to hTable
39399>>>>>>>>>>>        Send WriteSource "Structure_Abort hTable"
39400>>>>>>>>>>>        Send OnOperationBegin ("Structure_Abort "+String(hTable))
39401>>>>>>>>>>>            Structure_Abort hTable
39402>>>>>>>>>>>        Send OnOperationEnd
39403>>>>>>>>>>>        Set _phTable to hTable
39404>>>>>>>>>>>        Send _MakeFinalLogEntry "Restructure aborted"
39405>>>>>>>>>>>    End_Procedure
39406>>>>>>>>>>>    
39406>>>>>>>>>>>    Procedure Structure_Copy Integer hSourceTable
39408>>>>>>>>>>>        Integer hTable
39408>>>>>>>>>>>        Get _phTable to hTable
39409>>>>>>>>>>>        Send WriteSource "Structure_Copy hSourceTable to hTable"
39410>>>>>>>>>>>        Send OnOperationBegin ("Structure_Copy source-table: "+String(hSourceTable))
39411>>>>>>>>>>>            Structure_Copy hSourceTable to hTable
39412>>>>>>>>>>>        Send OnOperationEnd
39413>>>>>>>>>>>    End_Procedure
39414>>>>>>>>>>>    
39414>>>>>>>>>>>    Procedure Load_Def String sDefFile
39416>>>>>>>>>>>        Integer hTable
39416>>>>>>>>>>>        Get _phTable to hTable
39417>>>>>>>>>>>        Send WriteSource ("Load_Def "+sDefFile+" Onto hTable")
39418>>>>>>>>>>>        Send OnOperationBegin ("Load_Def def-file: "+String(sDefFile))
39419>>>>>>>>>>>            Load_Def sDefFile Onto hTable
39420>>>>>>>>>>>        Send OnOperationEnd
39421>>>>>>>>>>>    End_Procedure
39422>>>>>>>>>>>
39422>>>>>>>>>>>    Procedure Create_Field Integer iPosition // iPosition=0 => Field is appended
39424>>>>>>>>>>>        Integer hTable
39424>>>>>>>>>>>        Get _phTable to hTable
39425>>>>>>>>>>>        Send WriteSource ("Send Create_Field "+String(iPosition))
39426>>>>>>>>>>>        Send OnOperationBegin ("Create_Field position: "+String(iPosition))
39427>>>>>>>>>>>            Create_Field hTable At iPosition
39428>>>>>>>>>>>        Send OnOperationEnd
39429>>>>>>>>>>>    End_Procedure
39430>>>>>>>>>>>
39430>>>>>>>>>>>    Function Append_Field Returns Integer
39432>>>>>>>>>>>        Integer hTable iPosition
39432>>>>>>>>>>>        Get _phTable to hTable
39433>>>>>>>>>>>        Send WriteSource
39434>>>>>>>>>>>        Send WriteSource ("Send Append_Field hTable 0 // Append")
39435>>>>>>>>>>>        Send OnOperationBegin  "Create_Field position: 0 (append)"
39436>>>>>>>>>>>            Move 0 to iPosition // 0 means: append
39437>>>>>>>>>>>            Create_Field hTable At iPosition
39438>>>>>>>>>>>        Send OnOperationEnd
39439>>>>>>>>>>>        Function_Return iPosition
39440>>>>>>>>>>>    End_Function
39441>>>>>>>>>>>
39441>>>>>>>>>>>    Procedure Delete_Field Integer iPosition
39443>>>>>>>>>>>        Integer hTable
39443>>>>>>>>>>>        Get _phTable to hTable
39444>>>>>>>>>>>        Send WriteSource ("Send Delete_Field "+String(iPosition))
39445>>>>>>>>>>>        Send OnOperationBegin  ("Delete_Field position: "+String(iPosition))
39446>>>>>>>>>>>            Delete_Field hTable iPosition
39447>>>>>>>>>>>        Send OnOperationEnd
39448>>>>>>>>>>>    End_Procedure
39449>>>>>>>>>>>
39449>>>>>>>>>>>    Procedure Create_Index Integer iIndexNumber
39451>>>>>>>>>>>        Integer hTable
39451>>>>>>>>>>>        Integer iIndexHandle iMax
39451>>>>>>>>>>>        Boolean[] aTempIndices
39452>>>>>>>>>>>        Get _phTable to hTable
39453>>>>>>>>>>>        Move iIndexNumber to iIndexHandle
39454>>>>>>>>>>>
39454>>>>>>>>>>>        Send WriteSource ("Send Create_Index "+String(iIndexNumber))
39455>>>>>>>>>>>        Send OnOperationBegin ("Create_Index index: "+String(iIndexNumber))
39456>>>>>>>>>>>            Repeat
39456>>>>>>>>>>>>
39456>>>>>>>>>>>                Create_Index hTable at iIndexNumber
39457>>>>>>>>>>>                If (iIndexNumber<>iIndexHandle) Begin
39459>>>>>>>>>>>                    Move True to aTempIndices[iIndexNumber]
39460>>>>>>>>>>>                End
39460>>>>>>>>>>>>
39460>>>>>>>>>>>            Until (iIndexHandle=iIndexNumber)
39462>>>>>>>>>>>            Move (SizeOfArray(aTempIndices)-1) to iMax
39463>>>>>>>>>>>            For iIndexNumber from 1 to iMax
39469>>>>>>>>>>>>
39469>>>>>>>>>>>                If (aTempIndices[iIndexNumber]) Begin
39471>>>>>>>>>>>                    Send SuspendWriteSource
39472>>>>>>>>>>>                    Send Delete_Index iIndexNumber
39473>>>>>>>>>>>                    Send UnsuspendWriteSource
39474>>>>>>>>>>>                End
39474>>>>>>>>>>>>
39474>>>>>>>>>>>            Loop
39475>>>>>>>>>>>>
39475>>>>>>>>>>>        Send OnOperationEnd
39476>>>>>>>>>>>    End_Procedure
39477>>>>>>>>>>>
39477>>>>>>>>>>>    Procedure Delete_Index Integer iIndexNumber
39479>>>>>>>>>>>        Integer hTable
39479>>>>>>>>>>>        Get _phTable to hTable
39480>>>>>>>>>>>        Send WriteSource ('Send Delete_Index '+String(iIndexNumber))
39481>>>>>>>>>>>        Send OnOperationBegin ("Delete_Index index: "+String(iIndexNumber))
39482>>>>>>>>>>>            Delete_Index hTable iIndexNumber
39483>>>>>>>>>>>        Send OnOperationEnd
39484>>>>>>>>>>>    End_Procedure
39485>>>>>>>>>>>
39485>>>>>>>>>>>    Procedure Set Table_Attribute Integer iAttribute String sValue
39487>>>>>>>>>>>        Boolean bQuotes
39487>>>>>>>>>>>        Integer hTable iAttrType
39487>>>>>>>>>>>        Get _phTable to hTable
39488>>>>>>>>>>>        Get AttributeType of oAttributeFunctions iAttribute to iAttrType
39489>>>>>>>>>>>        If (iAttrType=ATYPE_FILE) Begin
39491>>>>>>>>>>>            Move (gaAttributes[iAttribute].iValueType=DF_ASCII) to bQuotes
39492>>>>>>>>>>>            Send WriteSource ("Set Table_Attribute "+gaAttributes[iAttribute].sName+" to "+If(bQuotes,'"','')+AttributeSymbolicValue(oAttributeFunctions,iAttribute,sValue)+If(bQuotes,'"',''))
39493>>>>>>>>>>>            Send OnOperationBegin ("Set_Attribute "+gaAttributes[iAttribute].sName+" to "+AttributeSymbolicValue(oAttributeFunctions,iAttribute,sValue))
39494>>>>>>>>>>>            Set_Attribute iAttribute of hTable to sValue
39497>>>>>>>>>>>            Send OnOperationEnd
39498>>>>>>>>>>>        End
39498>>>>>>>>>>>>
39498>>>>>>>>>>>        Else Begin
39499>>>>>>>>>>>            Error 814 "Attribute must be of type table"
39500>>>>>>>>>>>>
39500>>>>>>>>>>>        End
39500>>>>>>>>>>>>
39500>>>>>>>>>>>    End_Procedure
39501>>>>>>>>>>>
39501>>>>>>>>>>>    Function Table_Attribute Integer iAttribute Returns String
39503>>>>>>>>>>>        Integer hTable iAttrType
39503>>>>>>>>>>>        String sValue
39503>>>>>>>>>>>        Get _phTable to hTable
39504>>>>>>>>>>>        Get AttributeType of oAttributeFunctions iAttribute to iAttrType
39505>>>>>>>>>>>        If (iAttrType=ATYPE_FILELIST or iAttrType=ATYPE_FILE) Begin // You may get filelist attributes (but you can't set them)
39507>>>>>>>>>>>            Send WriteSource ("Get Table_Attribute "+gaAttributes[iAttribute].sName+" to sValue")
39508>>>>>>>>>>>            Send OnOperationBegin ("Get_Attribute "+gaAttributes[iAttribute].sName)
39509>>>>>>>>>>>            Get_Attribute iAttribute of hTable to sValue
39512>>>>>>>>>>>            Send OnOperationEnd
39513>>>>>>>>>>>        End
39513>>>>>>>>>>>>
39513>>>>>>>>>>>        Else Begin
39514>>>>>>>>>>>            Error 815 "Attribute must be of type table"
39515>>>>>>>>>>>>
39515>>>>>>>>>>>        End
39515>>>>>>>>>>>>
39515>>>>>>>>>>>        Function_Return sValue
39516>>>>>>>>>>>    End_Function
39517>>>>>>>>>>>
39517>>>>>>>>>>>    Procedure Set Field_Attribute Integer iAttribute Integer iField String sValue
39519>>>>>>>>>>>        Integer hTable iAttrType
39519>>>>>>>>>>>        Get _phTable to hTable
39520>>>>>>>>>>>        Get AttributeType of oAttributeFunctions iAttribute to iAttrType
39521>>>>>>>>>>>        If (iAttrType=ATYPE_FIELD) Begin
39523>>>>>>>>>>>            Send WriteSource ("Set Field_Attribute "+gaAttributes[iAttribute].sName+" "+String(iField)+" to "+AttributeSymbolicValue(oAttributeFunctions,iAttribute,sValue))
39524>>>>>>>>>>>            Send OnOperationBegin ("Set_Attribute "+gaAttributes[iAttribute].sName+" field: "+String(iField)+" to "+AttributeSymbolicValue(oAttributeFunctions,iAttribute,sValue))
39525>>>>>>>>>>>            Set_Attribute iAttribute of hTable iField to sValue
39528>>>>>>>>>>>            Send OnOperationEnd
39529>>>>>>>>>>>        End
39529>>>>>>>>>>>>
39529>>>>>>>>>>>        Else Begin
39530>>>>>>>>>>>            Error 816 "Attribute must be of type field"
39531>>>>>>>>>>>>
39531>>>>>>>>>>>        End
39531>>>>>>>>>>>>
39531>>>>>>>>>>>    End_Procedure
39532>>>>>>>>>>>
39532>>>>>>>>>>>    Function Field_Attribute Integer iAttribute Integer iField Returns String
39534>>>>>>>>>>>        Integer hTable iAttrType
39534>>>>>>>>>>>        String sValue
39534>>>>>>>>>>>        Get _phTable to hTable
39535>>>>>>>>>>>        Get AttributeType of oAttributeFunctions iAttribute to iAttrType
39536>>>>>>>>>>>        If (iAttrType=ATYPE_FIELD) Begin
39538>>>>>>>>>>>            Send WriteSource ("Get Field_Attribute "+gaAttributes[iAttribute].sName+" "+String(iField)+" to sValue")
39539>>>>>>>>>>>            Send OnOperationBegin ("Get_Attribute "+gaAttributes[iAttribute].sName+" field: "+String(iField))
39540>>>>>>>>>>>            Get_Attribute iAttribute of hTable iField to sValue
39543>>>>>>>>>>>            Send OnOperationEnd
39544>>>>>>>>>>>        End
39544>>>>>>>>>>>>
39544>>>>>>>>>>>        Else Begin
39545>>>>>>>>>>>            Error 815 "Attribute must be of type field"
39546>>>>>>>>>>>>
39546>>>>>>>>>>>        End
39546>>>>>>>>>>>>
39546>>>>>>>>>>>        Function_Return sValue
39547>>>>>>>>>>>    End_Function
39548>>>>>>>>>>>
39548>>>>>>>>>>>    Procedure Set Index_Attribute Integer iAttribute Integer iIndex String sValue
39550>>>>>>>>>>>        Integer hTable iAttrType
39550>>>>>>>>>>>        Get _phTable to hTable
39551>>>>>>>>>>>        Get AttributeType of oAttributeFunctions iAttribute to iAttrType
39552>>>>>>>>>>>        If (iAttrType=ATYPE_INDEX) Begin
39554>>>>>>>>>>>            Send WriteSource ("Set Index_Attribute "+gaAttributes[iAttribute].sName+" "+String(iIndex)+" to "+AttributeSymbolicValue(oAttributeFunctions,iAttribute,sValue))
39555>>>>>>>>>>>            Send OnOperationBegin ("Set_Attribute "+gaAttributes[iAttribute].sName+" index: "+String(iIndex)+" to "+AttributeSymbolicValue(oAttributeFunctions,iAttribute,sValue))
39556>>>>>>>>>>>            Set_Attribute iAttribute of hTable iIndex to sValue
39559>>>>>>>>>>>            Send OnOperationEnd
39560>>>>>>>>>>>        End
39560>>>>>>>>>>>>
39560>>>>>>>>>>>        Else Begin
39561>>>>>>>>>>>            Error 817 "Attribute must be of type index"
39562>>>>>>>>>>>>
39562>>>>>>>>>>>        End
39562>>>>>>>>>>>>
39562>>>>>>>>>>>    End_Procedure
39563>>>>>>>>>>>
39563>>>>>>>>>>>    Function Index_Attribute Integer iAttribute Integer iIndex Returns String
39565>>>>>>>>>>>        Integer hTable iAttrType
39565>>>>>>>>>>>        String sValue
39565>>>>>>>>>>>        Get _phTable to hTable
39566>>>>>>>>>>>        Get AttributeType of oAttributeFunctions iAttribute to iAttrType
39567>>>>>>>>>>>        If (iAttrType=ATYPE_INDEX) Begin
39569>>>>>>>>>>>            Send WriteSource ("Get Index_Attribute "+gaAttributes[iAttribute].sName+" "+String(iIndex)+" to sValue")
39570>>>>>>>>>>>            Send OnOperationBegin ("Get_Attribute "+gaAttributes[iAttribute].sName+" index: "+String(iIndex))
39571>>>>>>>>>>>            Get_Attribute iAttribute of hTable iIndex to sValue
39574>>>>>>>>>>>            Send OnOperationEnd
39575>>>>>>>>>>>        End
39575>>>>>>>>>>>>
39575>>>>>>>>>>>        Else Begin
39576>>>>>>>>>>>            Error 818 "Attribute must be of type index"
39577>>>>>>>>>>>>
39577>>>>>>>>>>>        End
39577>>>>>>>>>>>>
39577>>>>>>>>>>>        Function_Return sValue
39578>>>>>>>>>>>    End_Function
39579>>>>>>>>>>>
39579>>>>>>>>>>>    Procedure Set Index_Segment_Attribute Integer iAttribute Integer iIndex Integer iSegment String sValue
39581>>>>>>>>>>>        Integer hTable iAttrType
39581>>>>>>>>>>>        Get _phTable to hTable
39582>>>>>>>>>>>        Get AttributeType of oAttributeFunctions iAttribute to iAttrType
39583>>>>>>>>>>>        If (iAttrType=ATYPE_IDXSEG) Begin
39585>>>>>>>>>>>            Send WriteSource ("Set Index_Segment_Attribute "+gaAttributes[iAttribute].sName+" "+String(iIndex)+" "+String(iSegment)+" to "+AttributeSymbolicValue(oAttributeFunctions,iAttribute,sValue))
39586>>>>>>>>>>>            Send OnOperationBegin ("Set_Attribute "+gaAttributes[iAttribute].sName+" index: "+String(iIndex)+" segment: "+String(iSegment)+" to "+AttributeSymbolicValue(oAttributeFunctions,iAttribute,sValue))
39587>>>>>>>>>>>            Set_Attribute iAttribute of hTable iIndex iSegment to sValue
39590>>>>>>>>>>>            Send OnOperationEnd
39591>>>>>>>>>>>        End
39591>>>>>>>>>>>>
39591>>>>>>>>>>>        Else Begin
39592>>>>>>>>>>>            Error 819 "Attribute must be of type index-segment"
39593>>>>>>>>>>>>
39593>>>>>>>>>>>        End
39593>>>>>>>>>>>>
39593>>>>>>>>>>>    End_Procedure
39594>>>>>>>>>>>
39594>>>>>>>>>>>    Function Index_Segment_Attribute Integer iAttribute Integer iIndex Integer iSegment Returns String
39596>>>>>>>>>>>        Integer hTable iAttrType
39596>>>>>>>>>>>        String sValue
39596>>>>>>>>>>>        Get _phTable to hTable
39597>>>>>>>>>>>        Get AttributeType of oAttributeFunctions iAttribute to iAttrType
39598>>>>>>>>>>>        If (iAttrType=ATYPE_IDXSEG) Begin
39600>>>>>>>>>>>            Send WriteSource ("Get Index_Segment_Attribute "+gaAttributes[iAttribute].sName+" "+String(iIndex)+" "+String(iSegment)+" to sValue")
39601>>>>>>>>>>>            Send OnOperationBegin ("Get_Attribute "+gaAttributes[iAttribute].sName+" index: "+String(iIndex)+" segment: "+String(iSegment))
39602>>>>>>>>>>>            Get_Attribute iAttribute of hTable iIndex iSegment to sValue
39605>>>>>>>>>>>            Send OnOperationEnd
39606>>>>>>>>>>>        End
39606>>>>>>>>>>>>
39606>>>>>>>>>>>        Else Begin
39607>>>>>>>>>>>            Error 820 "Attribute must be of type index-segment"
39608>>>>>>>>>>>>
39608>>>>>>>>>>>        End
39608>>>>>>>>>>>>
39608>>>>>>>>>>>        Function_Return sValue
39609>>>>>>>>>>>    End_Function
39610>>>>>>>>>>>
39610>>>>>>>>>>>    Function Field_Map String sFieldName Returns Integer
39612>>>>>>>>>>>        Integer hTable iPos
39612>>>>>>>>>>>        Get _phTable to hTable
39613>>>>>>>>>>>        Send Activate of oErrorSilence // We do not want an error message if the field name is not present
39614>>>>>>>>>>>        Field_Map hTable sFieldName to iPos
39616>>>>>>>>>>>        Send Deactivate of oErrorSilence
39617>>>>>>>>>>>        If (ErrorEventCount(oErrorSilence)<>0) Begin
39619>>>>>>>>>>>            Move -1 to iPos
39620>>>>>>>>>>>        End
39620>>>>>>>>>>>>
39620>>>>>>>>>>>        Function_Return iPos
39621>>>>>>>>>>>    End_Function
39622>>>>>>>>>>>
39622>>>>>>>>>>>    Function Append_Field_2 String sColumnName Integer iType Integer iLen Integer iPrecision Returns Integer
39624>>>>>>>>>>>        Integer iPosition
39624>>>>>>>>>>>
39624>>>>>>>>>>>        Send WriteSource ('Get Append_Field_2 "'+sColumnName+'" '+FieldTypeText(oTableAccessFunctions,iType,2)+' '+String(iLen)+' '+String(iPrecision)+' to iPosition')
39625>>>>>>>>>>>
39625>>>>>>>>>>>        Send SuspendWriteSource
39626>>>>>>>>>>>        Get Append_Field to iPosition
39627>>>>>>>>>>>        Set Field_Attribute DF_FIELD_NAME iPosition to sColumnName
39628>>>>>>>>>>>        Set Field_Attribute DF_FIELD_TYPE iPosition to iType
39629>>>>>>>>>>>        If (iType<>DF_DATE) Begin
39631>>>>>>>>>>>            If (iType=DF_BCD) Begin
39633>>>>>>>>>>>                Set Field_Attribute DF_FIELD_LENGTH iPosition to iLen
39634>>>>>>>>>>>            End
39634>>>>>>>>>>>>
39634>>>>>>>>>>>            Else Begin
39635>>>>>>>>>>>                Set Field_Attribute DF_FIELD_LENGTH iPosition to iLen
39636>>>>>>>>>>>            End
39636>>>>>>>>>>>>
39636>>>>>>>>>>>            If (iType=DF_BCD) Begin
39638>>>>>>>>>>>                Set Field_Attribute DF_FIELD_PRECISION iPosition to iPrecision
39639>>>>>>>>>>>            End
39639>>>>>>>>>>>>
39639>>>>>>>>>>>        End
39639>>>>>>>>>>>>
39639>>>>>>>>>>>        Send UnsuspendWriteSource
39640>>>>>>>>>>>        Function_Return iPosition
39641>>>>>>>>>>>    End_Function
39642>>>>>>>>>>>
39642>>>>>>>>>>>    Function Append_Field_3 String sColumnName Integer iType Integer iLen Integer iPrecision Integer iRelFile Integer iRelField Returns Integer
39644>>>>>>>>>>>        Integer iPosition
39644>>>>>>>>>>>
39644>>>>>>>>>>>        Send WriteSource ('Get Append_Field_3 "'+sColumnName+'" '+FieldTypeText(oTableAccessFunctions,iType,2)+' '+String(iLen)+' '+String(iPrecision)+' '+String(iRelFile)+' '+String(iRelField)+' to iPosition')
39645>>>>>>>>>>>
39645>>>>>>>>>>>        Send SuspendWriteSource
39646>>>>>>>>>>>        Get Append_Field to iPosition
39647>>>>>>>>>>>        Set Field_Attribute DF_FIELD_NAME iPosition to sColumnName
39648>>>>>>>>>>>        Set Field_Attribute DF_FIELD_TYPE iPosition to iType
39649>>>>>>>>>>>        If (iType<>DF_DATE) Begin
39651>>>>>>>>>>>            If (iType=DF_BCD) Begin
39653>>>>>>>>>>>                Set Field_Attribute DF_FIELD_LENGTH iPosition to iLen
39654>>>>>>>>>>>            End
39654>>>>>>>>>>>>
39654>>>>>>>>>>>            Else Begin
39655>>>>>>>>>>>                Set Field_Attribute DF_FIELD_LENGTH iPosition to iLen
39656>>>>>>>>>>>            End
39656>>>>>>>>>>>>
39656>>>>>>>>>>>            If (iType=DF_BCD) Begin
39658>>>>>>>>>>>                Set Field_Attribute DF_FIELD_PRECISION iPosition to iPrecision
39659>>>>>>>>>>>            End
39659>>>>>>>>>>>>
39659>>>>>>>>>>>        End
39659>>>>>>>>>>>>
39659>>>>>>>>>>>        If (iRelFile<>0) Begin
39661>>>>>>>>>>>            Set Field_Attribute DF_FIELD_RELATED_FILE iPosition to iRelFile
39662>>>>>>>>>>>            Set Field_Attribute DF_FIELD_RELATED_FIELD iPosition to iRelField
39663>>>>>>>>>>>        End
39663>>>>>>>>>>>>
39663>>>>>>>>>>>        Send UnsuspendWriteSource
39664>>>>>>>>>>>        Function_Return iPosition
39665>>>>>>>>>>>    End_Function
39666>>>>>>>>>>>    
39666>>>>>>>>>>>    Procedure _AppendTableFieldExplicit tTableFieldExplicit strField 
39668>>>>>>>>>>>        Integer iColumn
39668>>>>>>>>>>>        Get Append_Field_3 strField.sName strField.iType strField.iLen strField.iPrecision strField.iRelFile strField.iRelField to iColumn
39669>>>>>>>>>>>//        Set Field_Attribute DF_FIELD_RELATED_FILE iColumn to strField.iRelFile
39669>>>>>>>>>>>//        Set Field_Attribute DF_FIELD_RELATED_FIELD iColumn to strField.iRelField
39669>>>>>>>>>>>    End_Procedure
39670>>>>>>>>>>>
39670>>>>>>>>>>>//    Function Append_Field_2 String sColumnName Integer iType Integer iLen Integer iPrecision Returns Integer
39670>>>>>>>>>>>//    Function Append_Field_3 String sColumnName Integer iType Integer iLen Integer iPrecision Integer iRelFile Integer iRelField Returns Integer
39670>>>>>>>>>>>
39670>>>>>>>>>>>    Procedure _DefineIndexExplicit tTableIndexExplicit strIndex Integer iIndex
39672>>>>>>>>>>>        Integer iSegmentIndex iSegmentMax
39672>>>>>>>>>>>        Move (SizeOfArray(strIndex.aFields)-1) to iSegmentMax
39673>>>>>>>>>>>        If (SizeOfArray(strIndex.aFields)<>0) Begin
39675>>>>>>>>>>>            Send WriteSource ''
39676>>>>>>>>>>>            Send WriteSource ('// Index '+String(iIndex)+":")
39677>>>>>>>>>>>            Send Create_Index iIndex
39678>>>>>>>>>>>            Set Index_Attribute DF_INDEX_NUMBER_SEGMENTS iIndex to iSegmentMax
39679>>>>>>>>>>>            For iSegmentIndex from 1 to iSegmentMax
39685>>>>>>>>>>>>
39685>>>>>>>>>>>                Send WriteSource ''
39686>>>>>>>>>>>                Set Index_Segment_Attribute DF_INDEX_SEGMENT_FIELD iIndex iSegmentIndex to strIndex.aFields[iSegmentIndex]
39687>>>>>>>>>>>                Set Index_Segment_Attribute DF_INDEX_SEGMENT_DIRECTION iIndex iSegmentIndex to (If(strIndex.aDescending[iSegmentIndex],DF_DESCENDING,DF_ASCENDING))
39688>>>>>>>>>>>                Set Index_Segment_Attribute DF_INDEX_SEGMENT_CASE iIndex iSegmentIndex to (If(strIndex.aCaseInsensitive[iSegmentIndex],DF_CASE_IGNORED,DF_CASE_USED))
39689>>>>>>>>>>>            Loop
39690>>>>>>>>>>>>
39690>>>>>>>>>>>            Set Index_Attribute DF_INDEX_TYPE iIndex to strIndex.iType
39691>>>>>>>>>>>        End
39691>>>>>>>>>>>>
39691>>>>>>>>>>>    End_Procedure
39692>>>>>>>>>>>
39692>>>>>>>>>>>        Function _FieldRangeNativeLengthSum Integer iFieldStart Integer iFieldEnd Returns Integer
39694>>>>>>>>>>>            Integer iField iLen iLenSum hTable iType
39694>>>>>>>>>>>            Move 0 to iLenSum
39695>>>>>>>>>>>            Get _phTable to hTable
39696>>>>>>>>>>>            For iField from iFieldStart to iFieldEnd
39702>>>>>>>>>>>>
39702>>>>>>>>>>>                Get_Attribute DF_FIELD_TYPE of hTable iField to iType
39705>>>>>>>>>>>                If (iType<>DF_OVERLAP) Begin
39707>>>>>>>>>>>                    Get_Attribute DF_FIELD_NATIVE_LENGTH of hTable iField to iLen
39710>>>>>>>>>>>                    Move (iLenSum+iLen) to iLenSum
39711>>>>>>>>>>>                End
39711>>>>>>>>>>>>
39711>>>>>>>>>>>            Loop
39712>>>>>>>>>>>>
39712>>>>>>>>>>>            Function_Return iLenSum
39713>>>>>>>>>>>        End_Function
39714>>>>>>>>>>>    
39714>>>>>>>>>>>    Function CreateTableExplicit tTableExplicit strTable String sFolder Returns Boolean
39716>>>>>>>>>>>        Integer iColumnIndex iColumnMax
39716>>>>>>>>>>>        Integer iIndexIndex iIndexMax
39716>>>>>>>>>>>        Integer iOffSet iLength
39716>>>>>>>>>>>        Integer hTable
39716>>>>>>>>>>>        Boolean bSucces
39716>>>>>>>>>>>        String sTableName
39716>>>>>>>>>>>
39716>>>>>>>>>>>        // Prepare root- and physical table names
39716>>>>>>>>>>>        Move strTable.sRootName to sTableName
39717>>>>>>>>>>>        Get TableRootNameStripDriver of oAttributeFunctions sTableName to sTableName
39718>>>>>>>>>>>        Get PathToFileRootName of oFileFunctions sTableName to sTableName
39719>>>>>>>>>>>        Move sTableName to strTable.sRootName
39720>>>>>>>>>>>
39720>>>>>>>>>>>        // We must fork certain parameters to abide with the driver (most notably the embedded database, max records etc...)
39720>>>>>>>>>>>        Get TrimTableDefinitionToDriver of oTableExplicitFunctions (&strTable) to bSucces
39721>>>>>>>>>>>        If (bSucces) Begin
39723>>>>>>>>>>>            If (Structure_Start_New_Table(Self, strTable.sRootName, sFolder, strTable.sDriver)) Begin
39725>>>>>>>>>>>                Set Table_Attribute DF_FILE_MAX_RECORDS to strTable.nMaxRecords
39726>>>>>>>>>>>                Set Table_Attribute DF_FILE_INTEGRITY_CHECK to strTable.iIntegrityCheck
39727>>>>>>>>>>>                Set Table_Attribute DF_FILE_IS_SYSTEM_FILE to (If(strTable.bSystemFile,1,0))
39728>>>>>>>>>>>                Move (SizeOfArray(strTable.aFields)-1) to iColumnMax
39729>>>>>>>>>>>
39729>>>>>>>>>>>                // Create columns
39729>>>>>>>>>>>                For iColumnIndex from 1 to iColumnMax
39735>>>>>>>>>>>>
39735>>>>>>>>>>>                    Send _AppendTableFieldExplicit strTable.aFields[iColumnIndex]
39736>>>>>>>>>>>                Loop
39737>>>>>>>>>>>>
39737>>>>>>>>>>>                
39737>>>>>>>>>>>                // Create indices
39737>>>>>>>>>>>                Move (SizeOfArray(strTable.aIndices)-1) to iIndexMax
39738>>>>>>>>>>>                For iIndexIndex from 1 to iIndexMax
39744>>>>>>>>>>>>
39744>>>>>>>>>>>                    Send _DefineIndexExplicit strTable.aIndices[iIndexIndex] iIndexIndex
39745>>>>>>>>>>>                Loop
39746>>>>>>>>>>>>
39746>>>>>>>>>>>
39746>>>>>>>>>>>                // Update overlap boundaries
39746>>>>>>>>>>>                Get _phTable to hTable
39747>>>>>>>>>>>                For iColumnIndex from 1 to iColumnMax
39753>>>>>>>>>>>>
39753>>>>>>>>>>>                    If (strTable.aFields[iColumnIndex].iType=DF_OVERLAP) Begin
39755>>>>>>>>>>>                        Get_Attribute DF_FIELD_OFFSET of hTable strTable.aFields[iColumnIndex].iOverlapFieldStart to iOffSet
39758>>>>>>>>>>>                        Set Field_Attribute DF_FIELD_OFFSET iColumnIndex to iOffSet
39759>>>>>>>>>>>                        Get _FieldRangeNativeLengthSum strTable.aFields[iColumnIndex].iOverlapFieldStart strTable.aFields[iColumnIndex].iOverlapFieldEnd to iLength
39760>>>>>>>>>>>                        Set Field_Attribute DF_FIELD_LENGTH iColumnIndex to iLength
39761>>>>>>>>>>>                    End
39761>>>>>>>>>>>>
39761>>>>>>>>>>>                Loop
39762>>>>>>>>>>>>
39762>>>>>>>>>>>
39762>>>>>>>>>>>                // Set field main index:
39762>>>>>>>>>>>                For iColumnIndex from 1 to iColumnMax
39768>>>>>>>>>>>>
39768>>>>>>>>>>>                    If (strTable.aFields[iColumnIndex].iMainIndex<>0) Begin
39770>>>>>>>>>>>                        Set Field_Attribute DF_FIELD_INDEX iColumnIndex to strTable.aFields[iColumnIndex].iMainIndex
39771>>>>>>>>>>>                    End
39771>>>>>>>>>>>>
39771>>>>>>>>>>>                Loop
39772>>>>>>>>>>>>
39772>>>>>>>>>>>
39772>>>>>>>>>>>                Get Structure_End to bSucces
39773>>>>>>>>>>>                If (not(bSucces)) Begin
39775>>>>>>>>>>>//                    Error 492 "Structure_End unsuccessful!"
39775>>>>>>>>>>>//                    Send WriteSource '// There were errors during the creation of this table'
39775>>>>>>>>>>>                End
39775>>>>>>>>>>>>
39775>>>>>>>>>>>            End
39775>>>>>>>>>>>>
39775>>>>>>>>>>>            Else Begin
39776>>>>>>>>>>>                Move False to bSucces
39777>>>>>>>>>>>            End
39777>>>>>>>>>>>>
39777>>>>>>>>>>>        End
39777>>>>>>>>>>>>
39777>>>>>>>>>>>        Function_Return bSucces
39778>>>>>>>>>>>    End_Function
39779>>>>>>>>>>>End_Class // cTableStructureFunctions
39780>>>>>>>>>>>
39780>>>>>>>>>>>Object _oTableStructureFunctions is a cTableStructure
39782>>>>>>>>>>>    Move Self to oTableStructureFunctions
39783>>>>>>>>>>>End_Object
39784>>>>>>>>>>>
39784>>>>>>>>>>>
39784>>>>>>>>>Use FileFunctions.pkg // Define oFileFunctions object
39784>>>>>>>>>Use TableAccessFunctions.pkg
39784>>>>>>>>>Use StringFunctions.pkg // Define oStringFunctions object
39784>>>>>>>>>
39784>>>>>>>>>
39784>>>>>>>>>Struct tTempTableDefinitionField
39784>>>>>>>>>    String sName            // Field name
39784>>>>>>>>>    Integer iType           // DF_BCD, DF_ASCII, DF_DATE, DF_TEXT, DF_BINARY, DF_DATETIME
39784>>>>>>>>>    Integer iLen
39784>>>>>>>>>    Integer iPrecision
39784>>>>>>>>>End_Struct
39784>>>>>>>>>
39784>>>>>>>>>Struct tTempTableDefinitionIndex
39784>>>>>>>>>    String sName
39784>>>>>>>>>    Boolean bOnline
39784>>>>>>>>>    Integer[] aFields
39784>>>>>>>>>    Boolean[] aCaseInsensitive
39784>>>>>>>>>    Boolean[] aDescending
39784>>>>>>>>>End_Struct
39784>>>>>>>>>
39784>>>>>>>>>Struct tTempTableDefinition
39784>>>>>>>>>    String sFolder     // Absolute location of table files. If blank, the data folder will be used.
39784>>>>>>>>>    String sSubFolder  // 
39784>>>>>>>>>    String sFileName   // Disk file name of table
39784>>>>>>>>>//    String sTableLongName
39784>>>>>>>>>    Integer iMaxRecords
39784>>>>>>>>>    Boolean bCompression
39784>>>>>>>>>    Boolean bSingleUser
39784>>>>>>>>>//    Integer iDriverId // TA_DRIVER_DATAFLEX TA_DRIVER_PERVASIVE TA_DRIVER_ORACLE TA_DRIVER_MS_SQL TA_DRIVER_DB2 TA_DRIVER_ODBC TA_DRIVER_MS_SQL_DAW TA_DRIVER_MAX
39784>>>>>>>>>    tTempTableDefinitionField[] aFields
39784>>>>>>>>>    tTempTableDefinitionField[] aFields
39784>>>>>>>>>    tTempTableDefinitionIndex[] aIndices
39784>>>>>>>>>    tTempTableDefinitionIndex[] aIndices
39784>>>>>>>>>End_Struct
39784>>>>>>>>>
39784>>>>>>>>>Struct tTempTableIndexSeederSegment
39784>>>>>>>>>    Integer iColumn
39784>>>>>>>>>    String sValue
39784>>>>>>>>>End_Struct
39784>>>>>>>>>
39784>>>>>>>>>Struct tTempTableHandle
39784>>>>>>>>>    String sDiskFileName
39784>>>>>>>>>    Integer hTable
39784>>>>>>>>>    String[] aIndexNames
39784>>>>>>>>>End_Struct
39784>>>>>>>>>
39784>>>>>>>>>Global_Variable Integer oTemporaryTablesFunctions
39784>>>>>>>>>Global_Variable tTempTableIndexSeederSegment[][] _gaTableSeeds
39784>>>>>>>>>
39784>>>>>>>>>Object _oTemporaryTablesFunctions is a cObject
39786>>>>>>>>>    Move Self to oTemporaryTablesFunctions
39787>>>>>>>>>
39787>>>>>>>>>    //> Returns an empty TempTable definition with only a few very basic attributes set.
39787>>>>>>>>>    Function EmptyTempTableDefinition Returns tTempTableDefinition
39790>>>>>>>>>        tTempTableDefinition strRval
39790>>>>>>>>>        tTempTableDefinition strRval
39790>>>>>>>>>        Move 10000 to strRval.iMaxRecords
39791>>>>>>>>>        Move False to strRval.bCompression
39792>>>>>>>>>        Move False to strRval.bSingleUser
39793>>>>>>>>>        Function_Return strRval
39794>>>>>>>>>    End_Function
39795>>>>>>>>>    
39795>>>>>>>>>    Procedure AddColumn tTempTableDefinition ByRef strTempTable String sName Integer iType Integer iLen Integer iPrecision
39798>>>>>>>>>        Integer iFieldIndex
39798>>>>>>>>>        Move (SizeOfArray(strTempTable.aFields)) to iFieldIndex
39799>>>>>>>>>        Move sName to strTempTable.aFields[iFieldIndex].sName
39800>>>>>>>>>        Move iType to strTempTable.aFields[iFieldIndex].iType
39801>>>>>>>>>        Move iLen to strTempTable.aFields[iFieldIndex].iLen
39802>>>>>>>>>        Move iPrecision to strTempTable.aFields[iFieldIndex].iPrecision
39803>>>>>>>>>    End_Procedure
39804>>>>>>>>>    
39804>>>>>>>>>    Procedure AddIndex tTempTableDefinition ByRef strTempTable Boolean bOnline
39807>>>>>>>>>        Integer iIndex
39807>>>>>>>>>        Move (SizeOfArray(strTempTable.aIndices)) to iIndex
39808>>>>>>>>>        If (iIndex=0) Begin
39810>>>>>>>>>            Move 1 to iIndex // First index is index 1. Not index 0.
39811>>>>>>>>>        End
39811>>>>>>>>>>
39811>>>>>>>>>        Move bOnline to strTempTable.aIndices[iIndex].bOnline
39812>>>>>>>>>    End_Procedure
39813>>>>>>>>>    
39813>>>>>>>>>    Procedure Set IndexName tTempTableDefinition ByRef strTempTable String sName
39816>>>>>>>>>        Integer iIndex
39816>>>>>>>>>        Move (SizeOfArray(strTempTable.aIndices)-1) to iIndex
39817>>>>>>>>>        Move sName to strTempTable.aIndices[iIndex].sName
39818>>>>>>>>>    End_Procedure
39819>>>>>>>>>
39819>>>>>>>>>                Function _FindColumnName tTempTableDefinition strTempTable String sName Returns Integer
39822>>>>>>>>>                    Integer iFieldIndex iFieldMax
39822>>>>>>>>>                    Move (Uppercase(sName)) to sName
39823>>>>>>>>>                    If (sName="RECNUM") Function_Return 0
39826>>>>>>>>>                    Move (SizeOfArray(strTempTable.aFields)-1) to iFieldMax
39827>>>>>>>>>                    For iFieldIndex from 0 to iFieldMax
39833>>>>>>>>>>
39833>>>>>>>>>                        If (sName=Uppercase(strTempTable.aFields[iFieldIndex].sName)) Begin
39835>>>>>>>>>                            Function_Return (iFieldIndex+1)
39836>>>>>>>>>                        End
39836>>>>>>>>>>
39836>>>>>>>>>                    Loop
39837>>>>>>>>>>
39837>>>>>>>>>                    Function_Return -1 // Not found
39838>>>>>>>>>                End_Function
39839>>>>>>>>>
39839>>>>>>>>>    Procedure AddIndexSegment tTempTableDefinition ByRef strTempTable String sColumnName Boolean bCaseInSensitive Boolean bDescending
39842>>>>>>>>>        Integer iSegmentIndex iIndex iField
39842>>>>>>>>>        
39842>>>>>>>>>        Get _FindColumnName strTempTable sColumnName to iField
39843>>>>>>>>>        
39843>>>>>>>>>        If (iField>=0) Begin
39845>>>>>>>>>            Move (SizeOfArray(strTempTable.aIndices)-1) to iIndex
39846>>>>>>>>>            Move (SizeOfArray(strTempTable.aIndices[iIndex].aFields)) to iSegmentIndex
39847>>>>>>>>>            Move iField to strTempTable.aIndices[iIndex].aFields[iSegmentIndex]
39848>>>>>>>>>            Move bCaseInSensitive to strTempTable.aIndices[iIndex].aCaseInsensitive[iSegmentIndex]
39849>>>>>>>>>            Move bDescending to strTempTable.aIndices[iIndex].aDescending[iSegmentIndex]
39850>>>>>>>>>        End
39850>>>>>>>>>>
39850>>>>>>>>>        Else Begin
39851>>>>>>>>>            Error 826 "Field not found"
39852>>>>>>>>>>
39852>>>>>>>>>        End
39852>>>>>>>>>>
39852>>>>>>>>>    End_Procedure
39853>>>>>>>>>
39853>>>>>>>>>    Function DropTable tTempTableDefinition strTempTable Boolean bOverWrite Returns Boolean
39856>>>>>>>>>        Integer iRval
39856>>>>>>>>>        String sFolder sTableRoot
39856>>>>>>>>>
39856>>>>>>>>>        Get TablePath strTempTable to sTableRoot
39857>>>>>>>>>
39857>>>>>>>>>        Get DeleteFileNew of oFileFunctions (sTableRoot+".dat") False to iRval
39858>>>>>>>>>        If (iRval=0) Begin
39860>>>>>>>>>            Get DeleteFileNew of oFileFunctions (sTableRoot+".k?") False to iRval
39861>>>>>>>>>        End
39861>>>>>>>>>>
39861>>>>>>>>>        If (iRval=0) Begin
39863>>>>>>>>>            Get DeleteFileNew of oFileFunctions (sTableRoot+".hdr") False to iRval
39864>>>>>>>>>        End
39864>>>>>>>>>>
39864>>>>>>>>>        If (iRval=0) Begin
39866>>>>>>>>>            Get DeleteFileNew of oFileFunctions (sTableRoot+".tag") False to iRval
39867>>>>>>>>>        End
39867>>>>>>>>>>
39867>>>>>>>>>        If (iRval=0) Begin
39869>>>>>>>>>            Get DeleteFileNew of oFileFunctions (sTableRoot+".vld") False to iRval
39870>>>>>>>>>        End
39870>>>>>>>>>>
39870>>>>>>>>>        If (iRval=0) Begin
39872>>>>>>>>>            Get DeleteFileNew of oFileFunctions (sTableRoot+".dat") False to iRval
39873>>>>>>>>>        End
39873>>>>>>>>>>
39873>>>>>>>>>        Function_Return (iRval=0)
39874>>>>>>>>>    End_Function
39875>>>>>>>>>    
39875>>>>>>>>>    //> Create table
39875>>>>>>>>>    Function CreateTable tTempTableDefinition strTempTable Boolean bOverWrite Returns Boolean
39878>>>>>>>>>        Integer iFieldIndex iFieldMax iGrb
39878>>>>>>>>>        Integer iIndexIndex iIndexMax iIndex
39878>>>>>>>>>        Integer iSegmentIndex iSegmentMax iSegment
39878>>>>>>>>>        Boolean bSuccess bOnline
39878>>>>>>>>>        String sFolder
39878>>>>>>>>>        tTempTableDefinitionField strField
39878>>>>>>>>>        tTempTableDefinitionField strField
39878>>>>>>>>>        tTempTableDefinitionIndex strIndex
39878>>>>>>>>>        tTempTableDefinitionIndex strIndex
39878>>>>>>>>>
39878>>>>>>>>>        // Calculate the desired folder:
39878>>>>>>>>>        If (strTempTable.sFolder="") begin
39880>>>>>>>>>            Get VdfFolderPath of oFileFunctions VDF_FILELIST to sFolder
39881>>>>>>>>>        End
39881>>>>>>>>>>
39881>>>>>>>>>        Else Begin
39882>>>>>>>>>            Move strTempTable.sFolder to sFolder
39883>>>>>>>>>        End
39883>>>>>>>>>>
39883>>>>>>>>>
39883>>>>>>>>>        If (strTempTable.sSubFolder<>"") Begin
39885>>>>>>>>>            Get CreateFolderMultiLevel of oFileFunctions sFolder strTempTable.sSubFolder to bSuccess
39886>>>>>>>>>            Get AppendPath of oFileFunctions sFolder strTempTable.sSubFolder to sFolder
39887>>>>>>>>>        End
39887>>>>>>>>>>
39887>>>>>>>>>        Else Begin
39888>>>>>>>>>            Move True to bSuccess
39889>>>>>>>>>            Move strTempTable.sFolder to sFolder
39890>>>>>>>>>        End
39890>>>>>>>>>>
39890>>>>>>>>>
39890>>>>>>>>>        If (bSuccess) Begin
39892>>>>>>>>>            Get Structure_Start_New_Table of oTableStructureFunctions strTempTable.sFileName sFolder "DATAFLEX" to bSuccess
39893>>>>>>>>>            If bSuccess Begin
39895>>>>>>>>>
39895>>>>>>>>>                Set Table_Attribute of oTableStructureFunctions DF_FILE_MAX_RECORDS to strTempTable.iMaxRecords
39896>>>>>>>>>
39896>>>>>>>>>                If (strTempTable.bSingleUser) Begin
39898>>>>>>>>>                    Set Table_Attribute of oTableStructureFunctions DF_FILE_MULTIUSER to DF_FILE_USER_SINGLE
39899>>>>>>>>>                End
39899>>>>>>>>>>
39899>>>>>>>>>                If (strTempTable.bCompression) Begin
39901>>>>>>>>>                    Set Table_Attribute of oTableStructureFunctions DF_FILE_COMPRESSION to DF_FILE_COMPRESS_FAST
39902>>>>>>>>>                End
39902>>>>>>>>>>
39902>>>>>>>>>
39902>>>>>>>>>                // Create fields:
39902>>>>>>>>>                Move (SizeOfArray(strTempTable.aFields)-1) to iFieldMax
39903>>>>>>>>>                For iFieldIndex from 0 to iFieldMax
39909>>>>>>>>>>
39909>>>>>>>>>                    Move strTempTable.aFields[iFieldIndex] to strField
39910>>>>>>>>>                    Get Append_Field_2 of oTableStructureFunctions strField.sName strField.iType strField.iLen strField.iPrecision to iGrb
39911>>>>>>>>>                Loop
39912>>>>>>>>>>
39912>>>>>>>>>
39912>>>>>>>>>                // Create indices:
39912>>>>>>>>>                Move (SizeOfArray(strTempTable.aIndices)-1) to iIndexMax
39913>>>>>>>>>                For iIndexIndex from 1 to iIndexMax
39919>>>>>>>>>>
39919>>>>>>>>>                    Move strTempTable.aIndices[iIndexIndex] to strIndex
39920>>>>>>>>>                    Move (SizeOfArray(strIndex.aFields)-1) to iSegmentMax
39921>>>>>>>>>
39921>>>>>>>>>                    If (iSegmentMax>=0) Begin
39923>>>>>>>>>                        Move iIndexIndex to iIndex
39924>>>>>>>>>                        Send Create_Index of oTableStructureFunctions iIndex
39925>>>>>>>>>                        Move strTempTable.aIndices[iIndexIndex].bOnline to bOnline
39926>>>>>>>>>                        Set Index_Attribute of oTableStructureFunctions DF_INDEX_TYPE iIndex to (If(bOnline,DF_INDEX_TYPE_ONLINE,DF_INDEX_TYPE_BATCH))
39927>>>>>>>>>                        Set Index_Attribute of oTableStructureFunctions DF_INDEX_NUMBER_SEGMENTS iIndex to (iSegmentMax+1)
39928>>>>>>>>>                        For iSegmentIndex from 0 to iSegmentMax
39934>>>>>>>>>>
39934>>>>>>>>>                            Move (iSegmentIndex+1) to iSegment
39935>>>>>>>>>                            Set Index_Segment_Attribute of oTableStructureFunctions DF_INDEX_SEGMENT_FIELD iIndex iSegment to strIndex.aFields[iSegmentIndex]
39936>>>>>>>>>                            Set Index_Segment_Attribute of oTableStructureFunctions DF_INDEX_SEGMENT_CASE iIndex iSegment to (If(strIndex.aCaseInsensitive[iSegmentIndex],DF_CASE_IGNORED,DF_CASE_USED))
39937>>>>>>>>>                            Set Index_Segment_Attribute of oTableStructureFunctions DF_INDEX_SEGMENT_DIRECTION iIndex iSegment to (If(strIndex.aDescending[iSegmentIndex],DF_DESCENDING,DF_ASCENDING))
39938>>>>>>>>>                        Loop
39939>>>>>>>>>>
39939>>>>>>>>>                    End
39939>>>>>>>>>>
39939>>>>>>>>>                Loop
39940>>>>>>>>>>
39940>>>>>>>>>                
39940>>>>>>>>>                // Round it up:
39940>>>>>>>>>                Get Structure_End of oTableStructureFunctions DF_STRUCTEND_OPT_NONE to bSuccess
39941>>>>>>>>>            End
39941>>>>>>>>>>
39941>>>>>>>>>        End
39941>>>>>>>>>>
39941>>>>>>>>>        Function_Return bSuccess
39942>>>>>>>>>    End_Function
39943>>>>>>>>>    
39943>>>>>>>>>    //> Returns path that may be used to open table (... as)
39943>>>>>>>>>    Function TablePath tTempTableDefinition strTempTable Returns String
39946>>>>>>>>>        String sFolder sTablePath
39946>>>>>>>>>        // Calculate the desired folder:
39946>>>>>>>>>        If (strTempTable.sFolder="") Begin
39948>>>>>>>>>            Get VdfFolderPath of oFileFunctions VDF_FILELIST to sFolder
39949>>>>>>>>>        End
39949>>>>>>>>>>
39949>>>>>>>>>        Else Begin
39950>>>>>>>>>            Move strTempTable.sFolder to sFolder
39951>>>>>>>>>        End
39951>>>>>>>>>>
39951>>>>>>>>>        
39951>>>>>>>>>        If (strTempTable.sSubFolder<>"") Begin
39953>>>>>>>>>            Get AppendPath of oFileFunctions sFolder strTempTable.sSubFolder to sFolder
39954>>>>>>>>>        End
39954>>>>>>>>>>
39954>>>>>>>>>        
39954>>>>>>>>>        Get AppendPath of oFileFunctions sFolder strTempTable.sFileName to sTablePath
39955>>>>>>>>>        Get PathStripType of oFileFunctions sTablePath to sTablePath
39956>>>>>>>>>        Function_Return sTablePath
39957>>>>>>>>>    End_Function
39958>>>>>>>>>    
39958>>>>>>>>>    Function OpenTable tTempTableDefinition strTempTable Boolean bExclusive Returns Integer 
39961>>>>>>>>>        Integer iTable iCode
39961>>>>>>>>>
39961>>>>>>>>>        Get TableExists strTempTable to iCode
39962>>>>>>>>>        
39962>>>>>>>>>        If (iCode=0) Begin // Does not exist
39964>>>>>>>>>            Get CreateTableAndOpen strTempTable True bExclusive to iTable
39965>>>>>>>>>        End
39965>>>>>>>>>>
39965>>>>>>>>>        If (iCode=1) Begin // Exists but does not match
39967>>>>>>>>>            Get OpenTableAsAutoHandle of oTableAccessFunctions (TablePath(Self,strTempTable)) (If(bExclusive,DF_EXCLUSIVE,DF_SHARE)) 0 to iTable
39968>>>>>>>>>        End
39968>>>>>>>>>>
39968>>>>>>>>>        If (iCode=2) Begin // Exists and matches the definition
39970>>>>>>>>>            Get OpenTableAsAutoHandle of oTableAccessFunctions (TablePath(Self,strTempTable)) (If(bExclusive,DF_EXCLUSIVE,DF_SHARE)) 0 to iTable
39971>>>>>>>>>        End
39971>>>>>>>>>>
39971>>>>>>>>>        Function_Return iTable
39972>>>>>>>>>    End_Function
39973>>>>>>>>>    
39973>>>>>>>>>    Function CreateTableAndOpen tTempTableDefinition strTempTable Boolean bOverWrite Boolean bExclusive Returns Integer
39976>>>>>>>>>        Integer iTable
39976>>>>>>>>>        Boolean bSuccess
39976>>>>>>>>>        Get CreateTable strTempTable bOverWrite to bSuccess
39977>>>>>>>>>        Move 0 to iTable
39978>>>>>>>>>        If (bSuccess) Begin
39980>>>>>>>>>            Get OpenTableAsAutoHandle of oTableAccessFunctions (TablePath(Self,strTempTable)) (If(bExclusive,DF_EXCLUSIVE,DF_SHARE)) 0 to iTable
39981>>>>>>>>>        End
39981>>>>>>>>>>
39981>>>>>>>>>        Function_Return iTable
39982>>>>>>>>>    End_Function
39983>>>>>>>>>    
39983>>>>>>>>>                Function _CompareTableToDefinitionColumns tTempTableDefinition strTempTable Integer iTable Returns Integer
39986>>>>>>>>>                    Integer iLen iPrec iType
39986>>>>>>>>>                    Integer iColumn iColumns
39986>>>>>>>>>                    Integer iColumnNumber
39986>>>>>>>>>                    Move (SizeOfArray(strTempTable.aFields)-1) to iColumns
39987>>>>>>>>>                    For iColumn from 0 to iColumns
39993>>>>>>>>>>
39993>>>>>>>>>                        Move strTempTable.aFields[iColumn].iPrecision to iPrec
39994>>>>>>>>>                        Get FieldNameToNumber of oTableAccessFunctions iTable strTempTable.aFields[iColumn].sName to iColumnNumber
39995>>>>>>>>>                        If (iColumnNumber=-1) Function_Return 1 // Missing column
39998>>>>>>>>>                        Get_Attribute DF_FIELD_TYPE of iTable iColumnNumber to iType
40001>>>>>>>>>                        If (iType<>strTempTable.aFields[iColumn].iType) Function_Return 2 // Column type mismatch
40004>>>>>>>>>                        Get_Attribute DF_FIELD_LENGTH of iTable iColumnNumber to iLen
40007>>>>>>>>>                        If (iLen<strTempTable.aFields[iColumn].iLen) Function_Return 3 // Column length mismatch
40010>>>>>>>>>                        Get_Attribute DF_FIELD_PRECISION of iTable iColumnNumber to iPrec
40013>>>>>>>>>                        If (iPrec<strTempTable.aFields[iColumn].iPrecision) Function_Return 4 // Column precision mismatch
40016>>>>>>>>>                    Loop
40017>>>>>>>>>>
40017>>>>>>>>>                    Function_Return 0 // Columns are defined
40018>>>>>>>>>                End_Function
40019>>>>>>>>>                    
40019>>>>>>>>>                Function _CompareTableToDefinitionIndices tTempTableDefinition strTempTable Integer iTable Returns Integer
40022>>>>>>>>>                    Integer iIndex iIndices
40022>>>>>>>>>                    Move (SizeOfArray(strTempTable.aIndices)-1) to iIndices
40023>>>>>>>>>                    For iIndex from 0 to iIndices
40029>>>>>>>>>>
40029>>>>>>>>>                        // Unfinished!
40029>>>>>>>>>                    Loop
40030>>>>>>>>>>
40030>>>>>>>>>                    Function_Return 0 // Indices are defined
40031>>>>>>>>>                End_Function
40032>>>>>>>>>                
40032>>>>>>>>>        Function _CompareTableToDefinition tTempTableDefinition strTempTable Integer iTable Returns Integer
40035>>>>>>>>>            Integer iError
40035>>>>>>>>>            Get _CompareTableToDefinitionColumns strTempTable iTable to iError
40036>>>>>>>>>            If (iError=0) Begin
40038>>>>>>>>>                Get _CompareTableToDefinitionIndices strTempTable iTable to iError
40039>>>>>>>>>            End
40039>>>>>>>>>>
40039>>>>>>>>>            Function_Return iError
40040>>>>>>>>>        End_Function
40041>>>>>>>>>
40041>>>>>>>>>    //> Returns  2: Exists and matches the definition.  1: Exists but does not match  0: Does not exist
40041>>>>>>>>>    Function TableExists tTempTableDefinition strTempTable Returns Integer
40044>>>>>>>>>        Integer iTable iError iRval
40044>>>>>>>>>        Get OpenTableAsAutoHandle of oTableAccessFunctions (TablePath(Self,strTempTable)) DF_SHARE 0 to iTable
40045>>>>>>>>>        If (iTable>0) Begin
40047>>>>>>>>>            Get _CompareTableToDefinition strTempTable iTable to iError
40048>>>>>>>>>            If (iError=0) Begin
40050>>>>>>>>>                Move 2 to iRval // Table exists and matches definition
40051>>>>>>>>>            End
40051>>>>>>>>>>
40051>>>>>>>>>            Else Begin
40052>>>>>>>>>                Move 1 to iRval // Table exists but does not match definition
40053>>>>>>>>>            End
40053>>>>>>>>>>
40053>>>>>>>>>            Close iTable
40054>>>>>>>>>        End
40054>>>>>>>>>>
40054>>>>>>>>>        Else Begin
40055>>>>>>>>>            Move 0 to iRval // Table does not exist
40056>>>>>>>>>        End
40056>>>>>>>>>>
40056>>>>>>>>>        Function_Return iRval
40057>>>>>>>>>    End_Function
40058>>>>>>>>>    
40058>>>>>>>>>    // This function creates a tTempTableDefinition value that resembles the one handed over in the
40058>>>>>>>>>    // strTableAttributes parameter. We say 'resembles' because a number of details are lost in the
40058>>>>>>>>>    // transformation (such as specific numbering of indices, overlaps makes no sense)
40058>>>>>>>>>    Function AttributesToTempTableDefinition tTableAttributes strTableAttributes Returns tTempTableDefinition
40061>>>>>>>>>        Integer iTable iRecords
40061>>>>>>>>>        Integer iColumn iColumns
40061>>>>>>>>>        Integer iIndex iIndices
40061>>>>>>>>>        Integer iSegment iSegments
40061>>>>>>>>>        Integer iColumnType iColumnLength iColumnPrecision
40061>>>>>>>>>        Integer iIndexColumn 
40061>>>>>>>>>        Boolean bCaseSense bDescending
40061>>>>>>>>>        String sColumnName
40061>>>>>>>>>        tTableAttributes[] aTables
40061>>>>>>>>>        tTableAttributes[] aTables
40062>>>>>>>>>        tTempTableDefinition strTableDefinition
40062>>>>>>>>>        tTempTableDefinition strTableDefinition
40062>>>>>>>>>        
40062>>>>>>>>>        // This we (irritatingly) have to do to be able to use the TableAttribute function
40062>>>>>>>>>        // of oAttributeFunctions for querying the strTableAttributes parameter:
40062>>>>>>>>>        Move strTableAttributes.iReadFromFileListEntryNo to iTable
40063>>>>>>>>>        Move strTableAttributes to aTables[0]
40064>>>>>>>>>
40064>>>>>>>>>        Get EmptyTempTableDefinition to strTableDefinition
40065>>>>>>>>>        Get TableAttribute of oAttributeFunctions aTables DF_FILE_MAX_RECORDS iTable 0 0 to strTableDefinition.iMaxRecords
40066>>>>>>>>>        
40066>>>>>>>>>        // Add columns:
40066>>>>>>>>>        Get TableAttribute of oAttributeFunctions aTables DF_FILE_NUMBER_FIELDS iTable 0 0 to iColumns
40067>>>>>>>>>        For iColumn from 1 to iColumns
40073>>>>>>>>>>
40073>>>>>>>>>            Get TableAttribute of oAttributeFunctions aTables DF_FIELD_NAME iTable iColumn 0 0 to sColumnName
40074>>>>>>>>>            Get TableAttribute of oAttributeFunctions aTables DF_FIELD_TYPE iTable iColumn 0 0 to iColumnType     
40075>>>>>>>>>            Get TableAttribute of oAttributeFunctions aTables DF_FIELD_LENGTH iTable iColumn 0 0 to iColumnLength   
40076>>>>>>>>>            Get TableAttribute of oAttributeFunctions aTables DF_FIELD_PRECISION iTable iColumn 0 0 to iColumnPrecision
40077>>>>>>>>>            If (iColumnType<>DF_OVERLAP) Begin
40079>>>>>>>>>                Send AddColumn (&strTableDefinition) sColumnName iColumnType iColumnLength iColumnPrecision
40080>>>>>>>>>            End
40080>>>>>>>>>>
40080>>>>>>>>>        Loop
40081>>>>>>>>>>
40081>>>>>>>>>        
40081>>>>>>>>>        // Add indices:
40081>>>>>>>>>        Get TableAttribute of oAttributeFunctions aTables DF_FILE_LAST_INDEX_NUMBER iTable 0 0 to iIndices
40082>>>>>>>>>        For iIndex from 1 to iIndices
40088>>>>>>>>>>
40088>>>>>>>>>            Get TableAttribute of oAttributeFunctions aTables DF_INDEX_NUMBER_SEGMENTS iTable iIndex 0 to iSegments
40089>>>>>>>>>            If (iSegments<>0) Begin
40091>>>>>>>>>                Send AddIndex (&strTableDefinition) True
40092>>>>>>>>>                For iSegment from 1 to iSegments
40098>>>>>>>>>>
40098>>>>>>>>>                    Get TableAttribute of oAttributeFunctions aTables DF_INDEX_SEGMENT_FIELD iTable iIndex iSegment to iIndexColumn
40099>>>>>>>>>                    Get TableAttribute of oAttributeFunctions aTables DF_INDEX_SEGMENT_CASE iTable iIndex iSegment to bCaseSense
40100>>>>>>>>>                    Move (Integer(TableAttribute(oAttributeFunctions,aTables,DF_INDEX_SEGMENT_CASE,iTable,iIndex,iSegment))=DF_CASE_USED) to bCaseSense
40101>>>>>>>>>                    Move (Integer(TableAttribute(oAttributeFunctions,aTables,DF_INDEX_SEGMENT_DIRECTION,iTable,iIndex,iSegment))=DF_DESCENDING) to bDescending
40102>>>>>>>>>                    Get TableAttribute of oAttributeFunctions aTables DF_FIELD_NAME iTable iIndexColumn 0 0 to sColumnName
40103>>>>>>>>>                    Send AddIndexSegment (&strTableDefinition) sColumnName (not(bCaseSense)) bDescending
40104>>>>>>>>>                Loop
40105>>>>>>>>>>
40105>>>>>>>>>            End
40105>>>>>>>>>>
40105>>>>>>>>>        Loop
40106>>>>>>>>>>
40106>>>>>>>>>        
40106>>>>>>>>>        Function_Return strTableDefinition
40107>>>>>>>>>    End_Function
40108>>>>>>>>>    
40108>>>>>>>>>    Function ValidateTempTableHandles tTempTableHandle[] aTableHandles Returns Boolean
40111>>>>>>>>>        Integer iIndex iMax iTable
40111>>>>>>>>>        
40111>>>>>>>>>        Move (SizeOfArray(aTableHandles)-1) to iMax
40112>>>>>>>>>        For iIndex from 0 to iMax
40118>>>>>>>>>>
40118>>>>>>>>>            Move aTableHandles[iIndex].hTable to iTable
40119>>>>>>>>>            If (iTable<=0) Begin
40121>>>>>>>>>                Function_Return False
40122>>>>>>>>>            End
40122>>>>>>>>>>
40122>>>>>>>>>        Loop
40123>>>>>>>>>>
40123>>>>>>>>>        Function_Return True
40124>>>>>>>>>    End_Function
40125>>>>>>>>>
40125>>>>>>>>>    Function OpenTemporaryTables tTempTableDefinition[] aTables Boolean bExclusive Returns tTempTableHandle[]
40128>>>>>>>>>        Integer iTableIndex iTableMax iTable
40128>>>>>>>>>        Integer iIndexIndex iIndexMax 
40128>>>>>>>>>        tTempTableHandle[] aTableHandles aEmpty
40128>>>>>>>>>        tTempTableHandle[] aTableHandles aEmpty
40130>>>>>>>>>        
40130>>>>>>>>>        Move (SizeOfArray(aTables)-1) to iTableMax
40131>>>>>>>>>        For iTableIndex from 0 to iTableMax
40137>>>>>>>>>>
40137>>>>>>>>>            Get OpenTable aTables[iTableIndex] bExclusive to iTable
40138>>>>>>>>>            Move iTable to aTableHandles[iTableIndex].hTable
40139>>>>>>>>>            Move aTables[iTableIndex].sFileName to aTableHandles[iTableIndex].sDiskFileName
40140>>>>>>>>>            // Copy index names to tTempTableHandle
40140>>>>>>>>>            Move (SizeOfArray(aTables[iTableIndex].aIndices)-1) to iIndexMax
40141>>>>>>>>>            For iIndexIndex from 0 to iIndexMax
40147>>>>>>>>>>
40147>>>>>>>>>                Move aTables[iTableIndex].aIndices[iIndexIndex].sName to aTableHandles[iTableIndex].aIndexNames[iIndexIndex]
40148>>>>>>>>>            Loop
40149>>>>>>>>>>
40149>>>>>>>>>        Loop
40150>>>>>>>>>>
40150>>>>>>>>>        
40150>>>>>>>>>        If (not(ValidateTempTableHandles(Self,aTableHandles))) Begin
40152>>>>>>>>>            Send CloseTemporaryTables aTableHandles
40153>>>>>>>>>            Move aEmpty to aTableHandles // Empty return value signals "error" to the caller
40154>>>>>>>>>        End
40154>>>>>>>>>>
40154>>>>>>>>>        
40154>>>>>>>>>        Function_Return aTableHandles
40155>>>>>>>>>    End_Function
40156>>>>>>>>>    
40156>>>>>>>>>    Procedure CloseTemporaryTables tTempTableHandle[] aTableHandles
40159>>>>>>>>>        Integer iIndex iMax iTable
40159>>>>>>>>>        
40159>>>>>>>>>        Move (SizeOfArray(aTableHandles)-1) to iMax
40160>>>>>>>>>        For iIndex from 0 to iMax
40166>>>>>>>>>>
40166>>>>>>>>>            Move aTableHandles[iIndex].hTable to iTable
40167>>>>>>>>>            If (iTable>0) Begin
40169>>>>>>>>>                Close iTable
40170>>>>>>>>>            End
40170>>>>>>>>>>
40170>>>>>>>>>        Loop
40171>>>>>>>>>>
40171>>>>>>>>>    End_Procedure
40172>>>>>>>>>    
40172>>>>>>>>>End_Object // _oTemporaryTablesFunctions
40173>>>>>>>>>
40173>>>>>>>>>Class cTemporaryTablesHandler is a cObject
40174>>>>>>>>>    Procedure Construct_Object
40176>>>>>>>>>        Forward Send Construct_Object
40178>>>>>>>>>        Property tTempTableDefinition[] paTableDefinitions
40179>>>>>>>>>        Property tTempTableHandle[] _paTableHandles
40180>>>>>>>>>    End_Procedure
40181>>>>>>>>>    
40181>>>>>>>>>    Function OpenTables Boolean bExclusive Returns Boolean
40183>>>>>>>>>        tTempTableHandle[] aTableHandles
40183>>>>>>>>>        tTempTableHandle[] aTableHandles
40184>>>>>>>>>        tTempTableDefinition[] aTables
40184>>>>>>>>>        tTempTableDefinition[] aTables
40185>>>>>>>>>        Get paTableDefinitions to aTables
40186>>>>>>>>>        Get OpenTemporaryTables of oTemporaryTablesFunctions aTables bExclusive to aTableHandles
40187>>>>>>>>>        Set _paTableHandles to aTableHandles
40188>>>>>>>>>        Function_Return (SizeOfArray(aTableHandles)>0)
40189>>>>>>>>>    End_Function
40190>>>>>>>>>    
40190>>>>>>>>>    Procedure CloseTables
40192>>>>>>>>>        tTempTableHandle[] aTableHandles aEmpty
40192>>>>>>>>>        tTempTableHandle[] aTableHandles aEmpty
40194>>>>>>>>>        Get _paTableHandles to aTableHandles
40195>>>>>>>>>        Send CloseTemporaryTables of oTemporaryTablesFunctions aTableHandles
40196>>>>>>>>>        Set _paTableHandles to aEmpty
40197>>>>>>>>>    End_Procedure
40198>>>>>>>>>
40198>>>>>>>>>
40198>>>>>>>>>            Function _FindTable String sTable Integer ByRef iTable Boolean bQuietOnError Returns Boolean
40200>>>>>>>>>                Integer iIndex iMax
40200>>>>>>>>>                tTempTableHandle[] aTableHandles
40200>>>>>>>>>                tTempTableHandle[] aTableHandles
40201>>>>>>>>>
40201>>>>>>>>>                Get _paTableHandles to aTableHandles
40202>>>>>>>>>                Move 0 to iTable
40203>>>>>>>>>                
40203>>>>>>>>>                Move (SizeOfArray(aTableHandles)-1) to iMax
40204>>>>>>>>>                For iIndex from 0 to iMax 
40210>>>>>>>>>>
40210>>>>>>>>>                    If (Uppercase(sTable)=Uppercase(aTableHandles[iIndex].sDiskFileName)) Begin
40212>>>>>>>>>                        Move aTableHandles[iIndex].hTable to iTable
40213>>>>>>>>>                        Function_Return True 
40214>>>>>>>>>                    End
40214>>>>>>>>>>
40214>>>>>>>>>                Loop
40215>>>>>>>>>>
40215>>>>>>>>>                If (bQuietOnError) Begin
40217>>>>>>>>>                    Error 424 ("Table-name not recognized ("+sTable+")")
40218>>>>>>>>>>
40218>>>>>>>>>                End
40218>>>>>>>>>>
40218>>>>>>>>>                Function_Return False
40219>>>>>>>>>            End_Function
40220>>>>>>>>>
40220>>>>>>>>>            Function _FindTableAndIndex String sTable String sIndex Integer ByRef iTable Integer ByRef iIndex Boolean bQuietOnError Returns Boolean
40222>>>>>>>>>                Integer iHandleIndex iHandleMax
40222>>>>>>>>>                Integer iIndexIndex iIndexMax
40222>>>>>>>>>                tTempTableHandle[] aTableHandles
40222>>>>>>>>>                tTempTableHandle[] aTableHandles
40223>>>>>>>>>                                    
40223>>>>>>>>>                Get _paTableHandles to aTableHandles
40224>>>>>>>>>                Move 0 to iTable
40225>>>>>>>>>                Move 0 to iIndex
40226>>>>>>>>>                
40226>>>>>>>>>                Move (SizeOfArray(aTableHandles)-1) to iHandleMax
40227>>>>>>>>>                For iHandleIndex from 0 to iHandleMax 
40233>>>>>>>>>>
40233>>>>>>>>>                    If (Uppercase(sTable)=Uppercase(aTableHandles[iHandleIndex].sDiskFileName)) Begin
40235>>>>>>>>>                        Move aTableHandles[iHandleIndex].hTable to iTable
40236>>>>>>>>>
40236>>>>>>>>>                        // If sIndex is an integer we take it for an index number
40236>>>>>>>>>                        If (IsInteger(oStringFunctions,sIndex)) Begin
40238>>>>>>>>>                            Move sIndex to iIndex
40239>>>>>>>>>                            Function_Return True
40240>>>>>>>>>                        End
40240>>>>>>>>>>
40240>>>>>>>>>                        
40240>>>>>>>>>                        // Else it must be an index name and we must look for it:
40240>>>>>>>>>                        Move (Lowercase(sIndex)) to sIndex
40241>>>>>>>>>                        Move (SizeOfArray(aTableHandles[iHandleIndex].aIndexNames)-1) to iIndexMax
40242>>>>>>>>>                        For iIndexIndex from 0 to iIndexMax
40248>>>>>>>>>>
40248>>>>>>>>>                            If (sIndex=aTableHandles[iHandleIndex].aIndexNames[iIndexIndex]) Begin
40250>>>>>>>>>                                Move iIndexIndex to iIndex
40251>>>>>>>>>                                Function_Return True
40252>>>>>>>>>                            End
40252>>>>>>>>>>
40252>>>>>>>>>                        Loop
40253>>>>>>>>>>
40253>>>>>>>>>                        
40253>>>>>>>>>                        If (not(bQuietOnError)) Begin
40255>>>>>>>>>                            Error 424 ("Table index not found ("+sTable+", index: "+sIndex+")")
40256>>>>>>>>>>
40256>>>>>>>>>                        End
40256>>>>>>>>>>
40256>>>>>>>>>                        Function_Return False // No sense in going through the rest of the tables,
40257>>>>>>>>>                    End
40257>>>>>>>>>>
40257>>>>>>>>>                Loop
40258>>>>>>>>>>
40258>>>>>>>>>                If (not(bQuietOnError)) Begin
40260>>>>>>>>>                    Error 425 ("Table index not found ("+sTable+", index: "+sIndex+")")
40261>>>>>>>>>>
40261>>>>>>>>>                End
40261>>>>>>>>>>
40261>>>>>>>>>                Function_Return False
40262>>>>>>>>>            End_Function
40263>>>>>>>>>    
40263>>>>>>>>>            Function _FindTableAndColumn String sTable String sColumn Integer ByRef iTable Integer ByRef iColumn Boolean bQuietOnError Returns Boolean
40265>>>>>>>>>                Integer iIndex iMax
40265>>>>>>>>>                tTempTableHandle[] aTableHandles
40265>>>>>>>>>                tTempTableHandle[] aTableHandles
40266>>>>>>>>>                                    
40266>>>>>>>>>                Get _paTableHandles to aTableHandles
40267>>>>>>>>>                Move 0 to iTable
40268>>>>>>>>>                Move 0 to iColumn
40269>>>>>>>>>                
40269>>>>>>>>>                Move (SizeOfArray(aTableHandles)-1) to iMax
40270>>>>>>>>>                For iIndex from 0 to iMax 
40276>>>>>>>>>>
40276>>>>>>>>>                    If (Uppercase(sTable)=Uppercase(aTableHandles[iIndex].sDiskFileName)) Begin
40278>>>>>>>>>                        Move aTableHandles[iIndex].hTable to iTable
40279>>>>>>>>>                        Get FieldNameToNumber of oTableAccessFunctions iTable sColumn to iColumn
40280>>>>>>>>>                        If (iColumn>=0) Begin
40282>>>>>>>>>                            Function_Return True
40283>>>>>>>>>                        End
40283>>>>>>>>>>
40283>>>>>>>>>                        If (not(bQuietOnError)) Begin
40285>>>>>>>>>                            Error 422 ("Table column not found ("+sTable+"."+sColumn+")")
40286>>>>>>>>>>
40286>>>>>>>>>                        End
40286>>>>>>>>>>
40286>>>>>>>>>                        Function_Return False // No sense in going through the rest of the tables,
40287>>>>>>>>>                    End
40287>>>>>>>>>>
40287>>>>>>>>>                Loop
40288>>>>>>>>>>
40288>>>>>>>>>                If (not(bQuietOnError)) Begin
40290>>>>>>>>>                    Error 423 ("Table column not found ("+sTable+"."+sColumn+")")
40291>>>>>>>>>>
40291>>>>>>>>>                End
40291>>>>>>>>>>
40291>>>>>>>>>                Function_Return False
40292>>>>>>>>>            End_Function
40293>>>>>>>>>            
40293>>>>>>>>>    Procedure Set Column_Value String sTable String sColumn String sValue
40295>>>>>>>>>        Integer iTable iColumn
40295>>>>>>>>>        If (_FindTableAndColumn(Self,sTable,sColumn,&iTable,&iColumn,False)) Begin
40297>>>>>>>>>            Set_Field_Value iTable iColumn to sValue
40300>>>>>>>>>        End
40300>>>>>>>>>>
40300>>>>>>>>>    End_Procedure
40301>>>>>>>>>    
40301>>>>>>>>>    Function Column_Value String sTable String sColumn Returns String
40303>>>>>>>>>        Integer iTable iColumn
40303>>>>>>>>>        String sRval
40303>>>>>>>>>        If (_FindTableAndColumn(Self,sTable,sColumn,&iTable,&iColumn,False)) Begin
40305>>>>>>>>>            Get_Field_Value iTable iColumn to sRval
40308>>>>>>>>>        End
40308>>>>>>>>>>
40308>>>>>>>>>        Else Begin
40309>>>>>>>>>            Move "" to sRval
40310>>>>>>>>>        End
40310>>>>>>>>>>
40310>>>>>>>>>        Function_Return (Rtrim(sRval))
40311>>>>>>>>>    End_Function
40312>>>>>>>>>    
40312>>>>>>>>>    Procedure SaveRecord String sTable
40314>>>>>>>>>        Integer iTable
40314>>>>>>>>>        If (_FindTable(Self,sTable,&iTable,False)) Begin
40316>>>>>>>>>            SaveRecord iTable
40317>>>>>>>>>        End
40317>>>>>>>>>>
40317>>>>>>>>>    End_Procedure
40318>>>>>>>>>    
40318>>>>>>>>>    Procedure Clear String sTable
40320>>>>>>>>>        Integer iTable
40320>>>>>>>>>        If (_FindTable(Self,sTable,&iTable,False)) Begin
40322>>>>>>>>>            Clear iTable
40323>>>>>>>>>            // Clear all preseeding seeds:
40323>>>>>>>>>            If (SizeOfArray(_gaTableSeeds)>iTable) Begin
40325>>>>>>>>>                Move (ResizeArray(_gaTableSeeds[iTable],0)) to _gaTableSeeds[iTable]
40326>>>>>>>>>            End
40326>>>>>>>>>>
40326>>>>>>>>>        End
40326>>>>>>>>>>
40326>>>>>>>>>    End_Procedure
40327>>>>>>>>>    
40327>>>>>>>>>    Procedure DeleteString String sTable
40329>>>>>>>>>        Integer iTable
40329>>>>>>>>>        If (_FindTable(Self,sTable,&iTable,False)) Begin
40331>>>>>>>>>            Delete iTable
40332>>>>>>>>>        End
40332>>>>>>>>>>
40332>>>>>>>>>    End_Procedure
40333>>>>>>>>>    
40333>>>>>>>>>    Procedure SeedIndex String sTable String sColumn String sValue
40335>>>>>>>>>        Integer iTable iColumn iSegment
40335>>>>>>>>>        If (_FindTableAndColumn(Self,sTable,sColumn,&iTable,&iColumn,False)) Begin
40337>>>>>>>>>            If (SizeOfArray(_gaTableSeeds)>iTable) Begin
40339>>>>>>>>>                Move (SizeOfArray(_gaTableSeeds[iTable])) to iSegment
40340>>>>>>>>>            End
40340>>>>>>>>>>
40340>>>>>>>>>            Else Begin
40341>>>>>>>>>                Move 0 to iSegment
40342>>>>>>>>>            End
40342>>>>>>>>>>
40342>>>>>>>>>            Move iColumn to _gaTableSeeds[iTable][iSegment].iColumn
40343>>>>>>>>>            Move sValue to _gaTableSeeds[iTable][iSegment].sValue
40344>>>>>>>>>            Set_Field_Value iTable iColumn to sValue
40347>>>>>>>>>        End
40347>>>>>>>>>>
40347>>>>>>>>>    End_Procedure
40348>>>>>>>>>    
40348>>>>>>>>>    Function Find String sTable String sIndex Integer iMode Boolean bConstrained Returns Boolean
40350>>>>>>>>>        Boolean bFound
40350>>>>>>>>>        Integer iTable iIndex
40350>>>>>>>>>        Integer iSegmentIndex iSegmentMax
40350>>>>>>>>>        Integer iColumn iType
40350>>>>>>>>>        String sValue
40350>>>>>>>>>        If (_FindTableAndIndex(Self,sTable,sIndex,&iTable,&iIndex,False)) Begin
40352>>>>>>>>>            Vfind iTable iIndex iMode
40354>>>>>>>>>            Move (Found) to bFound
40355>>>>>>>>>            If (bFound and bConstrained) Begin
40357>>>>>>>>>                // Check that seeded values are identical with the record found:
40357>>>>>>>>>                Move (SizeOfArray(_gaTableSeeds[iTable])-1) to iSegmentMax
40358>>>>>>>>>                For iSegmentIndex from 0 to iSegmentMax
40364>>>>>>>>>>
40364>>>>>>>>>                    Move _gaTableSeeds[iTable][iSegmentIndex].iColumn to iColumn
40365>>>>>>>>>                    Get_Field_Value iTable iColumn to sValue
40368>>>>>>>>>                    Get_Attribute DF_FIELD_TYPE of iTable iColumn to iType
40371>>>>>>>>>                    If (iType=DF_ASCII) Begin
40373>>>>>>>>>                        Move (_gaTableSeeds[iTable][iSegmentIndex].sValue=sValue) to bFound
40374>>>>>>>>>                    End
40374>>>>>>>>>>
40374>>>>>>>>>                    Else If (iType=DF_BCD) Begin
40377>>>>>>>>>                        Move (Number(_gaTableSeeds[iTable][iSegmentIndex].sValue)=Number(sValue)) to bFound
40378>>>>>>>>>                    End
40378>>>>>>>>>>
40378>>>>>>>>>                    Else If (iType=DF_DATE) Begin
40381>>>>>>>>>                        Move (Date(_gaTableSeeds[iTable][iSegmentIndex].sValue)=Date(sValue)) to bFound
40382>>>>>>>>>                    End
40382>>>>>>>>>>
40382>>>>>>>>>                    Else Begin
40383>>>>>>>>>                        Error 426 "Find was seeded by a TEXT or BINARY field"
40384>>>>>>>>>>
40384>>>>>>>>>                    End
40384>>>>>>>>>>
40384>>>>>>>>>                Loop
40385>>>>>>>>>>
40385>>>>>>>>>            End
40385>>>>>>>>>>
40385>>>>>>>>>            Function_Return (bFound)
40386>>>>>>>>>        End
40386>>>>>>>>>>
40386>>>>>>>>>        Function_Return False
40387>>>>>>>>>    End_Function
40388>>>>>>>>>End_Class
40389>>>>>>>>>
40389>>>>>>>>>
40389>>>>>>>>>//Procedure TestrTempTable
40389>>>>>>>>>//    tTempTableDefinition stDef
40389>>>>>>>>>//    Get EmptyTempTableDefinition of oTemporaryTablesFunctions to stDef
40389>>>>>>>>>//
40389>>>>>>>>>//    Move 200000 to stDef.iMaxRecords
40389>>>>>>>>>//    Move "badseeds" to stDef.sFileName
40389>>>>>>>>>//    Move "" to stDef.sFolder // blank means it goes in the data folder
40389>>>>>>>>>//    Move "test" to stDef.sSubFolder // means it goes in a subfolder of the data folder called test
40389>>>>>>>>>//    
40389>>>>>>>>>//    Send AddColumn of oTemporaryTablesFunctions (&stDef) "FirstName"   DF_ASCII 20 0  // field no 1
40389>>>>>>>>>//    Send AddColumn of oTemporaryTablesFunctions (&stDef) "LastName"    DF_ASCII 20 0  // field no 2
40389>>>>>>>>>//    Send AddColumn of oTemporaryTablesFunctions (&stDef) "Address"     DF_TEXT 256 0  // field no 3
40389>>>>>>>>>//    Send AddColumn of oTemporaryTablesFunctions (&stDef) "DateOfBirth" DF_DATE 0 0    // field no 4
40389>>>>>>>>>//    Send AddColumn of oTemporaryTablesFunctions (&stDef) "ArrestCount" DF_BCD 4 0     // field no 5
40389>>>>>>>>>//    Send AddColumn of oTemporaryTablesFunctions (&stDef) "HighestPct"  DF_BCD 4 2     // field no 6
40389>>>>>>>>>//    
40389>>>>>>>>>//    Send AddIndex of oTemporaryTablesFunctions (&stDef) True
40389>>>>>>>>>//    Send AddIndexSegment of oTemporaryTablesFunctions (&stDef) "FirstName" True False // FirstName
40389>>>>>>>>>//    Send AddIndexSegment of oTemporaryTablesFunctions (&stDef) "LastName"  True False // LastName
40389>>>>>>>>>//    
40389>>>>>>>>>//    Send AddIndex of oTemporaryTablesFunctions (&stDef) True
40389>>>>>>>>>//    Send AddIndexSegment of oTemporaryTablesFunctions (&stDef) "DateOfBirth" False False // DateOfBirth
40389>>>>>>>>>//    Send AddIndexSegment of oTemporaryTablesFunctions (&stDef) "Recnum"      False False // Recnum
40389>>>>>>>>>//    
40389>>>>>>>>>//    Send AddIndex of oTemporaryTablesFunctions (&stDef) True
40389>>>>>>>>>//    Send AddIndexSegment of oTemporaryTablesFunctions (&stDef) "HighestPct"  False True // HighestPct
40389>>>>>>>>>//    Send AddIndexSegment of oTemporaryTablesFunctions (&stDef) "ArrestCount" False True // ArrestCount
40389>>>>>>>>>//    
40389>>>>>>>>>//    If (CreateTable(oTemporaryTablesFunctions,stDef,True)) Begin
40389>>>>>>>>>//        Showln "Success"
40389>>>>>>>>>//    End
40389>>>>>>>>>//    Else Begin
40389>>>>>>>>>//        Showln "Failure"
40389>>>>>>>>>//    End
40389>>>>>>>>>//End_Procedure
40389>>>>>>>Use WindowsInfo.pkg
40389>>>>>>>Use SQLStatementHandles.pkg
Including file: SQLStatementHandles.pkg    (Z:\VmShare\Projects\WebQuery18-0\StureApsPublicLib\AppSrc\SQLStatementHandles.pkg)
40389>>>>>>>>>// SQLStatementHandles.pkg // StureApsPublicLib
40389>>>>>>>>>//
40389>>>>>>>>>// A SQL connection can execute one SQL statement at a time. It can generate
40389>>>>>>>>>// multiple statements but only one may execute at any given time.
40389>>>>>>>>>//
40389>>>>>>>>>// If you need to be able to execute multiple SQL statements simultaneously
40389>>>>>>>>>// you need to create a new connection and this is an un-welcome complication
40389>>>>>>>>>// of what should be simple. This package does away with this complexity by
40389>>>>>>>>>// automatically creating and reusing connections and therefore a minimum
40389>>>>>>>>>// will be created.
40389>>>>>>>>>//
40389>>>>>>>>>// It also means that at any time the application will have a number of open
40389>>>>>>>>>// connections in its 'cache'. If you want to reset this cache and close all
40389>>>>>>>>>// the connections (if you change filelist.cfg for example) here is how:
40389>>>>>>>>>//
40389>>>>>>>>>//  Send DisconnectAllConnections of oSQLStatementHandles
40389>>>>>>>>>//
40389>>>>>>>>>// (This implementation does not assume MARS to be enabled on ms sql driver)
40389>>>>>>>>>//
40389>>>>>>>>>// Do it like this:
40389>>>>>>>>>//
40389>>>>>>>>>//
40389>>>>>>>>>// Use SQLStatementHandles.pkg // Declare singleton object oSQLStatementHandles
40389>>>>>>>>>//
40389>>>>>>>>>// Procedure Something
40389>>>>>>>>>//     tSQLStatementHandle strStatement // Clever statement handle
40389>>>>>>>>>//     If (OpenStatementOnTable(oSQLStatementHandles,Customer.File_Number,&strStatement)) Begin
40389>>>>>>>>>//
40389>>>>>>>>>//         // Do anything with the strStatement.hHandle (except SQLClose'ing it)
40389>>>>>>>>>//         // At this point strStatement.hStatement is your normal statement handle.
40389>>>>>>>>>//
40389>>>>>>>>>//         // Close the statement and hand the corresponding connection back to the pool:
40389>>>>>>>>>//         Send CloseStatement of oSQLStatementHandles strStatement
40389>>>>>>>>>//     End
40389>>>>>>>>>// End_Procedure
40389>>>>>>>>>//
40389>>>>>>>>>
40389>>>>>>>>>Use sql.pkg
40389>>>>>>>>>
40389>>>>>>>>>Struct tSQLConnectionHandle
40389>>>>>>>>>    String sDriver
40389>>>>>>>>>    String sConnectString
40389>>>>>>>>>    Handle hHandle
40389>>>>>>>>>End_Struct
40389>>>>>>>>>
40389>>>>>>>>>Struct tSQLStatementHandle
40389>>>>>>>>>    Handle hHandle
40389>>>>>>>>>    tSQLConnectionHandle strConnectionHandle
40389>>>>>>>>>    tSQLConnectionHandle strConnectionHandle
40389>>>>>>>>>End_Struct
40389>>>>>>>>>
40389>>>>>>>>>Global_Variable tSQLConnectionHandle[] _gaSQLConnectionPool // Array of available SQL connections
40389>>>>>>>>>
40389>>>>>>>>>Global_Variable Integer oSQLStatementHandles
40389>>>>>>>>>Object _oSQLStatementHandles is a cObject
40391>>>>>>>>>    Move Self to oSQLStatementHandles
40392>>>>>>>>>
40392>>>>>>>>>    Property String _psCurrentFilelist
40394>>>>>>>>>
40394>>>>>>>>>    Procedure DisconnectAllConnections // and destroy them
40397>>>>>>>>>        Integer iMax iItem
40397>>>>>>>>>        Handle hConnection
40397>>>>>>>>>        Move (SizeOfArray(_gaSQLConnectionPool)-1) to iMax
40398>>>>>>>>>        For iItem from 0 to iMax
40404>>>>>>>>>>
40404>>>>>>>>>            Move _gaSQLConnectionPool[iItem].hHandle to hConnection
40405>>>>>>>>>            If (hConnection<>0) Begin
40407>>>>>>>>>                Send SQLDisconnect of hConnection
40408>>>>>>>>>                Send Destroy of hConnection
40409>>>>>>>>>            End
40409>>>>>>>>>>
40409>>>>>>>>>        Loop
40410>>>>>>>>>>
40410>>>>>>>>>        Move (ResizeArray(_gaSQLConnectionPool,0)) to _gaSQLConnectionPool
40411>>>>>>>>>    End_Procedure
40412>>>>>>>>>
40412>>>>>>>>>        Function _FilelistChanged Returns Boolean
40415>>>>>>>>>            String sFilelist
40415>>>>>>>>>            Get_Attribute DF_FILELIST_NAME to sFilelist
40418>>>>>>>>>            Function_Return (sFilelist<>_psCurrentFilelist(Self))
40419>>>>>>>>>        End_Function
40420>>>>>>>>>
40420>>>>>>>>>        // Every time a connection is requested we check if the database
40420>>>>>>>>>        // as been switched underneath our feet. This happens only in
40420>>>>>>>>>        // applications like VDFxray where a new workspace may be selected
40420>>>>>>>>>        // at any time. If it has then we must close all the connection we
40420>>>>>>>>>        // have in stock and remove them from our connection "cache":
40420>>>>>>>>>        Procedure _CheckIfFilelistChanged
40423>>>>>>>>>            String sFilelist
40423>>>>>>>>>            If (_FilelistChanged(Self)) Begin
40425>>>>>>>>>                Send DisconnectAllConnections
40426>>>>>>>>>                Get_Attribute DF_FILELIST_NAME to sFilelist
40429>>>>>>>>>                Set _psCurrentFilelist to sFilelist
40430>>>>>>>>>            End
40430>>>>>>>>>>
40430>>>>>>>>>        End_Procedure
40431>>>>>>>>>
40431>>>>>>>>>        Function _FindConnectionInPool String sDriver String sConnectString Returns Integer
40434>>>>>>>>>            Integer iMax iItem
40434>>>>>>>>>            Move (SizeOfArray(_gaSQLConnectionPool)-1) to iMax
40435>>>>>>>>>            For iItem from 0 to iMax
40441>>>>>>>>>>
40441>>>>>>>>>                If (sDriver=_gaSQLConnectionPool[iItem].sDriver and sConnectString=_gaSQLConnectionPool[iItem].sConnectString) Begin
40443>>>>>>>>>                    Function_Return iItem
40444>>>>>>>>>                End
40444>>>>>>>>>>
40444>>>>>>>>>            Loop
40445>>>>>>>>>>
40445>>>>>>>>>            Function_Return -1 // not found
40446>>>>>>>>>        End_Function
40447>>>>>>>>>
40447>>>>>>>>>
40447>>>>>>>>>    Function OpenConnection String sDriver String sConnectString tSQLConnectionHandle ByRef strConnectionHandle Returns Boolean
40450>>>>>>>>>        Boolean bSuccess
40450>>>>>>>>>        Integer iConnectionIndex hConnection hDataBaseConnection
40450>>>>>>>>>
40450>>>>>>>>>        Send _CheckIfFilelistChanged
40451>>>>>>>>>        Move True to bSuccess
40452>>>>>>>>>        Get _FindConnectionInPool sDriver sConnectString to iConnectionIndex // Do we already have one?
40453>>>>>>>>>        If (iConnectionIndex=-1) Begin // Create one
40455>>>>>>>>>            Get Create U_cSQLConnection to hConnection // Create SQL connection. Such a connection can only handle the execution of one statetment at a time.
40456>>>>>>>>>            Get SQLConnect of hConnection sDriver sConnectString to hDataBaseConnection
40457>>>>>>>>>            // The only thing we use the hDataBaseConnection for is:
40457>>>>>>>>>            If (hDataBaseConnection=0) Begin
40459>>>>>>>>>                Move False to bSuccess
40460>>>>>>>>>                Error 231 (sDriver+" could not connect to: "+sConnectString)
40461>>>>>>>>>>
40461>>>>>>>>>            End
40461>>>>>>>>>>
40461>>>>>>>>>            Move sDriver to strConnectionHandle.sDriver
40462>>>>>>>>>            Move sConnectString to strConnectionHandle.sConnectString
40463>>>>>>>>>            Move hConnection to strConnectionHandle.hHandle
40464>>>>>>>>>        End
40464>>>>>>>>>>
40464>>>>>>>>>        Else Begin // Take that one out of the pool
40465>>>>>>>>>            Move _gaSQLConnectionPool[iConnectionIndex] to strConnectionHandle
40466>>>>>>>>>            Move (RemoveFromArray(_gaSQLConnectionPool,iConnectionIndex)) to _gaSQLConnectionPool // Take it out of the pool
40467>>>>>>>>>        End
40467>>>>>>>>>>
40467>>>>>>>>>        Function_Return bSuccess
40468>>>>>>>>>    End_Function
40469>>>>>>>>>
40469>>>>>>>>>    Procedure CloseConnection tSQLConnectionHandle strConnectionHandle
40472>>>>>>>>>        Move strConnectionHandle to _gaSQLConnectionPool[SizeOfArray(_gaSQLConnectionPool)] // Put back in pool
40473>>>>>>>>>    End_Procedure
40474>>>>>>>>>
40474>>>>>>>>>    Function OpenStatement String sDriver String sConnectString tSQLStatementHandle ByRef strStatementHandle Returns Boolean
40477>>>>>>>>>        Boolean bSuccess
40477>>>>>>>>>        Move 0 to strStatementHandle.hHandle
40478>>>>>>>>>        Get OpenConnection sDriver sConnectString (&strStatementHandle.strConnectionHandle) to bSuccess
40479>>>>>>>>>        If (bSuccess) Begin
40481>>>>>>>>>            Get SQLOpen of strStatementHandle.strConnectionHandle.hHandle to strStatementHandle.hHandle
40482>>>>>>>>>        End
40482>>>>>>>>>>
40482>>>>>>>>>        Function_Return bSuccess
40483>>>>>>>>>    End_Function
40484>>>>>>>>>
40484>>>>>>>>>    Function OpenStatementOnTable Integer iTable tSQLStatementHandle ByRef strStatementHandle Returns Boolean
40487>>>>>>>>>        String sDriver sConnectString
40487>>>>>>>>>        Get_Attribute DF_FILE_DRIVER of iTable to sDriver
40490>>>>>>>>>        Get_Attribute DF_FILE_LOGIN of iTable to sConnectString
40493>>>>>>>>>        Function_Return (OpenStatement(Self,sDriver,sConnectString,&strStatementHandle))
40494>>>>>>>>>    End_Function
40495>>>>>>>>>
40495>>>>>>>>>    Procedure CloseStatement tSQLStatementHandle strStatement
40498>>>>>>>>>        Send SQLClose of strStatement.hHandle // obliterates it!
40499>>>>>>>>>        Send CloseConnection strStatement.strConnectionHandle // Connection back in pool!
40500>>>>>>>>>    End_Procedure
40501>>>>>>>>>
40501>>>>>>>>>End_Object
40502>>>>>>>Use TableDriverFunctions.pkg
40502>>>>>>>Use StructFunctions.pkg
40502>>>>>>>Use RecordBufferFunctions.pkg
Including file: RecordBufferFunctions.pkg    (Z:\VmShare\Projects\WebQuery18-0\StureApsPublicLib\AppSrc\RecordBufferFunctions.pkg)
40502>>>>>>>>>Use VdfBase.pkg // DAW package. Provides low level support expected of all VDF applications (windows and webapp)
40502>>>>>>>>>
40502>>>>>>>>>Struct _trbfRecordBuffer
40502>>>>>>>>>    Integer iTable
40502>>>>>>>>>    RowID rRowId
40502>>>>>>>>>End_Struct
40502>>>>>>>>>
40502>>>>>>>>>Global_Variable Integer oRecordBufferFunctions
40502>>>>>>>>>_trbfRecordBuffer[] _gartbfBufferStates
40502>>>>>>>>>_trbfRecordBuffer[] _gartbfBufferStates
40502>>>>>>>>>
40502>>>>>>>>>Object _oRecordBufferFunctions is a cObject
40504>>>>>>>>>    Move Self to oRecordBufferFunctions
40505>>>>>>>>>
40505>>>>>>>>>    Property _trbfRecordBuffer[] paRecordStack
40507>>>>>>>>>
40507>>>>>>>>>    Procedure PushRecord Integer iTable
40510>>>>>>>>>        _trbfRecordBuffer strRB
40510>>>>>>>>>        _trbfRecordBuffer strRB
40510>>>>>>>>>        _trbfRecordBuffer[] aRecordStack
40510>>>>>>>>>        _trbfRecordBuffer[] aRecordStack
40511>>>>>>>>>
40511>>>>>>>>>        Move iTable to strRB.iTable
40512>>>>>>>>>        Move (GetRowID(iTable)) to strRB.rRowId
40513>>>>>>>>>
40513>>>>>>>>>        Get paRecordStack to aRecordStack
40514>>>>>>>>>        Move strRB to aRecordStack[SizeOfArray(aRecordStack)]
40515>>>>>>>>>        Set paRecordStack to aRecordStack
40516>>>>>>>>>    End_Procedure
40517>>>>>>>>>
40517>>>>>>>>>        Procedure _PopRecord Integer iTable Boolean bRestoreBuffer
40520>>>>>>>>>            _trbfRecordBuffer strRB
40520>>>>>>>>>            _trbfRecordBuffer strRB
40520>>>>>>>>>            _trbfRecordBuffer[] aRecordStack
40520>>>>>>>>>            _trbfRecordBuffer[] aRecordStack
40521>>>>>>>>>
40521>>>>>>>>>            Get paRecordStack to aRecordStack
40522>>>>>>>>>            Move (aRecordStack[SizeOfArray(aRecordStack)-1]) to strRB
40523>>>>>>>>>
40523>>>>>>>>>            If (strRB.iTable=iTable) Begin
40525>>>>>>>>>
40525>>>>>>>>>                Move (ResizeArray(aRecordStack,SizeOfArray(aRecordStack)-1)) to aRecordStack
40526>>>>>>>>>                Set paRecordStack to aRecordStack
40527>>>>>>>>>
40527>>>>>>>>>                If (bRestoreBuffer) Begin
40529>>>>>>>>>                    Clear iTable
40530>>>>>>>>>                    If (not(IsNullRowID(strRB.rRowId))) Begin
40532>>>>>>>>>                        If (FindByRowID(strRB.iTable,strRB.rRowId)) Begin
40534>>>>>>>>>                        End
40534>>>>>>>>>>
40534>>>>>>>>>                    End
40534>>>>>>>>>>
40534>>>>>>>>>                End
40534>>>>>>>>>>
40534>>>>>>>>>            End
40534>>>>>>>>>>
40534>>>>>>>>>            Else Begin
40535>>>>>>>>>                Error DFERR_PROGRAM "Un-balanced record buffer push/pop"
40536>>>>>>>>>>
40536>>>>>>>>>            End
40536>>>>>>>>>>
40536>>>>>>>>>        End_Procedure
40537>>>>>>>>>
40537>>>>>>>>>    Procedure PopRecord Integer iTable // iTable parameter is used to check for balanced use of record stack
40540>>>>>>>>>        Send _PopRecord iTable True
40541>>>>>>>>>    End_Procedure
40542>>>>>>>>>
40542>>>>>>>>>    Procedure DropRecord Integer iTable // iTable parameter is used to check for balanced use of record stack
40545>>>>>>>>>        Send _PopRecord iTable False
40546>>>>>>>>>    End_Procedure
40547>>>>>>>>>
40547>>>>>>>>>        Function _IsRecordBufferActive Integer iTable Returns Boolean
40550>>>>>>>>>            Integer iStatus
40550>>>>>>>>>            Get_Attribute DF_FILE_STATUS of iTable to iStatus
40553>>>>>>>>>            Function_Return (iStatus=DF_FILE_ACTIVE or iStatus=DF_FILE_ACTIVE_CHANGED)
40554>>>>>>>>>        End_Function
40555>>>>>>>>>
40555>>>>>>>>>    Function IsNullRecordBuffer Integer iTable Returns Boolean
40558>>>>>>>>>        Function_Return (not(_IsRecordBufferActive(Self,iTable)))
40559>>>>>>>>>    End_Function
40560>>>>>>>>>
40560>>>>>>>>>    Function RecordBufferColumnValues Integer iTable Returns String[]
40563>>>>>>>>>        Integer iColumn iColumns iColumnType
40563>>>>>>>>>        String[] aColumnValues
40564>>>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iTable to iColumns
40567>>>>>>>>>        For iColumn from 0 to iColumns
40573>>>>>>>>>>
40573>>>>>>>>>            Get_Attribute DF_FIELD_TYPE of iTable iColumn to iColumnType
40576>>>>>>>>>            If (iColumnType<>DF_OVERLAP) Begin
40578>>>>>>>>>                Get_Field_Value iTable iColumn to aColumnValues[iColumn]
40581>>>>>>>>>            End
40581>>>>>>>>>>
40581>>>>>>>>>            Else Begin
40582>>>>>>>>>                Move "" to aColumnValues[iColumn
40583>>>>>>>>>            End
40583>>>>>>>>>>
40583>>>>>>>>>        Loop
40584>>>>>>>>>>
40584>>>>>>>>>        Function_Return aColumnValues
40585>>>>>>>>>    End_Function
40586>>>>>>>>>
40586>>>>>>>>>End_Object
40587>>>>>>>>>
40587>>>>>>>
40587>>>>>>>Enum_List // Column value types
40587>>>>>>>    Define tqSTRING
40587>>>>>>>    Define tqNUMBER
40587>>>>>>>    Define tqTEXT
40587>>>>>>>    Define tqDATE
40587>>>>>>>    Define tqDATETIME
40587>>>>>>>End_Enum_List
40587>>>>>>>
40587>>>>>>>Enum_List // Filter comparison modes
40587>>>>>>>    Define tqLT
40587>>>>>>>    Define tqLE
40587>>>>>>>    Define tqEQ
40587>>>>>>>    Define tqGE
40587>>>>>>>    Define tqGT
40587>>>>>>>    Define tqNE
40587>>>>>>>    // These can never be used for index optimization:
40587>>>>>>>//    Define tqCONTAINS   // DO NOT USE
40587>>>>>>>//    Define tqIN         // DO NOT USE (use orlist instead)
40587>>>>>>>    Define tqMATCH      // When evaluated on the embedded database tqMATCH and tqUCMATCH may be
40587>>>>>>>    Define tqUCMATCH    // expensive. On SQL they are converted to 'like' predicates and they fly.
40587>>>>>>>    Define _tqComparisonMax   // Stop-marker
40587>>>>>>>End_Enum_List
40587>>>>>>>
40587>>>>>>>Struct tTQResultRow
40587>>>>>>>    RowID    riRowId
40587>>>>>>>    String   sSortValue
40587>>>>>>>    String[] aColumnValues
40587>>>>>>>End_Struct
40587>>>>>>>
40587>>>>>>>Struct tTQResultSet
40587>>>>>>>    Integer iTable
40587>>>>>>>    tTQResultRow[] aRecords
40587>>>>>>>    tTQResultRow[] aRecords
40587>>>>>>>    Integer _iCurrentRowPointer
40587>>>>>>>End_Struct
40587>>>>>>>
40587>>>>>>>Struct _tTQValueSource
40587>>>>>>>    // An actual value is derived like this:
40587>>>>>>>    //  If iTable<>0 then: get_field_value iTable iColumn
40587>>>>>>>    //  Else If (hFunction<>0) then: get hFunction of hObject iColumn // Column is passed to hFunction as argument
40587>>>>>>>    //  Else If aOrList has elements the value of the _iOrListPointer'th element in aOrList is assumed
40587>>>>>>>    //  Else: sConstant
40587>>>>>>>    Integer iTable
40587>>>>>>>    Integer iColumn
40587>>>>>>>
40587>>>>>>>    Integer hObject
40587>>>>>>>    Integer hFunction
40587>>>>>>>
40587>>>>>>>    Integer iType
40587>>>>>>>    Integer iLen
40587>>>>>>>    Integer iDecimals
40587>>>>>>>
40587>>>>>>>    String  sConstant
40587>>>>>>>
40587>>>>>>>    String _sValue
40587>>>>>>>
40587>>>>>>>    String[] aOrList
40587>>>>>>>    Integer _iOrListPointer
40587>>>>>>>
40587>>>>>>>    String  sSQLResultSetColumnName
40587>>>>>>>//    Integer iSQLResultSetColumnNumber // This is implicitly given by the position of the _tTQValueSource member in the aSelectedColumns array of a tTableQuery type variable.
40587>>>>>>>End_Struct
40587>>>>>>>
40587>>>>>>>Struct tTQFilterSegment
40587>>>>>>>    _tTQValueSource strLeftValue
40587>>>>>>>    _tTQValueSource strLeftValue
40587>>>>>>>    Integer iComp // tqEQ, tqLT, tgLE, tqMATCH etc...
40587>>>>>>>    tWildCardEvalSequence strMatchEvalSequence // If selection by wild card string matching this member is needed
40587>>>>>>>    tWildCardEvalSequence strMatchEvalSequence // If selection by wild card string matching this member is needed
40587>>>>>>>    _tTQValueSource strRightValue
40587>>>>>>>    _tTQValueSource strRightValue
40587>>>>>>>End_Struct
40587>>>>>>>
40587>>>>>>>Struct _tTQTableRelationSegment
40587>>>>>>>    Integer iSourceTable
40587>>>>>>>    Integer iSourceColumn
40587>>>>>>>    Integer iInnerJoinComp
40587>>>>>>>    Integer iTargetColumn
40587>>>>>>>End_Struct
40587>>>>>>>
40587>>>>>>>Struct tTQTableRelation
40587>>>>>>>    Integer iTargetTable                  // The table that is being related to
40587>>>>>>>    String sForceSQLTableName             // If represented in a select statement we can force its name by setting this
40587>>>>>>>    _tTQTableRelationSegment[] aSegments  // The columns being used for the relation. Note that these may stem from a number of different
40587>>>>>>>    _tTQTableRelationSegment[] aSegments  // The columns being used for the relation. Note that these may stem from a number of different
40587>>>>>>>                                          // child tables. Note also that if aSegments is empty the record of the iTargetTable table is
40587>>>>>>>                                          // constant for the duration of the query execution. But they are all in effect "outer left joins".
40587>>>>>>>    Integer _iEmbeddedIndex               // What embedded index should be used to find a record of this kind (the iTargetTable kind)
40587>>>>>>>    Boolean bFixed                        // A table is fixed if the record buffer is constant through the query.
40587>>>>>>>    Boolean bInnerJoin                    // If a relation is marked as "inner join" the SQL generated will do something I can't remember.
40587>>>>>>>End_Struct
40587>>>>>>>
40587>>>>>>>Struct tTQFilterExpression //
40587>>>>>>>    Number nExpense // Expected expense of evaluating this expression.
40587>>>>>>>    Boolean bNot // Applies to strOperand or aSubExpressions whichever is 'active'
40587>>>>>>>    tTQFilterSegment strOperand
40587>>>>>>>    tTQFilterSegment strOperand
40587>>>>>>>    tTQFilterExpression[] aSubExpressions // If this array has members then tTQFilterSegment is disregarded
40587>>>>>>>    tTQFilterExpression[] aSubExpressions // If this array has members then tTQFilterSegment is disregarded
40587>>>>>>>    Integer iAndOr // 0=leaf(nothing), 1=and, 2=or, 3=xOr
40587>>>>>>>    Boolean _bOpen
40587>>>>>>>End_Struct
40587>>>>>>>
40587>>>>>>>// a or b and c xor (d or not(e))
40587>>>>>>>Enum_List // Filter expression 'keys'
40587>>>>>>>    Define _tqKeyNULL
40587>>>>>>>    Define tqKeyAND
40587>>>>>>>    Define tqKeyOR
40587>>>>>>>    Define tqKeyNOT
40587>>>>>>>    Define tqKeyPARLEFT
40587>>>>>>>    Define tqKeyPARRIGHT
40587>>>>>>>End_Enum_List
40587>>>>>>>
40587>>>>>>>Struct tTQOrderBySegment
40587>>>>>>>    Boolean bDescending
40587>>>>>>>    Boolean bUppercase
40587>>>>>>>    _tTQValueSource strValueSource
40587>>>>>>>    _tTQValueSource strValueSource
40587>>>>>>>End_Struct
40587>>>>>>>
40587>>>>>>>Struct _tTQInnerJoinControlBlock
40587>>>>>>>    Boolean bEnabled // Inner join enabled
40587>>>>>>>    Boolean bInitialized // Inner join initialised
40587>>>>>>>    String[] aCurrentParentSortValues // Sort values of current parent record
40587>>>>>>>    Boolean bSkipNextFetch // First run in inner join
40587>>>>>>>    Boolean bEndOfResultSet
40587>>>>>>>End_Struct
40587>>>>>>>
40587>>>>>>>Struct tTQPrefetchCacheControl
40587>>>>>>>    Boolean bUseSettings
40587>>>>>>>    Integer iPrefetchRecordCount
40587>>>>>>>    Integer iPrefetchRecordTimeout
40587>>>>>>>End_Struct
40587>>>>>>>
40587>>>>>>>Struct tTSQueryControlBlock
40587>>>>>>>    Boolean bCompiled
40587>>>>>>>    Boolean bInitialized
40587>>>>>>>
40587>>>>>>>    // How much do we prefer to limit the number of finds performed against the
40587>>>>>>>    // database over not having to sort all the selected rows in an array?
40587>>>>>>>    //
40587>>>>>>>    // A value of 0.1 (its default value) indicates that we are willing to accept
40587>>>>>>>    // 10 times more finds to not have to prefetch the whole set. A value of 1
40587>>>>>>>    // would mean that we are not willing to perform any unnecessary finds and
40587>>>>>>>    // thus prefetching would only occur if absolutely necessary.
40587>>>>>>>    //
40587>>>>>>>    // (actually it might make sense to set it according to the computing power or the
40587>>>>>>>    // network speed of the client and the expected size of the result set)
40587>>>>>>>    //
40587>>>>>>>    // If you set it higher than 1 it will prefer prefetch indices for no good
40587>>>>>>>    // reason (so don't do that).
40587>>>>>>>
40587>>>>>>>    Number nPrefetchAvoidanceFactor // Default assigned by NewQuery is 0.1
40587>>>>>>>
40587>>>>>>>    Integer iFindCount
40587>>>>>>>    Integer iSelectCount
40587>>>>>>>
40587>>>>>>>    Boolean bFirstRecord
40587>>>>>>>
40587>>>>>>>    Boolean bBreakScan
40587>>>>>>>    String sLogTag
40587>>>>>>>
40587>>>>>>>    Integer iCursor
40587>>>>>>>
40587>>>>>>>    Boolean[] aRelatedRecords // True if the same index in the aTableRelations array has already been executed
40587>>>>>>>
40587>>>>>>>    Integer iQueryMethod // tqDataFlex, tqSQLPKG or tqMERTECHINC
40587>>>>>>>    tSQLStatementHandle strSQLStatementHandle
40587>>>>>>>    tSQLStatementHandle strSQLStatementHandle
40587>>>>>>>    Boolean bSQLTableIsAnsi
40587>>>>>>>    tTQPrefetchCacheControl strSQLCacheControl
40587>>>>>>>    tTQPrefetchCacheControl strSQLCacheControl
40587>>>>>>>    tTQPrefetchCacheControl _strPreviousSQLCacheControl // Used to push the cache settings and restore previous value upon loop exit
40587>>>>>>>    tTQPrefetchCacheControl _strPreviousSQLCacheControl // Used to push the cache settings and restore previous value upon loop exit
40587>>>>>>>
40587>>>>>>>    _tTQInnerJoinControlBlock strInnerJoinCB
40587>>>>>>>    _tTQInnerJoinControlBlock strInnerJoinCB
40587>>>>>>>
40587>>>>>>>    Boolean bFilterExpressionActive
40587>>>>>>>End_Struct
40587>>>>>>>
40587>>>>>>>Enum_List // Query methods
40587>>>>>>>    Define tqDATAFLEX
40587>>>>>>>    Define tqSQLPKG
40587>>>>>>>    Define tqMERTECHINC
40587>>>>>>>End_Enum_List
40587>>>>>>>
40587>>>>>>>Struct tTSQueryCompiled
40587>>>>>>>    Integer iIndex
40587>>>>>>>    Boolean bBackwards
40587>>>>>>>
40587>>>>>>>    Number nENR // Expected number of rows according to iIndex. If nENR is zero the index is fully specified
40587>>>>>>>
40587>>>>>>>    Boolean bPrefetch
40587>>>>>>>    Boolean bIndexSeedSharpeningEnabled
40587>>>>>>>    Integer _iLimit
40587>>>>>>>    Integer _iPushLimit
40587>>>>>>>    tTQFilterSegment[] aJumpInValues
40587>>>>>>>    tTQFilterSegment[] aJumpInValues
40587>>>>>>>    tTQFilterSegment[] aJumpOutValues
40587>>>>>>>    tTQFilterSegment[] aJumpOutValues
40587>>>>>>>    tTQFilterSegment[] aOtherConditions // Non optimized conditions
40587>>>>>>>    tTQFilterSegment[] aOtherConditions // Non optimized conditions
40587>>>>>>>End_Struct
40587>>>>>>>
40587>>>>>>>//> The supreme struct!
40587>>>>>>>Struct tTableQuery
40587>>>>>>>    Integer iTable
40587>>>>>>>
40587>>>>>>>    Boolean bNoESQL            //> If true: Do not use ESQL even if SQL table.
40587>>>>>>>    Boolean bForcePrefetch     //> If true: Force finding of all rows before FindRecord loop execution.
40587>>>>>>>    Integer iForceIndex        //> If you don't care what the query analyzer says, you may force the table scan to be performed by this index (-1 means no force)
40587>>>>>>>    Integer iLimit             //> Limits the amount of rows returned by the loop
40587>>>>>>>    String  sForceSQLTableName //> Use this table name when generating ESQL (over the default value from filelist.cfg)
40587>>>>>>>    String  sForceSQLStatement //> DANGER! Use this to completely overtake the SQL generated by TQ. It's your responsability then that the columns of the result set are in synch with what TQ expects (qua the result set specification).
40587>>>>>>>    // Select:
40587>>>>>>>    _tTQValueSource[]     aColumnSources //> If this array is empty TQ will by default activate the iTable buffer.
40587>>>>>>>    _tTQValueSource[]     aColumnSources //> If this array is empty TQ will by default activate the iTable buffer.
40587>>>>>>>    _tTQValueSource[]     aOutputColumns //> This array contains a copy of the items added to aColumnSources that are column specific. The order of the columns will be identical to the order in which they were added
40587>>>>>>>    _tTQValueSource[]     aOutputColumns //> This array contains a copy of the items added to aColumnSources that are column specific. The order of the columns will be identical to the order in which they were added
40587>>>>>>>    Boolean               _bOutputColumnsFixated 
40587>>>>>>>    Boolean               bRestoreRecordBuffersOnQueryCompletion
40587>>>>>>>    // Where:
40587>>>>>>>    tTQFilterSegment[] aFilters //> Segments are and'ed
40587>>>>>>>    tTQFilterSegment[] aFilters //> Segments are and'ed
40587>>>>>>>    // Where (for filterexpressions):
40587>>>>>>>    tTQFilterExpression[] aFilterExpressions //> are of course also and'ed if there are more of them
40587>>>>>>>    tTQFilterExpression[] aFilterExpressions //> are of course also and'ed if there are more of them
40587>>>>>>>    // Order by:
40587>>>>>>>    tTQOrderBySegment[]   aOrdering
40587>>>>>>>    tTQOrderBySegment[]   aOrdering
40587>>>>>>>    // House keeping:
40587>>>>>>>    tTSQueryCompiled      _strCompiled
40587>>>>>>>    tTSQueryCompiled      _strCompiled
40587>>>>>>>    tTSQueryControlBlock  _strControlBlock
40587>>>>>>>    tTSQueryControlBlock  _strControlBlock
40587>>>>>>>    tTQResultSet          strResultSet
40587>>>>>>>    tTQResultSet          strResultSet
40587>>>>>>>
40587>>>>>>>    tTQTableRelation[]    aTableRelations //> Defines relations to parent tables
40587>>>>>>>    tTQTableRelation[]    aTableRelations //> Defines relations to parent tables
40587>>>>>>>End_Struct
40587>>>>>>>
40587>>>>>>>Struct _tTQIndexRating
40587>>>>>>>    Integer iIndex
40587>>>>>>>    Number  nExpectedNumberRows // With the filters supplied, how many rows can we expect to find by this index.
40587>>>>>>>    Boolean bOutputAgree // Does the index agree with the output order specified?
40587>>>>>>>    Integer iKeyLevels
40587>>>>>>>    Integer iKeyLength // A short key length might rate better if everything else was equal.
40587>>>>>>>End_Struct
40587>>>>>>>
40587>>>>>>>Struct _tTQIndexAnalysis
40587>>>>>>>    Number[] aSegmentReductions
40587>>>>>>>End_Struct
40587>>>>>>>
40587>>>>>>>Struct tTQTableAnalysis
40587>>>>>>>    Boolean bInitialized
40587>>>>>>>    DateTime dtAnalysisDateTime
40587>>>>>>>    Number nNumberOfRecords
40587>>>>>>>    _tTQIndexAnalysis[] aIndices
40587>>>>>>>    _tTQIndexAnalysis[] aIndices
40587>>>>>>>    String sTimeToComplete
40587>>>>>>>End_Struct
40587>>>>>>>
40587>>>>>>>Struct tTQTableMeta
40587>>>>>>>    Integer   _iIsInitialized
40587>>>>>>>    Integer[] aIndices // Indices to scan
40587>>>>>>>End_Struct
40587>>>>>>>
40587>>>>>>>Global_Variable tTQTableAnalysis[]  _gTQaTableAnalysis
40587>>>>>>>Global_Variable tTQTableMeta[]      _gTQaTableMeta
40587>>>>>>>
40587>>>>>>>Global_Variable Integer _giTQLogState // 0=No logging, 1=Log when LogTag'ed, 2=Log always
40587>>>>>>>Global_Variable Integer[] _gaTQLogTables
40587>>>>>>>
40587>>>>>>>Procedure Set TableQuery_LogState Global Integer iState
40589>>>>>>>    Move iState to _giTQLogState
40590>>>>>>>End_Procedure
40591>>>>>>>
40591>>>>>>>Class cTableQuerySQL is a cObject // Generates an SQL statement
40592>>>>>>>    Procedure Construct_Object
40594>>>>>>>        Forward Send Construct_Object
40596>>>>>>>        Property String psCollation "Latin1_General_BIN" // Or maybe "SQL_Latin1_CP850_BIN"? Who knows?
40597>>>>>>>    End_Procedure
40598>>>>>>>
40598>>>>>>>        Function _SQL_ColumnName tTableQuery strQ Integer hoTQ Integer iTable Integer iColumn Returns String
40600>>>>>>>            String sValue
40600>>>>>>>            Get ColumnName of hoTQ strQ iTable iColumn True to sValue
40601>>>>>>>            Function_Return sValue
40602>>>>>>>        End_Function
40603>>>>>>>
40603>>>>>>>        Function _SQL_TableName tTableQuery strQ Integer hoTQ Integer iTable Returns String
40605>>>>>>>            String sValue
40605>>>>>>>            Get TableName of hoTQ strQ iTable to sValue
40606>>>>>>>            Move ("["+sValue+"]") to sValue
40607>>>>>>>            Function_Return sValue
40608>>>>>>>        End_Function
40609>>>>>>>
40609>>>>>>>        Function _SQL_SelectColumns tTableQuery strQ Integer hoTQ Returns String
40611>>>>>>>            Integer iMax iItem iTable iColumn
40611>>>>>>>            String sColumnList sColumnName sTableName
40611>>>>>>>            Move (SizeOfArray(strQ.aColumnSources)-1) to iMax
40612>>>>>>>            If (iMax>=0) Begin
40614>>>>>>>                For iItem from 0 to iMax
40620>>>>>>>>
40620>>>>>>>                    If (iItem<>0) Begin
40622>>>>>>>                        Move (sColumnList+",") to sColumnList
40623>>>>>>>                    End
40623>>>>>>>>
40623>>>>>>>                    Move strQ.aColumnSources[iItem].iTable to iTable
40624>>>>>>>                    Move strQ.aColumnSources[iItem].iColumn to iColumn
40625>>>>>>>
40625>>>>>>>                    If (iColumn<>0) Begin
40627>>>>>>>                        Get _SQL_ColumnName strQ hoTQ iTable iColumn to sColumnName
40628>>>>>>>                    End
40628>>>>>>>>
40628>>>>>>>                    Else Begin
40629>>>>>>>                        Get TableName of hoTQ strQ iTable to sTableName
40630>>>>>>>                        Move (sTableName+".*") to sColumnName
40631>>>>>>>                    End
40631>>>>>>>>
40631>>>>>>>                    Move (sColumnList+sColumnName) to sColumnList
40632>>>>>>>                Loop
40633>>>>>>>>
40633>>>>>>>            End
40633>>>>>>>>
40633>>>>>>>            Else Begin
40634>>>>>>>                Move "*" to sColumnList
40635>>>>>>>            End
40635>>>>>>>>
40635>>>>>>>            Function_Return sColumnList
40636>>>>>>>        End_Function
40637>>>>>>>
40637>>>>>>>            Procedure _SQL_OuterLeftJoin_AddSegments tTableQuery strQ Integer hoTQ String ByRef sFromTables Integer iRelateItem
40639>>>>>>>                Integer iItem iItemMax
40639>>>>>>>                String sColumnName sComp
40639>>>>>>>                tTQTableRelation strRelation
40639>>>>>>>                tTQTableRelation strRelation
40639>>>>>>>                Move strQ.aTableRelations[iRelateItem] to strRelation
40640>>>>>>>                Move (SizeOfArray(strRelation.aSegments)-1) to iItemMax
40641>>>>>>>                For iItem from 0 to iItemMax
40647>>>>>>>>
40647>>>>>>>                    If (iItem<>0) Begin
40649>>>>>>>                        Move (sFromTables+" AND") to sFromTables
40650>>>>>>>                    End
40650>>>>>>>>
40650>>>>>>>                    Get _SQL_ColumnName strQ hoTQ strRelation.aSegments[iItem].iSourceTable strRelation.aSegments[iItem].iSourceColumn to sColumnName
40651>>>>>>>                    Move (sFromTables*sColumnName) to sFromTables
40652>>>>>>>
40652>>>>>>>                    Get _SQL_WhereClauseComperator strRelation.aSegments[iItem].iInnerJoinComp False to sComp
40653>>>>>>>                    Move (sFromTables*sComp) to sFromTables
40654>>>>>>>
40654>>>>>>>                    Get _SQL_ColumnName strQ hoTQ strRelation.iTargetTable strRelation.aSegments[iItem].iTargetColumn to sColumnName
40655>>>>>>>                    Move (sFromTables*sColumnName) to sFromTables
40656>>>>>>>                Loop
40657>>>>>>>>
40657>>>>>>>            End_Procedure
40658>>>>>>>
40658>>>>>>>            //select f.foo
40658>>>>>>>            //     , b.bar
40658>>>>>>>            //     , q.qux
40658>>>>>>>            //  from footable as f
40658>>>>>>>            //left outer
40658>>>>>>>            //  join bartable as b
40658>>>>>>>            //    on f.id = b.fid
40658>>>>>>>            //left outer
40658>>>>>>>            //  join quxtable as q
40658>>>>>>>            //    on b.id = q.bid
40658>>>>>>>
40658>>>>>>>        Function _SQL_OuterLeftJoins tTableQuery strQ Integer hoTQ Returns String
40660>>>>>>>            Integer iItem iItemMax
40660>>>>>>>            String sFromTables sTableName
40660>>>>>>>            Get TableName of hoTQ strQ strQ.iTable to sFromTables
40661>>>>>>>
40661>>>>>>>            Move (SizeOfArray(strQ.aTableRelations)-1) to iItemMax
40662>>>>>>>            For iItem from 0 to iItemMax
40668>>>>>>>>
40668>>>>>>>                If (not(strQ.aTableRelations[iItem].bFixed)) Begin
40670>>>>>>>                    Get _SQL_TableName strQ hoTQ strQ.aTableRelations[iItem].iTargetTable to sTableName
40671>>>>>>>                    Move (sFromTables+" left outer join"*sTableName+" on (") to sFromTables
40672>>>>>>>                    Send _SQL_OuterLeftJoin_AddSegments strQ hoTQ (&sFromTables) iItem
40673>>>>>>>                    Move (sFromTables+")") to sFromTables
40674>>>>>>>                End
40674>>>>>>>>
40674>>>>>>>            Loop
40675>>>>>>>>
40675>>>>>>>            Function_Return sFromTables
40676>>>>>>>        End_Function
40677>>>>>>>
40677>>>>>>>        Function _SQL_InnerJoins tTableQuery strQ Integer hoTQ Returns String
40679>>>>>>>            Integer iItem iItemMax
40679>>>>>>>            String sFromTables sTableName
40679>>>>>>>
40679>>>>>>>            Move (SizeOfArray(strQ.aTableRelations)-1) to iItemMax
40680>>>>>>>            For iItem from 0 to iItemMax
40686>>>>>>>>
40686>>>>>>>                If (strQ.aTableRelations[iItem].bInnerJoin) Begin
40688>>>>>>>                    Get _SQL_TableName strQ hoTQ strQ.aTableRelations[iItem].iTargetTable to sTableName
40689>>>>>>>                    Move (sFromTables+" inner join"*sTableName+" on (") to sFromTables
40690>>>>>>>                    Send _SQL_OuterLeftJoin_AddSegments strQ hoTQ (&sFromTables) iItem
40691>>>>>>>                    Move (sFromTables+")") to sFromTables
40692>>>>>>>                End
40692>>>>>>>>
40692>>>>>>>            Loop
40693>>>>>>>>
40693>>>>>>>            Function_Return sFromTables
40694>>>>>>>        End_Function
40695>>>>>>>
40695>>>>>>>            Function _SQL_WhereClauseComperator Integer iComp Boolean bIn Returns String
40697>>>>>>>                If (bIn) Begin
40699>>>>>>>                    Function_Return " in "
40700>>>>>>>                End
40700>>>>>>>>
40700>>>>>>>                If (iComp=tqLT) Function_Return "<"
40703>>>>>>>                If (iComp=tqLE) Function_Return "<="
40706>>>>>>>                If (iComp=tqEQ) Function_Return "="
40709>>>>>>>                If (iComp=tqGE) Function_Return ">="
40712>>>>>>>                If (iComp=tqGT) Function_Return ">"
40715>>>>>>>                If (iComp=tqNE) Function_Return "<>"
40718>>>>>>>                If (iComp=tqMATCH) Function_Return " like " // This can't be guaranteed on SQL. or what?
40721>>>>>>>                If (iComp=tqUCMATCH) Function_Return " like "
40724>>>>>>>//                If (iComp=tqCONTAINS) Function_Return "contains"
40724>>>>>>>                Function_Return "error"
40725>>>>>>>            End_Function
40726>>>>>>>
40726>>>>>>>                Function EscapeStringConstant String sValue Returns String
40728>>>>>>>                    Function_Return (Replaces("'",sValue,"''")) // cross fingers
40729>>>>>>>                End_Function
40730>>>>>>>
40730>>>>>>>            Function _SQL_WhereClauseValue tTableQuery strQ Integer hoTQ Integer iComp _tTQValueSource strValue Returns String
40732>>>>>>>                Boolean bFixed bDoValue
40732>>>>>>>                Integer iMax iItem
40732>>>>>>>                String sValue sColumnName sSQLdate
40732>>>>>>>                If (iComp=tqEQ and SizeOfArray(strValue.aOrList)<>0) Begin // IN
40734>>>>>>>                    Move (SizeOfArray(strValue.aOrList)-1) to iMax
40735>>>>>>>                    Move "(" to sValue
40736>>>>>>>                    For iItem from 0 to iMax
40742>>>>>>>>
40742>>>>>>>
40742>>>>>>>                        If (iItem>0) Begin
40744>>>>>>>                            Move (sValue+",") to sValue
40745>>>>>>>                        End
40745>>>>>>>>
40745>>>>>>>
40745>>>>>>>                        If (strValue.iType=tqSTRING or strValue.iType=tqTEXT) Begin
40747>>>>>>>                            Move (sValue+"'"+EscapeStringConstant(Self,strValue.aOrList[iItem])+"'") to sValue
40748>>>>>>>                        End
40748>>>>>>>>
40748>>>>>>>                        Else If (strValue.iType=tqDATE or strValue.iType=tqDATETIME) Begin
40751>>>>>>>                            Get DFDateToSQLDate of strQ._strControlBlock.strSQLStatementHandle.hHandle (Date(strValue.aOrList[iItem])) to sSQLdate
40752>>>>>>>                            Move (sValue+"'"+sSQLdate+"'") to sValue
40753>>>>>>>                        End
40753>>>>>>>>
40753>>>>>>>                        Else Begin
40754>>>>>>>                            Move (sValue+strValue.aOrList[iItem]) to sValue
40755>>>>>>>                        End
40755>>>>>>>>
40755>>>>>>>                    Loop
40756>>>>>>>>
40756>>>>>>>                    Move (sValue+")") to sValue
40757>>>>>>>                End
40757>>>>>>>>
40757>>>>>>>                Else Begin
40758>>>>>>>                    Move True to bDoValue
40759>>>>>>>                    If (strValue.iTable<>0) Begin
40761>>>>>>>                        Get _IsTableFixed of hoTQ strQ strValue.iTable to bFixed
40762>>>>>>>                        If (not(bFixed)) Begin
40764>>>>>>>                            Get _SQL_ColumnName strQ hoTQ strValue.iTable strValue.iColumn to sColumnName
40765>>>>>>>                            Move sColumnName to sValue
40766>>>>>>>                            Move False to bDoValue
40767>>>>>>>                        End
40767>>>>>>>>
40767>>>>>>>                    End
40767>>>>>>>>
40767>>>>>>>                    If (bDoValue) Begin // Either it's a constant or it's a fixed table:
40769>>>>>>>                        Get _ValueSourceValue of hoTQ (&strQ) strValue to sValue
40770>>>>>>>
40770>>>>>>>                        If (iComp=tqMATCH or iComp=tqUCMATCH) Begin
40772>>>>>>>                            Move (Replaces("%",sValue,"\%")) to sValue // Escape all SQL wildcard patterns
40773>>>>>>>                            Move (Replaces("_",sValue,"\_")) to sValue // that happens to be in the string
40774>>>>>>>                            Move (Replaces("[",sValue,"\[")) to sValue // by chance.
40775>>>>>>>                            Move (Replaces("]",sValue,"\]")) to sValue
40776>>>>>>>                            Move (Replaces("*",sValue,"%")) to sValue  // Replace our own * and ? wildcards
40777>>>>>>>                            Move (Replaces("?",sValue,"_")) to sValue  // with their SQL counterparts.
40778>>>>>>>                            If (iComp=tqUCMATCH) Begin
40780>>>>>>>                                Move (Uppercase(sValue)) to sValue
40781>>>>>>>                            End
40781>>>>>>>>
40781>>>>>>>                        End
40781>>>>>>>>
40781>>>>>>>
40781>>>>>>>                        If (strValue.iType=tqSTRING or strValue.iType=tqTEXT) Begin
40783>>>>>>>                            Move ("'"+EscapeStringConstant(Self,sValue)+"'") to sValue
40784>>>>>>>                        End
40784>>>>>>>>
40784>>>>>>>                        Else If (strValue.iType=tqDATE or strValue.iType=tqDATETIME) Begin
40787>>>>>>>                            Get DFDateToSQLDate of strQ._strControlBlock.strSQLStatementHandle.hHandle (Date(sValue)) to sValue
40788>>>>>>>                            Move ("'"+sValue+"'") to sValue
40789>>>>>>>                        End
40789>>>>>>>>
40789>>>>>>>
40789>>>>>>>                        If (iComp=tqMATCH or iComp=tqUCMATCH) Begin
40791>>>>>>>                            Move (sValue*"ESCAPE '\'") to sValue // tell mssql that the pattern has been escaped with the "\" character.
40792>>>>>>>                        End
40792>>>>>>>>
40792>>>>>>>                    End
40792>>>>>>>>
40792>>>>>>>                End
40792>>>>>>>>
40792>>>>>>>                Function_Return sValue
40793>>>>>>>            End_Function
40794>>>>>>>
40794>>>>>>>            Function _SQL_WhereClauseSegment tTableQuery strQ tTQFilterSegment strSegment Integer hoTQ Returns String
40796>>>>>>>                Integer iTable iColumn
40796>>>>>>>                Boolean bIn
40796>>>>>>>                String sValue
40796>>>>>>>                Move strSegment.strLeftValue.iTable to iTable
40797>>>>>>>                Move strSegment.strLeftValue.iColumn to iColumn
40798>>>>>>>                Get _SQL_ColumnName strq hoTQ iTable iColumn to sValue
40799>>>>>>>
40799>>>>>>>                Move (SizeOfArray(strSegment.strRightValue.aOrList)<>0) to bIn
40800>>>>>>>                Move (sValue+_SQL_WhereClauseComperator(Self,strSegment.iComp,bIn)) to sValue
40801>>>>>>>
40801>>>>>>>                Move (sValue+_SQL_WhereClauseValue(Self,strQ,hoTQ,strSegment.iComp,strSegment.strRightValue)) to sValue
40802>>>>>>>                Function_Return sValue
40803>>>>>>>            End_Function
40804>>>>>>>
40804>>>>>>>            Function _SQL_WhereClauseExpressionSegment tTableQuery strQ tTQFilterExpression[] aSegments Integer hoTQ Returns String
40806>>>>>>>                Integer iItem iItemMax
40806>>>>>>>                String sValue
40806>>>>>>>                Move (SizeOfArray(aSegments)-1) to iItemMax
40807>>>>>>>                For iItem from 0 to iItemMax
40813>>>>>>>>
40813>>>>>>>                    If (iItem>0) Begin
40815>>>>>>>                        If (aSegments[iItem-1].iAndOr=tqKeyAND) Begin
40817>>>>>>>                            Move (sValue*"AND") to sValue
40818>>>>>>>                        End
40818>>>>>>>>
40818>>>>>>>                        Else If (aSegments[iItem-1].iAndOr=tqKeyOR) Begin
40821>>>>>>>                            Move (sValue*"OR") to sValue
40822>>>>>>>                        End
40822>>>>>>>>
40822>>>>>>>                        Else Begin
40823>>>>>>>                            Send OnError 738 "Illegal operator in where clause expression"
40824>>>>>>>                        End
40824>>>>>>>>
40824>>>>>>>                    End
40824>>>>>>>>
40824>>>>>>>                    If (aSegments[iItem].bNot) Begin
40826>>>>>>>                        Move (sValue*"NOT") to sValue
40827>>>>>>>                    End
40827>>>>>>>>
40827>>>>>>>                    If (SizeOfArray(aSegments[iItem].aSubExpressions)>0) Begin
40829>>>>>>>                        Move (sValue*_SQL_WhereClauseExpressionSegment(Self,strQ,aSegments[iItem].aSubExpressions,hoTQ)) to sValue
40830>>>>>>>                    End
40830>>>>>>>>
40830>>>>>>>                    Else Begin
40831>>>>>>>                        Move (sValue*_SQL_WhereClauseSegment(Self,strQ,aSegments[iItem].strOperand,hoTQ)) to sValue
40832>>>>>>>                    End
40832>>>>>>>>
40832>>>>>>>                Loop
40833>>>>>>>>
40833>>>>>>>                Function_Return ("("+Trim(sValue)+")")
40834>>>>>>>            End_Function
40835>>>>>>>
40835>>>>>>>        Function _SQL_WhereClause tTableQuery strQ Integer hoTQ Returns String
40837>>>>>>>            Integer iMax iItem
40837>>>>>>>            Boolean bAddAND
40837>>>>>>>            String sValue
40837>>>>>>>            Move (SizeOfArray(strQ.aFilters)-1) to iMax
40838>>>>>>>            For iItem from 0 to iMax
40844>>>>>>>>
40844>>>>>>>                If (iItem<>0) Begin
40846>>>>>>>                    Move (sValue*"and") to sValue
40847>>>>>>>                End
40847>>>>>>>>
40847>>>>>>>                Move (sValue*_SQL_WhereClauseSegment(Self,strQ,strQ.aFilters[iItem],hoTQ)) to sValue
40848>>>>>>>            Loop
40849>>>>>>>>
40849>>>>>>>            Move (iMax>=0) to bAddAND
40850>>>>>>>            Move (SizeOfArray(strQ.aFilterExpressions)-1) to iMax
40851>>>>>>>            For iItem from 0 to iMax
40857>>>>>>>>
40857>>>>>>>                If (iItem>0 or bAddAND) Begin
40859>>>>>>>                    Move (sValue*"and") to sValue
40860>>>>>>>                End
40860>>>>>>>>
40860>>>>>>>                Move (sValue*_SQL_WhereClauseExpressionSegment(Self,strQ,strQ.aFilterExpressions[iItem].aSubExpressions,hoTQ)) to sValue
40861>>>>>>>            Loop
40862>>>>>>>>
40862>>>>>>>            Function_Return sValue
40863>>>>>>>        End_Function
40864>>>>>>>
40864>>>>>>>        Function _SQL_OrderByClause tTableQuery strQ Integer hoTQ Returns String
40866>>>>>>>            Integer iItem iMax iTable iColumn
40866>>>>>>>            String sValue sColumnName
40866>>>>>>>            Move (SizeOfArray(strQ.aOrdering)-1) to iMax
40867>>>>>>>            For iItem from 0 to iMax
40873>>>>>>>>
40873>>>>>>>                If (iItem<>0) Begin
40875>>>>>>>                    Move (sValue+", ") to sValue
40876>>>>>>>                End
40876>>>>>>>>
40876>>>>>>>                Move strQ.aOrdering[iItem].strValueSource.iTable to iTable
40877>>>>>>>                Move strQ.aOrdering[iItem].strValueSource.iColumn to iColumn
40878>>>>>>>                Get _SQL_ColumnName strQ hoTQ iTable iColumn to sColumnName
40879>>>>>>>                Move (sValue+sColumnName) to sValue
40880>>>>>>>                If (strQ.aOrdering[iItem].strValueSource.iType=tqSTRING) Begin
40882>>>>>>>                    Move (sValue+" collate "+psCollation(Self)) to sValue
40883>>>>>>>                End
40883>>>>>>>>
40883>>>>>>>                If (strQ.aOrdering[iItem].bDescending) Begin
40885>>>>>>>                    Move (sValue*"DESC") to sValue
40886>>>>>>>                End
40886>>>>>>>>
40886>>>>>>>                // ToDo: uppercase ordering
40886>>>>>>>//                If (strQ.aOrdering[iItem].bUppercase) Begin
40886>>>>>>>//                    // Somethings wrong here. And it's not the 'lower' instead of 'upper'
40886>>>>>>>//                    Move (sValue*"lower("+sValue+")") to sValue
40886>>>>>>>//                End
40886>>>>>>>            Loop
40887>>>>>>>>
40887>>>>>>>            Function_Return sValue
40888>>>>>>>        End_Function
40889>>>>>>>
40889>>>>>>>    Function _SQLSelectStatement tTableQuery strQ Integer hoTQ Returns String
40891>>>>>>>        String sStatement
40891>>>>>>>
40891>>>>>>>        Move "select" to sStatement
40892>>>>>>>
40892>>>>>>>        If (strQ.iLimit>0) Begin
40894>>>>>>>            Move (sStatement*"top "+String(strQ.iLimit)) to sStatement
40895>>>>>>>        End
40895>>>>>>>>
40895>>>>>>>        If (strQ.iLimit<0) Begin
40897>>>>>>>            Move (sStatement*"bottom "+String(0-strQ.iLimit)) to sStatement
40898>>>>>>>        End
40898>>>>>>>>
40898>>>>>>>
40898>>>>>>>        Move (sStatement*_SQL_SelectColumns(Self,strQ,hoTQ)) to sStatement
40899>>>>>>>
40899>>>>>>>        Move (sStatement*" from") to sStatement
40900>>>>>>>
40900>>>>>>>        Move (sStatement*_SQL_OuterLeftJoins(Self,strQ,hoTQ)) to sStatement // related records
40901>>>>>>>
40901>>>>>>>        Move (sStatement*_SQL_InnerJoins(Self,strQ,hoTQ)) to sStatement // find child records for each parent
40902>>>>>>>
40902>>>>>>>        If (SizeOfArray(strQ.aFilters)<>0 or SizeOfArray(strQ.aFilterExpressions)<>0) Begin
40904>>>>>>>            Move (sStatement*" where") to sStatement
40905>>>>>>>            Move (sStatement*_SQL_WhereClause(Self,strQ,hoTQ)) to sStatement
40906>>>>>>>        End
40906>>>>>>>>
40906>>>>>>>        If (SizeOfArray(strQ.aOrdering)<>0) Begin
40908>>>>>>>            Move (sStatement*" order by") to sStatement
40909>>>>>>>            Move (sStatement*_SQL_OrderByClause(Self,strQ,hoTQ)) to sStatement
40910>>>>>>>        End
40910>>>>>>>>
40910>>>>>>>        Function_Return sStatement
40911>>>>>>>    End_Function
40912>>>>>>>
40912>>>>>>>    Function _SQLDeleteStatement tTableQuery strQ Integer hoTQ Returns String
40914>>>>>>>        String sStatement
40914>>>>>>>
40914>>>>>>>        Move "delete" to sStatement
40915>>>>>>>
40915>>>>>>>//        If (strQ.iLimit<>0) Begin
40915>>>>>>>//            Send OnError 742 "Limit not allowed on delete statement"
40915>>>>>>>//            Function_Return "" // Error
40915>>>>>>>//        End
40915>>>>>>>//        
40915>>>>>>>//        If (SizeOfArray(strQ.aColumnSources)>0) Begin
40915>>>>>>>//            Send OnError 743 "Result column not allowed on delete statement"
40915>>>>>>>//            Function_Return "" // Error
40915>>>>>>>//        End
40915>>>>>>>
40915>>>>>>>        Move (sStatement*" from") to sStatement
40916>>>>>>>
40916>>>>>>>        Move (sStatement*_SQL_OuterLeftJoins(Self,strQ,hoTQ)) to sStatement // related records
40917>>>>>>>
40917>>>>>>>        Move (sStatement*_SQL_InnerJoins(Self,strQ,hoTQ)) to sStatement // find child records for each parent
40918>>>>>>>
40918>>>>>>>        If (SizeOfArray(strQ.aFilters)<>0 or SizeOfArray(strQ.aFilterExpressions)<>0) Begin
40920>>>>>>>            Move (sStatement*" where") to sStatement
40921>>>>>>>            Move (sStatement*_SQL_WhereClause(Self,strQ,hoTQ)) to sStatement
40922>>>>>>>        End
40922>>>>>>>>
40922>>>>>>>
40922>>>>>>>//        If (SizeOfArray(strQ.aOrdering)>0) Begin
40922>>>>>>>//            Send OnError 744 "Ordering not allowed on delete statement"
40922>>>>>>>//            Function_Return "" // Error
40922>>>>>>>//        End
40922>>>>>>>
40922>>>>>>>        Function_Return sStatement
40923>>>>>>>    End_Function
40924>>>>>>>End_Class
40925>>>>>>>
40925>>>>>>>Class cTableQueryFunctions is a cObject
40926>>>>>>>
40926>>>>>>>    Procedure Construct_Object
40928>>>>>>>        Forward Send Construct_Object
40930>>>>>>>
40930>>>>>>>        Property Number _pnPrefetchAvoidanceFactor // Temporary property used by index rating sort algorithm
40931>>>>>>>
40931>>>>>>>        Object oSQLGeneratorMSSQLDRV is a cTableQuerySQL
40933>>>>>>>        End_Object
40934>>>>>>>
40934>>>>>>>        Property Handle phoSQLGeneratorMSSQLDRC (oSQLGeneratorMSSQLDRV(Self))
40935>>>>>>>    End_Procedure
40936>>>>>>>
40936>>>>>>>    Function Version Returns String
40938>>>>>>>// Function_Return "0.96" // 9-05-2012
40938>>>>>>>        // Fixed error in MSSQLDRV SQL generating when an ordering segment is both ASCII and descending
40938>>>>>>>        // Removed timing and track of current-record
40938>>>>>>>// Function_Return "0.97" // 10-05-2012
40938>>>>>>>        // Addded methods ResetResultSetColumns and ResetOrdering
40938>>>>>>>        // Fixed seeding error on backwards ASCII columns
40938>>>>>>>        // Bug in ResultColumnValue function fixed
40938>>>>>>>        // Bug in _FindFirstRecordAux function fixed (related to 'VFind GE')
40938>>>>>>>        // SQL handling of dates repaired
40938>>>>>>>        // Parent column filter bugfix. No longer ends up in jump-in/out filters by accident
40938>>>>>>>        // Fixed _ValidateQuery to correctly complain about over-constrain on parent table columns
40938>>>>>>>        // Public function SQLStatement renamed to SQLSelectStatement
40938>>>>>>>// Function_Return "0.98" // 29-11-2012
40938>>>>>>>        // SQL date handling is now also effective if column type is DF_DATETIME (may go wrong if value also has a time part)
40938>>>>>>>        // Implementation of private function _DeleteConstraint changed (old one still there for 15.1)
40938>>>>>>>        // Method DeleteRecords added (ignore, not tested)
40938>>>>>>>// Function_Return "0.99" // 04-04-2013
40938>>>>>>>        // Fixed bug in AddFilterTableColumn method.
40938>>>>>>>        // Comperators tqCONTAINS and tqIN have been removed.
40938>>>>>>>        // Filter evaluating for index seeding capacitance has been fixed. Until now filters on parent tables may have wronged the index selection process.
40938>>>>>>>        // Error handling changed. All errors are now declared as DFERR_PROGRAM. If cTableQueryFunctions is subclassed procedure OnError may be augmented to do otherwise.
40938>>>>>>>        // Function HasData was designed to check for data before the main finding loop was entered. It may now also meaningfully be called after the main loop to query if the loop had any data at all.
40938>>>>>>>        // Function FixedTables added. Returns an array of tables that are referenced as "fixed" during the execution of a query. So if I want to repeat the find loop of a particular tTableQuery variable at a later time, the record buffers of these fixed tables must be restored to that of the original query. Does this make sense?
40938>>>>>>>        // Similarly NotFixedTables has been added.
40938>>>>>>>        // Function Belongs added. Returns true if the record currently in the buffer of the query main table evaluates true against the filters of query variable passed.
40938>>>>>>>        // Procedure RestoreRecordBuffersOnQueryCompletion added. Use to have TQ restore all affected record buffers on find loop completion.
40938>>>>>>>// Function_Return "0.991" // 25-09-2013
40938>>>>>>>        Function_Return "0.992"
40939>>>>>>>    End_Function
40940>>>>>>>
40940>>>>>>>    Function NewQuery Integer iTable Returns tTableQuery
40942>>>>>>>        Integer iFilterTable iArg
40942>>>>>>>        tTableQuery strQuery
40942>>>>>>>        tTableQuery strQuery
40942>>>>>>>        Move iTable to strQuery.iTable
40943>>>>>>>        Move -1     to strQuery.iForceIndex
40944>>>>>>>        Move False  to strQuery.bForcePrefetch
40945>>>>>>>        Move False  to strQuery.bNoESQL
40946>>>>>>>        Move False  to strQuery.bRestoreRecordBuffersOnQueryCompletion
40947>>>>>>>        Move False  to strQuery._strControlBlock.bInitialized
40948>>>>>>>        Move False  to strQuery._strControlBlock.bCompiled
40949>>>>>>>        Move -1     to strQuery._strControlBlock.iQueryMethod
40950>>>>>>>        Move 0.1    to strQuery._strControlBlock.nPrefetchAvoidanceFactor
40951>>>>>>>        Move False  to strQuery._strControlBlock.strInnerJoinCB.bEnabled // (CB=Control Block)
40952>>>>>>>        Move False  to strQuery._strControlBlock.strInnerJoinCB.bInitialized
40953>>>>>>>        Move False  to strQuery._strControlBlock.bFilterExpressionActive
40954>>>>>>>        Move True   to strQuery._strCompiled.bIndexSeedSharpeningEnabled
40955>>>>>>>        Move False  to strQuery._strCompiled.bBackwards
40956>>>>>>>        Move -1     to strQuery._strCompiled.nENR
40957>>>>>>>        Move False  to strQuery._bOutputColumnsFixated
40958>>>>>>>        Send ReadTableDefinition of oOverlapColumnFunctions iTable // Make sure that oOverlapColumnFunctions knows about this table
40959>>>>>>>        If (num_arguments>1) Begin // For a while multiple parameters was allowed. Therefore this. Also for a while.
40961>>>>>>>            Error 343 "TQ: Illegal call to NewQuery"
40962>>>>>>>>
40962>>>>>>>        End
40962>>>>>>>>
40962>>>>>>>        Function_Return strQuery
40963>>>>>>>    End_Function
40964>>>>>>>    
40964>>>>>>>    Procedure OnError Integer iErrNo String sErrorText
40966>>>>>>>        Error DFERR_PROGRAM ("TQ-"+String(iErrNo)+": "+sErrorText)
40967>>>>>>>>
40967>>>>>>>    End_Procedure
40968>>>>>>>
40968>>>>>>>    //> If you have a 2 level scan (scanning orders, and order lines for each order) you can save execution time by creating
40968>>>>>>>    //> the sub-query only once and then call ReUse to reinitialise it.
40968>>>>>>>    //>
40968>>>>>>>    //> This is how you might go about it without the ReUse method:
40968>>>>>>>    //>
40968>>>>>>>    //>      Open Order
40968>>>>>>>    //>      Open OrderLin
40968>>>>>>>    //>      tTableQuery strOrderQuery strOrderlineQuery
40968>>>>>>>    //>
40968>>>>>>>    //>      Get NewQuery of oTQ Order.file_number to strOrderQuery
40968>>>>>>>    //>
40968>>>>>>>    //>      While (FindRecord(oTQ,&strOrderQuery))
40968>>>>>>>    //>          Get NewQuery of oTQ OrderLin.file_number to strOrderlineQuery // New query for each order
40968>>>>>>>    //>          Send AddFilterRelate of oTQ (&strOrderlineQuery) Order.file_number
40968>>>>>>>    //>          While (FindRecord(oTQ,&strOrderlineQuery))
40968>>>>>>>    //>          Loop
40968>>>>>>>    //>      Loop
40968>>>>>>>    //>
40968>>>>>>>    //> With the ReUse method you can skip the repeated "compilation" of the inner query:
40968>>>>>>>    //>
40968>>>>>>>    //>      Open Order
40968>>>>>>>    //>      Open OrderLin
40968>>>>>>>    //>      tTableQuery strOrderQuery strOrderlineQuery
40968>>>>>>>    //>      Get NewQuery of oTQ Order.file_number to strOrderQuery
40968>>>>>>>    //>      Get NewQuery of oTQ OrderLin.file_number to strOrderlineQuery
40968>>>>>>>    //>      Send AddFilterRelate of oTQ (&strOrderlineQuery) Order.file_number
40968>>>>>>>    //>
40968>>>>>>>    //>      While (FindRecord(oTQ,&strOrderQuery))
40968>>>>>>>    //>          Send ReUse of oTQ (&strOrderlineQuery)
40968>>>>>>>    //>          While (FindRecord(oTQ,&strOrderlineQuery))
40968>>>>>>>    //>          Loop
40968>>>>>>>    //>      Loop
40968>>>>>>>    //>
40968>>>>>>>    Procedure ReUse tTableQuery ByRef strQuery
40970>>>>>>>        Move False to strQuery._strControlBlock.bInitialized
40971>>>>>>>    End_Procedure
40972>>>>>>>
40972>>>>>>>    //> The scanning algorithm may transparantly to the FindRecord loop decide
40972>>>>>>>    //> to find all the rows in advance (if for example the desired output order
40972>>>>>>>    //> is incompatible with the optimum search order). But if you call ForcePrefind
40972>>>>>>>    //> you can force the algorithm to pre-find the rows regardless of whether it
40972>>>>>>>    //> is necessary (or not?).
40972>>>>>>>
40972>>>>>>>    //> This is relevant if editing indexed columns of the rows found during the
40972>>>>>>>    //> FindRecord loop.
40972>>>>>>>    //
40972>>>>>>>    //> ForcePrefetch has no relevance (but does no harm) when run on a SQL table because the
40972>>>>>>>    //> algorithm in this case generates an SQL statement via the driver. In this
40972>>>>>>>    //> mode way the rows are "pre-found" anyway.
40972>>>>>>>
40972>>>>>>>    Procedure ForcePrefetch tTableQuery ByRef strQuery // Records will be prefetched.
40974>>>>>>>        Move True to strQuery.bForcePrefetch
40975>>>>>>>    End_Procedure
40976>>>>>>>
40976>>>>>>>    //> Even if we are querying an SQL table we may have reasons to force TQ to use
40976>>>>>>>    //> the record oriented driver interface. This call does that:
40976>>>>>>>    //>
40976>>>>>>>    //>     Send ForcePrefetch of oTQ (&strQ)
40976>>>>>>>    //>
40976>>>>>>>    //> If in addition we also want to specify the cache parameters used by the
40976>>>>>>>    //> driver we can also specify prefetch count and cache timeout (for the
40976>>>>>>>    //> duration of the query:
40976>>>>>>>    //>
40976>>>>>>>    //>     Send ForcePrefetch of oTQ (&strQ) 1000 2000
40976>>>>>>>    //>
40976>>>>>>>    //> This sets the prefetch cache to 1000 records and cache timeout to 2 seconds
40976>>>>>>>    //> and this will most certaimly give you a boost compared to the default values
40976>>>>>>>    //> which are 10ms for both of them.
40976>>>>>>>
40976>>>>>>>    Procedure ForceNoESQL tTableQuery ByRef strQuery Integer iPrefetchSize Integer iCacheTimeoutMS // ESQL will not be applied
40978>>>>>>>        Move True to strQuery.bNoESQL
40979>>>>>>>        If  (num_arguments>1) Begin
40981>>>>>>>            Move True to strQuery._strControlBlock.strSQLCacheControl.bUseSettings
40982>>>>>>>            Move iPrefetchSize to strQuery._strControlBlock.strSQLCacheControl.iPrefetchRecordCount
40983>>>>>>>            If (num_arguments>2) Begin
40985>>>>>>>                Move iCacheTimeoutMS to strQuery._strControlBlock.strSQLCacheControl.iPrefetchRecordTimeout
40986>>>>>>>            End
40986>>>>>>>>
40986>>>>>>>            Else Begin
40987>>>>>>>                Move 0 to strQuery._strControlBlock.strSQLCacheControl.iPrefetchRecordTimeout
40988>>>>>>>            End
40988>>>>>>>>
40988>>>>>>>        End
40988>>>>>>>>
40988>>>>>>>        Else Begin
40989>>>>>>>            Move False to strQuery._strControlBlock.strSQLCacheControl.bUseSettings
40990>>>>>>>        End
40990>>>>>>>>
40990>>>>>>>    End_Procedure
40991>>>>>>>
40991>>>>>>>    //> Don't evaluate, just use iIndex I tell you. Ignored by ESQL
40991>>>>>>>    Procedure ForceIndex tTableQuery ByRef strQuery Integer iIndex 
40993>>>>>>>        Move iIndex to strQuery.iForceIndex
40994>>>>>>>    End_Procedure
40995>>>>>>>
40995>>>>>>>    //> Limit number of rows in the result set.
40995>>>>>>>    Procedure SetLimit tTableQuery ByRef strQuery Integer iLimit 
40997>>>>>>>        Move iLimit to strQuery.iLimit
40998>>>>>>>    End_Procedure
40999>>>>>>>
40999>>>>>>>//    Procedure SetExpectedNumberOfRecords tTableQuery ByRef strQuery Integer iResultSetSize // Just a thought
40999>>>>>>>//    End_Procedure
40999>>>>>>>
40999>>>>>>>    //> Use this table name when generating ESQL rather than the default one. Because I tell you to!
40999>>>>>>>    Procedure ForceSQLTableName tTableQuery ByRef strQuery String sSqlTableName 
41001>>>>>>>        Move sSqlTableName to strQuery.sForceSQLTableName
41002>>>>>>>    End_Procedure
41003>>>>>>>
41003>>>>>>>    //> DANGER! Completely overtakes the scene. Make sure to "select" the columns expected by TQ
41003>>>>>>>    Procedure ForceSQLStatement tTableQuery ByRef strQuery String sSQLStatement 
41005>>>>>>>        Move sSQLStatement to strQuery.sForceSQLStatement
41006>>>>>>>    End_Procedure
41007>>>>>>>
41007>>>>>>>    Procedure RestoreRecordBuffersOnQueryCompletion tTableQuery ByRef strQuery Boolean bState
41009>>>>>>>        Move bState to strQuery.bRestoreRecordBuffersOnQueryCompletion
41010>>>>>>>    End_Procedure
41011>>>>>>>
41011>>>>>>>    //> Use LogTag to distinguish between different FindRecord loops in the log. Or
41011>>>>>>>    //> between different situations in different runs of the same FindLoop. When this is set, TQ 
41011>>>>>>>    //> will create a record in an un-listed log table by the name of (LogTableName(oTQ,strQuery))
41011>>>>>>>    Procedure SetLogTag tTableQuery ByRef strQuery String sTag
41013>>>>>>>        Move sTag to strQuery._strControlBlock.sLogTag
41014>>>>>>>    End_Procedure
41015>>>>>>>
41015>>>>>>>    //> Call BreakScan to terminate the FindRecord loop on next iteration. Note that when (explicitly or implicitly) we have set
41015>>>>>>>    //> the bForcePrefetch attribute, this will not be effective until we enter the actual find-loop. Which in that case will be
41015>>>>>>>    //> after all the rows have been found.
41015>>>>>>>    Procedure BreakScan tTableQuery ByRef strQuery
41017>>>>>>>        Move True to strQuery._strControlBlock.bBreakScan
41018>>>>>>>    End_Procedure
41019>>>>>>>
41019>>>>>>>    //> After query execution this will return an (english) string: "So many selected rows in so many finds"
41019>>>>>>>    Function StatisticsString tTableQuery strQuery Returns String
41021>>>>>>>        Integer iFound iSelect
41021>>>>>>>        Move strQuery._strControlBlock.iFindCount to iFound
41022>>>>>>>        Move strQuery._strControlBlock.iSelectCount to iSelect
41023>>>>>>>        Function_Return (String(iSelect)+" selected rows (in "+String(iFound)+" finds)")
41024>>>>>>>    End_Function
41025>>>>>>>
41025>>>>>>>    //> Returns the number of milliseconds it takes to make an "empty" round-trip to the SQL server. It makes at least 4 server calls.
41025>>>>>>>    Function ZeroSelectTime Integer iTable Returns Number
41027>>>>>>>        tSystemTimeMS strStart strStop
41027>>>>>>>        tSystemTimeMS strStart strStop
41027>>>>>>>        tTableQuery strQuery
41027>>>>>>>        tTableQuery strQuery
41027>>>>>>>        Boolean bFound
41027>>>>>>>
41027>>>>>>>        Get NewQuery iTable to strQuery
41028>>>>>>>        Send ForceSQLStatement (&strQuery) "select 1"
41029>>>>>>>        Repeat
41029>>>>>>>>
41029>>>>>>>            Get FindRecord (&strQuery) to bFound
41030>>>>>>>        Until (not(bFound))
41032>>>>>>>
41032>>>>>>>        Send ReUse (&strQuery)
41033>>>>>>>        Get SystemTimeMilliSeconds of oDateFunctions to strStart // We time the second loop (in case the first loop had to set up a connection)
41034>>>>>>>        Repeat
41034>>>>>>>>
41034>>>>>>>            Get FindRecord (&strQuery) to bFound
41035>>>>>>>        Until (not(bFound))
41037>>>>>>>
41037>>>>>>>        Get SystemTimeMilliSeconds of oDateFunctions to strStop
41038>>>>>>>        Function_Return (SystemTimeMilliSecondsElapsed(oDateFunctions,strStart, strStop))
41039>>>>>>>    End_Function
41040>>>>>>>
41040>>>>>>>        //> Returns the table name of iTable as used (in SQL staments) in the strQuery context.
41040>>>>>>>        Function TableName tTableQuery strQuery Integer iTable Returns String
41042>>>>>>>            Integer iRelateItem
41042>>>>>>>            String sValue
41042>>>>>>>            If (iTable=strQuery.iTable) Begin
41044>>>>>>>                Move strQuery.sForceSQLTableName to sValue
41045>>>>>>>            End
41045>>>>>>>>
41045>>>>>>>            Else Begin
41046>>>>>>>                Get _FindTableRelation strQuery iTable to iRelateItem
41047>>>>>>>                If (iRelateItem>=0) Begin
41049>>>>>>>                    Move strQuery.aTableRelations[iRelateItem].sForceSQLTableName to sValue
41050>>>>>>>                End
41050>>>>>>>>
41050>>>>>>>            End
41050>>>>>>>>
41050>>>>>>>            If (sValue="") Begin
41052>>>>>>>                Get_Attribute DF_FILE_LOGICAL_NAME of iTable to sValue
41055>>>>>>>            End
41055>>>>>>>>
41055>>>>>>>            If (sValue="") Begin
41057>>>>>>>                Send OnError 701 ("Table name could not be found for table "+String(iTable))
41058>>>>>>>            End
41058>>>>>>>>
41058>>>>>>>
41058>>>>>>>            Function_Return sValue
41059>>>>>>>        End_Function
41060>>>>>>>
41060>>>>>>>        //> Returns column name of iTable.iColumn as used (in SQL staments) in the strQuery context.
41060>>>>>>>        Function ColumnName tTableQuery strQuery Integer iTable Integer iColumn Boolean bIncludeTableName Returns String
41062>>>>>>>            String sColumnName sTableName
41062>>>>>>>            Get_Attribute DF_FIELD_NAME of iTable iColumn to sColumnName
41065>>>>>>>            If (sColumnName<>"") Begin
41067>>>>>>>                If (bIncludeTableName) Begin
41069>>>>>>>                    Get TableName strQuery iTable iColumn to sTableName
41070>>>>>>>                    Function_Return (sTableName+"."+sColumnName)
41071>>>>>>>                End
41071>>>>>>>>
41071>>>>>>>                Else Begin
41072>>>>>>>                    Function_Return sColumnName
41073>>>>>>>                End
41073>>>>>>>>
41073>>>>>>>            End
41073>>>>>>>>
41073>>>>>>>            Function_Return ""
41074>>>>>>>        End_Function
41075>>>>>>>
41075>>>>>>>        Function ComperatorID2String Integer iComp Returns String
41077>>>>>>>            If (iComp=tqLT) Function_Return "<"
41080>>>>>>>            If (iComp=tqLE) Function_Return "<="
41083>>>>>>>            If (iComp=tqEQ) Function_Return "="
41086>>>>>>>            If (iComp=tqGE) Function_Return ">="
41089>>>>>>>            If (iComp=tqGT) Function_Return ">"
41092>>>>>>>            If (iComp=tqNE) Function_Return "<>"
41095>>>>>>>//            If (iComp=tqIN) Function_Return "in"
41095>>>>>>>//            If (iComp=tqCONTAINS) Function_Return "contains"
41095>>>>>>>            If (iComp=tqMATCH) Function_Return "match"
41098>>>>>>>            If (iComp=tqUCMATCH) Function_Return "ucmatch"
41101>>>>>>>            Function_Return "error"
41102>>>>>>>        End_Function
41103>>>>>>>
41103>>>>>>>        Function ComperatorID2ComperatorString Integer iComp Returns String
41105>>>>>>>            If (iComp=tqLT) Function_Return "tqLT"
41108>>>>>>>            If (iComp=tqLE) Function_Return "tqLE"
41111>>>>>>>            If (iComp=tqEQ) Function_Return "tqEQ"
41114>>>>>>>            If (iComp=tqGE) Function_Return "tqGE"
41117>>>>>>>            If (iComp=tqGT) Function_Return "tqGT"
41120>>>>>>>            If (iComp=tqNE) Function_Return "tqNE"
41123>>>>>>>//            If (iComp=tqIN) Function_Return "tqIN"
41123>>>>>>>//            If (iComp=tqCONTAINS) Function_Return "tqCONTAINS"
41123>>>>>>>            If (iComp=tqMATCH) Function_Return "tqMATCH"
41126>>>>>>>            If (iComp=tqUCMATCH) Function_Return "tqUCMATCH"
41129>>>>>>>        End_Function
41130>>>>>>>
41130>>>>>>>        Function ComperatorString2ID String sComp Returns Integer
41132>>>>>>>            Integer iMax iItem
41132>>>>>>>            Move (_tqComparisonMax-1) to iMax
41133>>>>>>>            Move (Lowercase(sComp)) to sComp
41134>>>>>>>            For iItem from 0 to iMax
41140>>>>>>>>
41140>>>>>>>                If (sComp=Lowercase(ComperatorID2String(Self,iItem))) Begin
41142>>>>>>>                    Function_Return iItem
41143>>>>>>>                End
41143>>>>>>>>
41143>>>>>>>            Loop
41144>>>>>>>>
41144>>>>>>>            Function_Return -1 // not found
41145>>>>>>>        End_Function
41146>>>>>>>
41146>>>>>>>    Procedure AddOrderBy tTableQuery ByRef strQuery Integer iTable Integer iColumn Boolean bDescending Boolean bUppercase
41148>>>>>>>        Integer iCount iRelateItem
41148>>>>>>>        Move (SizeOfArray(strQuery.aOrdering)) to iCount
41149>>>>>>>        Move iTable to strQuery.aOrdering[iCount].strValueSource.iTable
41150>>>>>>>        Move iColumn to strQuery.aOrdering[iCount].strValueSource.iColumn
41151>>>>>>>        Get _ColumnType iTable iColumn to strQuery.aOrdering[iCount].strValueSource.iType
41152>>>>>>>        If (num_arguments>=4) Begin
41154>>>>>>>            Move bDescending to strQuery.aOrdering[iCount].bDescending
41155>>>>>>>        End
41155>>>>>>>>
41155>>>>>>>        Else Begin
41156>>>>>>>            Move False to strQuery.aOrdering[iCount].bDescending
41157>>>>>>>        End
41157>>>>>>>>
41157>>>>>>>        If (num_arguments>=5) Begin
41159>>>>>>>            Move bUppercase to strQuery.aOrdering[iCount].bUppercase
41160>>>>>>>        End
41160>>>>>>>>
41160>>>>>>>        Else Begin
41161>>>>>>>            Move False to strQuery.aOrdering[iCount].bUppercase
41162>>>>>>>        End
41162>>>>>>>>
41162>>>>>>>        If (iTable<>strQuery.iTable) Begin
41164>>>>>>>            // We will also check if this parent table is accessible via the known table relations:
41164>>>>>>>            Get _FindTableRelation strQuery iTable to iRelateItem
41165>>>>>>>            If (iRelateItem=-1) Begin
41167>>>>>>>                Send OnError 702 ("Unknown table relation to table "+String(iTable))
41168>>>>>>>            End
41168>>>>>>>>
41168>>>>>>>            Else Begin
41169>>>>>>>                // We're ordering by a parent table column which makes us have to prefetch the result:
41169>>>>>>>                Move True to strQuery.bForcePrefetch
41170>>>>>>>            End
41170>>>>>>>>
41170>>>>>>>        End
41170>>>>>>>>
41170>>>>>>>    End_Procedure
41171>>>>>>>
41171>>>>>>>    //> Delete all ordering information from the strQuery variable
41171>>>>>>>    Procedure ResetOrdering tTableQuery ByRef strQuery
41173>>>>>>>        // Check that the query is not already executing
41173>>>>>>>        If (strQuery._strControlBlock.bInitialized) Begin
41175>>>>>>>            Send OnError 740 "ResetOrdering called while query is executing"
41176>>>>>>>        End
41176>>>>>>>>
41176>>>>>>>        Else Begin
41177>>>>>>>            Move (ResizeArray(strQuery.aOrdering,0)) to strQuery.aOrdering
41178>>>>>>>        End
41178>>>>>>>>
41178>>>>>>>    End_Procedure
41179>>>>>>>    
41179>>>>>>>    Function _FindOrderBySegment tTableQuery strQuery Integer iTable Integer iColumn Returns Integer
41181>>>>>>>        Integer iItem iItemMax
41181>>>>>>>        Move (SizeOfArray(strQuery.aOrdering)-1) to iItemMax
41182>>>>>>>        For iItem from 0 to iItemMax
41188>>>>>>>>
41188>>>>>>>            If (iTable=strQuery.aOrdering[iItem].strValueSource.iTable and iColumn=strQuery.aOrdering[iItem].strValueSource.iColumn) Begin
41190>>>>>>>                Function_Return iItem
41191>>>>>>>            End
41191>>>>>>>>
41191>>>>>>>        Loop
41192>>>>>>>>
41192>>>>>>>        Function_Return -1 // Not found
41193>>>>>>>    End_Function
41194>>>>>>>
41194>>>>>>>    //> Shorthand for sending the AddOrdering a number of times to match the factual search order of a particular index. It's hard to explain why you'd do it, but I have.
41194>>>>>>>    Procedure SetOrderByToIndex tTableQuery ByRef strQuery Integer iIndex
41196>>>>>>>        tOCIndex strIndex
41196>>>>>>>        tOCIndex strIndex
41196>>>>>>>        Integer iSegment iSegments
41196>>>>>>>        Get IndexDefinition of oOverlapColumnFunctions strQuery.iTable iIndex to strIndex
41197>>>>>>>        Move (SizeOfArray(strIndex.aSegments)-1) to iSegments
41198>>>>>>>        For iSegment from 0 to iSegments
41204>>>>>>>>
41204>>>>>>>            Send AddOrderBy (&strQuery) strQuery.iTable strIndex.aSegments[iSegment].iColumn strIndex.aSegments[iSegment].bDescending strIndex.aSegments[iSegment].bUppercase
41205>>>>>>>        Loop
41206>>>>>>>>
41206>>>>>>>    End_Procedure
41207>>>>>>>
41207>>>>>>>        Function _ColumnType Integer iTable Integer iColumn Returns Integer
41209>>>>>>>            Integer iVdfType
41209>>>>>>>            Get_Attribute DF_FIELD_TYPE of iTable iColumn to iVdfType
41212>>>>>>>            If (iVdfType=DF_ASCII) Function_Return tqSTRING
41215>>>>>>>            If (iVdfType=DF_OVERLAP) Function_Return tqSTRING
41218>>>>>>>            If (iVdfType=DF_BCD) Function_Return tqNUMBER
41221>>>>>>>            If (iVdfType=DF_DATE) Function_Return tqDATE
41224>>>>>>>            If (iVdfType=DF_DATETIME) Function_Return tqDATETIME
41227>>>>>>>            If (iVdfType=DF_TEXT) Function_Return tqTEXT
41230>>>>>>>            Function_Return -1
41231>>>>>>>        End_Function
41232>>>>>>>
41232>>>>>>>    Procedure AddFilter tTableQuery ByRef strQuery Integer iTable Integer iColumn Integer iComp String sConstant
41234>>>>>>>        Integer iConstraintIndex iRelateItem
41234>>>>>>>        tTQFilterSegment strSegment
41234>>>>>>>        tTQFilterSegment strSegment
41234>>>>>>>        
41234>>>>>>>        Move iTable to strSegment.strLeftValue.iTable
41235>>>>>>>        Move iColumn to strSegment.strLeftValue.iColumn
41236>>>>>>>        Get _ColumnType iTable iColumn to strSegment.strLeftValue.iType
41237>>>>>>>        Move iComp to strSegment.iComp
41238>>>>>>>        Move sConstant to strSegment.strRightValue.sConstant
41239>>>>>>>        Get _ColumnType iTable iColumn to strSegment.strRightValue.iType
41240>>>>>>>
41240>>>>>>>        If (iTable<>strQuery.iTable) Begin
41242>>>>>>>            // Check if this parent table is accessible via the known table relations:
41242>>>>>>>            Get _FindTableRelation strQuery iTable to iRelateItem
41243>>>>>>>            If (iRelateItem=-1) Begin
41245>>>>>>>                Send OnError 703 ("Unknown table relation to table "+String(iTable))
41246>>>>>>>            End
41246>>>>>>>>
41246>>>>>>>        End
41246>>>>>>>>
41246>>>>>>>        
41246>>>>>>>        If (strQuery._strControlBlock.bFilterExpressionActive) Begin
41248>>>>>>>            Send FilterExpressionAddOperand (&strQuery) strSegment
41249>>>>>>>        End
41249>>>>>>>>
41249>>>>>>>        Else Begin
41250>>>>>>>            Move (SizeOfArray(strQuery.aFilters)) to iConstraintIndex
41251>>>>>>>            Move strSegment to strQuery.aFilters[iConstraintIndex]
41252>>>>>>>        End
41252>>>>>>>>
41252>>>>>>>    End_Procedure
41253>>>>>>>
41253>>>>>>>    Procedure AddFilterOrList tTableQuery ByRef strQuery Integer iTable Integer iColumn String[] aOrList
41255>>>>>>>        Integer iConstraintIndex iRelateItem
41255>>>>>>>        tTQFilterSegment strSegment
41255>>>>>>>        tTQFilterSegment strSegment
41255>>>>>>>
41255>>>>>>>        Move iTable to strSegment.strLeftValue.iTable
41256>>>>>>>        Move iColumn to strSegment.strLeftValue.iColumn
41257>>>>>>>        Get _ColumnType iTable iColumn to strSegment.strLeftValue.iType
41258>>>>>>>        Move tqEQ to strSegment.iComp
41259>>>>>>>        Move aOrList to strSegment.strRightValue.aOrList
41260>>>>>>>        Move 0 to strSegment.strRightValue._iOrListPointer
41261>>>>>>>        Get _ColumnType iTable iColumn to strSegment.strRightValue.iType
41262>>>>>>>
41262>>>>>>>        If (iTable<>strQuery.iTable) Begin
41264>>>>>>>            // Check if this parent table is accessible via the known table relations:
41264>>>>>>>            Get _FindTableRelation strQuery iTable to iRelateItem
41265>>>>>>>            If (iRelateItem=-1) Begin
41267>>>>>>>                Send OnError 704 ("Unknown table relation to table "+String(iTable))
41268>>>>>>>            End
41268>>>>>>>>
41268>>>>>>>        End
41268>>>>>>>>
41268>>>>>>>        
41268>>>>>>>        If (strQuery._strControlBlock.bFilterExpressionActive) Begin
41270>>>>>>>            Send FilterExpressionAddOperand (&strQuery) strSegment
41271>>>>>>>        End
41271>>>>>>>>
41271>>>>>>>        Else Begin
41272>>>>>>>            Move (SizeOfArray(strQuery.aFilters)) to iConstraintIndex
41273>>>>>>>            Move strSegment to strQuery.aFilters[iConstraintIndex]
41274>>>>>>>        End
41274>>>>>>>>
41274>>>>>>>    End_Procedure
41275>>>>>>>    
41275>>>>>>>    Procedure AddFilterTableColumn tTableQuery ByRef strQuery Integer iTable Integer iColumn Integer iComp Integer iFilterTable Integer iFilterColumn
41277>>>>>>>        Integer iConstraintIndex iRelateItem
41277>>>>>>>        tTQFilterSegment strSegment
41277>>>>>>>        tTQFilterSegment strSegment
41277>>>>>>>
41277>>>>>>>        Move iTable to strSegment.strLeftValue.iTable
41278>>>>>>>        Move iColumn to strSegment.strLeftValue.iColumn
41279>>>>>>>        Get _ColumnType iTable iColumn to strSegment.strLeftValue.iType
41280>>>>>>>        Move iComp to strSegment.iComp
41281>>>>>>>        Move iFilterTable to strSegment.strRightValue.iTable
41282>>>>>>>        Move iFilterColumn to strSegment.strRightValue.iColumn
41283>>>>>>>        Get _ColumnType iFilterTable iFilterColumn to strSegment.strRightValue.iType
41284>>>>>>>
41284>>>>>>>        If (strSegment.strLeftValue.iTable<>strQuery.iTable) Begin
41286>>>>>>>            // Check if left hand table is accessible via the known table relations:
41286>>>>>>>            Get _FindTableRelation strQuery strSegment.strLeftValue.iTable to iRelateItem
41287>>>>>>>            If (iRelateItem=-1) Begin
41289>>>>>>>                Send OnError 705 ("Unknown table relation to table "+String(strSegment.strLeftValue.iTable))
41290>>>>>>>            End
41290>>>>>>>>
41290>>>>>>>        End
41290>>>>>>>>
41290>>>>>>>
41290>>>>>>>        If (strQuery._strControlBlock.bFilterExpressionActive) Begin
41292>>>>>>>            Send FilterExpressionAddOperand (&strQuery) strSegment
41293>>>>>>>        End
41293>>>>>>>>
41293>>>>>>>        Else Begin
41294>>>>>>>            Move (SizeOfArray(strQuery.aFilters)) to iConstraintIndex
41295>>>>>>>            Move strSegment to strQuery.aFilters[iConstraintIndex]
41296>>>>>>>        End
41296>>>>>>>>
41296>>>>>>>    End_Procedure
41297>>>>>>>    
41297>>>>>>>        Procedure _AddConstrainRelateSegments tTableQuery ByRef strQuery Integer iTable Integer[] aColumns Integer iRelTable Integer[] aRelColumns
41299>>>>>>>            Integer iColumns iItem
41299>>>>>>>            Move (SizeOfArray(aColumns)-1) to iColumns
41300>>>>>>>            If ((iColumns+1)<>SizeOfArray(aRelColumns)) Begin
41302>>>>>>>                Send OnError 706 "Number of segments do not match in AddFilterRelate method"
41303>>>>>>>            End
41303>>>>>>>>
41303>>>>>>>            For iItem from 0 to iColumns
41309>>>>>>>>
41309>>>>>>>                If (iItem<>0 and strQuery._strControlBlock.bFilterExpressionActive) Begin
41311>>>>>>>                    Send FilterPressKey (&strQuery) tqKeyAND // Put and between the segments
41312>>>>>>>                End
41312>>>>>>>>
41312>>>>>>>                Send AddFilterTableColumn (&strQuery) iTable aColumns[iItem] tqEQ iRelTable aRelColumns[iItem]
41313>>>>>>>            Loop
41314>>>>>>>>
41314>>>>>>>        End_Procedure
41315>>>>>>>
41315>>>>>>>    Procedure AddFilterRelate tTableQuery ByRef strQuery Integer iParentTable
41317>>>>>>>        Integer iTable iColumn iColumns iRelTable iRelColumn
41317>>>>>>>        Boolean bAnyColumnsAtAll
41317>>>>>>>        Send ReadTableDefinition of oOverlapColumnFunctions iParentTable
41318>>>>>>>        Move strQuery.iTable to iTable
41319>>>>>>>        Move False to bAnyColumnsAtAll
41320>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iTable to iColumns
41323>>>>>>>        For iColumn from 1 to iColumns
41329>>>>>>>>
41329>>>>>>>            Get_Attribute DF_FIELD_RELATED_FILE of iTable iColumn to iRelTable
41332>>>>>>>            If (iRelTable=iParentTable) Begin
41334>>>>>>>                Get_Attribute DF_FIELD_RELATED_FIELD of iTable iColumn to iRelColumn
41337>>>>>>>                Send _AddConstrainRelateSegments (&strQuery) strQuery.iTable (TranslateOverlap(oOverlapColumnFunctions,iTable,iColumn)) iRelTable (TranslateOverlap(oOverlapColumnFunctions,iRelTable,iRelColumn))
41338>>>>>>>                Move True to bAnyColumnsAtAll
41339>>>>>>>            End
41339>>>>>>>>
41339>>>>>>>        Loop
41340>>>>>>>>
41340>>>>>>>        If (bAnyColumnsAtAll) Begin // If there were any segments relating we assume that the relation is good. If not we consider it an error of the table definitions.
41342>>>>>>>            // Tell the relationship handler that it should not worry about iParentTable. It is automatically and constantly related.
41342>>>>>>>            Send AddTableRelationFixedRecord (&strQuery) iParentTable 
41343>>>>>>>        End
41343>>>>>>>>
41343>>>>>>>        Else Begin
41344>>>>>>>            Send OnError 707 "Main query table does not relate to the parent table passed"
41345>>>>>>>        End
41345>>>>>>>>
41345>>>>>>>    End_Procedure
41346>>>>>>>
41346>>>>>>>    //> AddFilterRelateFixedRecord is equivalent to AddFilterRelate but it defines the
41346>>>>>>>    //> filter based on constant filters rather than dynamic "table column filters".
41346>>>>>>>    Procedure AddFilterRelateFixedRecord tTableQuery ByRef strQuery Integer iParentTable
41348>>>>>>>        Integer iTable iColumn iColumns iRelTable iRelColumn iIndex iMax
41348>>>>>>>        Integer[] aColumns aRelColumns
41350>>>>>>>        String sValue
41350>>>>>>>        Boolean bAnythingAtAll
41350>>>>>>>        Send ReadTableDefinition of oOverlapColumnFunctions iParentTable
41351>>>>>>>        Move strQuery.iTable to iTable
41352>>>>>>>        Move False to bAnythingAtAll
41353>>>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of iTable to iColumns
41356>>>>>>>        For iColumn from 1 to iColumns
41362>>>>>>>>
41362>>>>>>>            Get_Attribute DF_FIELD_RELATED_FILE of iTable iColumn to iRelTable
41365>>>>>>>            If (iRelTable=iParentTable) Begin
41367>>>>>>>                Get_Attribute DF_FIELD_RELATED_FIELD of iTable iColumn to iRelColumn
41370>>>>>>>                Get TranslateOverlap of oOverlapColumnFunctions iTable iColumn to aColumns
41371>>>>>>>                Get TranslateOverlap of oOverlapColumnFunctions iRelTable iRelColumn to aRelColumns
41372>>>>>>>                Move (SizeOfArray(aColumns)-1) to iMax
41373>>>>>>>                If ((iMax+1)=SizeOfArray(aRelColumns)) Begin
41375>>>>>>>                    Get_Field_Value iRelColumn aRelColumns[iIndex] to sValue
41378>>>>>>>                    Send AddFilter (&strQuery) iTable aColumns[iIndex] tqEQ sValue
41379>>>>>>>                    Move True to bAnythingAtAll
41380>>>>>>>                End
41380>>>>>>>>
41380>>>>>>>                Else Begin
41381>>>>>>>                    Send OnError 745 "Number of segments do not match in AddFilterRelateAsConstant method"
41382>>>>>>>                End
41382>>>>>>>>
41382>>>>>>>            End
41382>>>>>>>>
41382>>>>>>>        Loop
41383>>>>>>>>
41383>>>>>>>        If (not(bAnythingAtAll)) Begin // If there were any segments relating we assume that the relation is good. If not we consider it an error of the table definitions.
41385>>>>>>>            Send OnError 746 "Main query table does not relate to the parent table passed"
41386>>>>>>>        End
41386>>>>>>>>
41386>>>>>>>    End_Procedure
41387>>>>>>>  
41387>>>>>>>    Procedure FilterKeyPadOn tTableQuery ByRef strQuery
41389>>>>>>>        Integer iItem
41389>>>>>>>        If (strQuery._strControlBlock.bFilterExpressionActive) Begin
41391>>>>>>>            Send OnError 708 "Filter expression already active (keypad is already on)"
41392>>>>>>>        End
41392>>>>>>>>
41392>>>>>>>        Else Begin
41393>>>>>>>            Move (SizeOfArray(strQuery.aFilterExpressions)) to iItem
41394>>>>>>>            Move True to strQuery._strControlBlock.bFilterExpressionActive
41395>>>>>>>            Move False to strQuery.aFilterExpressions[iItem]._bOpen
41396>>>>>>>        End
41396>>>>>>>>
41396>>>>>>>    End_Procedure
41397>>>>>>>
41397>>>>>>>            Procedure _FilterExpressionAndOr tTQFilterExpression[] ByRef aSegments Integer iKey
41399>>>>>>>                Integer iItem
41399>>>>>>>                Move (SizeOfArray(aSegments)-1) to iItem
41400>>>>>>>                If (iItem>=0 and aSegments[iItem].iAndOr=_tqKeyNULL) Begin
41402>>>>>>>                    If (aSegments[iItem]._bOpen) Begin
41404>>>>>>>                        Send _FilterExpressionAndOr (&aSegments[iItem].aSubExpressions) iKey
41405>>>>>>>                    End
41405>>>>>>>>
41405>>>>>>>                    Else Begin
41406>>>>>>>                        Move iKey to aSegments[iItem].iAndOr
41407>>>>>>>                    End
41407>>>>>>>>
41407>>>>>>>                End
41407>>>>>>>>
41407>>>>>>>                Else Begin
41408>>>>>>>                    Send OnError 709 "Logical operator (AND/OR) not allowed"
41409>>>>>>>                End
41409>>>>>>>>
41409>>>>>>>            End_Procedure
41410>>>>>>>
41410>>>>>>>            Procedure _FilterExpressionNot tTQFilterExpression[] ByRef aSegments
41412>>>>>>>                Integer iItem
41412>>>>>>>                Move (SizeOfArray(aSegments)-1) to iItem
41413>>>>>>>                If (iItem>=0) Begin
41415>>>>>>>                    If (aSegments[iItem]._bOpen) Begin
41417>>>>>>>                        Send _FilterExpressionNot (&aSegments[iItem].aSubExpressions)
41418>>>>>>>                    End
41418>>>>>>>>
41418>>>>>>>                    Else Begin
41419>>>>>>>                        If (aSegments[iItem].iAndOr=_tqKeyNULL) Begin
41421>>>>>>>                            Move True to aSegments[iItem].bNot
41422>>>>>>>                        End
41422>>>>>>>>
41422>>>>>>>                        Else Begin
41423>>>>>>>                            Send OnError 710 "Logical operator (NOT) not allowed"
41424>>>>>>>                        End
41424>>>>>>>>
41424>>>>>>>                    End
41424>>>>>>>>
41424>>>>>>>                End
41424>>>>>>>>
41424>>>>>>>                Else Begin
41425>>>>>>>                    Send OnError 711 "Logical operator (NOT) not allowed"
41426>>>>>>>                End
41426>>>>>>>>
41426>>>>>>>            End_Procedure
41427>>>>>>>
41427>>>>>>>            Procedure _FilterExpressionLeftParenthesis tTQFilterExpression[] ByRef aSegments
41429>>>>>>>                Integer iItem
41429>>>>>>>                Move (SizeOfArray(aSegments)-1) to iItem
41430>>>>>>>                If (iItem>=0) Begin
41432>>>>>>>                    If (aSegments[iItem]._bOpen) Begin
41434>>>>>>>                        Send _FilterExpressionLeftParenthesis (&aSegments[iItem].aSubExpressions)
41435>>>>>>>                    End
41435>>>>>>>>
41435>>>>>>>                    Else Begin
41436>>>>>>>                        If (aSegments[iItem].iAndOr=_tqKeyNULL) Begin
41438>>>>>>>                            Move True to aSegments[iItem]._bOpen
41439>>>>>>>                        End
41439>>>>>>>>
41439>>>>>>>                        Else Begin
41440>>>>>>>                            Move True to aSegments[iItem+1]._bOpen
41441>>>>>>>                        End
41441>>>>>>>>
41441>>>>>>>                    End
41441>>>>>>>>
41441>>>>>>>                End
41441>>>>>>>>
41441>>>>>>>                Else Begin
41442>>>>>>>                    Send OnError 713 "'(' not allowed"
41443>>>>>>>                End
41443>>>>>>>>
41443>>>>>>>            End_Procedure
41444>>>>>>>
41444>>>>>>>            Procedure _FilterExpressionRightParenthesis tTQFilterExpression[] ByRef aSegments
41446>>>>>>>                Integer iItem
41446>>>>>>>                Move (SizeOfArray(aSegments)-1) to iItem
41447>>>>>>>                If (iItem>=0) Begin
41449>>>>>>>                    If (aSegments[iItem]._bOpen) Begin
41451>>>>>>>                        If (SizeOfArray(aSegments[iItem].aSubExpressions)=0 or not(aSegments[iItem].aSubExpressions[SizeOfArray(aSegments[iItem].aSubExpressions)-1]._bOpen)) Begin
41453>>>>>>>                            Move False to aSegments[iItem]._bOpen
41454>>>>>>>                        End
41454>>>>>>>>
41454>>>>>>>                        Else Begin
41455>>>>>>>                            Send _FilterExpressionRightParenthesis (&aSegments[iItem].aSubExpressions)
41456>>>>>>>                        End
41456>>>>>>>>
41456>>>>>>>                    End
41456>>>>>>>>
41456>>>>>>>                    Else Begin
41457>>>>>>>                        Send OnError 714 "')' not allowed"
41458>>>>>>>                    End
41458>>>>>>>>
41458>>>>>>>                End
41458>>>>>>>>
41458>>>>>>>                Else Begin
41459>>>>>>>                    Send OnError 715 "Empty sub-expression, ')' not allowed"
41460>>>>>>>                End
41460>>>>>>>>
41460>>>>>>>            End_Procedure
41461>>>>>>>
41461>>>>>>>        Procedure _FilterPressKey tTableQuery ByRef strQuery Integer iKey
41463>>>>>>>            Integer iActiveFilterExpression
41463>>>>>>>            If (strQuery._strControlBlock.bFilterExpressionActive) Begin
41465>>>>>>>                Move (SizeOfArray(strQuery.aFilterExpressions)-1) to iActiveFilterExpression
41466>>>>>>>                If (iKey=tqKeyAND or iKey=tqKeyOR) Begin
41468>>>>>>>                    Send _FilterExpressionAndOr (&strQuery.aFilterExpressions[iActiveFilterExpression].aSubExpressions) iKey
41469>>>>>>>                End
41469>>>>>>>>
41469>>>>>>>                Else If (iKey=tqKeyNOT) Begin
41472>>>>>>>                    Send _FilterExpressionNot (&strQuery.aFilterExpressions[iActiveFilterExpression].aSubExpressions)
41473>>>>>>>                End
41473>>>>>>>>
41473>>>>>>>                Else If (iKey=tqKeyPARLEFT or iKey=tqKeyPARRIGHT) Begin
41476>>>>>>>                    If (iKey=tqKeyPARLEFT) Begin
41478>>>>>>>                        Send _FilterExpressionLeftParenthesis (&strQuery.aFilterExpressions[iActiveFilterExpression].aSubExpressions)
41479>>>>>>>                    End
41479>>>>>>>>
41479>>>>>>>                    Else If (iKey=tqKeyPARRIGHT) Begin
41482>>>>>>>                        Send _FilterExpressionRightParenthesis (&strQuery.aFilterExpressions[iActiveFilterExpression].aSubExpressions)
41483>>>>>>>                    End
41483>>>>>>>>
41483>>>>>>>                End
41483>>>>>>>>
41483>>>>>>>                Else Begin
41484>>>>>>>                    Send OnError 716 "Unknown 'key' passed to FilterPressKey method"
41485>>>>>>>                End
41485>>>>>>>>
41485>>>>>>>            End
41485>>>>>>>>
41485>>>>>>>            Else Begin
41486>>>>>>>                Send OnError 717 "No active filter expression"
41487>>>>>>>            End
41487>>>>>>>>
41487>>>>>>>        End_Procedure
41488>>>>>>>
41488>>>>>>>    Procedure FilterPressKey tTableQuery ByRef strQuery Integer iKey
41490>>>>>>>        If (strQuery._strControlBlock.bFilterExpressionActive) Begin
41492>>>>>>>            Send _FilterPressKey (&strQuery) iKey
41493>>>>>>>        End
41493>>>>>>>>
41493>>>>>>>        Else Begin
41494>>>>>>>            Send OnError 718 "No active filter expression"
41495>>>>>>>        End
41495>>>>>>>>
41495>>>>>>>    End_Procedure
41496>>>>>>>
41496>>>>>>>        Procedure _FilterExpressionAddOperand tTableQuery ByRef strQuery tTQFilterExpression[] ByRef aFilterSegments tTQFilterSegment strConstrainSegment
41498>>>>>>>            Integer iItem
41498>>>>>>>//            Boolean bHasSubExp
41498>>>>>>>            Move (SizeOfArray(aFilterSegments)-1) to iItem
41499>>>>>>>            If (iItem>=0) Begin
41501>>>>>>>                If (aFilterSegments[iItem]._bOpen) Begin
41503>>>>>>>                    Send _FilterExpressionAddOperand (&strQuery) (&aFilterSegments[iItem].aSubExpressions) strConstrainSegment
41504>>>>>>>                End
41504>>>>>>>>
41504>>>>>>>                Else Begin
41505>>>>>>>//                    Move (SizeOfArray(aFilterSegments[iItem].aSubExpressions)>0) to bHasSubExp
41505>>>>>>>                    If (aFilterSegments[iItem].iAndOr=_tqKeyNULL) Begin // if operator has not been added
41507>>>>>>>                        Move strConstrainSegment to aFilterSegments[iItem].strOperand
41508>>>>>>>                    End
41508>>>>>>>>
41508>>>>>>>                    Else Begin // Operator has been added, well take the next segment
41509>>>>>>>                        Move strConstrainSegment to aFilterSegments[iItem+1].strOperand
41510>>>>>>>                    End
41510>>>>>>>>
41510>>>>>>>                End
41510>>>>>>>>
41510>>>>>>>            End
41510>>>>>>>>
41510>>>>>>>            Else Begin
41511>>>>>>>                Move strConstrainSegment to aFilterSegments[0].strOperand
41512>>>>>>>            End
41512>>>>>>>>
41512>>>>>>>        End_Procedure
41513>>>>>>>
41513>>>>>>>    Procedure FilterExpressionAddOperand tTableQuery ByRef strQuery tTQFilterSegment strFilterSegment
41515>>>>>>>        Integer iActiveFilterExpression
41515>>>>>>>        Move (SizeOfArray(strQuery.aFilterExpressions)-1) to iActiveFilterExpression
41516>>>>>>>        If (iActiveFilterExpression>=0) Begin
41518>>>>>>>            Send _FilterExpressionAddOperand (&strQuery) (&strQuery.aFilterExpressions[iActiveFilterExpression].aSubExpressions) strFilterSegment
41519>>>>>>>        End
41519>>>>>>>>
41519>>>>>>>        Else Begin
41520>>>>>>>            Send OnError 719 "No active expression filter"
41521>>>>>>>        End
41521>>>>>>>>
41521>>>>>>>    End_Procedure
41522>>>>>>>
41522>>>>>>>    Procedure FilterEnterOverAndOut tTableQuery ByRef strQuery
41524>>>>>>>        If (strQuery._strControlBlock.bFilterExpressionActive) Begin
41526>>>>>>>            Move False to strQuery._strControlBlock.bFilterExpressionActive
41527>>>>>>>        End
41527>>>>>>>>
41527>>>>>>>        Else Begin
41528>>>>>>>            Send OnError 720 "No active filter expression to close"
41529>>>>>>>        End
41529>>>>>>>>
41529>>>>>>>    End_Procedure
41530>>>>>>>
41530>>>>>>>        Function _ValidateQuery tTableQuery strQuery Returns Boolean
41532>>>>>>>            // Check that no more than 1 constraints is put on each column (allow for interval checking though)
41532>>>>>>>            Integer iConstrainMax iConstrainIndex iComp 
41532>>>>>>>            Integer iNewLoad iCurrentLoad iColumn
41532>>>>>>>            Integer iTable
41532>>>>>>>            Integer[][] aaConstrainLoads
41533>>>>>>>            Move (SizeOfArray(strQuery.aFilters)-1) to iConstrainMax
41534>>>>>>>            For iConstrainIndex from 0 to iConstrainMax
41540>>>>>>>>
41540>>>>>>>
41540>>>>>>>                Move strQuery.aFilters[iConstrainIndex].strLeftValue.iTable to iTable
41541>>>>>>>                
41541>>>>>>>                If (iTable>=SizeOfArray(aaConstrainLoads)) Begin
41543>>>>>>>                    Move 0 to aaConstrainLoads[iTable][0]
41544>>>>>>>                End
41544>>>>>>>>
41544>>>>>>>
41544>>>>>>>                // Check that no more than 1 constraints is put on each column (allow for interval checking though)
41544>>>>>>>                Move strQuery.aFilters[iConstrainIndex].iComp to iComp
41545>>>>>>>                If (iComp=tqGT or iComp=tqGE) Move 1 to iNewLoad      // 01
41548>>>>>>>                Else If (iComp=tqLT or iComp=tqLE) Move 2 to iNewLoad // 10
41552>>>>>>>                Else Move 3 to iNewLoad                               // 11
41554>>>>>>>
41554>>>>>>>                Move strQuery.aFilters[iConstrainIndex].strLeftValue.iColumn to iColumn
41555>>>>>>>                
41555>>>>>>>                If (iColumn>=SizeOfArray(aaConstrainLoads[iTable])) Begin
41557>>>>>>>                    Move 0 to iCurrentLoad
41558>>>>>>>                End
41558>>>>>>>>
41558>>>>>>>                Else Begin
41559>>>>>>>                    Move aaConstrainLoads[iTable][iColumn] to iCurrentLoad
41560>>>>>>>                End
41560>>>>>>>>
41560>>>>>>>                If (iNewLoad iand iCurrentLoad) Begin
41562>>>>>>>                    Send OnError 739 (Replace("#","Illegal filter. Column # is over-constrained",ColumnName(Self,strQuery,iTable,iColumn,True)))
41563>>>>>>>                    Function_Return False
41564>>>>>>>                End
41564>>>>>>>>
41564>>>>>>>                Move (iCurrentLoad+iNewLoad) to aaConstrainLoads[iTable][iColumn]
41565>>>>>>>
41565>>>>>>>                // ToDo: (maybe) Check that tables used for AddFilterRelate are not used as relate tables also.
41565>>>>>>>
41565>>>>>>>            Loop
41566>>>>>>>>
41566>>>>>>>            Function_Return True
41567>>>>>>>        End_Function
41568>>>>>>>
41568>>>>>>>        Function _IsTableFixed tTableQuery strQ Integer iTable Returns Boolean
41570>>>>>>>            Integer iRelateItem
41570>>>>>>>            If (iTable=strQ.iTable) Begin
41572>>>>>>>                Function_Return False // If it's the main table of the query it is definitely not fixed.
41573>>>>>>>            End
41573>>>>>>>>
41573>>>>>>>            Get _FindTableRelation strQ iTable to iRelateItem
41574>>>>>>>            If (iRelateItem<>-1) Begin
41576>>>>>>>                Function_Return strQ.aTableRelations[iRelateItem].bFixed
41577>>>>>>>            End
41577>>>>>>>>
41577>>>>>>>            Send OnError 735 ("Table not related: "+String(iTable))
41578>>>>>>>        End_Function
41579>>>>>>>
41579>>>>>>>        Function _ColumnRatings tTableQuery strQuery Returns Number[]
41581>>>>>>>            // Calculate an array of columns that can be used for jump-in /jump-out.
41581>>>>>>>            // If a column has a jump-in value or a jump-out value it is rated (apr) 0.5.
41581>>>>>>>            // If a column has both it is rated 2.0.
41581>>>>>>>            Integer iColumn
41581>>>>>>>            Integer iIndex iIndices
41581>>>>>>>            Integer iSegment iSegments
41581>>>>>>>            Integer iConstraint iConstraints
41581>>>>>>>            Integer iTable iComp
41581>>>>>>>
41581>>>>>>>            Number[] aColumnRatings
41582>>>>>>>            tOCTable strTable
41582>>>>>>>            tOCTable strTable
41582>>>>>>>
41582>>>>>>>            Move strQuery.iTable to iTable
41583>>>>>>>
41583>>>>>>>            Get TableDefinition of oOverlapColumnFunctions iTable to strTable
41584>>>>>>>
41584>>>>>>>            Move (SizeOfArray(strTable.aIndices)-1) to iIndices
41585>>>>>>>            Move (SizeOfArray(strQuery.aFilters)-1) to iConstraints
41586>>>>>>>            Move (ResizeArray(aColumnRatings,SizeOfArray(strTable.aColumns))) to aColumnRatings
41587>>>>>>>
41587>>>>>>>            For iIndex from 1 to iIndices
41593>>>>>>>>
41593>>>>>>>                Move (SizeOfArray(strTable.aIndices[iIndex].aSegments)-1) to iSegments
41594>>>>>>>
41594>>>>>>>                For iSegment from 0 to iSegments
41600>>>>>>>>
41600>>>>>>>                    Move strTable.aIndices[iIndex].aSegments[iSegment].iColumn to iColumn
41601>>>>>>>
41601>>>>>>>                    If (aColumnRatings[iColumn]=0) Begin // To avoid the same column getting added ratings because appearing in multiple indices
41603>>>>>>>
41603>>>>>>>                        For iConstraint from 0 to iConstraints
41609>>>>>>>>
41609>>>>>>>
41609>>>>>>>                            // Only evaluate filters that:
41609>>>>>>>                            //  1. (left side) filters on a column in the query main table
41609>>>>>>>                            //  2. (right side) does not filter on a column from a table that changes on each new main table record
41609>>>>>>>
41609>>>>>>>                            If ( strQuery.aFilters[iConstraint].strLeftValue.iTable=iTable and ;                                    ( strQuery.aFilters[iConstraint].strRightValue.iTable=0 or ;                                      _IsTableFixed(Self,strQuery,strQuery.aFilters[iConstraint].strRightValue.iTable) )) Begin
41611>>>>>>>
41611>>>>>>>                                Move strQuery.aFilters[iConstraint].iComp to iComp
41612>>>>>>>                                If (iColumn=strQuery.aFilters[iConstraint].strLeftValue.iColumn) Begin
41614>>>>>>>
41614>>>>>>>                                    If (iComp=tqEQ) Begin
41616>>>>>>>                                        Move 2 to aColumnRatings[iColumn]
41617>>>>>>>                                    End
41617>>>>>>>>
41617>>>>>>>                                    Else If (iComp=tqGE or iComp=tqGT) Begin
41620>>>>>>>                                        Move (aColumnRatings[iColumn]+0.49) to aColumnRatings[iColumn]
41621>>>>>>>                                    End
41621>>>>>>>>
41621>>>>>>>                                    Else If (iComp=tqLT or iComp=tqLE) Begin
41624>>>>>>>                                        Move (aColumnRatings[iColumn]+0.51) to aColumnRatings[iColumn]
41625>>>>>>>                                    End
41625>>>>>>>>
41625>>>>>>>                                    // Note: Using the values 0.49 and 0.51 is a trick to allow the consumer
41625>>>>>>>                                    //       of these data to determine whether the constraining operator
41625>>>>>>>                                    //       was Lx or Gx (or both). It means nothing to the final ranking
41625>>>>>>>                                    //       of the indices. They are both weighed by 0.5.
41625>>>>>>>                                End
41625>>>>>>>>
41625>>>>>>>                            End
41625>>>>>>>>
41625>>>>>>>                        Loop
41626>>>>>>>>
41626>>>>>>>                    End
41626>>>>>>>>
41626>>>>>>>                Loop
41627>>>>>>>>
41627>>>>>>>            Loop
41628>>>>>>>>
41628>>>>>>>
41628>>>>>>>            Function_Return aColumnRatings
41629>>>>>>>        End_Function
41630>>>>>>>
41630>>>>>>>            // If this returns true column iColumn is constrained to a fixed value. (If it is, the
41630>>>>>>>            // column may be discarded if appearing as a most-significant index segment)
41630>>>>>>>            Function _ColumnFixedByEqConstraint tTableQuery strQuery Integer iColumn Returns Boolean
41632>>>>>>>                Integer iConstraintIndex iConstraintMax
41632>>>>>>>                tTQFilterSegment strConstraint
41632>>>>>>>                tTQFilterSegment strConstraint
41632>>>>>>>
41632>>>>>>>                Move (SizeOfArray(strQuery.aFilters)-1) to iConstraintMax
41633>>>>>>>                For iConstraintIndex from 0 to iConstraintMax
41639>>>>>>>>
41639>>>>>>>                    Move strQuery.aFilters[iConstraintIndex] to strConstraint
41640>>>>>>>                    If (strConstraint.iComp=tqEQ and ;                        strConstraint.strLeftValue.iTable=strQuery.iTable and ;                        strConstraint.strLeftValue.iColumn=iColumn and ;                        SizeOfArray(strConstraint.strRightValue.aOrList)<2) Begin
41642>>>>>>>                        Function_Return True
41643>>>>>>>                    End
41643>>>>>>>>
41643>>>>>>>                Loop
41644>>>>>>>>
41644>>>>>>>                Function_Return False
41645>>>>>>>            End_Function
41646>>>>>>>
41646>>>>>>>            Function _IndexSegmentAgreement tTQOrderBySegment strOrderSegment Integer iTable tOCIndexSegment[] aIndexSegments Integer iIndexSegment Boolean bBackwards Boolean bEQ Returns Boolean
41648>>>>>>>                If (iIndexSegment<SizeOfArray(aIndexSegments)) Begin //If there is no more segments in the index then obviously we cant be in agreement
41650>>>>>>>                    If (strOrderSegment.strValueSource.iTable=iTable) Begin // If the required segment is of another table we're definately not in agreement
41652>>>>>>>                        If (strOrderSegment.strValueSource.iColumn=aIndexSegments[iIndexSegment].iColumn) Begin
41654>>>>>>>                            If (strOrderSegment.bUppercase=aIndexSegments[iIndexSegment].bUppercase) Begin
41656>>>>>>>                                If (bEQ) Begin // It doesn't matter if they don't match if we are under an EQ constraint
41658>>>>>>>                                    Function_Return True // So we just say: fine!
41659>>>>>>>                                End
41659>>>>>>>>
41659>>>>>>>                                // If we are not under an EQ constraint we have to consider the direction:
41659>>>>>>>                                If (bBackwards) Begin
41661>>>>>>>                                    If ((Integer(strOrderSegment.bDescending)+Integer(aIndexSegments[iIndexSegment].bDescending))=1) Begin // xor = if they are opposite
41663>>>>>>>                                        Function_Return True
41664>>>>>>>                                    End
41664>>>>>>>>
41664>>>>>>>                                End
41664>>>>>>>>
41664>>>>>>>                                Else Begin
41665>>>>>>>                                    If (strOrderSegment.bDescending=aIndexSegments[iIndexSegment].bDescending) Begin
41667>>>>>>>                                        Function_Return True
41668>>>>>>>                                    End
41668>>>>>>>>
41668>>>>>>>                                End
41668>>>>>>>>
41668>>>>>>>                            End
41668>>>>>>>>
41668>>>>>>>                        End
41668>>>>>>>>
41668>>>>>>>                    End
41668>>>>>>>>
41668>>>>>>>                End
41668>>>>>>>>
41668>>>>>>>                Function_Return False
41669>>>>>>>            End_Function
41670>>>>>>>            
41670>>>>>>>            // The index is trimmed in the sence that most-significant segments of the index are removed
41670>>>>>>>            // if they are bounded by an eq-constraint.
41670>>>>>>>            Function _TrimIndexSegments tTableQuery strQuery tOCIndexSegment[] aIndexSegments Returns tOCIndexSegment[]
41672>>>>>>>                Integer iSegments iSkipSegments
41672>>>>>>>                tOCIndexSegment[] aRemainingSegments
41672>>>>>>>                tOCIndexSegment[] aRemainingSegments
41673>>>>>>>                Move 0 to iSkipSegments
41674>>>>>>>                Move (SizeOfArray(aIndexSegments)-1) to iSegments
41675>>>>>>>                While (iSkipSegments<=iSegments and _ColumnFixedByEqConstraint(Self,strQuery,aIndexSegments[iSkipSegments].iColumn))
41679>>>>>>>                    Increment iSkipSegments
41680>>>>>>>                Loop
41681>>>>>>>>
41681>>>>>>>                If (SizeOfArray(aIndexSegments)>0) Begin
41683>>>>>>>                    Move (CopyArray(aIndexSegments,iSkipSegments,iSegments)) to aRemainingSegments
41684>>>>>>>                End
41684>>>>>>>>
41684>>>>>>>                Function_Return aRemainingSegments
41685>>>>>>>            End_Function
41686>>>>>>>            
41686>>>>>>>            Function _TrimOrderBySegments tTableQuery strQuery tTQOrderBySegment[] aOrderingBySegments Returns tTQOrderBySegment[]
41688>>>>>>>                Integer iTable
41688>>>>>>>                Integer iSegments iSkipSegments
41688>>>>>>>                tTQOrderBySegment[] aRemainingSegments
41688>>>>>>>                tTQOrderBySegment[] aRemainingSegments
41689>>>>>>>
41689>>>>>>>                Move strQuery.iTable to iTable
41690>>>>>>>                Move 0 to iSkipSegments
41691>>>>>>>                Move (SizeOfArray(aOrderingBySegments)-1) to iSegments
41692>>>>>>>                If (iSegments>=0) Begin
41694>>>>>>>                    While (iSkipSegments<=iSegments and aOrderingBySegments[iSkipSegments].strValueSource.iTable=iTable and _ColumnFixedByEqConstraint(Self,strQuery,aOrderingBySegments[iSkipSegments].strValueSource.iColumn))
41698>>>>>>>                        Increment iSkipSegments
41699>>>>>>>                    Loop
41700>>>>>>>>
41700>>>>>>>                    Move (CopyArray(aOrderingBySegments,iSkipSegments,iSegments)) to aRemainingSegments
41701>>>>>>>                End
41701>>>>>>>>
41701>>>>>>>                Function_Return aRemainingSegments
41702>>>>>>>            End_Function
41703>>>>>>>            
41703>>>>>>>        Function _IndexAgreement tTableQuery strQuery Integer iIndex Boolean bFinalDecision Returns Boolean
41705>>>>>>>            // Is the index in agreement with the specified output order?
41705>>>>>>>            // 
41705>>>>>>>            // For each segment in the desired output order it must be the case that it is a
41705>>>>>>>            // table column based segment and that either:
41705>>>>>>>            //  
41705>>>>>>>            //     1)   its value is fixed by a eq-constraint and all segments before it has been 
41705>>>>>>>            //          satisfied the same way (if the column happens to be the same as the
41705>>>>>>>            //          "next segment" in the index we're testing, then we must disregard that
41705>>>>>>>            //          segment from then on).
41705>>>>>>>            // or
41705>>>>>>>            //     2)   it is satisfied by the "next segment" in the index we're testing
41705>>>>>>>            //
41705>>>>>>>            tOCIndex              strIndex
41705>>>>>>>            tOCIndex              strIndex
41705>>>>>>>            tOCIndexSegment[]     aIndexSegments
41705>>>>>>>            tOCIndexSegment[]     aIndexSegments
41706>>>>>>>            tTQOrderBySegment[]   aOrderingSegments
41706>>>>>>>            tTQOrderBySegment[]   aOrderingSegments
41707>>>>>>>            _tTQValueSource       strValueSource
41707>>>>>>>            _tTQValueSource       strValueSource
41707>>>>>>>            
41707>>>>>>>            Boolean bOrderSegmentOK bIndexSegmentMatch
41707>>>>>>>            Boolean bBackwards bEq
41707>>>>>>>            Integer iIndexSegment iIndexSegments
41707>>>>>>>            Integer iOrderingSegment iOrderingSegments
41707>>>>>>>            Integer iConstraint
41707>>>>>>>            
41707>>>>>>>            If (strQuery._strCompiled.nENR=0) Begin // If index is fully specified all indices agree
41709>>>>>>>                Function_Return True
41710>>>>>>>            End
41710>>>>>>>>
41710>>>>>>>
41710>>>>>>>            If (bFinalDecision) Begin
41712>>>>>>>                Move strQuery._strCompiled.bBackwards to bBackwards
41713>>>>>>>            End
41713>>>>>>>>
41713>>>>>>>            Else Begin
41714>>>>>>>                If (iIndex>1000) Begin
41716>>>>>>>                    Move (iIndex-1000) to iIndex
41717>>>>>>>                    Move True to bBackwards
41718>>>>>>>                End
41718>>>>>>>>
41718>>>>>>>                Else Begin
41719>>>>>>>                    Move False to bBackwards
41720>>>>>>>                End
41720>>>>>>>>
41720>>>>>>>            End
41720>>>>>>>>
41720>>>>>>>            
41720>>>>>>>            Get IndexDefinition of oOverlapColumnFunctions strQuery.iTable iIndex to strIndex
41721>>>>>>>            
41721>>>>>>>            Get _TrimIndexSegments strQuery strIndex.aSegments to aIndexSegments
41722>>>>>>>            Get _TrimOrderBySegments strQuery strQuery.aOrdering to aOrderingSegments
41723>>>>>>>
41723>>>>>>>            Move (SizeOfArray(aIndexSegments)-1) to iIndexSegments
41724>>>>>>>            Move (SizeOfArray(aOrderingSegments)-1) to iOrderingSegments
41725>>>>>>>            
41725>>>>>>>            Move 0 to iIndexSegment
41726>>>>>>>            
41726>>>>>>>            For iOrderingSegment from 0 to iOrderingSegments
41732>>>>>>>>
41732>>>>>>>                Move False to bOrderSegmentOK
41733>>>>>>>                Move aOrderingSegments[iOrderingSegment].strValueSource to strValueSource
41734>>>>>>>                If (iOrderingSegment<=iIndexSegments and strValueSource.iTable=strQuery.iTable) Begin // If the order-segment is main-table-based
41736>>>>>>>                    
41736>>>>>>>                    Get _FindConstraintEQ strQuery.aFilters strQuery.iTable strValueSource.iColumn False to iConstraint
41737>>>>>>>                    Move (iConstraint<>-1) to bEq
41738>>>>>>>                    
41738>>>>>>>                    Get _IndexSegmentAgreement aOrderingSegments[iOrderingSegment] strQuery.iTable aIndexSegments iIndexSegment bBackwards bEq to bIndexSegmentMatch
41739>>>>>>>                    
41739>>>>>>>                    If (bIndexSegmentMatch) Begin
41741>>>>>>>                        Move True to bOrderSegmentOK
41742>>>>>>>                        Increment iIndexSegment
41743>>>>>>>                    End
41743>>>>>>>>
41743>>>>>>>                    Else Begin
41744>>>>>>>                        // If the segment is constrained by an EQ we are still in agreement
41744>>>>>>>                        If (_ColumnFixedByEqConstraint(Self,strQuery,strValueSource.iColumn)) Begin
41746>>>>>>>                            Move True to bOrderSegmentOK
41747>>>>>>>                        End
41747>>>>>>>>
41747>>>>>>>                    End
41747>>>>>>>>
41747>>>>>>>                End
41747>>>>>>>>
41747>>>>>>>
41747>>>>>>>                If (not(bOrderSegmentOK)) Begin
41749>>>>>>>                    Function_Return False
41750>>>>>>>                End
41750>>>>>>>>
41750>>>>>>>            Loop
41751>>>>>>>>
41751>>>>>>>            Function_Return True
41752>>>>>>>        End_Function
41753>>>>>>>
41753>>>>>>>        Function _IndexExpectedNumberRows tTableQuery strQuery Integer iIndex Number[] aColumnRatings _tTQIndexAnalysis strIndexA Returns Number
41755>>>>>>>            Boolean bAccept
41755>>>>>>>            Integer iTable iColumn
41755>>>>>>>            Integer iSegmentIndex iSegmentMax iPushIndex
41755>>>>>>>            Number nExpectedNumberRows 
41755>>>>>>>            tOCIndex strIndex
41755>>>>>>>            tOCIndex strIndex
41755>>>>>>>            Number nColumnRating
41755>>>>>>>            
41755>>>>>>>            If (iIndex>=1000) Begin
41757>>>>>>>                Move (iIndex-1000) to iIndex
41758>>>>>>>            End
41758>>>>>>>>
41758>>>>>>>
41758>>>>>>>            Move strQuery.iTable to iTable
41759>>>>>>>            Get_Attribute DF_FILE_RECORDS_USED of iTable to nExpectedNumberRows
41762>>>>>>>            Get IndexDefinition of oOverlapColumnFunctions iTable iIndex to strIndex
41763>>>>>>>            Move (SizeOfArray(strIndex.aSegments)) to iSegmentMax
41764>>>>>>>            
41764>>>>>>>            Move True to bAccept
41765>>>>>>>            Move 0 to iSegmentIndex
41766>>>>>>>            
41766>>>>>>>            While (bAccept and iSegmentIndex<iSegmentMax) // From l-to-r: get all consecutive EQ segments
41770>>>>>>>                Move strIndex.aSegments[iSegmentIndex].iColumn to iColumn
41771>>>>>>>                Move aColumnRatings[iColumn] to nColumnRating
41772>>>>>>>                Move (nColumnRating=2) to bAccept
41773>>>>>>>                If (bAccept) Begin
41775>>>>>>>                    Move (nExpectedNumberRows*strIndexA.aSegmentReductions[iSegmentIndex]) to nExpectedNumberRows
41776>>>>>>>                    Increment iSegmentIndex
41777>>>>>>>                End
41777>>>>>>>>
41777>>>>>>>            Loop
41778>>>>>>>>
41778>>>>>>>            
41778>>>>>>>            If (bAccept) Begin // Means that all segments have been provided eq constraints
41780>>>>>>>                Function_Return 0 // The best possible result    
41781>>>>>>>            End
41781>>>>>>>>
41781>>>>>>>            
41781>>>>>>>            Move iSegmentIndex to iPushIndex
41782>>>>>>>            Move True to bAccept
41783>>>>>>>            
41783>>>>>>>            While (bAccept and iSegmentIndex<iSegmentMax) // Continuing l-to-r: get all consecutive GE/GT segments
41787>>>>>>>                Move strIndex.aSegments[iSegmentIndex].iColumn to iColumn
41788>>>>>>>                Move aColumnRatings[iColumn] to nColumnRating
41789>>>>>>>                Move (nColumnRating>=1 or nColumnRating=0.49) to bAccept
41790>>>>>>>                If (bAccept) Begin
41792>>>>>>>                    Move (nExpectedNumberRows*0.5) to nExpectedNumberRows
41793>>>>>>>                    Increment iSegmentIndex
41794>>>>>>>                End
41794>>>>>>>>
41794>>>>>>>            Loop
41795>>>>>>>>
41795>>>>>>>
41795>>>>>>>            Move iPushIndex to iSegmentIndex
41796>>>>>>>            Move True to bAccept
41797>>>>>>>            
41797>>>>>>>            While (bAccept and iSegmentIndex<iSegmentMax) // Continuing l-to-r: get all consecutive LE/LT segments
41801>>>>>>>                Move strIndex.aSegments[iSegmentIndex].iColumn to iColumn
41802>>>>>>>                Move aColumnRatings[iColumn] to nColumnRating
41803>>>>>>>                Move (nColumnRating>=1 or nColumnRating=0.51) to bAccept
41804>>>>>>>                If (bAccept) Begin
41806>>>>>>>                    Move (nExpectedNumberRows*0.5) to nExpectedNumberRows
41807>>>>>>>                    Increment iSegmentIndex
41808>>>>>>>                End
41808>>>>>>>>
41808>>>>>>>            Loop
41809>>>>>>>>
41809>>>>>>>            Function_Return nExpectedNumberRows
41810>>>>>>>        End_Function
41811>>>>>>>
41811>>>>>>>        Function _IndexRating tTableQuery strQuery Integer iIndex Number[] aColumnRatings _tTQIndexAnalysis strIndexA Returns _tTQIndexRating
41813>>>>>>>            Integer iTable
41813>>>>>>>            _tTQIndexRating strRating
41813>>>>>>>            _tTQIndexRating strRating
41813>>>>>>>            Move strQuery.iTable to iTable
41814>>>>>>>            Move iIndex to strRating.iIndex
41815>>>>>>>            Get _IndexExpectedNumberRows strQuery iIndex aColumnRatings strIndexA to strRating.nExpectedNumberRows
41816>>>>>>>            If (strRating.nExpectedNumberRows=0) Begin
41818>>>>>>>                Move True to strRating.bOutputAgree
41819>>>>>>>            End
41819>>>>>>>>
41819>>>>>>>            Else Begin
41820>>>>>>>                Get _IndexAgreement strQuery iIndex False to strRating.bOutputAgree
41821>>>>>>>            End
41821>>>>>>>>
41821>>>>>>>            If (iIndex>=1000) Begin // find lt by index iIndex-1000
41823>>>>>>>                Move (iIndex-1000) to iIndex
41824>>>>>>>                Get_Attribute DF_INDEX_LEVELS of iTable iIndex 0 to strRating.iKeyLevels
41827>>>>>>>                Get_Attribute DF_INDEX_KEY_LENGTH of iTable iIndex 0 to strRating.iKeyLength
41830>>>>>>>                Move (strRating.iKeyLength+1) to strRating.iKeyLength // Always prefer find gt to find lt when all else is equal
41831>>>>>>>            End
41831>>>>>>>>
41831>>>>>>>            Else Begin
41832>>>>>>>                Get_Attribute DF_INDEX_LEVELS of iTable iIndex 0 to strRating.iKeyLevels
41835>>>>>>>                Get_Attribute DF_INDEX_KEY_LENGTH of iTable iIndex 0 to strRating.iKeyLength
41838>>>>>>>            End
41838>>>>>>>>
41838>>>>>>>
41838>>>>>>>            Function_Return strRating
41839>>>>>>>        End_Function
41840>>>>>>>
41840>>>>>>>        Function _IndexRatings tTableQuery strQuery Returns _tTQIndexRating[]
41842>>>>>>>            // Create an array of defined indices on the table and for each index assign a rating
41842>>>>>>>            // Sort the array of indices according to rating and pick the one with the highest one.
41842>>>>>>>            Integer iItem iMax 
41842>>>>>>>            Integer iIndex
41842>>>>>>>            Integer[] aIndices
41843>>>>>>>            Number[] aColumnRatings
41844>>>>>>>            tTQTableAnalysis strAnalysis
41844>>>>>>>            tTQTableAnalysis strAnalysis
41844>>>>>>>            _tTQIndexRating strRating
41844>>>>>>>            _tTQIndexRating strRating
41844>>>>>>>            _tTQIndexRating[] aIndexRatings
41844>>>>>>>            _tTQIndexRating[] aIndexRatings
41845>>>>>>>            
41845>>>>>>>            Get TableAnalysis strQuery.iTable to strAnalysis
41846>>>>>>>            
41846>>>>>>>            Get _ColumnRatings strQuery to aColumnRatings
41847>>>>>>>
41847>>>>>>>            Get TableIndices strQuery.iTable to aIndices // All on-line indices
41848>>>>>>>            
41848>>>>>>>            Move (SizeOfArray(aIndices)-1) to iMax
41849>>>>>>>            For iItem from 0 to iMax
41855>>>>>>>>
41855>>>>>>>                Move aIndices[iItem] to iIndex
41856>>>>>>>                Get _IndexRating strQuery iIndex aColumnRatings strAnalysis.aIndices[iIndex] to strRating
41857>>>>>>>                Move strRating to aIndexRatings[SizeOfArray(aIndexRatings)]
41858>>>>>>>                // Also check the reverse index:
41858>>>>>>>                Get _IndexRating strQuery (1000+iIndex) aColumnRatings strAnalysis.aIndices[iIndex] to strRating
41859>>>>>>>                Move strRating to aIndexRatings[SizeOfArray(aIndexRatings)]
41860>>>>>>>            Loop
41861>>>>>>>>
41861>>>>>>>            Function_Return aIndexRatings
41862>>>>>>>        End_Function
41863>>>>>>>
41863>>>>>>>        Function _LowestIndexNumber Integer iTable Returns Integer
41865>>>>>>>            Integer iIndex iIndexMax iSegments
41865>>>>>>>
41865>>>>>>>            Get_Attribute DF_FILE_LAST_INDEX_NUMBER of iTable to iIndexMax
41868>>>>>>>            Move 1 to iIndex
41869>>>>>>>            While (iIndex<=iIndexMax)
41873>>>>>>>                Get_Attribute DF_INDEX_NUMBER_SEGMENTS of iTable iIndex to iSegments
41876>>>>>>>                If (iSegments<>0) Begin
41878>>>>>>>                    Function_Return iIndex
41879>>>>>>>                End
41879>>>>>>>>
41879>>>>>>>            Loop
41880>>>>>>>>
41880>>>>>>>            
41880>>>>>>>            Function_Return 0 // None found
41881>>>>>>>        End_Function
41882>>>>>>>
41882>>>>>>>        Function _CompareIndexRating _tTQIndexRating strRatingLeft _tTQIndexRating strRatingRight Returns Integer
41884>>>>>>>            Number nFactorLeft nFactorRight
41884>>>>>>>            Number nPrefetchAvoidanceFactor
41884>>>>>>>        
41884>>>>>>>            Get _pnPrefetchAvoidanceFactor to nPrefetchAvoidanceFactor
41885>>>>>>>        
41885>>>>>>>            // This means that we accept an index in agreement with the output order if it is more
41885>>>>>>>            // than 10 times less efficient (assuming that nPrefetchAvoidanceFactor is 0.1 (which it is (by default)))
41885>>>>>>>            Move (If(strRatingLeft.bOutputAgree,nPrefetchAvoidanceFactor,1)) to nFactorLeft
41886>>>>>>>            Move (If(strRatingRight.bOutputAgree,nPrefetchAvoidanceFactor,1)) to nFactorRight
41887>>>>>>>            
41887>>>>>>>            Move (strRatingLeft.nExpectedNumberRows*nFactorLeft) to nFactorLeft
41888>>>>>>>            Move (strRatingRight.nExpectedNumberRows*nFactorRight) to nFactorRight
41889>>>>>>>
41889>>>>>>>            If (nFactorLeft > nFactorRight) Function_Return (GT) // Right is best
41892>>>>>>>            If (nFactorLeft < nFactorRight) Function_Return (LT) // Left is best
41895>>>>>>>            
41895>>>>>>>            If (strRatingLeft.iKeyLevels>strRatingRight.iKeyLevels) Function_Return (GT) // Right is best
41898>>>>>>>            If (strRatingLeft.iKeyLevels<strRatingRight.iKeyLevels) Function_Return (LT) // Left is best 
41901>>>>>>>            
41901>>>>>>>            If (strRatingLeft.iKeyLength>strRatingRight.iKeyLength) Function_Return (GT) // Right is best
41904>>>>>>>            If (strRatingLeft.iKeyLength<strRatingRight.iKeyLength) Function_Return (LT) // Left is best
41907>>>>>>>                                                                                  
41907>>>>>>>            Function_Return (EQ)
41908>>>>>>>        End_Function
41909>>>>>>>
41909>>>>>>>        Function _CalculateIndex tTableQuery ByRef strQuery Returns _tTQIndexRating[] 
41911>>>>>>>            Integer iIndex iIndexIndex
41911>>>>>>>            Number nENR
41911>>>>>>>            _tTQIndexRating[] aIndexRatings
41911>>>>>>>            _tTQIndexRating[] aIndexRatings
41912>>>>>>>            
41912>>>>>>>            Get _IndexRatings strQuery to aIndexRatings
41913>>>>>>>            Move (SizeOfArray(aIndexRatings)-1) to iIndexIndex
41914>>>>>>>            If (iIndexIndex>=0) Begin
41916>>>>>>>                If (strQuery.bForcePrefetch) Begin
41918>>>>>>>                    // If prefetch is forced anyway, we will not consider prefetch an "extra" cost.
41918>>>>>>>                    Set _pnPrefetchAvoidanceFactor to 1 
41919>>>>>>>                End
41919>>>>>>>>
41919>>>>>>>                Else Begin
41920>>>>>>>                    Set _pnPrefetchAvoidanceFactor to strQuery._strControlBlock.nPrefetchAvoidanceFactor
41921>>>>>>>                End
41921>>>>>>>>
41921>>>>>>>                Move (SortArray(aIndexRatings,Self,GET__CompareIndexRating)) to aIndexRatings
41922>>>>>>>                Move aIndexRatings[0].iIndex to iIndex
41923>>>>>>>                Move aIndexRatings[0].nExpectedNumberRows to nENR
41924>>>>>>>            End
41924>>>>>>>>
41924>>>>>>>            Else Begin
41925>>>>>>>                Move 0 to iIndex
41926>>>>>>>                Move -1 to nENR // No idea
41927>>>>>>>            End
41927>>>>>>>>
41927>>>>>>>
41927>>>>>>>            If (iIndex>=1000) Begin
41929>>>>>>>                Move (iIndex-1000) to iIndex
41930>>>>>>>                Move (not(strQuery._strCompiled.bBackwards)) to strQuery._strCompiled.bBackwards // Flip
41931>>>>>>>            End
41931>>>>>>>>
41931>>>>>>>            
41931>>>>>>>            Move iIndex to strQuery._strCompiled.iIndex
41932>>>>>>>            Move nENR to strQuery._strCompiled.nENR
41933>>>>>>>            
41933>>>>>>>            Function_Return aIndexRatings
41934>>>>>>>        End_Function
41935>>>>>>>        
41935>>>>>>>    Function IndexRatingText tTableQuery strQuery _tTQIndexRating[] aIndexRatings Returns String
41937>>>>>>>        Boolean bBackwards
41937>>>>>>>        Integer iItem iMax iTable iIndex
41937>>>>>>>        Number nRecCount nFactor
41937>>>>>>>        String sValue sIndex sTemp
41937>>>>>>>
41937>>>>>>>        Move strQuery.iTable to iTable
41938>>>>>>>        Get_Attribute DF_FILE_RECORDS_USED of iTable to nRecCount
41941>>>>>>>        
41941>>>>>>>        If (strQuery.bForcePrefetch) Begin
41943>>>>>>>            Move 1 to nFactor
41944>>>>>>>        End
41944>>>>>>>>
41944>>>>>>>        Else Begin
41945>>>>>>>            Move strQuery._strControlBlock.nPrefetchAvoidanceFactor to nFactor
41946>>>>>>>        End
41946>>>>>>>>
41946>>>>>>>        
41946>>>>>>>        If (strQuery.iForceIndex=-1) Begin
41948>>>>>>>            Move "Index Ratings\n\nRatings are based on expected number of rows (ENR). If the use of an index implies prefetching and sorting data then ENR is multiplied by # (but not shown).\n\nIndex ratings, best to worst (there is # rows in table #):\n" to sValue
41949>>>>>>>            Move (Replace("#",sValue,String(1.0/nFactor))) to sValue
41950>>>>>>>            Move (Replace("#",sValue,NumberToString(oStringFunctions,nRecCount,0))) to sValue
41951>>>>>>>            Move (Replace("#",sValue,TableName(Self,strQuery,iTable))) to sValue
41952>>>>>>>            Move (SizeOfArray(aIndexRatings)-1) to iMax
41953>>>>>>>            For iItem from 0 to iMax
41959>>>>>>>>
41959>>>>>>>                Move "Index ##: ENR=#, #, Levels/length=#/#" to sIndex
41960>>>>>>>                Move aIndexRatings[iItem].iIndex to iIndex
41961>>>>>>>                If (iIndex>1000) Begin
41963>>>>>>>                    Move (iIndex-1000) to iIndex
41964>>>>>>>                    Move True to bBackwards
41965>>>>>>>                End
41965>>>>>>>>
41965>>>>>>>                Else Begin
41966>>>>>>>                    Move False to bBackwards
41967>>>>>>>                End
41967>>>>>>>>
41967>>>>>>>                Move (Replace("#",sIndex,String(iIndex))) to sIndex
41968>>>>>>>                If (bBackwards) Begin
41970>>>>>>>                    Move (Replace("#",sIndex," (backwards)")) to sIndex
41971>>>>>>>                End
41971>>>>>>>>
41971>>>>>>>                Else Begin
41972>>>>>>>                    Move (Replace("#",sIndex,"")) to sIndex
41973>>>>>>>                End
41973>>>>>>>>
41973>>>>>>>                Move (Replace("#",sIndex,String(aIndexRatings[iItem].nExpectedNumberRows))) to sIndex
41974>>>>>>>                Move (If(aIndexRatings[iItem].bOutputAgree,"Ordering ok","Prefetch needed")) to sTemp
41975>>>>>>>                Move (Replace("#",sIndex,sTemp)) to sIndex
41976>>>>>>>                Move (Replace("#",sIndex,String(aIndexRatings[iItem].iKeyLevels))) to sIndex
41977>>>>>>>                Move (Replace("#",sIndex,String(aIndexRatings[iItem].iKeyLength))) to sIndex
41978>>>>>>>                Move (sValue+"\n"+sIndex) to sValue
41979>>>>>>>            Loop
41980>>>>>>>>
41980>>>>>>>        End
41980>>>>>>>>
41980>>>>>>>        Else Begin
41981>>>>>>>            Move "Indices have not been rated (index was forced)" to sValue
41982>>>>>>>        End
41982>>>>>>>>
41982>>>>>>>        Function_Return sValue
41983>>>>>>>    End_Function
41984>>>>>>>
41984>>>>>>>    Procedure OnIndexCalculated tTableQuery strQuery _tTQIndexRating[] aIndexRatings
41986>>>>>>>    End_Procedure
41987>>>>>>>
41987>>>>>>>                Function _FindConstraintEQ tTQFilterSegment[] aFilters Integer iTable Integer iColumn Boolean bOrListOnly Returns Integer
41989>>>>>>>                    Integer iConstraint iConstraints
41989>>>>>>>                    Move (SizeOfArray(aFilters)-1) to iConstraints
41990>>>>>>>                    For iConstraint from 0 to iConstraints
41996>>>>>>>>
41996>>>>>>>                        If (iTable=aFilters[iConstraint].strLeftValue.iTable and ;                            iColumn=aFilters[iConstraint].strLeftValue.iColumn and aFilters[iConstraint].iComp=tqEQ) Begin
41998>>>>>>>                            If (not(bOrListOnly) or SizeOfArray(aFilters[iConstraint].strRightValue.aOrList)>0) Begin
42000>>>>>>>                                Function_Return iConstraint
42001>>>>>>>                            End
42001>>>>>>>>
42001>>>>>>>                        End
42001>>>>>>>>
42001>>>>>>>                    Loop
42002>>>>>>>>
42002>>>>>>>                    Function_Return -1
42003>>>>>>>                End_Function
42004>>>>>>>
42004>>>>>>>                Procedure _AppendConstraint tTQFilterSegment[] ByRef aConstraint tTQFilterSegment strConstraint
42006>>>>>>>                    Integer iIndex
42006>>>>>>>                    Move (SizeOfArray(aConstraint)) to iIndex
42007>>>>>>>                    Move strConstraint to aConstraint[iIndex]
42008>>>>>>>                End_Procedure
42009>>>>>>>                
42009>>>>>>>                Procedure _DeleteConstraint tTQFilterSegment[] ByRef aFilters Integer iConstraint
42011>>>>>>>                    Move (RemoveFromArray(aFilters,iConstraint)) to aFilters
42012>>>>>>>                End_Procedure
42013>>>>>>>        
42013>>>>>>>        Procedure _CalculateJumpInOutConditionsStep01 tTableQuery ByRef strQuery Integer ByRef iSegment Integer iSegments tOCIndex strIndex
42015>>>>>>>            // 1: As long as we can consequetively provide EQ constraints on the segment, we copy the constraint to 
42015>>>>>>>            //    both the JumpInValues and JumpOutValues (and disregard that constraint from then on)
42015>>>>>>>            Integer iTable iIndex iColumn iConstraint
42015>>>>>>>            Boolean bCont
42015>>>>>>>            
42015>>>>>>>            Move strQuery.iTable to iTable
42016>>>>>>>            Move strQuery._strCompiled.iIndex to iIndex
42017>>>>>>>            
42017>>>>>>>            Move True to bCont
42018>>>>>>>
42018>>>>>>>            While (bCont and iSegment<=iSegments)
42022>>>>>>>                Move strIndex.aSegments[iSegment].iColumn to iColumn
42023>>>>>>>                Get _FindConstraintEQ strQuery.aFilters iTable iColumn False to iConstraint
42024>>>>>>>                Move (iConstraint<>-1) to bCont
42025>>>>>>>                If (bCont) Begin
42027>>>>>>>                    Send _AppendConstraint (&strQuery._strCompiled.aJumpInValues) strQuery.aFilters[iConstraint] 
42028>>>>>>>                    Send _AppendConstraint (&strQuery._strCompiled.aJumpOutValues) strQuery.aFilters[iConstraint]
42029>>>>>>>                    Send _DeleteConstraint (&strQuery.aFilters) iConstraint
42030>>>>>>>                    Increment iSegment
42031>>>>>>>                End
42031>>>>>>>>
42031>>>>>>>            Loop
42032>>>>>>>>
42032>>>>>>>        End_Procedure
42033>>>>>>>
42033>>>>>>>                Function _FindConstraintGEGT tTQFilterSegment[] aFilters Integer iTable Integer iColumn Boolean bAlsoEQ Returns Integer
42035>>>>>>>                    Integer iConstraint iConstraints iComp
42035>>>>>>>                    Move (SizeOfArray(aFilters)-1) to iConstraints
42036>>>>>>>                    For iConstraint from 0 to iConstraints
42042>>>>>>>>
42042>>>>>>>                        If (iTable=aFilters[iConstraint].strLeftValue.iTable and iColumn=aFilters[iConstraint].strLeftValue.iColumn) Begin
42044>>>>>>>                            Move aFilters[iConstraint].iComp to iComp
42045>>>>>>>                            If (iComp=tqGT or iComp=tqGE or (bAlsoEQ and iComp=tqEQ)) Begin
42047>>>>>>>                                Function_Return iConstraint
42048>>>>>>>                            End
42048>>>>>>>>
42048>>>>>>>                        End
42048>>>>>>>>
42048>>>>>>>                    Loop
42049>>>>>>>>
42049>>>>>>>                    Function_Return -1
42050>>>>>>>                End_Function
42051>>>>>>>                
42051>>>>>>>                Function _FindConstraintLELT tTQFilterSegment[] aFilters Integer iTable Integer iColumn Boolean bAlsoEQ Returns Integer
42053>>>>>>>                    Integer iConstraint iConstraints iComp
42053>>>>>>>                    Move (SizeOfArray(aFilters)-1) to iConstraints
42054>>>>>>>                    For iConstraint from 0 to iConstraints
42060>>>>>>>>
42060>>>>>>>                        If (iTable=aFilters[iConstraint].strLeftValue.iTable and iColumn=aFilters[iConstraint].strLeftValue.iColumn) Begin
42062>>>>>>>                            Move aFilters[iConstraint].iComp to iComp
42063>>>>>>>                            If (iComp=tqLT or iComp=tqLE or (bAlsoEQ and iComp=tqEQ)) Begin
42065>>>>>>>                                Function_Return iConstraint
42066>>>>>>>                            End
42066>>>>>>>>
42066>>>>>>>                        End
42066>>>>>>>>
42066>>>>>>>                    Loop
42067>>>>>>>>
42067>>>>>>>                    Function_Return -1
42068>>>>>>>                End_Function
42069>>>>>>>                
42069>>>>>>>        Procedure _CalculateJumpInOutConditionsStep02 tTableQuery ByRef strQuery Integer ByRef iJumpInSegment Integer ByRef iJumpOutSegment Integer iSegments tOCIndex strIndex
42071>>>>>>>            // 2. If we can then provide a LT,LE,GE,GT type constraint (for JumpInValues and JumpOutValues 
42071>>>>>>>            //    indepentdantly) we move the constraint to JumpInValues/JumpOutValues (and disregard that 
42071>>>>>>>            //    constraint from then on *unless* it's a jump-in constraint and the comperator is GT (or LT 
42071>>>>>>>            //    if it's a descending index segment))
42071>>>>>>>            Integer iTable iIndex iColumn iConstraint
42071>>>>>>>            Boolean bCont
42071>>>>>>>            
42071>>>>>>>            Move strQuery.iTable to iTable
42072>>>>>>>            Move strQuery._strCompiled.iIndex to iIndex
42073>>>>>>>            
42073>>>>>>>            // Jump in
42073>>>>>>>            If (iJumpInSegment<=iSegments) Begin
42075>>>>>>>                Move strIndex.aSegments[iJumpInSegment].iColumn to iColumn
42076>>>>>>>                If (strIndex.aSegments[iJumpInSegment].bDescending) Begin
42078>>>>>>>                    Get _FindConstraintLELT strQuery.aFilters iTable iColumn False to iConstraint
42079>>>>>>>                    If (iConstraint<>-1) Begin
42081>>>>>>>                        Send _AppendConstraint (&strQuery._strCompiled.aJumpInValues) strQuery.aFilters[iConstraint]
42082>>>>>>>                        If (strQuery.aFilters[iConstraint].iComp=tqLE) Begin
42084>>>>>>>                            Send _DeleteConstraint (&strQuery.aFilters) iConstraint
42085>>>>>>>                        End
42085>>>>>>>>
42085>>>>>>>                        Increment iJumpInSegment
42086>>>>>>>                    End
42086>>>>>>>>
42086>>>>>>>                    Else Begin
42087>>>>>>>                        Move -1 to iJumpInSegment
42088>>>>>>>                    End
42088>>>>>>>>
42088>>>>>>>                End
42088>>>>>>>>
42088>>>>>>>                Else Begin
42089>>>>>>>                    Get _FindConstraintGEGT strQuery.aFilters iTable iColumn False to iConstraint
42090>>>>>>>                    If (iConstraint<>-1) Begin
42092>>>>>>>                        Send _AppendConstraint (&strQuery._strCompiled.aJumpInValues) strQuery.aFilters[iConstraint] 
42093>>>>>>>                        If (strQuery.aFilters[iConstraint].iComp=tqGE) Begin
42095>>>>>>>                            Send _DeleteConstraint (&strQuery.aFilters) iConstraint
42096>>>>>>>                        End
42096>>>>>>>>
42096>>>>>>>                        Increment iJumpInSegment
42097>>>>>>>                    End
42097>>>>>>>>
42097>>>>>>>                    Else Begin
42098>>>>>>>                        Move -1 to iJumpInSegment
42099>>>>>>>                    End
42099>>>>>>>>
42099>>>>>>>                End
42099>>>>>>>>
42099>>>>>>>            End
42099>>>>>>>>
42099>>>>>>>            
42099>>>>>>>            // Jump out
42099>>>>>>>            If (iJumpOutSegment<=iSegments) Begin
42101>>>>>>>                Move strIndex.aSegments[iJumpOutSegment].iColumn to iColumn
42102>>>>>>>                If (strIndex.aSegments[iJumpOutSegment].bDescending) Begin
42104>>>>>>>                    Get _FindConstraintGEGT strQuery.aFilters iTable iColumn False to iConstraint
42105>>>>>>>                    If (iConstraint<>-1) Begin
42107>>>>>>>                        Send _AppendConstraint (&strQuery._strCompiled.aJumpOutValues) strQuery.aFilters[iConstraint] 
42108>>>>>>>                        Send _DeleteConstraint (&strQuery.aFilters) iConstraint
42109>>>>>>>                        Increment iJumpOutSegment
42110>>>>>>>                    End
42110>>>>>>>>
42110>>>>>>>                    Else Begin
42111>>>>>>>                        Move -1 to iJumpOutSegment
42112>>>>>>>                    End
42112>>>>>>>>
42112>>>>>>>                End
42112>>>>>>>>
42112>>>>>>>                Else Begin
42113>>>>>>>                    Get _FindConstraintLELT strQuery.aFilters iTable iColumn False to iConstraint
42114>>>>>>>                    If (iConstraint<>-1) Begin
42116>>>>>>>                        Send _AppendConstraint (&strQuery._strCompiled.aJumpOutValues) strQuery.aFilters[iConstraint] 
42117>>>>>>>                        Send _DeleteConstraint (&strQuery.aFilters) iConstraint
42118>>>>>>>                        Increment iJumpOutSegment
42119>>>>>>>                    End
42119>>>>>>>>
42119>>>>>>>                    Else Begin
42120>>>>>>>                        Move -1 to iJumpOutSegment
42121>>>>>>>                    End
42121>>>>>>>>
42121>>>>>>>                End
42121>>>>>>>>
42121>>>>>>>            End
42121>>>>>>>>
42121>>>>>>>        End_Procedure
42122>>>>>>>
42122>>>>>>>        Procedure _CalculateJumpInOutConditions tTableQuery ByRef strQuery
42124>>>>>>>            Integer iSegment iSegments iTable iIndex iTempIndex
42124>>>>>>>            Integer iJumpInSegment iJumpOutSegment
42124>>>>>>>            Boolean bBackwards 
42124>>>>>>>            tTQFilterSegment[] aBackupConstraints
42124>>>>>>>            tTQFilterSegment[] aBackupConstraints
42125>>>>>>>            tOCIndex strIndex
42125>>>>>>>            tOCIndex strIndex
42125>>>>>>>            
42125>>>>>>>            Move strQuery.iTable to iTable
42126>>>>>>>            Move strQuery._strCompiled.iIndex to iIndex
42127>>>>>>>            Move strQuery._strCompiled.bBackwards to bBackwards
42128>>>>>>>            Move strQuery.aFilters to aBackupConstraints
42129>>>>>>>            
42129>>>>>>>            // If the scan index is not compatible with the output index we are forced to 
42129>>>>>>>            // prefetch the record set in order to sort it before we "output" it:
42129>>>>>>>            If (not(_IndexAgreement(Self,strQuery,iIndex,True))) Begin
42131>>>>>>>
42131>>>>>>>                // If the index is the exact uppersite we still consider the index in agreement.
42131>>>>>>>                // Therefore we do not pass the information that the index is scanned backwards to 
42131>>>>>>>                // the _IndexAgreement function.
42131>>>>>>>                
42131>>>>>>>                Move True to strQuery._strCompiled.bPrefetch
42132>>>>>>>                Move strQuery._strCompiled._iLimit to strQuery._strCompiled._iPushLimit 
42133>>>>>>>
42133>>>>>>>                If (strQuery._strCompiled.bBackwards) Begin // set to the opposite of what was tested above _IndexAgreement call
42135>>>>>>>                    Move strQuery._strCompiled.iIndex to iTempIndex
42136>>>>>>>                End
42136>>>>>>>>
42136>>>>>>>                Else Begin
42137>>>>>>>                    Move (strQuery._strCompiled.iIndex+1000) to iTempIndex
42138>>>>>>>                End
42138>>>>>>>>
42138>>>>>>>
42138>>>>>>>                If (strQuery.iForceIndex=-1 and strQuery.iLimit<>0 and _IndexAgreement(Self,strQuery,iTempIndex,False)) Begin
42140>>>>>>>                    // If tail and negated index is ok then we do _not_ reset the limit.
42140>>>>>>>                End
42140>>>>>>>>
42140>>>>>>>                Else Begin
42141>>>>>>>                    Move 0 to strQuery._strCompiled._iLimit
42142>>>>>>>                End
42142>>>>>>>>
42142>>>>>>>                
42142>>>>>>>            End
42142>>>>>>>>
42142>>>>>>>            Else Begin
42143>>>>>>>                Move 0 to strQuery._strCompiled._iPushLimit
42144>>>>>>>            End
42144>>>>>>>>
42144>>>>>>>                
42144>>>>>>>            // Initialize:
42144>>>>>>>            Move (ResizeArray(strQuery._strCompiled.aJumpInValues,0)) to strQuery._strCompiled.aJumpInValues
42145>>>>>>>            Move (ResizeArray(strQuery._strCompiled.aJumpOutValues,0)) to strQuery._strCompiled.aJumpOutValues
42146>>>>>>>            Move (ResizeArray(strQuery._strCompiled.aOtherConditions,0)) to strQuery._strCompiled.aOtherConditions
42147>>>>>>>            
42147>>>>>>>            Get IndexDefinition of oOverlapColumnFunctions strQuery.iTable iIndex to strIndex
42148>>>>>>>            Move (SizeOfArray(strIndex.aSegments)-1) to iSegments
42149>>>>>>>        
42149>>>>>>>            Move 0 to iSegment // Used to be 1
42150>>>>>>>             
42150>>>>>>>            // Calculating the JumpInValues:
42150>>>>>>>            //     Starting with the most significant segment we go through the segments of the iScanIndex
42150>>>>>>>            //        1. As long as we can consequetively provide EQ constraints on the segment, we copy the 
42150>>>>>>>            //           constraint to both the JumpInValues and JumpOutValues (and disregard that constraint 
42150>>>>>>>            //           from then on)
42150>>>>>>>                         Send _CalculateJumpInOutConditionsStep01 (&strQuery) (&iSegment) iSegments strIndex
42151>>>>>>>            //        2. If we can then provide a LT,LE,GE,GT type constraint (for JumpInValues and JumpOutValues 
42151>>>>>>>            //           respectively) we move the constraint to JumpInValues/JumpOutValues (and disregard that 
42151>>>>>>>            //           constraint from then on)
42151>>>>>>>                         Move iSegment to iJumpInSegment
42152>>>>>>>                         Move iSegment to iJumpOutSegment
42153>>>>>>>                         Send _CalculateJumpInOutConditionsStep02 (&strQuery) (&iJumpInSegment) (&iJumpOutSegment) iSegments strIndex
42154>>>>>>>            //        3. The constraints that are then left are copied to the aOtherConstraints array
42154>>>>>>>                         Move strQuery.aFilters to strQuery._strCompiled.aOtherConditions
42155>>>>>>>            Move aBackupConstraints to strQuery.aFilters 
42156>>>>>>>        End_Procedure
42157>>>>>>>
42157>>>>>>>                        Procedure _IncrementJumpInOutCondition _tTQValueSource ByRef stValue Integer ByRef bIncrement Integer ByRef bCarry
42159>>>>>>>                            Integer iMax
42159>>>>>>>                            Move (SizeOfArray(stValue.aOrList)-1) to iMax
42160>>>>>>>                            If (iMax>=0) Begin // If it's an or-list
42162>>>>>>>                                If (bIncrement or bCarry) Begin
42164>>>>>>>                                    Increment stValue._iOrListPointer
42165>>>>>>>                                    If (stValue._iOrListPointer>iMax) Begin
42167>>>>>>>                                        Move True to bCarry
42168>>>>>>>                                        Move 0 to stValue._iOrListPointer
42169>>>>>>>                                    End
42169>>>>>>>>
42169>>>>>>>                                    Else Begin
42170>>>>>>>                                        Move False to bCarry
42171>>>>>>>                                    End
42171>>>>>>>>
42171>>>>>>>                                    Move False to bIncrement
42172>>>>>>>                                End
42172>>>>>>>>
42172>>>>>>>                            End
42172>>>>>>>>
42172>>>>>>>                        End_Procedure
42173>>>>>>>                        
42173>>>>>>>                        Procedure _ResetOrListPointer _tTQValueSource ByRef stValue
42175>>>>>>>                            If (SizeOfArray(stValue.aOrList)>0) Begin
42177>>>>>>>                                Move 0 to stValue._iOrListPointer
42178>>>>>>>                            End
42178>>>>>>>>
42178>>>>>>>                        End_Procedure
42179>>>>>>>
42179>>>>>>>                Function _IncrementJumpInOutConditions tTableQuery ByRef strQuery Integer iJumpOutTriggerIndex Returns Boolean
42181>>>>>>>                    // This function increments jump-in/out pointers and returns false if pointers could not
42181>>>>>>>                    // be incremented. The pointers are into arrays of or-list values
42181>>>>>>>                    // Parameter iJumpOutTriggerIndex points to the constrain segment that triggered the jump-out
42181>>>>>>>                    // that in turn triggered the call of this function.
42181>>>>>>>                    // The or-list pointers to the left of (and including) iJumpOutTriggerIndex must be incremented
42181>>>>>>>                    // while the or-list pointers to the right must be reset.
42181>>>>>>>                    Integer iItem iMax iIndex
42181>>>>>>>                    Boolean bCarry bIncrement bSuccess bReturnFalse
42181>>>>>>>                    Move (SizeOfArray(strQuery._strCompiled.aJumpOutValues)-1) to iMax
42182>>>>>>>
42182>>>>>>>                    Move False to bReturnFalse
42183>>>>>>>
42183>>>>>>>                    If (iJumpOutTriggerIndex>=0) Begin
42185>>>>>>>                        // Increment pointers to the left
42185>>>>>>>                        Move False to bCarry
42186>>>>>>>                        Move True to bIncrement
42187>>>>>>>                        If (SizeOfArray(strQuery._strCompiled.aJumpOutValues)>0) Begin // Only of there are any jumpout values to increment upon
42189>>>>>>>                            For iItem from 0 to iJumpOutTriggerIndex
42195>>>>>>>>
42195>>>>>>>                                Move (iJumpOutTriggerIndex-iItem) to iIndex // Go throught it backwards (least significant first)
42196>>>>>>>                                Send _IncrementJumpInOutCondition (&strQuery._strCompiled.aJumpOutValues[iIndex].strRightValue) (&bIncrement) (&bCarry)
42197>>>>>>>                            Loop
42198>>>>>>>>
42198>>>>>>>                        End
42198>>>>>>>>
42198>>>>>>>                        Move (not(bCarry) and not(bIncrement)) to bSuccess
42199>>>>>>>                    End
42199>>>>>>>>
42199>>>>>>>                    Else Begin
42200>>>>>>>                        Move True to bSuccess
42201>>>>>>>                        Move True to bReturnFalse
42202>>>>>>>                    End
42202>>>>>>>>
42202>>>>>>>                    // Reset the or-lists to the lessor significant side of iJumpOutTriggerIndex
42202>>>>>>>                    If (bSuccess) Begin
42204>>>>>>>                        For iItem from (iJumpOutTriggerIndex+1) to iMax
42210>>>>>>>>
42210>>>>>>>                            Send _ResetOrListPointer (&strQuery._strCompiled.aJumpOutValues[iItem].strRightValue)
42211>>>>>>>                        Loop
42212>>>>>>>>
42212>>>>>>>                    End
42212>>>>>>>>
42212>>>>>>>
42212>>>>>>>                    If (bReturnFalse) Begin
42214>>>>>>>                        // The point is that no-way will we return true if nothing was actually incremented
42214>>>>>>>                        Function_Return False
42215>>>>>>>                    End
42215>>>>>>>>
42215>>>>>>>
42215>>>>>>>                    Function_Return bSuccess
42216>>>>>>>                End_Function
42217>>>>>>>
42217>>>>>>>                Procedure _SortVariantArray String[] ByRef aValues Integer iType Boolean bReverseArray
42219>>>>>>>                    Integer iMax iItem
42219>>>>>>>                    String[] aStringValues
42220>>>>>>>                    Number[] aNumberValues
42221>>>>>>>                    Date[] aDateValues
42222>>>>>>>                    DateTime[] aDateTimeValues
42223>>>>>>>
42223>>>>>>>                    Move (SizeOfArray(aValues)-1) to iMax
42224>>>>>>>                    If (iType=tqSTRING or iType=tqTEXT) Begin
42226>>>>>>>                        Move (SortArray(aValues)) to aValues
42227>>>>>>>                    End
42227>>>>>>>>
42227>>>>>>>                    Else If (iType=tqNUMBER) Begin
42230>>>>>>>                        For iItem from 0 to iMax
42236>>>>>>>>
42236>>>>>>>                            Move aValues[iItem] to aNumberValues[iItem]
42237>>>>>>>                        Loop
42238>>>>>>>>
42238>>>>>>>                        Move (SortArray(aNumberValues)) to aNumberValues
42239>>>>>>>                        For iItem from 0 to iMax
42245>>>>>>>>
42245>>>>>>>                            Move aNumberValues[iItem] to aValues[iItem]
42246>>>>>>>                        Loop
42247>>>>>>>>
42247>>>>>>>                    End
42247>>>>>>>>
42247>>>>>>>                    Else If (iType=tqDATE) Begin
42250>>>>>>>                        For iItem from 0 to iMax
42256>>>>>>>>
42256>>>>>>>                            Move aValues[iItem] to aDateValues[iItem]
42257>>>>>>>                        Loop
42258>>>>>>>>
42258>>>>>>>                        Move (SortArray(aDateValues)) to aDateValues
42259>>>>>>>                        For iItem from 0 to iMax
42265>>>>>>>>
42265>>>>>>>                            Move aDateValues[iItem] to aValues[iItem]
42266>>>>>>>                        Loop
42267>>>>>>>>
42267>>>>>>>                    End
42267>>>>>>>>
42267>>>>>>>                    Else If (iType=tqDATETIME) Begin
42270>>>>>>>                        For iItem from 0 to iMax
42276>>>>>>>>
42276>>>>>>>                            Move aValues[iItem] to aDateTimeValues[iItem]
42277>>>>>>>                        Loop
42278>>>>>>>>
42278>>>>>>>                        Move (SortArray(aDateTimeValues)) to aDateTimeValues
42279>>>>>>>                        For iItem from 0 to iMax
42285>>>>>>>>
42285>>>>>>>                            Move aDateTimeValues[iItem] to aValues[iItem]
42286>>>>>>>                        Loop
42287>>>>>>>>
42287>>>>>>>                    End
42287>>>>>>>>
42287>>>>>>>                    
42287>>>>>>>                    If (bReverseArray) Begin
42289>>>>>>>                        Move (ReverseArray(aValues)) to aValues
42290>>>>>>>                    End
42290>>>>>>>>
42290>>>>>>>                End_Procedure
42291>>>>>>>                
42291>>>>>>>                    Function _SortSegmentReversed tTableQuery strQ _tTQValueSource strLeftValue Returns Boolean
42293>>>>>>>                        Integer iItem iMax
42293>>>>>>>                        Move (SizeOfArray(strQ.aOrdering)-1) to iMax
42294>>>>>>>                        For iItem from 0 to iMax
42300>>>>>>>>
42300>>>>>>>                            If (strQ.aOrdering[iItem].strValueSource.iTable=strQ.iTable and ;                                strQ.iTable=strLeftValue.iTable and ;                                strQ.aOrdering[iItem].strValueSource.iColumn=strLeftValue.iColumn) Begin
42302>>>>>>>                                    Function_Return strQ.aOrdering[iItem].bDescending
42303>>>>>>>                            End
42303>>>>>>>>
42303>>>>>>>                        Loop
42304>>>>>>>>
42304>>>>>>>                    End_Function
42305>>>>>>>
42305>>>>>>>                Procedure _SortOrListValues tTableQuery ByRef strQ   
42307>>>>>>>                    // Sorting the OrList values serves two purposes:
42307>>>>>>>                    // 1: The rows will be found in the order specified by the scan index
42307>>>>>>>                    // 2: The mechanism that determines which OrList to "increment" will be confused
42307>>>>>>>                    //    if the OrList values do not appear in sequence (it's the break level
42307>>>>>>>                    //    computation that will go wrong)
42307>>>>>>>                    Boolean bReverseArray
42307>>>>>>>                    Integer iItem iMax
42307>>>>>>>                    Move (SizeOfArray(strQ._strCompiled.aJumpInValues)-1) to iMax
42308>>>>>>>                    For iItem from 0 to iMax
42314>>>>>>>>
42314>>>>>>>                        // Should we sort backwards?
42314>>>>>>>                        Get _SortSegmentReversed strQ strQ._strCompiled.aJumpInValues[iItem].strLeftValue to bReverseArray
42315>>>>>>>                        Send _SortVariantArray (&strQ._strCompiled.aJumpInValues[iItem].strRightValue.aOrList) strQ._strCompiled.aJumpInValues[iItem].strLeftValue.iType bReverseArray //(Integer(bReverseArray)+Integer(strQ._strCompiled.bBackwards)=1)
42316>>>>>>>                    Loop
42317>>>>>>>>
42317>>>>>>>                    Move (SizeOfArray(strQ._strCompiled.aJumpOutValues)-1) to iMax
42318>>>>>>>                    For iItem from 0 to iMax
42324>>>>>>>>
42324>>>>>>>                        // Should we sort backwards?
42324>>>>>>>                        Get _SortSegmentReversed strQ strQ._strCompiled.aJumpOutValues[iItem].strLeftValue to bReverseArray
42325>>>>>>>                        Send _SortVariantArray (&strQ._strCompiled.aJumpOutValues[iItem].strRightValue.aOrList) strQ._strCompiled.aJumpOutValues[iItem].strLeftValue.iType bReverseArray //(Integer(bReverseArray)+Integer(strQ._strCompiled.bBackwards)=1)
42326>>>>>>>                    Loop
42327>>>>>>>>
42327>>>>>>>                End_Procedure
42328>>>>>>>                
42328>>>>>>>                Function _CanFindIndexInRatings _tTQIndexRating[] aIndexRatings Integer iIndex Boolean ByRef bBackwards Number ByRef nENR Returns Boolean
42330>>>>>>>                    Integer iItem iMax
42330>>>>>>>                    Move (SizeOfArray(aIndexRatings)-1) to iMax
42331>>>>>>>                    For iItem from 0 to iMax
42337>>>>>>>>
42337>>>>>>>                        If (iIndex=aIndexRatings[iItem].iIndex or (iIndex+1000)=aIndexRatings[iItem].iIndex) Begin
42339>>>>>>>                            Move (aIndexRatings[iItem].iIndex>1000) to bBackwards
42340>>>>>>>                            Move aIndexRatings[iItem].nExpectedNumberRows to nENR
42341>>>>>>>                            Function_Return True
42342>>>>>>>                        End
42342>>>>>>>>
42342>>>>>>>                    Loop
42343>>>>>>>>
42343>>>>>>>                    Function_Return False
42344>>>>>>>                End_Function
42345>>>>>>>
42345>>>>>>>            Function SQLSelectStatement tTableQuery strQuery Returns String
42347>>>>>>>                Handle hoSQLGenerator
42347>>>>>>>                String sStatement
42347>>>>>>>                Send _TableRelateStatesReset (&strQuery)
42348>>>>>>>                If (strQuery.sForceSQLStatement<>"") Begin
42350>>>>>>>                    Function_Return strQuery.sForceSQLStatement
42351>>>>>>>                End
42351>>>>>>>>
42351>>>>>>>                Get phoSQLGeneratorMSSQLDRC to hoSQLGenerator
42352>>>>>>>                Get _SQLSelectStatement of hoSQLGenerator strQuery Self to sStatement
42353>>>>>>>                Function_Return sStatement
42354>>>>>>>            End_Function
42355>>>>>>>            
42355>>>>>>>            Function SQLDeleteStatement tTableQuery strQuery Returns String
42357>>>>>>>                Handle hoSQLGenerator
42357>>>>>>>                String sStatement
42357>>>>>>>                Send _TableRelateStatesReset (&strQuery)
42358>>>>>>>                Get phoSQLGeneratorMSSQLDRC to hoSQLGenerator
42359>>>>>>>                Get _SQLDeleteStatement of hoSQLGenerator strQuery Self to sStatement
42360>>>>>>>                Function_Return sStatement
42361>>>>>>>            End_Function
42362>>>>>>>
42362>>>>>>>                // Used by TableQueryStructureFunctions.pkg
42362>>>>>>>                Procedure _ReadParentSortValues tTableQuery ByRef strParentQuery tTableQuery ByRef strChildQuery
42364>>>>>>>                    Integer iItem iItemMax
42364>>>>>>>                    String sValue
42364>>>>>>>                    String[] aValues
42365>>>>>>>                    Move (SizeOfArray(strParentQuery.aOrdering)-1) to iItemMax
42366>>>>>>>                    For iItem from 0 to iItemMax
42372>>>>>>>>
42372>>>>>>>                        Get ResultColumnValue (&strParentQuery) strParentQuery.aOrdering[iItem].strValueSource.iTable strParentQuery.aOrdering[iItem].strValueSource.iColumn to sValue
42373>>>>>>>                        If (strParentQuery.aOrdering[iItem].bUppercase) Begin
42375>>>>>>>                            Move (Uppercase(sValue)) to sValue
42376>>>>>>>                        End
42376>>>>>>>>
42376>>>>>>>                        Move sValue to aValues[iItem]
42377>>>>>>>                    Loop
42378>>>>>>>>
42378>>>>>>>                    Move aValues to strChildQuery._strControlBlock.strInnerJoinCB.aCurrentParentSortValues
42379>>>>>>>                End_Procedure
42380>>>>>>>
42380>>>>>>>//            Global_Variable Integer _giSQLHandleCheckIndent
42380>>>>>>>//            Move 0 to _giSQLHandleCheckIndent
42380>>>>>>>//            Procedure ShowInit tSQLStatementHandle strStatement Integer iTable
42380>>>>>>>//                Showln (Repeat("    ",_giSQLHandleCheckIndent)) "Initialize using connection " (String(strStatement.strConnectionHandle.hHandle)) ". Statement handle is: " (String(strStatement.hHandle)) " (Table " (String(iTable)) ")"
42380>>>>>>>//                Increment _giSQLHandleCheckIndent
42380>>>>>>>//            End_Procedure
42380>>>>>>>//            Procedure ShowDeInit tSQLStatementHandle strStatement Integer iTable
42380>>>>>>>//                Decrement _giSQLHandleCheckIndent
42380>>>>>>>//                Showln (Repeat("    ",_giSQLHandleCheckIndent)) "Deinitialize using connection " (String(strStatement.strConnectionHandle.hHandle)) ". Statement handle is: " (String(strStatement.hHandle)) " (Table " (String(iTable)) ")"
42380>>>>>>>//            End_Procedure
42380>>>>>>>
42380>>>>>>>            Function _InitializeQuery tTableQuery ByRef strQuery Returns Boolean
42382>>>>>>>                Integer iTable iPrefetchCount iPrefetchTimeout
42382>>>>>>>                Integer iDecimalSeparator iDriverIndex
42382>>>>>>>                String sDriver sStatement
42382>>>>>>>                tSQLStatementHandle strStatement
42382>>>>>>>                tSQLStatementHandle strStatement
42382>>>>>>>                If (not(strQuery._strControlBlock.bInitialized)) Begin
42384>>>>>>>                    Move True to strQuery._strControlBlock.bInitialized
42385>>>>>>>                    
42385>>>>>>>                    If (strQuery.bRestoreRecordBuffersOnQueryCompletion) Begin
42387>>>>>>>                        Send _PushNoneFixedBuffers strQuery
42388>>>>>>>                    End
42388>>>>>>>>
42388>>>>>>>                    
42388>>>>>>>                    Move strQuery.iTable to iTable
42389>>>>>>>                    Get_Attribute DF_FILE_DRIVER of iTable to sDriver
42392>>>>>>>                    
42392>>>>>>>                    If (strQuery._strControlBlock.iQueryMethod=tqSQLPKG) Begin
42394>>>>>>>                        If (not(strQuery._strControlBlock.strInnerJoinCB.bEnabled) or not(strQuery._strControlBlock.strInnerJoinCB.bInitialized)) Begin
42396>>>>>>>                            
42396>>>>>>>                            If (OpenStatementOnTable(oSQLStatementHandles,strQuery.iTable,&strStatement)) Begin
42398>>>>>>>                                Move strStatement to strQuery._strControlBlock.strSQLStatementHandle
42399>>>>>>>
42399>>>>>>>                                Send _TableRelateStatesReset (&strQuery)
42400>>>>>>>                                Get SQLSelectStatement strQuery Self to sStatement
42401>>>>>>>                                Move (ToANSI(sStatement)) to sStatement
42402>>>>>>>                                Send SQLExecDirect of strStatement.hHandle sStatement
42403>>>>>>>                                Send SQLFetchActivatesBuffer of strStatement.hHandle strQuery.iTable True // True: DF_FILE_ACTIVATE will be true
42404>>>>>>>                                
42404>>>>>>>                                If (strQuery._strControlBlock.strInnerJoinCB.bEnabled) Begin
42406>>>>>>>                                    Move True to strQuery._strControlBlock.strInnerJoinCB.bInitialized
42407>>>>>>>                                    Move False to strQuery._strControlBlock.strInnerJoinCB.bSkipNextFetch
42408>>>>>>>                                    Move False to strQuery._strControlBlock.strInnerJoinCB.bEndOfResultSet
42409>>>>>>>                                End
42409>>>>>>>>
42409>>>>>>>    //                            Send ShowInit strStatement strQuery.iTable
42409>>>>>>>                            End
42409>>>>>>>>
42409>>>>>>>                            
42409>>>>>>>                        End
42409>>>>>>>>
42409>>>>>>>                    End
42409>>>>>>>>
42409>>>>>>>                    Else Begin
42410>>>>>>>                        If (sDriver<>"DATAFLEX") Begin // We're on an SQL backend 
42412>>>>>>>                            // This means that we have been 'forced' to use the record oriented 
42412>>>>>>>                            // interface but we are in fact an SQL table and therefore we might
42412>>>>>>>                            // might want to tamper with the prefetch cache settings:
42412>>>>>>>                            If (strQuery._strControlBlock.strSQLCacheControl.bUseSettings) Begin
42414>>>>>>>                                Move strQuery._strControlBlock.strSQLCacheControl.iPrefetchRecordCount to iPrefetchCount
42415>>>>>>>                                Move strQuery._strControlBlock.strSQLCacheControl.iPrefetchRecordTimeout to iPrefetchTimeout
42416>>>>>>>                                If (iPrefetchCount<>0) Begin
42418>>>>>>>                                    Get_Attribute DF_FILE_BLOCK_SIZE of iTable to strQuery._strControlBlock._strPreviousSQLCacheControl.iPrefetchRecordCount
42421>>>>>>>                                    Set_Attribute DF_FILE_BLOCK_SIZE of iTable to iPrefetchCount
42424>>>>>>>                                End
42424>>>>>>>>
42424>>>>>>>                                If (iPrefetchTimeout<>0) Begin
42426>>>>>>>                                    Get TableCacheTimeout of oTableDriverFunctions iTable to strQuery._strControlBlock._strPreviousSQLCacheControl.iPrefetchRecordTimeout
42427>>>>>>>                                    Set TableCacheTimeout of oTableDriverFunctions iTable to iPrefetchTimeout
42428>>>>>>>                                End
42428>>>>>>>>
42428>>>>>>>                            End
42428>>>>>>>>
42428>>>>>>>                        End
42428>>>>>>>>
42428>>>>>>>                    End
42428>>>>>>>>
42428>>>>>>>                End
42428>>>>>>>>
42428>>>>>>>                Function_Return (strQuery._strControlBlock.bInitialized)
42429>>>>>>>            End_Function
42430>>>>>>>            
42430>>>>>>>            Procedure _DeinitializeQuery tTableQuery ByRef strQuery
42432>>>>>>>                Integer iTable iPrefetchCount iPrefetchTimeout
42432>>>>>>>                String sDriver
42432>>>>>>>                If (strQuery._strControlBlock.iQueryMethod=tqSQLPKG) Begin
42434>>>>>>>                    If (not(strQuery._strControlBlock.strInnerJoinCB.bInitialized)) Begin // inner join => don't close the statement
42436>>>>>>>//                    Send ShowDeInit strQuery._strControlBlock.strSQLStatementHandle strQuery.iTable
42436>>>>>>>                        Send CloseStatement of oSQLStatementHandles strQuery._strControlBlock.strSQLStatementHandle
42437>>>>>>>                    End
42437>>>>>>>>
42437>>>>>>>                End
42437>>>>>>>>
42437>>>>>>>                Else Begin
42438>>>>>>>                    Move strQuery.iTable to iTable
42439>>>>>>>                    Get_Attribute DF_FILE_DRIVER of iTable to sDriver
42442>>>>>>>                    If (sDriver<>"DATAFLEX") Begin // We're on an SQL backend 
42444>>>>>>>                        // This means that we have been 'forced' to use the record oriented 
42444>>>>>>>                        // interface but we are in fact an SQL table and therefore we want
42444>>>>>>>                        // to restore the prefetch cache settings (if they were originally set):
42444>>>>>>>                        If (strQuery._strControlBlock.strSQLCacheControl.bUseSettings) Begin
42446>>>>>>>                            Move strQuery._strControlBlock.strSQLCacheControl.iPrefetchRecordCount to iPrefetchCount
42447>>>>>>>                            Move strQuery._strControlBlock.strSQLCacheControl.iPrefetchRecordTimeout to iPrefetchTimeout
42448>>>>>>>                            If (iPrefetchCount<>0) Begin // Only then did we change it in the first place
42450>>>>>>>                                // Reset prefetch setting
42450>>>>>>>                                Set_Attribute DF_FILE_BLOCK_SIZE of iTable to strQuery._strControlBlock._strPreviousSQLCacheControl.iPrefetchRecordCount
42453>>>>>>>                            End
42453>>>>>>>>
42453>>>>>>>                            If (iPrefetchTimeout<>0) Begin // Only then did we change it in the first place
42455>>>>>>>                                // Restore cache time out setting
42455>>>>>>>                                Set TableCacheTimeout of oTableDriverFunctions iTable to strQuery._strControlBlock._strPreviousSQLCacheControl.iPrefetchRecordTimeout
42456>>>>>>>                            End
42456>>>>>>>>
42456>>>>>>>                        End
42456>>>>>>>>
42456>>>>>>>                    End
42456>>>>>>>>
42456>>>>>>>                End
42456>>>>>>>>
42456>>>>>>>            End_Procedure
42457>>>>>>>
42457>>>>>>>                Function _QueryMethodSQL tTableQuery strQuery Returns Boolean
42459>>>>>>>                    String sDriver
42459>>>>>>>                    Integer iQueryMethod
42459>>>>>>>                    Move tqDATAFLEX to iQueryMethod 
42460>>>>>>>                    If (not(strQuery.bNoESQL)) Begin
42462>>>>>>>                        Get_Attribute DF_FILE_DRIVER of strQuery.iTable to sDriver
42465>>>>>>>                        If (sDriver="MSSQLDRV") Begin
42467>>>>>>>                            Move tqSQLPKG to iQueryMethod
42468>>>>>>>                        End
42468>>>>>>>>
42468>>>>>>>                    End
42468>>>>>>>>
42468>>>>>>>                    Function_Return (iQueryMethod<>tqDATAFLEX)
42469>>>>>>>                End_Function
42470>>>>>>>
42470>>>>>>>            Function _CompileQuery tTableQuery ByRef strQuery Returns Boolean
42472>>>>>>>                Boolean bBackwards
42472>>>>>>>                Boolean[] aSortDescending
42473>>>>>>>                Number nENR
42473>>>>>>>                Number[] aColumnRatings
42474>>>>>>>                String sDriver sFormat
42474>>>>>>>                _tTQIndexRating strRating
42474>>>>>>>                _tTQIndexRating strRating
42474>>>>>>>                _tTQIndexRating[] aIndexRatings
42474>>>>>>>                _tTQIndexRating[] aIndexRatings
42475>>>>>>>                tTQFilterSegment[] aTemp
42475>>>>>>>                tTQFilterSegment[] aTemp
42476>>>>>>>
42476>>>>>>>                If (not(strQuery._strControlBlock.bCompiled)) Begin                    
42478>>>>>>>                    If (_ValidateQuery(Self,strQuery)) Begin
42480>>>>>>>                        
42480>>>>>>>                        // Determine query method:
42480>>>>>>>                        Move tqDATAFLEX to strQuery._strControlBlock.iQueryMethod 
42481>>>>>>>                        If (not(strQuery.bNoESQL)) Begin
42483>>>>>>>                            Get_Attribute DF_FILE_DRIVER of strQuery.iTable to sDriver
42486>>>>>>>                            If (sDriver="MSSQLDRV") Begin
42488>>>>>>>                                Move tqSQLPKG to strQuery._strControlBlock.iQueryMethod
42489>>>>>>>                                Get_Attribute DF_FILE_TABLE_CHARACTER_FORMAT of strQuery.iTable to sFormat
42492>>>>>>>                                Move (sFormat<>"OEM") to strQuery._strControlBlock.bSQLTableIsAnsi
42493>>>>>>>                            End
42493>>>>>>>>
42493>>>>>>>                        End
42493>>>>>>>>
42493>>>>>>>                        
42493>>>>>>>                        If (strQuery._strControlBlock.iQueryMethod=tqDATAFLEX) Begin
42495>>>>>>>                        
42495>>>>>>>                            Move False to strQuery._strCompiled.bBackwards
42496>>>>>>>                            
42496>>>>>>>                            Move strQuery.bForcePrefetch to strQuery._strCompiled.bPrefetch
42497>>>>>>>                
42497>>>>>>>                            Get _CalculateIndex (&strQuery) to aIndexRatings
42498>>>>>>>                            
42498>>>>>>>                            If (strQuery.iForceIndex<>-1) Begin
42500>>>>>>>                                If (_CanFindIndexInRatings(Self,aIndexRatings,strQuery.iForceIndex,&bBackwards,&nENR)) Begin
42502>>>>>>>                                    Move strQuery.iForceIndex to strQuery._strCompiled.iIndex
42503>>>>>>>                                    Move bBackwards to strQuery._strCompiled.bBackwards
42504>>>>>>>                                    Move nENR to strQuery._strCompiled.nENR
42505>>>>>>>                                End
42505>>>>>>>>
42505>>>>>>>                                Else Begin
42506>>>>>>>                                    Send OnError 721 "Illegal index forced"
42507>>>>>>>                                End
42507>>>>>>>>
42507>>>>>>>                            End
42507>>>>>>>>
42507>>>>>>>        
42507>>>>>>>                            If (strQuery.iLimit>=0) Begin
42509>>>>>>>                                Move strQuery.iLimit to strQuery._strCompiled._iLimit
42510>>>>>>>                            End
42510>>>>>>>>
42510>>>>>>>                            Else Begin 
42511>>>>>>>                                // If limit is -3 for example, we only want the 3 last rows of the 
42511>>>>>>>                                // set. In this case we instruct TableQuery to reverse the ordering 
42511>>>>>>>                                // and return the first three. Hokus pokus. (and then of course they
42511>>>>>>>                                // will be occurring in the wrong order). ((deal with that later))
42511>>>>>>>                                Move (-strQuery.iLimit) to strQuery._strCompiled._iLimit
42512>>>>>>>                                Move (not(strQuery._strCompiled.bBackwards)) to strQuery._strCompiled.bBackwards // reverse index search
42513>>>>>>>                            End
42513>>>>>>>>
42513>>>>>>>        
42513>>>>>>>                            Send OnIndexCalculated strQuery aIndexRatings
42514>>>>>>>        
42514>>>>>>>                            Send _CalculateJumpInOutConditions (&strQuery)
42515>>>>>>>        
42515>>>>>>>                            Send _SortOrListValues (&strQuery) // Make sure that values occur in the sequence they would be if occurring in an index
42516>>>>>>>                            
42516>>>>>>>                            If (strQuery._strCompiled.bBackwards) Begin // If backwards, we swap jump-in and jump-out conditions
42518>>>>>>>                                Move strQuery._strCompiled.aJumpInValues to aTemp
42519>>>>>>>                                Move strQuery._strCompiled.aJumpOutValues to strQuery._strCompiled.aJumpInValues
42520>>>>>>>                                Move aTemp to strQuery._strCompiled.aJumpOutValues
42521>>>>>>>                            End
42521>>>>>>>>
42521>>>>>>>                        End
42521>>>>>>>>
42521>>>>>>>
42521>>>>>>>                        Move True to strQuery._strControlBlock.bCompiled
42522>>>>>>>                    End
42522>>>>>>>>
42522>>>>>>>                    Move False to strQuery._strControlBlock.bInitialized
42523>>>>>>>                End
42523>>>>>>>>
42523>>>>>>>                Function_Return (strQuery._strControlBlock.bCompiled)
42524>>>>>>>            End_Function
42525>>>>>>>
42525>>>>>>>    //> This will analyse the query and calculate a query strategy. The strategy may be
42525>>>>>>>    //> inspected by inspecting the values of strQuery members
42525>>>>>>>    Function CompileQuery tTableQuery ByRef strQuery Returns Boolean
42527>>>>>>>        Move False to strQuery._strControlBlock.bCompiled
42528>>>>>>>        Function_Return (_CompileQuery(Self,&strQuery))
42529>>>>>>>    End_Function
42530>>>>>>>
42530>>>>>>>        Function _ValueSourceValue tTableQuery ByRef strQuery _tTQValueSource strValue Returns String
42532>>>>>>>            Integer iColumn
42532>>>>>>>            String sValue
42532>>>>>>>            If (strValue.iTable<>0) Begin
42534>>>>>>>                If (strValue.iTable<>strQuery.iTable) Begin // Only called when dataflex handling
42536>>>>>>>                    Send _RelateToTable (&strQuery) strValue.iTable
42537>>>>>>>                End
42537>>>>>>>>
42537>>>>>>>                Move strValue.iColumn to iColumn
42538>>>>>>>                If (iColumn=0) Begin
42540>>>>>>>                    Move (SerializeRowID(GetRowID(strValue.iTable))) to sValue
42541>>>>>>>                End
42541>>>>>>>>
42541>>>>>>>                Else Begin
42542>>>>>>>                    Get_Field_Value strValue.iTable iColumn to sValue
42545>>>>>>>                    Move (Rtrim(sValue)) to sValue
42546>>>>>>>                End
42546>>>>>>>>
42546>>>>>>>            End
42546>>>>>>>>
42546>>>>>>>            Else If (strValue.hFunction<>0) Begin
42549>>>>>>>                Get strValue.hFunction of strValue.hObject strValue.iColumn to sValue
42550>>>>>>>            End
42550>>>>>>>>
42550>>>>>>>            Else If (SizeOfArray(strValue.aOrList)>0) Begin
42553>>>>>>>                Move strValue.aOrList[strValue._iOrListPointer] to sValue
42554>>>>>>>            End
42554>>>>>>>>
42554>>>>>>>            Else Begin
42555>>>>>>>                Move strValue.sConstant to sValue
42556>>>>>>>            End
42556>>>>>>>>
42556>>>>>>>            If (strValue.iType=tqNUMBER and sValue="") Begin
42558>>>>>>>                Move "0" to sValue
42559>>>>>>>            End
42559>>>>>>>>
42559>>>>>>>            Function_Return sValue
42560>>>>>>>        End_Function
42561>>>>>>>
42561>>>>>>>            Function _ValueSourceScriptValueOrListFormat String[] aOrList Integer iType Returns String
42563>>>>>>>                Integer iItem iMax
42563>>>>>>>                Boolean bOk
42563>>>>>>>                String sValue
42563>>>>>>>                If (iType=tqSTRING or iType=tqTEXT) Begin
42565>>>>>>>                    Move (SizeOfArray(aOrList)-1) to iMax
42566>>>>>>>                    Move True to bOk
42567>>>>>>>                    For iItem from 0 to iMax
42573>>>>>>>>
42573>>>>>>>                        If (bOk) Begin
42575>>>>>>>                            Get AddQuotes of oStringFunctions (&aOrList[iItem]) "'" to bOk
42576>>>>>>>                        End
42576>>>>>>>>
42576>>>>>>>                    Loop
42577>>>>>>>>
42577>>>>>>>                    If (bOk) Begin
42579>>>>>>>                        Get JoinString aOrList "," 0 0 to sValue
42580>>>>>>>                        Move ("("+sValue+")") to sValue
42581>>>>>>>                    End
42581>>>>>>>>
42581>>>>>>>                    Else Begin
42582>>>>>>>                        Move "" to sValue // Signals an error
42583>>>>>>>                    End
42583>>>>>>>>
42583>>>>>>>                End
42583>>>>>>>>
42583>>>>>>>                Else Begin
42584>>>>>>>                    Get JoinString aOrList "," 0 0 to sValue
42585>>>>>>>                    Move ("("+sValue+")") to sValue
42586>>>>>>>                End
42586>>>>>>>>
42586>>>>>>>                Function_Return sValue
42587>>>>>>>            End_Function
42588>>>>>>>
42588>>>>>>>        Function _ValueSourceDisplayValue tTableQuery ByRef strQ _tTQValueSource strValue Returns String // Called by TQ test facility in VDFxray
42590>>>>>>>            Integer iMax iItem
42590>>>>>>>            String sValue
42590>>>>>>>            Move (SizeOfArray(strValue.aOrList)-1) to iMax
42591>>>>>>>            If (iMax>=0) Begin
42593>>>>>>>                For iItem from 0 to iMax
42599>>>>>>>>
42599>>>>>>>                    Move (sValue+strValue.aOrList[iItem]) to sValue
42600>>>>>>>                    If (iItem<>iMax) Begin
42602>>>>>>>                        Move (sValue+" ; ") to sValue
42603>>>>>>>                    End
42603>>>>>>>>
42603>>>>>>>                Loop
42604>>>>>>>>
42604>>>>>>>            End
42604>>>>>>>>
42604>>>>>>>            Else Begin
42605>>>>>>>                Get _ValueSourceValue (&strQ) strValue to sValue
42606>>>>>>>            End
42606>>>>>>>>
42606>>>>>>>            Function_Return sValue
42607>>>>>>>        End_Function
42608>>>>>>>            
42608>>>>>>>        Procedure _AssignConstraintValues tTableQuery ByRef strQuery tTQFilterSegment[] ByRef aFilters
42610>>>>>>>            Integer iMax iIndex
42610>>>>>>>            Move (SizeOfArray(aFilters)-1) to iMax
42611>>>>>>>            For iIndex from 0 to iMax
42617>>>>>>>>
42617>>>>>>>                // If it's a contraint by a table column value and if the table is not fixed we do not bother to assign 
42617>>>>>>>                // initial values. Instead we "calculate" them on each record.
42617>>>>>>>                If (aFilters[iIndex].strRightValue.iTable=0 or _IsTableFixed(Self,strQuery,aFilters[iIndex].strRightValue.iTable)) Begin
42619>>>>>>>                    Get _ValueSourceValue (&strQuery) aFilters[iIndex].strRightValue to aFilters[iIndex].strRightValue._sValue
42620>>>>>>>                    If (aFilters[iIndex].iComp=tqMATCH) Begin
42622>>>>>>>                        Get WildCardEvalSequence of oStringFunctions aFilters[iIndex].strRightValue._sValue to aFilters[iIndex].strMatchEvalSequence
42623>>>>>>>                    End
42623>>>>>>>>
42623>>>>>>>                    If (aFilters[iIndex].iComp=tqUCMATCH) Begin
42625>>>>>>>                        Get WildCardEvalSequence of oStringFunctions (Uppercase(aFilters[iIndex].strRightValue._sValue)) to aFilters[iIndex].strMatchEvalSequence
42626>>>>>>>                    End
42626>>>>>>>>
42626>>>>>>>                End
42626>>>>>>>>
42626>>>>>>>            Loop
42627>>>>>>>>
42627>>>>>>>        End_Procedure
42628>>>>>>>        
42628>>>>>>>            Procedure _AssignFilterExpressionValue tTableQuery ByRef strQuery tTQFilterExpression ByRef strFilterExpression
42630>>>>>>>                Integer iItem iItemMax
42630>>>>>>>
42630>>>>>>>                Get _ValueSourceValue (&strQuery) strFilterExpression.strOperand.strRightValue to strFilterExpression.strOperand.strRightValue._sValue
42631>>>>>>>                If (strFilterExpression.strOperand.iComp=tqMATCH) Begin
42633>>>>>>>                    Get WildCardEvalSequence of oStringFunctions strFilterExpression.strOperand.strRightValue._sValue to strFilterExpression.strOperand.strMatchEvalSequence
42634>>>>>>>                End
42634>>>>>>>>
42634>>>>>>>                If (strFilterExpression.strOperand.iComp=tqUCMATCH) Begin
42636>>>>>>>                    Get WildCardEvalSequence of oStringFunctions (Uppercase(strFilterExpression.strOperand.strRightValue._sValue)) to strFilterExpression.strOperand.strMatchEvalSequence
42637>>>>>>>                End
42637>>>>>>>>
42637>>>>>>>                 
42637>>>>>>>                Move (SizeOfArray(strFilterExpression.aSubExpressions)-1) to iItemMax
42638>>>>>>>                For iItem from 0 to iItemMax
42644>>>>>>>>
42644>>>>>>>                   Send _AssignFilterExpressionValue (&strQuery) (&strFilterExpression.aSubExpressions[iItem])
42645>>>>>>>                Loop
42646>>>>>>>>
42646>>>>>>>            End_Procedure
42647>>>>>>>            
42647>>>>>>>        Procedure _AssignFilterExpressionValues tTableQuery ByRef strQuery
42649>>>>>>>            Integer iItem iItemMax
42649>>>>>>>            tTQFilterExpression strFilterExpression
42649>>>>>>>            tTQFilterExpression strFilterExpression
42649>>>>>>>            Move (SizeOfArray(strQuery.aFilterExpressions)-1) to iItemMax
42650>>>>>>>            For iItem from 0 to iItemMax
42656>>>>>>>>
42656>>>>>>>                Send _AssignFilterExpressionValue (&strQuery) (&strQuery.aFilterExpressions[iItem])
42657>>>>>>>            Loop
42658>>>>>>>>
42658>>>>>>>        End_Procedure
42659>>>>>>>
42659>>>>>>>        Procedure _ReassignJumpInOutConstraintValues tTableQuery ByRef strQuery tTQFilterSegment[] ByRef aJumpInConstraints tTQFilterSegment[] ByRef aJumpOutConstraints
42661>>>>>>>            Integer iTable iColumn iJumpOutItem
42661>>>>>>>            _tTQValueSource stSource
42661>>>>>>>            _tTQValueSource stSource
42661>>>>>>>            String sValue
42661>>>>>>>            Integer iItem iMax
42661>>>>>>>            Move (SizeOfArray(aJumpOutConstraints)-1) to iMax
42662>>>>>>>            For iItem from 0 to iMax
42668>>>>>>>>
42668>>>>>>>                If (SizeOfArray(aJumpOutConstraints[iItem].strRightValue.aOrList)>0) Begin
42670>>>>>>>                    Move aJumpOutConstraints[iItem].strLeftValue.iTable to iTable
42671>>>>>>>                    Move aJumpOutConstraints[iItem].strLeftValue.iColumn to iColumn
42672>>>>>>>                    Move aJumpOutConstraints[iItem].strRightValue to stSource
42673>>>>>>>                    Get _ValueSourceValue (&strQuery) stSource to sValue
42674>>>>>>>                    Move sValue to aJumpOutConstraints[iItem].strRightValue._sValue
42675>>>>>>>                    Get _FindConstraintEQ aJumpInConstraints iTable iColumn True to iJumpOutItem
42676>>>>>>>                    If (iJumpOutItem>-1) Begin
42678>>>>>>>                        Move sValue to aJumpInConstraints[iJumpOutItem].strRightValue._sValue
42679>>>>>>>                    End
42679>>>>>>>>
42679>>>>>>>                    Else Begin
42680>>>>>>>                        Send OnError 722 "Unmatched jumpin or-list (should have been matched in jump-out constraints)"
42681>>>>>>>                    End
42681>>>>>>>>
42681>>>>>>>                End
42681>>>>>>>>
42681>>>>>>>            Loop
42682>>>>>>>>
42682>>>>>>>        End_Procedure
42683>>>>>>>
42683>>>>>>>                Function _SharpenJumpInValue String sValue Integer iTable Integer iColumn Boolean bDescending Returns String
42685>>>>>>>                    // NOTE: If the function does not succeed in sharpening the value, no harm
42685>>>>>>>                    // is done (other than some potentially unnescessary finds).
42685>>>>>>>                    Integer iType iLen iDecs
42685>>>>>>>                    Number nValue
42685>>>>>>>                    Date dValue
42685>>>>>>>                    DateTime dtValue
42685>>>>>>>                    
42685>>>>>>>                    Get_Attribute DF_FIELD_TYPE of iTable iColumn to iType
42688>>>>>>>                    Get_Attribute DF_FIELD_LENGTH of iTable iColumn to iLen
42691>>>>>>>                    Get_Attribute DF_FIELD_PRECISION of iTable iColumn to iDecs
42694>>>>>>>                    
42694>>>>>>>                    If (iType=DF_BCD) Begin 
42696>>>>>>>                        Move sValue to nValue
42697>>>>>>>                        // OBS! Here we need a check that we do not in- or decrement the value out of range
42697>>>>>>>                        If (bDescending) Begin 
42699>>>>>>>                            If (iDecs=0) Move (nValue-1) to nValue
42702>>>>>>>                            Else If (iDecs=2) Move (nValue-0.01) to nValue
42706>>>>>>>                            Else If (iDecs=4) Move (nValue-0.0001) to nValue
42710>>>>>>>                            Else If (iDecs=6) Move (nValue-0.000001) to nValue
42714>>>>>>>                            Else If (iDecs=8) Move (nValue-0.00000001) to nValue
42718>>>>>>>                        End
42718>>>>>>>>
42718>>>>>>>                        Else Begin
42719>>>>>>>                            If (iDecs=0) Move (nValue+1) to nValue
42722>>>>>>>                            Else If (iDecs=2) Move (nValue+0.01) to nValue
42726>>>>>>>                            Else If (iDecs=4) Move (nValue+0.0001) to nValue
42730>>>>>>>                            Else If (iDecs=6) Move (nValue+0.000001) to nValue
42734>>>>>>>                            Else If (iDecs=8) Move (nValue+0.00000001) to nValue
42738>>>>>>>                        End
42738>>>>>>>>
42738>>>>>>>                        Move nValue to sValue
42739>>>>>>>                    End
42739>>>>>>>>
42739>>>>>>>                    Else If (iType=DF_DATE) Begin
42742>>>>>>>                        Move sValue to dValue
42743>>>>>>>                        If (bDescending) Begin
42745>>>>>>>                            If (Integer(dValue>0)) Begin
42747>>>>>>>                                Get DateIncrement of oDateFunctions dValue DS_DAY -1 to dValue
42748>>>>>>>                            End
42748>>>>>>>>
42748>>>>>>>                        End
42748>>>>>>>>
42748>>>>>>>                        Else Begin
42749>>>>>>>                            If (dValue<LargestPossibleDate) Begin
42751>>>>>>>                                Get DateIncrement of oDateFunctions dValue DS_DAY 1 to dValue
42752>>>>>>>                            End
42752>>>>>>>>
42752>>>>>>>                        End
42752>>>>>>>>
42752>>>>>>>                        Move dValue to sValue
42753>>>>>>>                    End
42753>>>>>>>>
42753>>>>>>>                    Else If (iType=DF_DATETIME) Begin
42756>>>>>>>                        Move sValue to dtValue
42757>>>>>>>                        // OBS. Here we need a check that we do not in- or decrement the value out of range
42757>>>>>>>                        If (bDescending) Begin
42759>>>>>>>                            Get DateTimeIncrement of oDateFunctions dtValue DS_SECOND -1 to dValue
42760>>>>>>>                        End
42760>>>>>>>>
42760>>>>>>>                        Else Begin
42761>>>>>>>                            Get DateTimeIncrement of oDateFunctions dtValue DS_SECOND 1 to dValue
42762>>>>>>>                        End
42762>>>>>>>>
42762>>>>>>>                        Move dtValue to sValue
42763>>>>>>>                    End
42763>>>>>>>>
42763>>>>>>>                    Else If (iType=DF_ASCII) Begin
42766>>>>>>>                        // This involves knowing the collate sequence of the DB and this we
42766>>>>>>>                        // can only know that for sure if the driver is "DATAFLEX". (clue: Get CurrentCollateString of oVdfRuntimeFunctions)
42766>>>>>>>                    End
42766>>>>>>>>
42766>>>>>>>                    Function_Return sValue
42767>>>>>>>                End_Function
42768>>>>>>>
42768>>>>>>>        Procedure _SeedRecordBuffer tTableQuery strQ
42770>>>>>>>            Boolean bIndexSeedSharpeningEnabled bBackwards
42770>>>>>>>            Integer iMax iMax2 iIndex iTable iColumn
42770>>>>>>>            String sValue
42770>>>>>>>            tTQFilterSegment[] aFilters
42770>>>>>>>            tTQFilterSegment[] aFilters
42771>>>>>>>            tocIndex strIndex
42771>>>>>>>            tocIndex strIndex
42771>>>>>>>
42771>>>>>>>            Move strQ._strCompiled.bIndexSeedSharpeningEnabled to bIndexSeedSharpeningEnabled
42772>>>>>>>
42772>>>>>>>            Move strQ._strCompiled.aJumpInValues to aFilters
42773>>>>>>>
42773>>>>>>>            Move (SizeOfArray(aFilters)-1) to iMax
42774>>>>>>>            For iIndex from 0 to iMax
42780>>>>>>>>
42780>>>>>>>                Move aFilters[iIndex].strLeftValue.iTable to iTable
42781>>>>>>>                Move aFilters[iIndex].strLeftValue.iColumn to iColumn
42782>>>>>>>                Move aFilters[iIndex].strRightValue._sValue to sValue
42783>>>>>>>
42783>>>>>>>                If (bIndexSeedSharpeningEnabled) Begin
42785>>>>>>>                    If (aFilters[iIndex].iComp=tqLT) Begin // Attempt to sharpen jump-in value on descending segment
42787>>>>>>>                        Get _SharpenJumpInValue sValue iTable iColumn True to sValue
42788>>>>>>>                    End
42788>>>>>>>>
42788>>>>>>>                    Else If (aFilters[iIndex].iComp=tqGT) Begin // Attempt to sharpen jump-in value on ascending segment
42791>>>>>>>                        Get _SharpenJumpInValue sValue iTable iColumn False to sValue
42792>>>>>>>                    End
42792>>>>>>>>
42792>>>>>>>                End
42792>>>>>>>>
42792>>>>>>>
42792>>>>>>>                Set_Field_Value iTable iColumn to sValue
42795>>>>>>>            Loop
42796>>>>>>>>
42796>>>>>>>
42796>>>>>>>            Get IndexDefinition of oOverlapColumnFunctions strQ.iTable strQ._strCompiled.iIndex to strIndex
42797>>>>>>>            Move (SizeOfArray(strIndex.aSegments)-1) to iMax2
42798>>>>>>>            For iIndex from (iMax+1) to iMax2
42804>>>>>>>>
42804>>>>>>>                Move ((Integer(strQ._strCompiled.bBackwards)+Integer(strIndex.aSegments[iIndex].bDescending))=1) to bBackwards // xor
42805>>>>>>>                If (strIndex.aSegments[iIndex].iColumn>0 or bBackwards) Begin // Don't seed a negative recnum !!!!
42807>>>>>>>                    Send SeedMinValue of oIndexFunctions strQ.iTable strIndex.aSegments[iIndex].iColumn (bBackwards)
42808>>>>>>>                End
42808>>>>>>>>
42808>>>>>>>            Loop
42809>>>>>>>>
42809>>>>>>>        End_Procedure
42810>>>>>>>
42810>>>>>>>            Function _TestNumber Number nValueLeft Integer iComp Number nValueRight Returns Boolean
42812>>>>>>>                If (iComp=tqEQ) Function_Return (nValueLeft =  nValueRight)
42815>>>>>>>                If (iComp=tqLT) Function_Return (nValueLeft <  nValueRight)
42818>>>>>>>                If (iComp=tqLE) Function_Return (nValueLeft <= nValueRight)
42821>>>>>>>                If (iComp=tqGE) Function_Return (nValueLeft >= nValueRight)
42824>>>>>>>                If (iComp=tqGT) Function_Return (nValueLeft >  nValueRight)
42827>>>>>>>                If (iComp=tqNE) Function_Return (nValueLeft <> nValueRight)
42830>>>>>>>                Function_Return False
42831>>>>>>>            End_Function
42832>>>>>>>
42832>>>>>>>            Function _TestString String sValueLeft Integer iComp tWildCardEvalSequence strMatchSequence String sValueRight Returns Boolean
42834>>>>>>>                If (iComp=tqEQ) Function_Return (sValueLeft =  sValueRight)
42837>>>>>>>                If (iComp=tqLT) Function_Return (sValueLeft <  sValueRight)
42840>>>>>>>                If (iComp=tqLE) Function_Return (sValueLeft <= sValueRight)
42843>>>>>>>                If (iComp=tqGE) Function_Return (sValueLeft >= sValueRight)
42846>>>>>>>                If (iComp=tqGT) Function_Return (sValueLeft >  sValueRight)
42849>>>>>>>                If (iComp=tqNE) Function_Return (sValueLeft <> sValueRight)
42852>>>>>>>//                If (iComp=tqCONTAINS) Function_Return (sValueLeft contains sValueRight)
42852>>>>>>>//                If (iComp=tqIN) Begin
42852>>>>>>>//                    If sValueLeft in sValueRight Begin
42852>>>>>>>//                        Function_Return True
42852>>>>>>>//                    End
42852>>>>>>>//                End
42852>>>>>>>                If (iComp=tqMATCH) Begin
42854>>>>>>>                    Function_Return (WildCardMatch(oStringFunctions,sValueLeft,strMatchSequence))
42855>>>>>>>                End
42855>>>>>>>>
42855>>>>>>>                If (iComp=tqUCMATCH) Begin
42857>>>>>>>                    Function_Return (WildCardMatch(oStringFunctions,Uppercase(sValueLeft),strMatchSequence))
42858>>>>>>>                End
42858>>>>>>>>
42858>>>>>>>                Function_Return False
42859>>>>>>>            End_Function
42860>>>>>>>
42860>>>>>>>            Function _TestText String sValueLeft Integer iComp tWildCardEvalSequence stMatchSequence String sValueRight Returns Boolean
42862>>>>>>>                Function_Return (_TestString(Self,sValueLeft,iComp,stMatchSequence,sValueRight))
42863>>>>>>>            End_Function
42864>>>>>>>        
42864>>>>>>>            Function _TestDate Date dValueLeft Integer iComp Date dValueRight Returns Boolean
42866>>>>>>>                If (iComp=tqEQ) Function_Return (dValueLeft =  dValueRight)
42869>>>>>>>                If (iComp=tqLT) Function_Return (dValueLeft <  dValueRight)
42872>>>>>>>                If (iComp=tqLE) Function_Return (dValueLeft <= dValueRight)
42875>>>>>>>                If (iComp=tqGE) Function_Return (dValueLeft >= dValueRight)
42878>>>>>>>                If (iComp=tqGT) Function_Return (dValueLeft >  dValueRight)
42881>>>>>>>                If (iComp=tqNE) Function_Return (dValueLeft <> dValueRight)
42884>>>>>>>                Function_Return False
42885>>>>>>>            End_Function
42886>>>>>>>        
42886>>>>>>>            Function _TestDateTime DateTime dtValueLeft Integer iComp DateTime dtValueRight Returns Boolean
42888>>>>>>>                If (iComp=tqEQ) Function_Return (dtValueLeft =  dtValueRight)
42891>>>>>>>                If (iComp=tqLT) Function_Return (dtValueLeft <  dtValueRight)
42894>>>>>>>                If (iComp=tqLE) Function_Return (dtValueLeft <= dtValueRight)
42897>>>>>>>                If (iComp=tqGE) Function_Return (dtValueLeft >= dtValueRight)
42900>>>>>>>                If (iComp=tqGT) Function_Return (dtValueLeft >  dtValueRight)
42903>>>>>>>                If (iComp=tqNE) Function_Return (dtValueLeft <> dtValueRight)
42906>>>>>>>                Function_Return False
42907>>>>>>>            End_Function
42908>>>>>>>            
42908>>>>>>>            Function _EvaluateFilter tTableQuery ByRef strQuery tTQFilterSegment strFilter Boolean bOrlistAllItems Returns Boolean
42910>>>>>>>                Integer iType iOrListMax iOrListIndex
42910>>>>>>>                Boolean bEval bFoundInOrList
42910>>>>>>>                String sLeftValue sRightValue
42910>>>>>>>
42910>>>>>>>                Get _ValueSourceValue (&strQuery) strFilter.strLeftValue to sLeftValue
42911>>>>>>>                Move strFilter.strLeftValue.iType to iType
42912>>>>>>>                
42912>>>>>>>                Move (SizeOfArray(strFilter.strRightValue.aOrList)-1) to iOrListMax
42913>>>>>>>                If (bOrlistAllItems and iOrListMax>=0) Begin
42915>>>>>>>                    Move False to bFoundInOrList
42916>>>>>>>                    For iOrListIndex from 0 to iOrListMax
42922>>>>>>>>
42922>>>>>>>                        If (not(bFoundInOrList)) Begin
42924>>>>>>>                            If (iType=tqSTRING)        Get _TestString   sLeftValue strFilter.iComp strFilter.strMatchEvalSequence strFilter.strRightValue.aOrList[iOrListIndex] to bFoundInOrList
42927>>>>>>>                            Else If (iType=tqNUMBER)   Get _TestNumber   sLeftValue strFilter.iComp strFilter.strRightValue.aOrList[iOrListIndex] to bFoundInOrList
42931>>>>>>>                            Else If (iType=tqTEXT)     Get _TestText     sLeftValue strFilter.iComp strFilter.strMatchEvalSequence strFilter.strRightValue.aOrList[iOrListIndex] to bFoundInOrList
42935>>>>>>>                            Else If (iType=tqDATE)     Get _TestDate     sLeftValue strFilter.iComp strFilter.strRightValue.aOrList[iOrListIndex] to bFoundInOrList
42939>>>>>>>                            Else If (iType=tqDATETIME) Get _TestDateTime sLeftValue strFilter.iComp strFilter.strRightValue.aOrList[iOrListIndex] to bFoundInOrList
42943>>>>>>>                        End
42943>>>>>>>>
42943>>>>>>>                    Loop
42944>>>>>>>>
42944>>>>>>>                    Move bFoundInOrList to bEval
42945>>>>>>>                End
42945>>>>>>>>
42945>>>>>>>                Else Begin
42946>>>>>>>                    If (strFilter.strRightValue.iTable<>0 and not(_IsTableFixed(Self,strQuery,strFilter.strRightValue.iTable))) Begin
42948>>>>>>>                        Get _ValueSourceValue (&strQuery) strFilter.strRightValue to sRightValue
42949>>>>>>>                        If (strFilter.iComp=tqMATCH or strFilter.iComp=tqUCMATCH) Begin
42951>>>>>>>                            Get WildCardEvalSequence of oStringFunctions sRightValue to strFilter.strMatchEvalSequence
42952>>>>>>>                        End
42952>>>>>>>>
42952>>>>>>>                    end
42952>>>>>>>>
42952>>>>>>>                    Else Begin
42953>>>>>>>                        Move strFilter.strRightValue._sValue to sRightValue
42954>>>>>>>                    End
42954>>>>>>>>
42954>>>>>>>                    If (iType=tqSTRING)        Get _TestString   sLeftValue strFilter.iComp strFilter.strMatchEvalSequence sRightValue to bEval
42957>>>>>>>                    Else If (iType=tqNUMBER)   Get _TestNumber   sLeftValue strFilter.iComp sRightValue to bEval
42961>>>>>>>                    Else If (iType=tqTEXT)     Get _TestText     sLeftValue strFilter.iComp strFilter.strMatchEvalSequence sRightValue to bEval
42965>>>>>>>                    Else If (iType=tqDATE)     Get _TestDate     sLeftValue strFilter.iComp sRightValue to bEval
42969>>>>>>>                    Else If (iType=tqDATETIME) Get _TestDateTime sLeftValue strFilter.iComp sRightValue to bEval
42973>>>>>>>                End
42973>>>>>>>>
42973>>>>>>>                Function_Return bEval
42974>>>>>>>            End_Function
42975>>>>>>>            
42975>>>>>>>        Function _EvaluateConstraints tTableQuery ByRef strQuery tTQFilterSegment[] aFilters Boolean bOrlistAllItems Integer ByRef iFailedConstrainIndex Returns Boolean
42977>>>>>>>            Integer iMax iIndex 
42977>>>>>>>            Boolean bEval 
42977>>>>>>>            Move (SizeOfArray(aFilters)-1) to iMax
42978>>>>>>>            
42978>>>>>>>            For iIndex from 0 to iMax
42984>>>>>>>>
42984>>>>>>>                Get _EvaluateFilter (&strQuery) aFilters[iIndex] bOrlistAllItems to bEval
42985>>>>>>>                If (not(bEval)) Begin
42987>>>>>>>                    Move iIndex to iFailedConstrainIndex
42988>>>>>>>                    Function_Return False
42989>>>>>>>                End
42989>>>>>>>>
42989>>>>>>>            Loop
42990>>>>>>>>
42990>>>>>>>
42990>>>>>>>            Move -1 to iFailedConstrainIndex // Nothing failed
42991>>>>>>>            Function_Return True
42992>>>>>>>        End_Function
42993>>>>>>>    
42993>>>>>>>                Function _EvaluateFilterExpression tTableQuery ByRef strQuery tTQFilterExpression[] aExpressions Returns Boolean
42995>>>>>>>                    Integer iItem iItemMax
42995>>>>>>>                    Boolean bRvalDetermined bEvalResult bAtomExpression
42995>>>>>>>                    Move False to bRvalDetermined
42996>>>>>>>                    Move (SizeOfArray(aExpressions)-1) to iItemMax
42997>>>>>>>                    Move 0 to iItem
42998>>>>>>>                    While (iItem<=iItemMax)
43002>>>>>>>                        
43002>>>>>>>                        If (iItem>0 and ((bEvalResult and aExpressions[iItem-1].iAndOr=tqKeyOR) or ;                                    (not(bEvalResult) and aExpressions[iItem-1].iAndOr=tqKeyAND))) Begin
43004>>>>>>>                            // Do nothing! Evaluating the current item will not change the overall value
43004>>>>>>>                        End
43004>>>>>>>>
43004>>>>>>>                        Else Begin
43005>>>>>>>                        
43005>>>>>>>                            If (SizeOfArray(aExpressions[iItem].aSubExpressions)>0) Begin
43007>>>>>>>                                Get _EvaluateFilterExpression (&strQuery) aExpressions[iItem].aSubExpressions to bAtomExpression
43008>>>>>>>                            End
43008>>>>>>>>
43008>>>>>>>                            Else Begin
43009>>>>>>>                                Get _EvaluateFilter (&strQuery) aExpressions[iItem].strOperand True to bAtomExpression
43010>>>>>>>                            End
43010>>>>>>>>
43010>>>>>>>                            If (aExpressions[iItem].bNot) Begin
43012>>>>>>>                                Move (not(bAtomExpression)) to bAtomExpression
43013>>>>>>>                            End
43013>>>>>>>>
43013>>>>>>>                            
43013>>>>>>>                            If (iItem=0) Begin
43015>>>>>>>                                Move bAtomExpression to bEvalResult
43016>>>>>>>                            End
43016>>>>>>>>
43016>>>>>>>                            Else Begin
43017>>>>>>>                                If (aExpressions[iitem-1].iAndOr=tqKeyAND) Begin
43019>>>>>>>                                    Move (bEvalResult and bAtomExpression) to bEvalResult
43020>>>>>>>                                End
43020>>>>>>>>
43020>>>>>>>                                Else If (aExpressions[iitem-1].iAndOr=tqKeyOR) Begin
43023>>>>>>>                                    Move (bEvalResult or bAtomExpression) to bEvalResult
43024>>>>>>>                                End
43024>>>>>>>>
43024>>>>>>>                                Else Begin
43025>>>>>>>                                    Send OnError 723 "Unknown operator (should be AND or OR)"
43026>>>>>>>                                End
43026>>>>>>>>
43026>>>>>>>                            End
43026>>>>>>>>
43026>>>>>>>                        End
43026>>>>>>>>
43026>>>>>>>                        Increment iItem
43027>>>>>>>                    Loop
43028>>>>>>>>
43028>>>>>>>
43028>>>>>>>                    //    If (not(bRvalDetermined)) Begin
43028>>>>>>>                    //        Error 724 "Expression could not evaluate"
43028>>>>>>>                    //    End
43028>>>>>>>
43028>>>>>>>                    Function_Return bEvalResult
43029>>>>>>>                End_Function
43030>>>>>>>
43030>>>>>>>        Function _EvaluateFilterExpressions tTableQuery ByRef strQuery Returns Boolean
43032>>>>>>>            Boolean bEvalResult
43032>>>>>>>            Integer iItem iItemMax
43032>>>>>>>            Move True to bEvalResult
43033>>>>>>>            Move (SizeOfArray(strQuery.aFilterExpressions)-1) to iItemMax
43034>>>>>>>            Move 0 to iItem
43035>>>>>>>            While (bEvalResult and iItem<=iItemMax)
43039>>>>>>>                Get _EvaluateFilterExpression (&strQuery) strQuery.aFilterExpressions[iItem].aSubExpressions to bEvalResult
43040>>>>>>>                Increment iItem
43041>>>>>>>            Loop
43042>>>>>>>>
43042>>>>>>>            Function_Return bEvalResult
43043>>>>>>>        End_Function
43044>>>>>>>        
43044>>>>>>>    //> The function returns true if the record currently in
43044>>>>>>>    //> the buffer of the query main table evaluates true
43044>>>>>>>    //> against the filters of strQuery.
43044>>>>>>>    Function Belongs tTableQuery strQuery Returns Boolean
43046>>>>>>>        Boolean bBelongs
43046>>>>>>>        Integer iGrb
43046>>>>>>>        // New record! Indicate that related buffers have to be reconsidered 
43046>>>>>>>        // and found if needed:
43046>>>>>>>        Send _TableRelateStatesReset (&strQuery)
43047>>>>>>>        // Evaluate against all filters added to the query:
43047>>>>>>>        Get _EvaluateConstraints (&strQuery) strQuery.aFilters True (&iGrb) to bBelongs
43048>>>>>>>        Function_Return bBelongs
43049>>>>>>>    End_Function
43050>>>>>>>
43050>>>>>>>//    Procedure ExecuteQuery tTableQuery ByRef strQuery
43050>>>>>>>//        Boolean bFound
43050>>>>>>>//        Move True to strQuery.bForcePrefetch
43050>>>>>>>//        If (_CompileQuery(Self,&strQuery)) Begin
43050>>>>>>>//            If (_InitializeQuery(Self,&strQuery)) Begin
43050>>>>>>>//                // When bForcePrefetch is true finding the record will populate the
43050>>>>>>>//                // result array inside strQuery:
43050>>>>>>>//                Get FindRecord (&strQuery) to bFound // and that's all we need
43050>>>>>>>//                Get SystemTimeMilliSeconds of oDateFunctions to strQuery._strControlBlock.strStopTime
43050>>>>>>>//            End
43050>>>>>>>//        End
43050>>>>>>>//    End_Procedure
43050>>>>>>>
43050>>>>>>>    Procedure PurgeResultSet tTableQuery ByRef strQuery
43052>>>>>>>        Move strQuery.iTable to strQuery.strResultSet.iTable
43053>>>>>>>        Move (ResizeArray(strQuery.strResultSet.aRecords,0)) to strQuery.strResultSet.aRecords
43054>>>>>>>        Move -1 to strQuery.strResultSet._iCurrentRowPointer
43055>>>>>>>    End_Procedure
43056>>>>>>>
43056>>>>>>>
43056>>>>>>>                Procedure _ResultSetAddCurrentRecord tTableQuery ByRef strQuery
43058>>>>>>>                    Integer iRow iSegment iMax iColumn
43058>>>>>>>                    Integer iTable
43058>>>>>>>                    String sValue sSortValue
43058>>>>>>>                    tocIndexSegment stSegment
43058>>>>>>>                    tocIndexSegment stSegment
43058>>>>>>>
43058>>>>>>>                    // Row ID
43058>>>>>>>                    Move (SizeOfArray(strQuery.strResultSet.aRecords)) to iRow
43059>>>>>>>                    Move (GetRowID(strQuery.iTable)) to strQuery.strResultSet.aRecords[iRow].riRowId
43060>>>>>>>
43060>>>>>>>                    // Calculate sort value
43060>>>>>>>                    Move "" to sSortValue
43061>>>>>>>                    Move (SizeOfArray(strQuery.aOrdering)-1) to iMax
43062>>>>>>>                    For iSegment from 0 to iMax
43068>>>>>>>>
43068>>>>>>>                        Move strQuery.aOrdering[iSegment].strValueSource.iTable to iTable
43069>>>>>>>                        Move strQuery.aOrdering[iSegment].strValueSource.iColumn to stSegment.iColumn
43070>>>>>>>                        Move strQuery.aOrdering[iSegment].bDescending to stSegment.bDescending
43071>>>>>>>                        Move strQuery.aOrdering[iSegment].bUppercase to stSegment.bUppercase
43072>>>>>>>                        If (iTable<>strQuery.iTable) Begin
43074>>>>>>>                            Send _RelateToTable (&strQuery) iTable
43075>>>>>>>                        End
43075>>>>>>>>
43075>>>>>>>                        Get IndexSegmentSortValue of oIndexFunctions iTable stSegment to sValue
43076>>>>>>>                        Move (sSortValue+sValue) to sSortValue
43077>>>>>>>                    Loop
43078>>>>>>>>
43078>>>>>>>                    Move sSortValue to strQuery.strResultSet.aRecords[iRow].sSortValue
43079>>>>>>>
43079>>>>>>>                    // Read selected column values
43079>>>>>>>                    Move (SizeOfArray(strQuery.aColumnSources)-1) to iMax
43080>>>>>>>                    For iColumn from 0 to iMax
43086>>>>>>>>
43086>>>>>>>                        Get _ValueSourceValue (&strQuery) strQuery.aColumnSources[iColumn] to strQuery.strResultSet.aRecords[iRow].aColumnValues[iColumn]
43087>>>>>>>                    Loop
43088>>>>>>>>
43088>>>>>>>                End_Procedure
43089>>>>>>>
43089>>>>>>>                    Function _ResultSetRecordsCompare tTQResultRow stVal1 tTQResultRow stVal2 Returns Integer
43091>>>>>>>                        If (stVal1.sSortValue<stVal2.sSortValue) Function_Return (LT)
43094>>>>>>>                        If (stVal1.sSortValue>stVal2.sSortValue) Function_Return (GT)
43097>>>>>>>                        Function_Return (EQ)
43098>>>>>>>                    End_Function
43099>>>>>>>
43099>>>>>>>                Procedure _ResultSetSort tTableQuery ByRef strQuery
43101>>>>>>>                    If (SizeOfArray(strQuery.aOrdering)>0) Begin
43103>>>>>>>                        Move (SortArray(strQuery.strResultSet.aRecords,Self,GET__ResultSetRecordsCompare)) to strQuery.strResultSet.aRecords
43104>>>>>>>                    End
43104>>>>>>>>
43104>>>>>>>                End_Procedure
43105>>>>>>>
43105>>>>>>>                Procedure _ResultSetActivateCurrentRecord tTableQuery ByRef strQuery
43107>>>>>>>                    Boolean bFound
43107>>>>>>>                    Integer iTable
43107>>>>>>>                    RowID riRowID
43107>>>>>>>                    Move strQuery.iTable to iTable
43108>>>>>>>                    Move strQuery.strResultSet.aRecords[strQuery.strResultSet._iCurrentRowPointer].riRowId to riRowID
43109>>>>>>>                    Move (FindByRowID(iTable,riRowID)) to bFound
43110>>>>>>>                    Send _TableRelateStatesReset (&strQuery)
43111>>>>>>>                    If (bFound) Begin
43113>>>>>>>                        Send _RelateMainRecord (&strQuery)
43114>>>>>>>                    End
43114>>>>>>>>
43114>>>>>>>                    Else Begin
43115>>>>>>>                        Send OnError 725 "Result set record not found"
43116>>>>>>>                    End
43116>>>>>>>>
43116>>>>>>>                End_Procedure
43117>>>>>>>
43117>>>>>>>            Function _FindFirstRecordAux tTableQuery ByRef strQuery Integer ByRef iFailedConstrainIndex Returns Boolean
43119>>>>>>>                Boolean bFound bEval
43119>>>>>>>                Integer iTable iIndex iJunk
43119>>>>>>>
43119>>>>>>>                Move strQuery.iTable to iTable
43120>>>>>>>                Move strQuery._strCompiled.iIndex to iIndex
43121>>>>>>>                Clear iTable
43122>>>>>>>
43122>>>>>>>                Send _TableRelateStatesReset (&strQuery) // Reset information about what related records have already been found
43123>>>>>>>                Send _SeedRecordBuffer strQuery
43124>>>>>>>
43124>>>>>>>                If (strQuery._strCompiled.bBackwards) Begin
43126>>>>>>>                    Vfind iTable iIndex LE
43128>>>>>>>                End
43128>>>>>>>>
43128>>>>>>>                Else Begin
43129>>>>>>>                    Vfind iTable iIndex GE
43131>>>>>>>                    If (Found) Begin // Problem and fix pointed out by Russell McDougall
43133>>>>>>>                        // From the on-line help:
43133>>>>>>>
43133>>>>>>>                        // "A Find GE always finds a record unless the table is empty. A find GE after
43133>>>>>>>                        // the last record in the table will still return the last record. It always sets
43133>>>>>>>                        // the Predefined Indicators Found to True and FindErr to False). Note that this
43133>>>>>>>                        // behavior is different than for LE. A Find LE before the first record in the table
43133>>>>>>>                        // will not return a record, and will set the predefined indicators Found to False
43133>>>>>>>                        // and FindErr to True."
43133>>>>>>>
43133>>>>>>>                        // This feature of the find and vfind commands forces us to check
43133>>>>>>>                        // that the record found is not a record that it really shouldn't have found in the
43133>>>>>>>                        // first place:
43133>>>>>>>
43133>>>>>>>                        Get _EvaluateConstraints (&strQuery) strQuery._strCompiled.aJumpInValues False (&iFailedConstrainIndex) to bEval
43134>>>>>>>                        Move bEval to Found
43135>>>>>>>                    End
43135>>>>>>>>
43135>>>>>>>                End
43135>>>>>>>>
43135>>>>>>>                Move (Found) to bFound
43136>>>>>>>
43136>>>>>>>                Increment strQuery._strControlBlock.iFindCount
43137>>>>>>>                If (bFound) Begin
43139>>>>>>>                    Repeat
43139>>>>>>>>
43139>>>>>>>                        // Jump out?
43139>>>>>>>                        Get _EvaluateConstraints (&strQuery) strQuery._strCompiled.aJumpOutValues False (&iFailedConstrainIndex) to bEval
43140>>>>>>>                        If (not(bEval)) Begin // If jump-out criteria does not evaluate: jump out
43142>>>>>>>                            Function_Return False
43143>>>>>>>                        End
43143>>>>>>>>
43143>>>>>>>                        // Evaluate 'other' criteria
43143>>>>>>>                        Get _EvaluateConstraints (&strQuery) strQuery._strCompiled.aOtherConditions True (&iJunk) to bEval
43144>>>>>>>                        If (bEval) Begin // Evaluate filter expressions
43146>>>>>>>                            Get _EvaluateFilterExpressions (&strQuery) to bEval
43147>>>>>>>                        End
43147>>>>>>>>
43147>>>>>>>                        If (not(bEval)) Begin
43149>>>>>>>                            If (strQuery._strCompiled.bBackwards) Begin
43151>>>>>>>                                Vfind iTable iIndex LT
43153>>>>>>>                            End
43153>>>>>>>>
43153>>>>>>>                            Else Begin
43154>>>>>>>                                Vfind iTable iIndex GT
43156>>>>>>>                            End
43156>>>>>>>>
43156>>>>>>>                            Move (Found) to bFound
43157>>>>>>>                            Increment strQuery._strControlBlock.iFindCount
43158>>>>>>>                            Send _TableRelateStatesReset (&strQuery)
43159>>>>>>>                            If (not(bFound)) Begin // end of table
43161>>>>>>>                                Move (SizeOfArray(strQuery._strCompiled.aJumpOutValues)-1) to iFailedConstrainIndex
43162>>>>>>>                                Function_Return False
43163>>>>>>>                            End
43163>>>>>>>>
43163>>>>>>>                        End
43163>>>>>>>>
43163>>>>>>>                    Until (bEval)
43165>>>>>>>                End
43165>>>>>>>>
43165>>>>>>>
43165>>>>>>>//                Move (GetRowID(iTable)) to strQuery._strControlBlock.rCurrentRecord
43165>>>>>>>                If (bFound) Begin
43167>>>>>>>                    Increment strQuery._strControlBlock.iSelectCount
43168>>>>>>>                End
43168>>>>>>>>
43168>>>>>>>                Function_Return bFound
43169>>>>>>>            End_Function // _FindFirstRecordAux
43170>>>>>>>            
43170>>>>>>>            Procedure _SQLBindResultTables tTableQuery ByRef strQuery
43172>>>>>>>                Integer iItem iItemMax
43172>>>>>>>                Move (SizeOfArray(strQuery.aColumnSources)-1) to iItemMax
43173>>>>>>>
43173>>>>>>>                If (iItemMax>=0) Begin
43175>>>>>>>                    For iItem from 0 to iItemMax
43181>>>>>>>>
43181>>>>>>>                        If (strQuery.aColumnSources[iItem].iColumn=0) Begin
43183>>>>>>>                             Send SQLBindFile of strQuery._strControlBlock.strSQLStatementHandle.hHandle strQuery.aColumnSources[iItem].iTable
43184>>>>>>>                        End
43184>>>>>>>>
43184>>>>>>>                    Loop
43185>>>>>>>>
43185>>>>>>>                End
43185>>>>>>>>
43185>>>>>>>                Else Begin
43186>>>>>>>                    Send SQLBindFile of strQuery._strControlBlock.strSQLStatementHandle.hHandle strQuery.iTable
43187>>>>>>>                End
43187>>>>>>>>
43187>>>>>>>            End_Procedure
43188>>>>>>>
43188>>>>>>>                    Function _SQLCheckAgainstParentRecord_CompareSortingSegmentValues String sValue1 String sValue2 Integer iType Returns Integer
43190>>>>>>>                        Date dValue1 dValue2
43190>>>>>>>                        DateTime dtValue1 dtValue2
43190>>>>>>>                        Number nValue1 nValue2
43190>>>>>>>                        If (iType=tqNUMBER) Begin
43192>>>>>>>                            Move sValue1 to nValue1
43193>>>>>>>                            Move sValue2 to nValue2
43194>>>>>>>                            If (nValue1>nValue2) Function_Return tqGT
43197>>>>>>>                            If (nValue1<nValue2) Function_Return tqLT
43200>>>>>>>                        End
43200>>>>>>>>
43200>>>>>>>                        Else If (iType=tqDATE) Begin
43203>>>>>>>                            Move sValue1 to dValue1
43204>>>>>>>                            Move sValue2 to dValue2
43205>>>>>>>                            If (dValue1>dValue2) Function_Return tqGT
43208>>>>>>>                            If (dValue1<dValue2) Function_Return tqLT
43211>>>>>>>                        End
43211>>>>>>>>
43211>>>>>>>                        Else If (iType=tqDATETIME) Begin
43214>>>>>>>                            Move sValue1 to dtValue1
43215>>>>>>>                            Move sValue2 to dtValue2
43216>>>>>>>                            If (dtValue1>dtValue2) Function_Return tqGT
43219>>>>>>>                            If (dtValue1<dtValue2) Function_Return tqLT
43222>>>>>>>                        End
43222>>>>>>>>
43222>>>>>>>                        Else If (iType=tqSTRING) Begin
43225>>>>>>>                            If (sValue1>sValue2) Function_Return tqGT
43228>>>>>>>                            If (sValue1<sValue2) Function_Return tqLT
43231>>>>>>>                        End
43231>>>>>>>>
43231>>>>>>>                        Else Begin
43232>>>>>>>                            Send OnError 726 ("Unknown column type ("+String(iType))
43233>>>>>>>                        End
43233>>>>>>>>
43233>>>>>>>                        Function_Return tqEQ
43234>>>>>>>                    End_Function
43235>>>>>>>            
43235>>>>>>>                Function _SQLCheckAgainstParentRecord tTableQuery ByRef strQuery Boolean ByRef bCatchUpWithParent Returns Boolean
43237>>>>>>>                    Integer iItem iItemMax iCompareResult
43237>>>>>>>                    String sValue1 sValue2
43237>>>>>>>                    Move (SizeOfArray(strQuery._strControlBlock.strInnerJoinCB.aCurrentParentSortValues)-1) to iItemMax
43238>>>>>>>                    For iItem from 0 to iItemMax
43244>>>>>>>>
43244>>>>>>>                        Move strQuery._strControlBlock.strInnerJoinCB.aCurrentParentSortValues[iItem] to sValue1
43245>>>>>>>                        Get ResultColumnValue (&strQuery) strQuery.aOrdering[iItem].strValueSource.iTable strQuery.aOrdering[iItem].strValueSource.iColumn to sValue2
43246>>>>>>>                        If (strQuery.aOrdering[iItem].bUppercase) Begin
43248>>>>>>>                           // Move (Uppercase(sValue1)) to sValue1 // This has already been uppercased by the parent record collection mechanism (procedure _ReadParentSortValues)
43248>>>>>>>                            Move (Uppercase(sValue2)) to sValue2
43249>>>>>>>                        End
43249>>>>>>>>
43249>>>>>>>                        Get _SQLCheckAgainstParentRecord_CompareSortingSegmentValues sValue1 sValue2 strQuery.aOrdering[iItem].strValueSource.iType to iCompareResult
43250>>>>>>>                        If (strQuery.aOrdering[iItem].bDescending) Begin
43252>>>>>>>                            Move (If(iCompareResult=tqGT,tqLT,tqGT)) to iCompareResult
43253>>>>>>>                        End
43253>>>>>>>>
43253>>>>>>>                        If (iCompareResult=tqGT) Begin // Parent is greater => child query must catch up
43255>>>>>>>                            Move True to bCatchUpWithParent
43256>>>>>>>                            Function_Return False
43257>>>>>>>                        End
43257>>>>>>>>
43257>>>>>>>                        Else If (iCompareResult=tqLT) Begin // Child is greater which means we must fake a end-of-result set
43260>>>>>>>                            Move False to bCatchUpWithParent
43261>>>>>>>                            Function_Return False
43262>>>>>>>                        End
43262>>>>>>>>
43262>>>>>>>                    Loop
43263>>>>>>>>
43263>>>>>>>                    Move False to bCatchUpWithParent
43264>>>>>>>                    Function_Return True
43265>>>>>>>                End_Function
43266>>>>>>>            
43266>>>>>>>            Function _SQLFindNextRecord tTableQuery ByRef strQuery Returns Boolean
43268>>>>>>>                Integer iFetchResult iItem iItemMax
43268>>>>>>>                Boolean bFound bSelect bInnerJoin bCatchUpWithParent bBelongsToCurrentParent
43268>>>>>>>
43268>>>>>>>
43268>>>>>>>                Move (SizeOfArray(strQuery._strControlBlock.strInnerJoinCB.aCurrentParentSortValues)-1) to iItemMax
43269>>>>>>>                Move (iItemMax>=0) to bInnerJoin // We are an inner join and should be prepared to fake a 'record not found'
43270>>>>>>>
43270>>>>>>>                If (bInnerJoin) Begin
43272>>>>>>>
43272>>>>>>>                    If (strQuery._strControlBlock.strInnerJoinCB.bEndOfResultSet) Begin
43274>>>>>>>                        Function_Return False
43275>>>>>>>                    End
43275>>>>>>>>
43275>>>>>>>
43275>>>>>>>                    Repeat
43275>>>>>>>>
43275>>>>>>>                        If (strQuery._strControlBlock.strInnerJoinCB.bSkipNextFetch) Begin
43277>>>>>>>                            Move False to strQuery._strControlBlock.strInnerJoinCB.bSkipNextFetch
43278>>>>>>>                            Move True to bFound
43279>>>>>>>                        End
43279>>>>>>>>
43279>>>>>>>                        Else Begin
43280>>>>>>>                            Get SQLFetch of strQuery._strControlBlock.strSQLStatementHandle.hHandle to iFetchResult
43281>>>>>>>                            Move (iFetchResult<>0) to bFound
43282>>>>>>>                            Increment strQuery._strControlBlock.iFindCount
43283>>>>>>>                        End
43283>>>>>>>>
43283>>>>>>>                        If (bFound) Begin
43285>>>>>>>                            Send _TableRelateStatesReset (&strQuery)
43286>>>>>>>                            Send _SQLBindResultTables (&strQuery)
43287>>>>>>>                            Get _SQLCheckAgainstParentRecord (&strQuery) (&bCatchUpWithParent) to bBelongsToCurrentParent
43288>>>>>>>                            If (bBelongsToCurrentParent) Begin
43290>>>>>>>                                Move True to bSelect
43291>>>>>>>                            End
43291>>>>>>>>
43291>>>>>>>                            Else Begin
43292>>>>>>>                                If (not(bCatchUpWithParent)) Begin
43294>>>>>>>                                    Move True to strQuery._strControlBlock.strInnerJoinCB.bSkipNextFetch
43295>>>>>>>                                End
43295>>>>>>>>
43295>>>>>>>                            End
43295>>>>>>>>
43295>>>>>>>                        End
43295>>>>>>>>
43295>>>>>>>                        Else Begin
43296>>>>>>>                            Move True to strQuery._strControlBlock.strInnerJoinCB.bEndOfResultSet
43297>>>>>>>                        End
43297>>>>>>>>
43297>>>>>>>                    Until (not(bFound) or bSelect or not(bCatchUpWithParent))
43299>>>>>>>
43299>>>>>>>                    If (bSelect) Begin
43301>>>>>>>                        Increment strQuery._strControlBlock.iSelectCount
43302>>>>>>>                        Function_Return True
43303>>>>>>>                    End
43303>>>>>>>>
43303>>>>>>>
43303>>>>>>>                End
43303>>>>>>>>
43303>>>>>>>                Else Begin
43304>>>>>>>
43304>>>>>>>                    Get SQLFetch of strQuery._strControlBlock.strSQLStatementHandle.hHandle to iFetchResult
43305>>>>>>>                    Move (iFetchResult<>0) to bFound
43306>>>>>>>                    If (bFound) Begin
43308>>>>>>>                        Send _SQLBindResultTables (&strQuery)
43309>>>>>>>                        Increment strQuery._strControlBlock.iSelectCount
43310>>>>>>>                    End
43310>>>>>>>>
43310>>>>>>>                    Increment strQuery._strControlBlock.iFindCount
43311>>>>>>>
43311>>>>>>>                    Function_Return bFound
43312>>>>>>>                End
43312>>>>>>>>
43312>>>>>>>                Function_Return False
43313>>>>>>>            End_Function
43314>>>>>>>
43314>>>>>>>        Register_Function FindRecord tTableQuery ByRef strQuery Returns Boolean
43314>>>>>>>
43314>>>>>>>        Function _FindFirstRecord tTableQuery ByRef strQuery Returns Boolean
43316>>>>>>>            Boolean bFound bIncremented bTmp
43316>>>>>>>            Integer iLastIndex iSize iTable
43316>>>>>>>            Integer iFailedConstrainIndex
43316>>>>>>>            Integer iLogState iFetchResult
43316>>>>>>>
43316>>>>>>>            Move 0 to strQuery._strControlBlock.iFindCount
43317>>>>>>>            Move 0 to strQuery._strControlBlock.iSelectCount
43318>>>>>>>            Move False to strQuery._strControlBlock.bBreakScan
43319>>>>>>>            Send PurgeResultSet (&strQuery) // Zero the result set
43320>>>>>>>
43320>>>>>>>            If (strQuery._strControlBlock.iQueryMethod=tqSQLPKG) Begin
43322>>>>>>>                Get _SQLFindNextRecord (&strQuery) to bFound
43323>>>>>>>            End
43323>>>>>>>>
43323>>>>>>>            Else Begin
43324>>>>>>>
43324>>>>>>>                // Makes the procedure reset all OrList pointers. Return value not used:
43324>>>>>>>                Get _IncrementJumpInOutConditions (&strQuery) -1 to bFound
43325>>>>>>>                Move strQuery.iTable to iTable
43326>>>>>>>                Clear iTable //
43327>>>>>>>                Send _TableRelateStatesReset (&strQuery)
43328>>>>>>>                Send _AssignConstraintValues (&strQuery) (&strQuery._strCompiled.aJumpInValues)
43329>>>>>>>                Send _AssignConstraintValues (&strQuery) (&strQuery._strCompiled.aJumpOutValues)
43330>>>>>>>                Send _AssignConstraintValues (&strQuery) (&strQuery._strCompiled.aOtherConditions)
43331>>>>>>>                Send _AssignFilterExpressionValues (&strQuery)
43332>>>>>>>
43332>>>>>>>                If (strQuery._strCompiled.bPrefetch) Begin
43334>>>>>>>                    Move False to strQuery._strCompiled.bPrefetch // Temporarily set bPrefetch to false
43335>>>>>>>
43335>>>>>>>                    Send ReUse (&strQuery) // resets strQuery.blabla.bInitialized
43336>>>>>>>                    Move strQuery.bForcePrefetch to bTmp
43337>>>>>>>
43337>>>>>>>                    // Here comes a dirty trick to avoid FindRecord deleting
43337>>>>>>>                    // the ResultArray of the strQuery variable on completion. The
43337>>>>>>>                    // default behavior is to reset the resultset on completion if
43337>>>>>>>                    // prefetch was not forced. It's dirty because I am fooling
43337>>>>>>>                    // FindRecord into not re-compiling the report. Here it goes:
43337>>>>>>>                    Move True to strQuery.bForcePrefetch
43338>>>>>>>                    Move _giTQLogState to iLogState
43339>>>>>>>                    Move 0 to _giTQLogState // Do not log the "inner" loop
43340>>>>>>>
43340>>>>>>>                    While (FindRecord(Self,&strQuery))
43344>>>>>>>                        Send _ResultSetAddCurrentRecord (&strQuery)
43345>>>>>>>                    Loop
43346>>>>>>>>
43346>>>>>>>                    Move bTmp to strQuery.bForcePrefetch
43347>>>>>>>                    Move iLogState to _giTQLogState // Restore log-state
43348>>>>>>>
43348>>>>>>>                    Send _ResultSetSort (&strQuery)
43349>>>>>>>
43349>>>>>>>                    Move False to strQuery._strControlBlock.bBreakScan // Cancel effect of possible break imposed by limit
43350>>>>>>>                    Move True to strQuery._strCompiled.bPrefetch // Restore bPrefetch
43351>>>>>>>                    If (strQuery._strCompiled._iPushLimit<>0) Begin
43353>>>>>>>
43353>>>>>>>                        If (SizeOfArray(strQuery.strResultSet.aRecords)>Abs(strQuery._strCompiled._iPushLimit)) Begin
43355>>>>>>>                            // If the record set is greater than our limit we'll have to prune it.
43355>>>>>>>                            If (strQuery.iLimit>0) Begin // We're supposed to return the head
43357>>>>>>>                                Move (ResizeArray(strQuery.strResultSet.aRecords,strQuery._strCompiled._iPushLimit)) to strQuery.strResultSet.aRecords
43358>>>>>>>                            End
43358>>>>>>>>
43358>>>>>>>                            Else Begin // We're supposed to take the tail
43359>>>>>>>                                Move (SizeOfArray(strQuery.strResultSet.aRecords)-1) to iLastIndex
43360>>>>>>>                                Move strQuery._strCompiled._iPushLimit to iSize
43361>>>>>>>                                Move (CopyArray(strQuery.strResultSet.aRecords,iLastIndex-iSize+1,iLastIndex)) to strQuery.strResultSet.aRecords
43362>>>>>>>                            End
43362>>>>>>>>
43362>>>>>>>                            Move (SizeOfArray(strQuery.strResultSet.aRecords)) to strQuery._strControlBlock.iSelectCount
43363>>>>>>>                        End
43363>>>>>>>>
43363>>>>>>>
43363>>>>>>>                        If (SizeOfArray(strQuery.strResultSet.aRecords)>strQuery._strCompiled._iPushLimit) Begin
43365>>>>>>>                            Move (ResizeArray(strQuery.strResultSet.aRecords,strQuery._strCompiled._iPushLimit)) to strQuery.strResultSet.aRecords
43366>>>>>>>                            Move (SizeOfArray(strQuery.strResultSet.aRecords)) to strQuery._strControlBlock.iSelectCount
43367>>>>>>>                        End
43367>>>>>>>>
43367>>>>>>>                        Move strQuery._strCompiled._iPushLimit to strQuery._strCompiled._iLimit
43368>>>>>>>                        Move 0 to strQuery._strCompiled._iPushLimit
43369>>>>>>>                    End
43369>>>>>>>>
43369>>>>>>>                    Move (SizeOfArray(strQuery.strResultSet.aRecords)>0) to bFound
43370>>>>>>>                    If (bFound) Begin
43372>>>>>>>                        Move 0 to strQuery.strResultSet._iCurrentRowPointer
43373>>>>>>>                        Send _ResultSetActivateCurrentRecord (&strQuery)
43374>>>>>>>                    End
43374>>>>>>>>
43374>>>>>>>                End
43374>>>>>>>>
43374>>>>>>>                Else Begin
43375>>>>>>>                    Repeat
43375>>>>>>>>
43375>>>>>>>                        Get _FindFirstRecordAux (&strQuery) (&iFailedConstrainIndex) to bFound
43376>>>>>>>                        If (not(bFound)) Begin
43378>>>>>>>                            Get _IncrementJumpInOutConditions (&strQuery) iFailedConstrainIndex to bIncremented
43379>>>>>>>                            If (bIncremented) Begin
43381>>>>>>>                                Send _ReassignJumpInOutConstraintValues (&strQuery) (&strQuery._strCompiled.aJumpInValues) (&strQuery._strCompiled.aJumpOutValues)
43382>>>>>>>                            End
43382>>>>>>>>
43382>>>>>>>                        End
43382>>>>>>>>
43382>>>>>>>                    Until (bFound or not(bIncremented))
43384>>>>>>>                End
43384>>>>>>>>
43384>>>>>>>            End
43384>>>>>>>>
43384>>>>>>>
43384>>>>>>>            Function_Return bFound
43385>>>>>>>        End_Function // _FindFirstRecord
43386>>>>>>>
43386>>>>>>>            Function _FindNextRecordAux tTableQuery ByRef strQuery Integer ByRef iFailedConstrainIndex Returns Boolean
43388>>>>>>>                Integer iTable iIndex iJunk
43388>>>>>>>                Boolean bFound bEval
43388>>>>>>>
43388>>>>>>>                Move strQuery.iTable to iTable
43389>>>>>>>                Move strQuery._strCompiled.iIndex to iIndex
43390>>>>>>>                If (strQuery._strCompiled.bBackwards) Begin
43392>>>>>>>                    Vfind iTable iIndex LT
43394>>>>>>>                End
43394>>>>>>>>
43394>>>>>>>                Else Begin
43395>>>>>>>                    Vfind iTable iIndex GT
43397>>>>>>>                End
43397>>>>>>>>
43397>>>>>>>                Move (Found) to bFound
43398>>>>>>>                Increment strQuery._strControlBlock.iFindCount
43399>>>>>>>                Send _TableRelateStatesReset (&strQuery)
43400>>>>>>>                If (bFound) Begin
43402>>>>>>>                    Repeat
43402>>>>>>>>
43402>>>>>>>                        // Jump out?
43402>>>>>>>                        Get _EvaluateConstraints (&strQuery) strQuery._strCompiled.aJumpOutValues False (&iFailedConstrainIndex) to bEval
43403>>>>>>>                        If (not(bEval)) Begin // If jump-out criteria does not evaluate: jump out
43405>>>>>>>                            Function_Return False
43406>>>>>>>                        End
43406>>>>>>>>
43406>>>>>>>                        // Evaluate 'other' criteria
43406>>>>>>>                        Get _EvaluateConstraints (&strQuery) strQuery._strCompiled.aOtherConditions True (&iJunk) to bEval
43407>>>>>>>                        If (bEval) Begin // Evaluate filter expressions
43409>>>>>>>                            Get _EvaluateFilterExpressions (&strQuery) to bEval
43410>>>>>>>                        End
43410>>>>>>>>
43410>>>>>>>                        If (not(bEval)) Begin
43412>>>>>>>                            If (strQuery._strCompiled.bBackwards) Begin
43414>>>>>>>                                Vfind iTable iIndex LT
43416>>>>>>>                            End
43416>>>>>>>>
43416>>>>>>>                            Else Begin
43417>>>>>>>                                Vfind iTable iIndex GT
43419>>>>>>>                            End
43419>>>>>>>>
43419>>>>>>>                            Increment strQuery._strControlBlock.iFindCount
43420>>>>>>>                            Move (Found) to bFound
43421>>>>>>>                            Send _TableRelateStatesReset (&strQuery)
43422>>>>>>>                            If (not(bFound)) Begin // end of table
43424>>>>>>>                                Move (SizeOfArray(strQuery._strCompiled.aJumpOutValues)-1) to iFailedConstrainIndex
43425>>>>>>>                                Function_Return False
43426>>>>>>>                            End
43426>>>>>>>>
43426>>>>>>>                        End
43426>>>>>>>>
43426>>>>>>>                    Until (bEval)
43428>>>>>>>                End
43428>>>>>>>>
43428>>>>>>>
43428>>>>>>>                If (bFound) Begin
43430>>>>>>>                    Increment strQuery._strControlBlock.iSelectCount
43431>>>>>>>                End
43431>>>>>>>>
43431>>>>>>>
43431>>>>>>>                Function_Return bFound
43432>>>>>>>            End_Function
43433>>>>>>>
43433>>>>>>>        Function _FindNextRecord tTableQuery ByRef strQuery Returns Boolean
43435>>>>>>>            Boolean bFound bIncremented
43435>>>>>>>            Integer iFailedConstrainIndex iFetchResult
43435>>>>>>>
43435>>>>>>>            If (strQuery._strControlBlock.bBreakScan) Begin
43437>>>>>>>                Move False to bFound
43438>>>>>>>            End
43438>>>>>>>>
43438>>>>>>>            Else Begin
43439>>>>>>>
43439>>>>>>>                If (strQuery._strControlBlock.iQueryMethod=tqSQLPKG) Begin
43441>>>>>>>                    Get _SQLFindNextRecord (&strQuery) to bFound
43442>>>>>>>                End
43442>>>>>>>>
43442>>>>>>>                Else Begin
43443>>>>>>>                    If (strQuery._strCompiled.bPrefetch) Begin
43445>>>>>>>                        Move ((strQuery.strResultSet._iCurrentRowPointer+1)<SizeOfArray(strQuery.strResultSet.aRecords)) to bFound
43446>>>>>>>                        If (bFound) Begin
43448>>>>>>>                            Increment strQuery.strResultSet._iCurrentRowPointer
43449>>>>>>>                            Send _ResultSetActivateCurrentRecord (&strQuery)
43450>>>>>>>                        End
43450>>>>>>>>
43450>>>>>>>                    End
43450>>>>>>>>
43450>>>>>>>                    Else Begin
43451>>>>>>>                        Get _FindNextRecordAux (&strQuery) (&iFailedConstrainIndex) to bFound
43452>>>>>>>
43452>>>>>>>                        Repeat
43452>>>>>>>>
43452>>>>>>>                            If (not(bFound)) Begin
43454>>>>>>>                                Get _IncrementJumpInOutConditions (&strQuery) iFailedConstrainIndex to bIncremented
43455>>>>>>>                                If (bIncremented) Begin
43457>>>>>>>                                    Send _ReassignJumpInOutConstraintValues (&strQuery) (&strQuery._strCompiled.aJumpInValues) (&strQuery._strCompiled.aJumpOutValues)
43458>>>>>>>                                    Get _FindFirstRecordAux (&strQuery) (&iFailedConstrainIndex) to bFound
43459>>>>>>>                                End
43459>>>>>>>>
43459>>>>>>>                            End
43459>>>>>>>>
43459>>>>>>>                        Until (bFound or not(bIncremented))
43461>>>>>>>                    End
43461>>>>>>>>
43461>>>>>>>                End
43461>>>>>>>>
43461>>>>>>>            End
43461>>>>>>>>
43461>>>>>>>
43461>>>>>>>            Function_Return bFound
43462>>>>>>>        End_Function
43463>>>>>>>
43463>>>>>>>// *** TableRelation functions *** TableRelation functions *** TableRelation functions *** TableRelation functions *** TableRelation functions ***
43463>>>>>>>
43463>>>>>>>        Function _ColumnSourceFind tTableQuery strQ Integer iTable Integer iColumn Returns Integer
43465>>>>>>>            Integer iItem iMax
43465>>>>>>>            Move (SizeOfArray(strQ.aColumnSources)-1) to iMax
43466>>>>>>>            For iItem from 0 to iMax
43472>>>>>>>>
43472>>>>>>>                If (strQ.aColumnSources[iItem].iTable=iTable) Begin
43474>>>>>>>                    If (strQ.aColumnSources[iItem].iColumn=iColumn or strQ.aColumnSources[iItem].iColumn=0) Begin
43476>>>>>>>                        Function_Return iItem
43477>>>>>>>                    End
43477>>>>>>>>
43477>>>>>>>                End
43477>>>>>>>>
43477>>>>>>>            Loop
43478>>>>>>>>
43478>>>>>>>            Function_Return -1 // not found
43479>>>>>>>        End_Function
43480>>>>>>>
43480>>>>>>>        //> Internal function used to find the index for the relation recip for tabel iTable.
43480>>>>>>>        Function _FindTableRelation tTableQuery strQ Integer iTable Returns Integer
43482>>>>>>>            Integer iItem iMax
43482>>>>>>>            Move (SizeOfArray(strQ.aTableRelations)-1) to iMax
43483>>>>>>>            For iItem from 0 to iMax
43489>>>>>>>>
43489>>>>>>>                If (strQ.aTableRelations[iItem].iTargetTable=iTable) Begin
43491>>>>>>>                    Function_Return iItem
43492>>>>>>>                End
43492>>>>>>>>
43492>>>>>>>            Loop
43493>>>>>>>>
43493>>>>>>>            Function_Return -1 // not found
43494>>>>>>>        End_Function
43495>>>>>>>
43495>>>>>>>        // If bFixed is true it means that the parent record is fixed for the duration of the query. In turn, that means
43495>>>>>>>        // that the relation mechanism will not find records in that table (iTargetTable).
43495>>>>>>>        Procedure _AddTableRelation tTableQuery ByRef strQ Integer iTargetTable Boolean bFixed
43497>>>>>>>            Integer iItem
43497>>>>>>>            Get _FindTableRelation strQ iTargetTable to iItem
43498>>>>>>>            If (iItem=-1) Begin
43500>>>>>>>                Move (SizeOfArray(strQ.aTableRelations)) to iItem
43501>>>>>>>                Move iTargetTable to strQ.aTableRelations[iItem].iTargetTable
43502>>>>>>>                Move -1 to strQ.aTableRelations[iItem]._iEmbeddedIndex
43503>>>>>>>                Move bFixed to strQ.aTableRelations[iItem].bFixed
43504>>>>>>>            End
43504>>>>>>>>
43504>>>>>>>            Else Begin
43505>>>>>>>                If (bFixed) Begin // If it's already there then bFixed=true wins.
43507>>>>>>>                    Move bFixed to strQ.aTableRelations[iItem].bFixed
43508>>>>>>>                End
43508>>>>>>>>
43508>>>>>>>            End
43508>>>>>>>>
43508>>>>>>>        End_Procedure
43509>>>>>>>
43509>>>>>>>            Function _CompareTableRelationSegments _tTQTableRelationSegment strValue1 _tTQTableRelationSegment strValue2 Returns Integer
43511>>>>>>>                Number nValue1 nValue2
43511>>>>>>>                Move (strValue1.iInnerJoinComp*10000+strValue1.iSourceColumn*10000+strValue1.iSourceTable*10000+strValue1.iTargetColumn) to nValue1
43512>>>>>>>                Move (strValue2.iInnerJoinComp*10000+strValue2.iSourceColumn*10000+strValue2.iSourceTable*10000+strValue2.iTargetColumn) to nValue2
43513>>>>>>>                If (nValue1<nValue2) Function_Return (LT)
43516>>>>>>>                Else If (nValue1>nValue2) Function_Return (GT)
43520>>>>>>>                Function_Return (EQ)
43521>>>>>>>            End_Function
43522>>>>>>>
43522>>>>>>>        Function _TableRelationsAreSegmentArraysIdentical _tTQTableRelationSegment[] aSegments1 _tTQTableRelationSegment[] aSegments2 Returns Boolean
43524>>>>>>>            Integer iItem iItemMax1 iItemMax2
43524>>>>>>>            Move (SizeOfArray(aSegments1)-1) to iItemMax1
43525>>>>>>>            Move (SizeOfArray(aSegments2)-1) to iItemMax2
43526>>>>>>>            If (iItemMax1<>iItemMax2) Begin
43528>>>>>>>                Function_Return False
43529>>>>>>>            End
43529>>>>>>>>
43529>>>>>>>            // The arrays are not ordered so to tell if they are identical they need to be sorted first.
43529>>>>>>>            Move (SortArray(aSegments1,Self,GET__CompareTableRelationSegments)) to aSegments1
43530>>>>>>>            Move (SortArray(aSegments2,Self,GET__CompareTableRelationSegments)) to aSegments2
43531>>>>>>>            For iItem from 0 to iItemMax1
43537>>>>>>>>
43537>>>>>>>                If (_CompareTableRelationSegments(Self,aSegments1[iItem],aSegments2[iItem])<>EQ) Begin
43539>>>>>>>                    Function_Return False
43540>>>>>>>                End
43540>>>>>>>>
43540>>>>>>>            Loop
43541>>>>>>>>
43541>>>>>>>        End_Function
43542>>>>>>>
43542>>>>>>>        Function _TableRelationsAreIdentical tTQTableRelation strRel1 tTQTableRelation strRel2 Returns Boolean
43544>>>>>>>            If (strRel1.iTargetTable<>strRel2.iTargetTable or strRel1.bFixed<>strRel2.bFixed) Begin
43546>>>>>>>                Function_Return False
43547>>>>>>>            End
43547>>>>>>>>
43547>>>>>>>            If (not(_TableRelationsAreSegmentArraysIdentical(Self,strRel1.aSegments,strRel2.aSegments))) Begin
43549>>>>>>>                Function_Return False
43550>>>>>>>            End
43550>>>>>>>>
43550>>>>>>>            Function_Return True
43551>>>>>>>        End_Function
43552>>>>>>>
43552>>>>>>>        Function _AddTableRelationB2B tTableQuery ByRef strQ tTQTableRelation strRelation Returns Boolean
43554>>>>>>>            Integer iItem
43554>>>>>>>            Get _FindTableRelation strQ strRelation.iTargetTable to iItem
43555>>>>>>>            If (iItem=-1) Begin
43557>>>>>>>                Move strRelation to strQ.aTableRelations[SizeOfArray(strQ.aTableRelations)]
43558>>>>>>>            End
43558>>>>>>>>
43558>>>>>>>            Else Begin
43559>>>>>>>                If (not(_TableRelationsAreIdentical(Self,strRelation,strQ.aTableRelations[iItem]))) Begin
43561>>>>>>>                    Send OnError 727 "Table takes on more than one role"
43562>>>>>>>                    Function_Return False
43563>>>>>>>                End
43563>>>>>>>>
43563>>>>>>>            End
43563>>>>>>>>
43563>>>>>>>            Function_Return True
43564>>>>>>>        End_Function
43565>>>>>>>
43565>>>>>>>    Procedure AddTableRelation tTableQuery ByRef strQ Integer iTargetTable
43567>>>>>>>        Send _AddTableRelation (&strQ) iTargetTable False
43568>>>>>>>    End_Procedure
43569>>>>>>>
43569>>>>>>>    // This is called from the AddFilterRelate procedure.
43569>>>>>>>    Procedure AddTableRelationFixedRecord tTableQuery ByRef strQ Integer iTargetTable
43571>>>>>>>        Send _AddTableRelation (&strQ) iTargetTable True
43572>>>>>>>    End_Procedure
43573>>>>>>>
43573>>>>>>>    Procedure _AddTableRelationSegment tTableQuery ByRef strQ Integer iSourceTable Integer iSourceColumn Integer iComp Integer iTargetTable Integer iTargetColumn
43575>>>>>>>        Integer iItem
43575>>>>>>>        tTQTableRelation strRelatation
43575>>>>>>>        tTQTableRelation strRelatation
43575>>>>>>>        _tTQTableRelationSegment strSegment
43575>>>>>>>        _tTQTableRelationSegment strSegment
43575>>>>>>>        Get _FindTableRelation strQ iTargetTable to iItem
43576>>>>>>>        If (iItem>=0) Begin
43578>>>>>>>
43578>>>>>>>            // Check that iSourceTable is already available in the .aRelations member. If not: error!
43578>>>>>>>            If (iSourceTable=strQ.iTable or _FindTableRelation(Self,strQ,iSourceTable)<>-1) Begin
43580>>>>>>>                Move strQ.aTableRelations[iItem] to strRelatation
43581>>>>>>>                Move iSourceTable to strSegment.iSourceTable
43582>>>>>>>                Move iComp to strSegment.iInnerJoinComp
43583>>>>>>>                Move iSourceColumn to strSegment.iSourceColumn
43584>>>>>>>                Move iTargetColumn to strSegment.iTargetColumn
43585>>>>>>>                Move strSegment to strRelatation.aSegments[SizeOfArray(strRelatation.aSegments)]
43586>>>>>>>                Move strRelatation to strQ.aTableRelations[iItem]
43587>>>>>>>            End
43587>>>>>>>>
43587>>>>>>>            Else Begin
43588>>>>>>>                Send OnError 728 ("No relation has been set up for table "+String(iSourceTable))
43589>>>>>>>            End
43589>>>>>>>>
43589>>>>>>>        End
43589>>>>>>>>
43589>>>>>>>        Else Begin
43590>>>>>>>            Send OnError 729 ("No relation has been set up for table "+String(iTargetTable))
43591>>>>>>>        End
43591>>>>>>>>
43591>>>>>>>    End_Procedure
43592>>>>>>>
43592>>>>>>>    Procedure AddTableRelationSegment tTableQuery ByRef strQ Integer iSourceTable Integer iSourceColumn Integer iTargetTable Integer iTargetColumn
43594>>>>>>>        Send _AddTableRelationSegment (&strQ) iSourceTable iSourceColumn tqEQ iTargetTable iTargetColumn
43595>>>>>>>    End_Procedure
43596>>>>>>>
43596>>>>>>>    Procedure _AddTableRelationInnerJoinSegment tTableQuery ByRef strQ Integer iSourceTable Integer iSourceColumn Integer iComp Integer iTargetTable Integer iTargetColumn
43598>>>>>>>        Send _AddTableRelationSegment (&strQ) iSourceTable iSourceColumn iComp iTargetTable iTargetColumn
43599>>>>>>>    End_Procedure
43600>>>>>>>
43600>>>>>>>    //> Use this method over the AddTableRelation ditto to register a table relation by its generic relation
43600>>>>>>>    Procedure _AddTableRelationAuto tTableQuery ByRef strQ Integer iSourceTable Integer iTargetTable Boolean bFixed
43602>>>>>>>        Integer iItem iMax iRelateItem
43602>>>>>>>        Integer[] aSourceColumns aTargetColumns
43604>>>>>>>
43604>>>>>>>        Get _FindTableRelation strQ iTargetTable to iRelateItem
43605>>>>>>>        If (iRelateItem=-1) Begin
43607>>>>>>>            If (TableColumnsRelatingBetweenTables(oOverlapColumnFunctions,iSourceTable,iTargetTable,&aSourceColumns,&aTargetColumns)) Begin
43609>>>>>>>                Send AddTableRelation (&strQ) iTargetTable
43610>>>>>>>                Move (SizeOfArray(aSourceColumns)-1) to iMax
43611>>>>>>>                For iItem from 0 to iMax
43617>>>>>>>>
43617>>>>>>>                    Send AddTableRelationSegment (&strQ) iSourceTable aSourceColumns[iItem] iTargetTable aTargetColumns[iItem]
43618>>>>>>>                Loop
43619>>>>>>>>
43619>>>>>>>            End
43619>>>>>>>>
43619>>>>>>>            Else Begin
43620>>>>>>>                Send OnError 730 ("Tables do not relate ("+String(iSourceTable)+"->"+String(iTargetTable)+")")
43621>>>>>>>            End
43621>>>>>>>>
43621>>>>>>>        End
43621>>>>>>>>
43621>>>>>>>        Else Begin // If a relation is already there:
43622>>>>>>>// ToDo:    // Here we need to check if the current segment array is empty.
43622>>>>>>>            // If it is, we add the relation segments
43622>>>>>>>            // If it's not, we should check that it is currently set
43622>>>>>>>            // to the "plain df relation" and give an Error if it's not.
43622>>>>>>>        End
43622>>>>>>>>
43622>>>>>>>    End_Procedure
43623>>>>>>>
43623>>>>>>>    Procedure AddTableRelationAuto tTableQuery ByRef strQ Integer iSourceTable Integer iTargetTable
43625>>>>>>>        Send _AddTableRelationAuto (&strQ) iSourceTable iTargetTable False
43626>>>>>>>    End_Procedure
43627>>>>>>>
43627>>>>>>>    Procedure AddTableRelationAutoFixed tTableQuery ByRef strQ Integer iSourceTable Integer iTargetTable
43629>>>>>>>        Send _AddTableRelationAuto (&strQ) iSourceTable iTargetTable True
43630>>>>>>>    End_Procedure
43631>>>>>>>
43631>>>>>>>        Function _TableRelationAlreadyOK tTableQuery ByRef strQ tTQTableRelation strRelation Returns Boolean
43633>>>>>>>            Integer iSegment iSegmentMax
43633>>>>>>>            String sSourceValue sTargetValue
43633>>>>>>>
43633>>>>>>>            If (not(strRelation.bFixed)) Begin
43635>>>>>>>                Move (SizeOfArray(strRelation.aSegments)-1) to iSegmentMax
43636>>>>>>>                For iSegment from 0 to iSegmentMax
43642>>>>>>>>
43642>>>>>>>                    Get ResultColumnValue (&strQ) strRelation.aSegments[iSegment].iSourceTable strRelation.aSegments[iSegment].iSourceColumn to sSourceValue
43643>>>>>>>                    Get_Field_Value strRelation.iTargetTable strRelation.aSegments[iSegment].iTargetColumn to sTargetValue
43646>>>>>>>                    If (sSourceValue<>sTargetValue) Begin
43648>>>>>>>                        Function_Return (False)
43649>>>>>>>                    End
43649>>>>>>>>
43649>>>>>>>                Loop
43650>>>>>>>>
43650>>>>>>>            End
43650>>>>>>>>
43650>>>>>>>            Function_Return (True)
43651>>>>>>>        End_Function
43652>>>>>>>
43652>>>>>>>        Function _SQLNumericToDFNumeric Integer iTable String sValue Returns String
43654>>>>>>>            Integer iDriverDS iRuntimeDS iDriverIndex
43654>>>>>>>            String sDriver
43654>>>>>>>
43654>>>>>>>            Get_Attribute DF_FILE_DRIVER of iTable to sDriver
43657>>>>>>>            Get DriverIndex of oTableDriverFunctions sDriver to iDriverIndex
43658>>>>>>>            Get_Attribute DF_DRIVER_DRIVER_DECIMAL_SEPARATOR of iDriverIndex to iDriverDS
43661>>>>>>>
43661>>>>>>>            Get_Attribute DF_DECIMAL_SEPARATOR to iRuntimeDS
43664>>>>>>>
43664>>>>>>>            If (iRuntimeDS<>iDriverDS) Begin
43666>>>>>>>                Move (Replaces(Character(iDriverDS),sValue,Character(iRuntimeDS))) to sValue
43667>>>>>>>            End
43667>>>>>>>>
43667>>>>>>>
43667>>>>>>>            If (Left(sValue,1)=Character(iRuntimeDS)) Begin
43669>>>>>>>                Move ("0"+sValue) to sValue
43670>>>>>>>            End
43670>>>>>>>>
43670>>>>>>>
43670>>>>>>>            Function_Return sValue
43671>>>>>>>        End_Function
43672>>>>>>>
43672>>>>>>>    Function ResultColumnValue tTableQuery ByRef strQ Integer iTable Integer iColumn Returns String
43674>>>>>>>        Integer iRelateItem iColumnSourceItem iType
43674>>>>>>>        Integer iDriverDecimalPlaces iDecimalPlaces
43674>>>>>>>        String sValue
43674>>>>>>>        If (strQ._strControlBlock.iQueryMethod=tqDATAFLEX) Begin
43676>>>>>>>            Send _RelateToTable (&strQ) iTable
43677>>>>>>>            If (iColumn=0) Begin
43679>>>>>>>                Move (SerializeRowID(GetRowID(iTable))) to sValue
43680>>>>>>>            End
43680>>>>>>>>
43680>>>>>>>            Else Begin
43681>>>>>>>                Get_Field_Value iTable iColumn to sValue
43684>>>>>>>                Move (Rtrim(sValue)) to sValue
43685>>>>>>>            End
43685>>>>>>>>
43685>>>>>>>        End
43685>>>>>>>>
43685>>>>>>>        Else Begin
43686>>>>>>>            If (SizeOfArray(strQ.aColumnSources)=0) Begin
43688>>>>>>>                If (iTable=strQ.iTable) Begin
43690>>>>>>>                    Get_Field_Value iTable iColumn to sValue
43693>>>>>>>                    Move (Rtrim(sValue)) to sValue
43694>>>>>>>                End
43694>>>>>>>>
43694>>>>>>>                Else Begin
43695>>>>>>>                    Send OnError 731 "Column not part of result set."
43696>>>>>>>                End
43696>>>>>>>>
43696>>>>>>>            End
43696>>>>>>>>
43696>>>>>>>            Else Begin
43697>>>>>>>                Get _ColumnSourceFind strQ iTable iColumn to iColumnSourceItem
43698>>>>>>>                If (iColumnSourceItem<>-1) Begin
43700>>>>>>>                    If (strQ.aColumnSources[iColumnSourceItem].iColumn=0) Begin
43702>>>>>>>                        Get_Field_Value iTable iColumn to sValue
43705>>>>>>>                        Move (Rtrim(sValue)) to sValue
43706>>>>>>>                    End
43706>>>>>>>>
43706>>>>>>>                    Else Begin
43707>>>>>>>                        // 
43707>>>>>>>                        Get SQLColumnValue of strQ._strControlBlock.strSQLStatementHandle.hHandle (iColumnSourceItem+1) to sValue
43708>>>>>>>                        Move strQ.aColumnSources[iColumnSourceItem].iType to iType
43709>>>>>>>                        If (iType=tqDATE) Begin
43711>>>>>>>                            Get SQLDateToDFDate of strQ._strControlBlock.strSQLStatementHandle.hHandle sValue to sValue
43712>>>>>>>                        End
43712>>>>>>>>
43712>>>>>>>                        Else If (iType=tqNUMBER) Begin
43715>>>>>>>                            Get _SQLNumericToDFNumeric iTable sValue to sValue
43716>>>>>>>                        End
43716>>>>>>>>
43716>>>>>>>                        Else If (iType=tqSTRING or iType=tqTEXT) Begin
43719>>>>>>>                            If (strQ._strControlBlock.bSQLTableIsAnsi) Begin
43721>>>>>>>                                Move (ToOEM(sValue)) to sValue
43722>>>>>>>                            End
43722>>>>>>>>
43722>>>>>>>                            Move (Rtrim(sValue)) to sValue
43723>>>>>>>                        End
43723>>>>>>>>
43723>>>>>>>                    End
43723>>>>>>>>
43723>>>>>>>                End
43723>>>>>>>>
43723>>>>>>>                Else Begin
43724>>>>>>>                    Send OnError 732 "Unknown result column"
43725>>>>>>>                End
43725>>>>>>>>
43725>>>>>>>            End
43725>>>>>>>>
43725>>>>>>>        End
43725>>>>>>>>
43725>>>>>>>        Function_Return sValue
43726>>>>>>>    End_Function
43727>>>>>>>
43727>>>>>>>    Function ResultColumnValues tTableQuery ByRef strQ Boolean bIncludeRowIDs Returns String[]
43729>>>>>>>        Boolean bDone
43729>>>>>>>        Integer iItem iMax iTable iColumn 
43729>>>>>>>        String[] aValues
43730>>>>>>>        Move (SizeOfArray(strQ.aColumnSources)-1) to iMax
43731>>>>>>>        Move 0 to iItem
43732>>>>>>>        Move False to bDone
43733>>>>>>>        While (not(bDone) and iItem<=iMax)
43737>>>>>>>            If (not(bIncludeRowIDs)) Begin
43739>>>>>>>                Move (strQ.aColumnSources[iItem].iColumn=0) to bDone // The ones that are Table.* are excluded
43740>>>>>>>            End
43740>>>>>>>>
43740>>>>>>>            If (not(bDone)) Begin
43742>>>>>>>                Get ResultColumnValue (&strQ) strQ.aColumnSources[iItem].iTable strQ.aColumnSources[iItem].iColumn to aValues[iItem]
43743>>>>>>>            End
43743>>>>>>>>
43743>>>>>>>            Increment iItem
43744>>>>>>>        Loop
43745>>>>>>>>
43745>>>>>>>        Function_Return aValues
43746>>>>>>>    End_Function
43747>>>>>>>    
43747>>>>>>>    Function OutputColumnValues tTableQuery ByRef strQ Boolean bIncludeRowIDs Returns String[]
43749>>>>>>>        Boolean bDone
43749>>>>>>>        Integer iItem iMax iTable iColumn 
43749>>>>>>>        String[] aValues
43750>>>>>>>        Move (SizeOfArray(strQ.aOutputColumns)-1) to iMax
43751>>>>>>>        Move 0 to iItem
43752>>>>>>>        Move False to bDone
43753>>>>>>>        While (not(bDone) and iItem<=iMax)
43757>>>>>>>            If (not(bIncludeRowIDs)) Begin
43759>>>>>>>                Move (strQ.aOutputColumns[iItem].iColumn=0) to bDone // The ones that are Table.* are excluded
43760>>>>>>>            End
43760>>>>>>>>
43760>>>>>>>            If (not(bDone)) Begin
43762>>>>>>>                Get ResultColumnValue (&strQ) strQ.aOutputColumns[iItem].iTable strQ.aOutputColumns[iItem].iColumn to aValues[iItem]
43763>>>>>>>            End
43763>>>>>>>>
43763>>>>>>>            Increment iItem
43764>>>>>>>        Loop
43765>>>>>>>>
43765>>>>>>>        Function_Return aValues
43766>>>>>>>    End_Function
43767>>>>>>>
43767>>>>>>>
43767>>>>>>>            Function __RelateSegmentsToColumns _tTQTableRelationSegment[] aSegments Returns Integer[]
43769>>>>>>>                Integer iItem iMax
43769>>>>>>>                Integer[] aColumns
43770>>>>>>>                Move (SizeOfArray(aSegments)-1) to iMax
43771>>>>>>>                For iItem from 0 to iMax
43777>>>>>>>>
43777>>>>>>>                    Move aSegments[iItem].iTargetColumn to aColumns[iItem]
43778>>>>>>>                Loop
43779>>>>>>>>
43779>>>>>>>                Function_Return aColumns
43780>>>>>>>            End_Function
43781>>>>>>>
43781>>>>>>>        Procedure _RelateTablePerform tTableQuery ByRef strQ Integer iRelateItem // Is only called when i embedded mode
43783>>>>>>>            Integer iMax iItem iIndex
43783>>>>>>>            Integer iSourceTable iSourceColumn iTargetTable iTargetColumn
43783>>>>>>>            String sValue
43783>>>>>>>            Integer[] aColumns
43784>>>>>>>            tTQTableRelation strRelation
43784>>>>>>>            tTQTableRelation strRelation
43784>>>>>>>
43784>>>>>>>            Move strQ.aTableRelations[iRelateItem] to strRelation
43785>>>>>>>
43785>>>>>>>            If (not(strRelation.bFixed)) Begin // If fixed we will just accept the record that is there.
43787>>>>>>>                Move (SizeOfArray(strRelation.aSegments)-1) to iMax
43788>>>>>>>
43788>>>>>>>                Move strRelation.iTargetTable to iTargetTable
43789>>>>>>>                Clear iTargetTable
43790>>>>>>>                For iItem from 0 to iMax
43796>>>>>>>>
43796>>>>>>>                    Move strRelation.aSegments[iItem].iSourceTable to iSourceTable
43797>>>>>>>                    Move strRelation.aSegments[iItem].iSourceColumn to iSourceColumn
43798>>>>>>>                    Move strRelation.aSegments[iItem].iTargetColumn to iTargetColumn
43799>>>>>>>                    Get ResultColumnValue (&strQ) iSourceTable iSourceColumn to sValue
43800>>>>>>>                    Set_Field_Value iTargetTable iTargetColumn to sValue
43803>>>>>>>                Loop
43804>>>>>>>>
43804>>>>>>>                If (strRelation._iEmbeddedIndex=-1) Begin
43806>>>>>>>                    Get __RelateSegmentsToColumns strRelation.aSegments to aColumns
43807>>>>>>>                    Get FindEQIndex of oIndexFunctions iTargetTable aColumns to iIndex
43808>>>>>>>                    If (iIndex=-1) Begin
43810>>>>>>>                        Send OnError 733 ("Can't identify record in related table "+String(iTargetTable))
43811>>>>>>>                    End
43811>>>>>>>>
43811>>>>>>>                    Move iIndex to strRelation._iEmbeddedIndex
43812>>>>>>>                    Move strRelation to strQ.aTableRelations[iRelateItem]
43813>>>>>>>                End
43813>>>>>>>>
43813>>>>>>>                Else Begin
43814>>>>>>>                    Move strRelation._iEmbeddedIndex to iIndex
43815>>>>>>>                End
43815>>>>>>>>
43815>>>>>>>
43815>>>>>>>                Vfind iTargetTable iIndex EQ
43817>>>>>>>                If (not(Found)) Begin
43819>>>>>>>                    Clear iTargetTable
43820>>>>>>>                End
43820>>>>>>>>
43820>>>>>>>            End
43820>>>>>>>>
43820>>>>>>>        End_Procedure
43821>>>>>>>
43821>>>>>>>    Procedure _RelateToTable tTableQuery ByRef strQ Integer iTable // This is only called for embedded type queries (from the ResultColumnValue function)
43823>>>>>>>        Integer iRelateItem
43823>>>>>>>        Boolean bTableRelated
43823>>>>>>>        tTQTableRelation strRelation
43823>>>>>>>        tTQTableRelation strRelation
43823>>>>>>>        If (iTable<>strQ.iTable) Begin // If iTable is not the main table of the query
43825>>>>>>>
43825>>>>>>>            Get _FindTableRelation strQ iTable to iRelateItem
43826>>>>>>>            If (iRelateItem<>-1) Begin
43828>>>>>>>
43828>>>>>>>                Move strQ._strControlBlock.aRelatedRecords[iRelateItem] to bTableRelated
43829>>>>>>>                If (not(bTableRelated)) Begin //
43831>>>>>>>
43831>>>>>>>                    Move strQ.aTableRelations[iRelateItem] to strRelation
43832>>>>>>>                    If (not(strRelation.bFixed)) Begin // If no items we will just accept the current record
43834>>>>>>>
43834>>>>>>>                        If (IsNullRowID(GetRowID(strQ.iTable))) Begin
43836>>>>>>>                            Clear iTable
43837>>>>>>>                        End
43837>>>>>>>>
43837>>>>>>>                        Else Begin
43838>>>>>>>
43838>>>>>>>                            If (not(_TableRelationAlreadyOK(Self,&strQ,strRelation))) Begin // If not already good by chance.
43840>>>>>>>                                // It could already be OK by chance in which case it will not perform a relate. If the parent
43840>>>>>>>                                // record is the same as for the previous child record. Or if it has been "fixated" by an
43840>>>>>>>                                // outer loop in which case it would be constant. It is the responsability of the
43840>>>>>>>                                // programmer to ensure that tables do have to take on double roles.
43840>>>>>>>                                Send _RelateTablePerform (&strQ) iRelateItem
43841>>>>>>>                            End
43841>>>>>>>>
43841>>>>>>>
43841>>>>>>>                        End
43841>>>>>>>>
43841>>>>>>>                    End
43841>>>>>>>>
43841>>>>>>>
43841>>>>>>>                    Move True to strQ._strControlBlock.aRelatedRecords[iRelateItem] // update TableRelateState to "performed"
43842>>>>>>>                End
43842>>>>>>>>
43842>>>>>>>            End
43842>>>>>>>>
43842>>>>>>>            Else Begin
43843>>>>>>>                Send OnError 734 "Table not related"
43844>>>>>>>            End
43844>>>>>>>>
43844>>>>>>>        End
43844>>>>>>>>
43844>>>>>>>    End_Procedure
43845>>>>>>>
43845>>>>>>>    // This is called in preparation for a new record to indicate the related buffers have
43845>>>>>>>    // to be reconsidered and rectified if needed.
43845>>>>>>>    Procedure _TableRelateStatesReset tTableQuery ByRef strQ
43847>>>>>>>        Boolean[] abEmpty
43848>>>>>>>        Move abEmpty to strQ._strControlBlock.aRelatedRecords
43849>>>>>>>        Move (ResizeArray(strQ._strControlBlock.aRelatedRecords,SizeOfArray(strQ.aTableRelations),False)) to strQ._strControlBlock.aRelatedRecords
43850>>>>>>>    End_Procedure
43851>>>>>>>
43851>>>>>>>        Function __CompareColumnSource _tTQValueSource strValue1 _tTQValueSource strValue2 Returns Integer
43853>>>>>>>            Boolean bCompleteRecord1 bCompleteRecord2
43853>>>>>>>            Move (strValue1.iColumn=0) to bCompleteRecord1
43854>>>>>>>            Move (strValue2.iColumn=0) to bCompleteRecord2
43855>>>>>>>            If (bCompleteRecord1=bCompleteRecord2) Begin
43857>>>>>>>                Function_Return (EQ)
43858>>>>>>>            End
43858>>>>>>>>
43858>>>>>>>            If (bCompleteRecord1) Begin
43860>>>>>>>                Function_Return (GT)
43861>>>>>>>            End
43861>>>>>>>>
43861>>>>>>>            Else Begin
43862>>>>>>>                Function_Return (LT)
43863>>>>>>>            End
43863>>>>>>>>
43863>>>>>>>        End_Function
43864>>>>>>>
43864>>>>>>>    //> Add table column to the result set.
43864>>>>>>>    Procedure AddResultColumn tTableQuery ByRef strQ Integer iTable Integer iColumn Boolean bRejectIfAlreadyThere
43866>>>>>>>        Integer iColumnSourceItem
43866>>>>>>>        Boolean _bRejectIfAlreadyThere
43866>>>>>>>        
43866>>>>>>>        If (num_arguments>=4) Begin
43868>>>>>>>            Move bRejectIfAlreadyThere to _bRejectIfAlreadyThere
43869>>>>>>>        End
43869>>>>>>>>
43869>>>>>>>        Else Begin
43870>>>>>>>            Move False to _bRejectIfAlreadyThere
43871>>>>>>>        End
43871>>>>>>>>
43871>>>>>>>        
43871>>>>>>>        If (_bRejectIfAlreadyThere) Begin
43873>>>>>>>            Get _ColumnSourceFind strQ iTable iColumn to iColumnSourceItem
43874>>>>>>>            If (iColumnSourceItem>=0) Begin
43876>>>>>>>                Procedure_Return // The column is already there => skip it
43877>>>>>>>            End
43877>>>>>>>>
43877>>>>>>>        End
43877>>>>>>>>
43877>>>>>>>        
43877>>>>>>>        If (iTable=strQ.iTable or _FindTableRelation(Self,strQ,iTable)<>-1) Begin // We accept only ourselves or one of our related.
43879>>>>>>>            Move (SizeOfArray(strQ.aColumnSources)) to iColumnSourceItem
43880>>>>>>>            Move iTable to strQ.aColumnSources[iColumnSourceItem].iTable
43881>>>>>>>            Move iColumn to strQ.aColumnSources[iColumnSourceItem].iColumn
43882>>>>>>>            Get _ColumnType iTable iColumn to strQ.aColumnSources[iColumnSourceItem].iType
43883>>>>>>>            If (not(strQ._bOutputColumnsFixated)) Begin
43885>>>>>>>                Move strQ.aColumnSources[iColumnSourceItem] to strQ.aOutputColumns[SizeOfArray(strQ.aOutputColumns)]
43886>>>>>>>            End
43886>>>>>>>>
43886>>>>>>>            Move (SortArray(strQ.aColumnSources,Self,GET___CompareColumnSource)) to strQ.aColumnSources
43887>>>>>>>        End
43887>>>>>>>>
43887>>>>>>>        Else Begin
43888>>>>>>>            Send OnError 736 ("Unknown table in result set ("+String(iTable)+")")
43889>>>>>>>        End
43889>>>>>>>>
43889>>>>>>>    End_Procedure
43890>>>>>>>    
43890>>>>>>>    Procedure FixateOutputColumns tTableQuery ByRef strQ
43892>>>>>>>        Move True to strQ._bOutputColumnsFixated
43893>>>>>>>    End_Procedure
43894>>>>>>>    
43894>>>>>>>    Procedure AddResultTable tTableQuery ByRef strQ Integer iTable
43896>>>>>>>        Send AddResultColumn (&strQ) iTable 0
43897>>>>>>>    End_Procedure
43898>>>>>>>
43898>>>>>>>    Procedure ResetResultSetColumns tTableQuery ByRef strQuery
43900>>>>>>>        // Check that the query is not already executing
43900>>>>>>>        If (strQuery._strControlBlock.bInitialized) Begin
43902>>>>>>>            Send OnError 741 "ResetResultSetColumns called while query is executing"
43903>>>>>>>        End
43903>>>>>>>>
43903>>>>>>>        Else Begin
43904>>>>>>>            Move (ResizeArray(strQuery.aColumnSources,0)) to strQuery.aColumnSources
43905>>>>>>>            Move (ResizeArray(strQuery.aOutputColumns,0)) to strQuery.aOutputColumns
43906>>>>>>>        End
43906>>>>>>>>
43906>>>>>>>    End_Procedure
43907>>>>>>>
43907>>>>>>>    Function _IsColumnIncludedInResultSet tTableQuery strQ Integer iTable Integer iColumn Returns Boolean
43909>>>>>>>        Integer iItem iItemMax
43909>>>>>>>        Move (SizeOfArray(strQ.aColumnSources)-1) to iItemMax
43910>>>>>>>        If (strQ.iTable=iTable and iItemMax=-1) Begin
43912>>>>>>>            Function_Return True //
43913>>>>>>>        End
43913>>>>>>>>
43913>>>>>>>        For iItem from 0 to iItemMax
43919>>>>>>>>
43919>>>>>>>            If (iTable=strQ.aColumnSources[iItem].iTable) Begin
43921>>>>>>>                If (iColumn=strQ.aColumnSources[iItem].iColumn or strQ.aColumnSources[iItem].iColumn=0) Begin
43923>>>>>>>                    Function_Return True
43924>>>>>>>                End
43924>>>>>>>>
43924>>>>>>>            End
43924>>>>>>>>
43924>>>>>>>        Loop
43925>>>>>>>>
43925>>>>>>>        Function_Return False
43926>>>>>>>    End_Function
43927>>>>>>>
43927>>>>>>>// *** End of TableRelation functions *** End of TableRelation functions *** End of TableRelation functions *** End of TableRelation functions *** End of TableRelation functions ***
43927>>>>>>>
43927>>>>>>>
43927>>>>>>>        // If iTable has a name in filelist.cfg we use that, other wise
43927>>>>>>>        // we try the SQL table name.
43927>>>>>>>        Function LogTableName tTableQuery strQuery Returns String
43929>>>>>>>            Integer iTable
43929>>>>>>>            String sTableName
43929>>>>>>>            Move strQuery.iTable to iTable
43930>>>>>>>            Get_Attribute DF_FILE_LOGICAL_NAME of iTable to sTableName
43933>>>>>>>            If (sTableName="") Begin
43935>>>>>>>                Move strQuery.sForceSQLTableName to sTableName
43936>>>>>>>            End
43936>>>>>>>>
43936>>>>>>>            If (sTableName<>"") Begin
43938>>>>>>>                Move (sTableName+"_tqlog.dat") to sTableName
43939>>>>>>>            End
43939>>>>>>>>
43939>>>>>>>            Function_Return sTableName
43940>>>>>>>        End_Function
43941>>>>>>>
43941>>>>>>>        Function LogTableNameFullPath tTableQuery strQuery Returns String
43943>>>>>>>            String sFolder sTablePath
43943>>>>>>>            Get VdfFolderPath of oFileFunctions VDF_FILELIST to sFolder
43944>>>>>>>            Get AppendPath of oFileFunctions sFolder "tq-logdata" to sFolder
43945>>>>>>>            Get AppendPath of oFileFunctions sFolder (LogTableName(Self,strQuery)) to sTablePath
43946>>>>>>>            Function_Return sTablePath
43947>>>>>>>        End_Function
43948>>>>>>>
43948>>>>>>>        Function LogTableCreate tTableQuery strQuery Returns Boolean
43950>>>>>>>            tTempTableDefinition strTable
43950>>>>>>>            tTempTableDefinition strTable
43950>>>>>>>
43950>>>>>>>            Get EmptyTempTableDefinition of oTemporaryTablesFunctions to strTable
43951>>>>>>>
43951>>>>>>>            Move 20000 to strTable.iMaxRecords // Max number of logs
43952>>>>>>>            Get LogTableName strQuery to strTable.sFileName
43953>>>>>>>            Move "" to strTable.sFolder // blank means it goes in the data folder
43954>>>>>>>            Move "tq-logdata" to strTable.sSubFolder // means it goes in a subfolder of the data folder called "tq-logdata"
43955>>>>>>>
43955>>>>>>>            Send AddColumn of oTemporaryTablesFunctions (&strTable) "DateTime"         DF_ASCII    23 0  // field no 1
43956>>>>>>>            Send AddColumn of oTemporaryTablesFunctions (&strTable) "ExecTime"         DF_BCD       8 0  // field no 2
43957>>>>>>>            Send AddColumn of oTemporaryTablesFunctions (&strTable) "LogTag"           DF_ASCII    20 0  // field no 3
43958>>>>>>>            Send AddColumn of oTemporaryTablesFunctions (&strTable) "User"             DF_ASCII    20 0  // field no 4
43959>>>>>>>            Send AddColumn of oTemporaryTablesFunctions (&strTable) "Application"      DF_ASCII    20 0  // field no 5
43960>>>>>>>            Send AddColumn of oTemporaryTablesFunctions (&strTable) "SessionStart"     DF_ASCII    23 0  // field no 6
43961>>>>>>>            Send AddColumn of oTemporaryTablesFunctions (&strTable) "FullTableScan"    DF_BCD       2 0  // field no 7
43962>>>>>>>            Send AddColumn of oTemporaryTablesFunctions (&strTable) "RecordsFound"     DF_BCD      10 0  // field no 8
43963>>>>>>>            Send AddColumn of oTemporaryTablesFunctions (&strTable) "RecordsSelected"  DF_BCD      10 0  // field no 9
43964>>>>>>>            Send AddColumn of oTemporaryTablesFunctions (&strTable) "UnusedFilters"    DF_BCD       4 0  // field no 10
43965>>>>>>>            Send AddColumn of oTemporaryTablesFunctions (&strTable) "Index"            DF_BCD       4 0  // field no 11
43966>>>>>>>            Send AddColumn of oTemporaryTablesFunctions (&strTable) "IndexForced"      DF_BCD       2 0  // field no 12
43967>>>>>>>            Send AddColumn of oTemporaryTablesFunctions (&strTable) "PrefetchForced"   DF_BCD       2 0  // field no 13
43968>>>>>>>            Send AddColumn of oTemporaryTablesFunctions (&strTable) "Limit"            DF_BCD       6 0  // field no 14
43969>>>>>>>            Send AddColumn of oTemporaryTablesFunctions (&strTable) "ScanComplete"     DF_BCD       2 0  // field no 15
43970>>>>>>>            Send AddColumn of oTemporaryTablesFunctions (&strTable) "TQserialised"     DF_BINARY 2040 0  // field no 16
43971>>>>>>>            Move True to strTable.bCompression
43972>>>>>>>            
43972>>>>>>>            If (CreateTable(oTemporaryTablesFunctions,strTable,True)) Begin
43974>>>>>>>//                Showln "LogTableCreate Success"
43974>>>>>>>                Function_Return True
43975>>>>>>>            End
43975>>>>>>>>
43975>>>>>>>            Else Begin
43976>>>>>>>//                Showln "LogTableCreate Failure"
43976>>>>>>>            End
43976>>>>>>>>
43976>>>>>>>            Function_Return False
43977>>>>>>>        End_Function
43978>>>>>>>        
43978>>>>>>>        Function OpenLogTable tTableQuery strQuery Returns Integer 
43980>>>>>>>            Integer iLogTable
43980>>>>>>>            String sLogTableName
43980>>>>>>>            Move 0 to iLogTable
43981>>>>>>>            Get LogTableNameFullPath strQuery to sLogTableName
43982>>>>>>>            // We do not expect the log file to have an entry in filelist.cfg 
43982>>>>>>>            // so we open it "as".
43982>>>>>>>            If (sLogTableName<>"") Begin
43984>>>>>>>                Get OpenTableAsAutoHandle of oTableAccessFunctions sLogTableName DF_SHARE 0 to iLogTable
43985>>>>>>>                If (iLogTable=0) Begin // If the table isn't there, we create it
43987>>>>>>>                    If (LogTableCreate(Self,strQuery)) Begin
43989>>>>>>>                        Get OpenTableAsAutoHandle of oTableAccessFunctions sLogTableName DF_SHARE 0 to iLogTable
43990>>>>>>>                    End
43990>>>>>>>>
43990>>>>>>>                End
43990>>>>>>>>
43990>>>>>>>            End
43990>>>>>>>>
43990>>>>>>>            Else Begin
43991>>>>>>>                // No error! (I changed my mind)
43991>>>>>>>                // Error xxx ("Table name for log file could not be calculated (table: "+String(strQuery.iTable)+")")
43991>>>>>>>            End
43991>>>>>>>>
43991>>>>>>>            Function_Return iLogTable
43992>>>>>>>        End_Function
43993>>>>>>>        
43993>>>>>>>        Function LogTableHandle tTableQuery strQuery Returns Integer 
43995>>>>>>>            Integer iLogTable
43995>>>>>>>            Move 0 to iLogTable
43996>>>>>>>            If (strQuery.iTable<SizeOfArray(_gaTQLogTables)) Begin
43998>>>>>>>                Move _gaTQLogTables[strQuery.iTable] to iLogTable
43999>>>>>>>            End
43999>>>>>>>>
43999>>>>>>>            If (iLogTable=0) Begin
44001>>>>>>>                // Attempt to open log table
44001>>>>>>>                Get OpenLogTable strQuery to iLogTable
44002>>>>>>>                If (iLogTable=0) Move -1 to iLogTable
44005>>>>>>>                Move iLogTable to _gaTQLogTables[strQuery.iTable]
44006>>>>>>>            End
44006>>>>>>>>
44006>>>>>>>            Function_Return iLogTable
44007>>>>>>>        End_Function
44008>>>>>>>        
44008>>>>>>>        Function TableQueryUser Returns String
44010>>>>>>>            Function_Return (NetworkUserName(oWindowsInfo))
44011>>>>>>>        End_Function
44012>>>>>>>        
44012>>>>>>>//                Procedure _LogAppend String sValue String[] ByRef aValues
44012>>>>>>>//                    Send StringPush of oStackFunctions sValue (&aValues)
44012>>>>>>>//                End_Procedure
44012>>>>>>>//                
44012>>>>>>>//                Procedure _LogAppendValueSource _tTQValueSource strValue String[] ByRef aValues
44012>>>>>>>//                    Integer iItem iMax
44012>>>>>>>//                    Send _LogAppend strValue.iTable    (&aValues)
44012>>>>>>>//                    Send _LogAppend strValue.iColumn   (&aValues)
44012>>>>>>>//                    Send _LogAppend strValue.iType     (&aValues)
44012>>>>>>>//                    Send _LogAppend strValue.iLen      (&aValues)
44012>>>>>>>//                    Send _LogAppend strValue.iDecimals (&aValues)
44012>>>>>>>//                    Send _LogAppend strValue.sConstant (&aValues)
44012>>>>>>>//                    Send _LogAppend strValue.sSQLResultSetColumnName (&aValues)
44012>>>>>>>//                    Move (SizeOfArray(strValue.aOrList)-1) to iMax
44012>>>>>>>//                    Send _LogAppend iMax               (&aValues)
44012>>>>>>>//                    For iItem from 0 to iMax
44012>>>>>>>//                        Send _LogAppend strValue.aOrList[iItem] (&aValues)
44012>>>>>>>//                    Loop
44012>>>>>>>//                End_Procedure
44012>>>>>>>//                
44012>>>>>>>//            Procedure _LogAppendFilter tTQFilterSegment strFilter String[] ByRef aValues
44012>>>>>>>//                Send _LogAppendValueSource strFilter.strLeftValue  (&aValues)
44012>>>>>>>//                Send _LogAppend strFilter.iComp                    (&aValues)
44012>>>>>>>//                Send _LogAppendValueSource strFilter.strRightValue (&aValues)
44012>>>>>>>//            End_Procedure
44012>>>>>>>//
44012>>>>>>>//            Procedure _LogAppendOrderSegment tTQOrderBySegment strSegment String[] ByRef aValues
44012>>>>>>>//                Send _LogAppend strSegment.bDescending                (&aValues)
44012>>>>>>>//                Send _LogAppend strSegment.bUppercase                 (&aValues)
44012>>>>>>>//                Send _LogAppendValueSource strSegment.strValueSource  (&aValues)
44012>>>>>>>//            End_Procedure
44012>>>>>>>
44012>>>>>>>    //> Returns an array of tables that are referenced as constants during the execution of a query.
44012>>>>>>>    //> So if you want to repeat the find loop of a particular tTableQuery variable, the record 
44012>>>>>>>    //> buffers of fixed tables must be restored to that of the original query. Does this make sense?
44012>>>>>>>    Function _FixedTables tTableQuery strQuery Boolean bFixed Returns Integer[]
44014>>>>>>>        Integer iMax iIndex
44014>>>>>>>        Integer[] aTables
44015>>>>>>>        Move (SizeOfArray(strQuery.aTableRelations)-1) to iMax
44016>>>>>>>        For iIndex from 0 to iMax
44022>>>>>>>>
44022>>>>>>>            If (strQuery.aTableRelations[iIndex].bFixed=bFixed) Begin
44024>>>>>>>                If (IntegerAddToSet(oStackFunctions,&aTables,strQuery.aTableRelations[iIndex].iTargetTable)) Begin
44026>>>>>>>                    // Do nothing
44026>>>>>>>                End
44026>>>>>>>>
44026>>>>>>>            End
44026>>>>>>>>
44026>>>>>>>        Loop
44027>>>>>>>>
44027>>>>>>>        Function_Return aTables
44028>>>>>>>    End_Function
44029>>>>>>>
44029>>>>>>>    Function FixedTables tTableQuery strQuery Returns Integer[]
44031>>>>>>>        Function_Return (_FixedTables(Self,strQuery,True))
44032>>>>>>>    End_Function
44033>>>>>>>    
44033>>>>>>>    Function NotFixedTables tTableQuery strQuery Returns Integer[]
44035>>>>>>>        Boolean bGrb
44035>>>>>>>        Integer[] aTables
44036>>>>>>>        Get _FixedTables strQuery False to aTables
44037>>>>>>>        Get IntegerAddToSet of oStackFunctions (&aTables) strQuery.iTable to bGrb
44038>>>>>>>        Function_Return aTables
44039>>>>>>>    End_Function
44040>>>>>>>    
44040>>>>>>>    Function FixedTablesRowIDs tTableQuery strQuery Returns RowID[]
44042>>>>>>>        Integer iItem iMax
44042>>>>>>>        Integer[] aFixedTables
44043>>>>>>>        RowID[] aRowIDs
44044>>>>>>>        Get FixedTables strQuery to aFixedTables
44045>>>>>>>        Move (SizeOfArray(aFixedTables)-1) to iItem
44046>>>>>>>        For iItem from 0 to iMax
44052>>>>>>>>
44052>>>>>>>            Move (GetRowID(aFixedTables[iItem])) to aRowIDs[iItem]
44053>>>>>>>        Loop
44054>>>>>>>>
44054>>>>>>>        Function_Return aRowIDs
44055>>>>>>>    End_Function
44056>>>>>>>    
44056>>>>>>>    Function FixedTablesRowIDs_Serialized tTableQuery strQuery Returns String[]
44058>>>>>>>        Integer iItem iMax
44058>>>>>>>        Integer[] aFixedTables
44059>>>>>>>        String[] aRowIDs
44060>>>>>>>        Get FixedTables strQuery to aFixedTables
44061>>>>>>>        Move (SizeOfArray(aFixedTables)-1) to iItem
44062>>>>>>>        For iItem from 0 to iMax
44068>>>>>>>>
44068>>>>>>>            Move (SerializeRowID(GetRowID(aFixedTables[iItem]))) to aRowIDs[iItem]
44069>>>>>>>        Loop
44070>>>>>>>>
44070>>>>>>>        Function_Return aRowIDs
44071>>>>>>>    End_Function
44072>>>>>>>    
44072>>>>>>>    Function FixedTablesRestore tTableQuery strQuery RowID[] aRowIDs Returns Boolean
44074>>>>>>>        Boolean bFound
44074>>>>>>>        RowID riRow
44074>>>>>>>        Integer iItem iMax
44074>>>>>>>        Integer[] aFixedTables
44075>>>>>>>        Get FixedTables strQuery to aFixedTables
44076>>>>>>>        Move (SizeOfArray(aFixedTables)-1) to iMax
44077>>>>>>>        For iItem from 0 to iMax
44083>>>>>>>>
44083>>>>>>>            Move aRowIDs[iItem] to riRow
44084>>>>>>>            If (IsNullRowID(riRow)) Begin
44086>>>>>>>                Clear aFixedTables[iItem]
44087>>>>>>>            End
44087>>>>>>>>
44087>>>>>>>            Else Begin
44088>>>>>>>                Move (FindByRowID(aFixedTables[iItem],aRowIDs[iItem])) to bFound
44089>>>>>>>                If (not(bFound)) Begin
44091>>>>>>>                    Function_Return False
44092>>>>>>>                End
44092>>>>>>>>
44092>>>>>>>            End
44092>>>>>>>>
44092>>>>>>>        Loop
44093>>>>>>>>
44093>>>>>>>        Function_Return True
44094>>>>>>>    End_Function
44095>>>>>>>
44095>>>>>>>    Function FixedTablesRestore_Serialized tTableQuery strQuery String[] asRowIDs Returns Boolean
44097>>>>>>>        Integer iItem iMax
44097>>>>>>>        RowID[] ariRowIDs
44098>>>>>>>        Move (SizeOfArray(asRowIDs)-1) to iMax
44099>>>>>>>        For iItem from 0 to iMax
44105>>>>>>>>
44105>>>>>>>            Move (DeserializeRowID(asRowIDs[iItem])) to ariRowIDs[iItem]
44106>>>>>>>        Loop
44107>>>>>>>>
44107>>>>>>>        Function_Return (FixedTablesRestore(Self,strQuery,ariRowIDs))
44108>>>>>>>    End_Function
44109>>>>>>>
44109>>>>>>>    Procedure _PushNoneFixedBuffers tTableQuery strQuery
44111>>>>>>>        Integer iItem iMax iTable
44111>>>>>>>        Integer[] aTables
44112>>>>>>>        Get NotFixedTables strQuery to aTables
44113>>>>>>>        Move (SizeOfArray(aTables)-1) to iMax
44114>>>>>>>        For iItem from 0 to iMax
44120>>>>>>>>
44120>>>>>>>            Move aTables[iItem] to iTable
44121>>>>>>>            Send PushRecord of oRecordBufferFunctions iTable
44122>>>>>>>        Loop
44123>>>>>>>>
44123>>>>>>>    End_Procedure
44124>>>>>>>    Procedure _PopNoneFixedBuffers tTableQuery strQuery
44126>>>>>>>        Integer iItem iMax iTable
44126>>>>>>>        Integer[] aTables
44127>>>>>>>        Get NotFixedTables strQuery to aTables
44128>>>>>>>        Move (ReverseArray(aTables)) to aTables
44129>>>>>>>        Move (SizeOfArray(aTables)-1) to iMax
44130>>>>>>>        For iItem from 0 to iMax
44136>>>>>>>>
44136>>>>>>>            Move aTables[iItem] to iTable
44137>>>>>>>            Send PopRecord of oRecordBufferFunctions iTable
44138>>>>>>>        Loop
44139>>>>>>>>
44139>>>>>>>    End_Procedure
44140>>>>>>>    
44140>>>>>>>    
44140>>>>>>>    Function TableQueryToString tTableQuery strQuery Returns String
44142>>>>>>>        String sTQ
44142>>>>>>>        Get VariantToString of oStructFunctions strQuery to sTQ
44143>>>>>>>        Function_Return sTQ
44144>>>>>>>    End_Function
44145>>>>>>>    
44145>>>>>>>    Function StringToTableQuery String sTQ Returns tTableQuery
44147>>>>>>>        tTableQuery strQuery
44147>>>>>>>        tTableQuery strQuery
44147>>>>>>>        tValueTree strValueTree
44147>>>>>>>        tValueTree strValueTree
44147>>>>>>>        Get StringToValueTree of oStructFunctions sTQ to strValueTree
44148>>>>>>>        ValueTreeDeserializeParameter strValueTree to strQuery
44149>>>>>>>        Function_Return strQuery
44150>>>>>>>    End_Function
44151>>>>>>>        
44151>>>>>>>    Function TableQuerySerializedForLog tTableQuery strQuery Returns String
44153>>>>>>>        String sTQ
44153>>>>>>>        Get TableQueryToString strQuery to sTQ
44154>>>>>>>        Function_Return ("V1.0,"+sTQ)
44155>>>>>>>    End_Function
44156>>>>>>>        
44156>>>>>>>            Function _NextValueInArray String[] aValues Integer ByRef iPos Returns String
44158>>>>>>>                String sValue
44158>>>>>>>                Move aValues[iPos] to sValue
44159>>>>>>>                Increment iPos
44160>>>>>>>                Function_Return sValue
44161>>>>>>>            End_Function
44162>>>>>>>        
44162>>>>>>>                Function _LogReadValueSource String[] aValues Integer ByRef iPos Returns _tTQValueSource
44164>>>>>>>                    _tTQValueSource strValue
44164>>>>>>>                    _tTQValueSource strValue
44164>>>>>>>                    Integer iItem iMax
44164>>>>>>>                    Get _NextValueInArray aValues (&iPos) to strValue.iTable   
44165>>>>>>>                    Get _NextValueInArray aValues (&iPos) to strValue.iColumn  
44166>>>>>>>                    Get _NextValueInArray aValues (&iPos) to strValue.iType    
44167>>>>>>>                    Get _NextValueInArray aValues (&iPos) to strValue.iLen     
44168>>>>>>>                    Get _NextValueInArray aValues (&iPos) to strValue.iDecimals
44169>>>>>>>                    Get _NextValueInArray aValues (&iPos) to strValue.sConstant
44170>>>>>>>                    Get _NextValueInArray aValues (&iPos) to strValue.sSQLResultSetColumnName
44171>>>>>>>                    Get _NextValueInArray aValues (&iPos) to iMax
44172>>>>>>>                    For iItem from 0 to iMax
44178>>>>>>>>
44178>>>>>>>                        Get _NextValueInArray aValues (&iPos) to strValue.aOrList[iItem]
44179>>>>>>>                    Loop
44180>>>>>>>>
44180>>>>>>>                    Function_Return strValue
44181>>>>>>>                End_Function
44182>>>>>>>
44182>>>>>>>            Function _LogReadFilter String[] aValues Integer ByRef iPos Returns tTQFilterSegment
44184>>>>>>>                tTQFilterSegment strFilter
44184>>>>>>>                tTQFilterSegment strFilter
44184>>>>>>>                Get _LogReadValueSource aValues (&iPos) to strFilter.strLeftValue
44185>>>>>>>                Get _NextValueInArray aValues (&iPos) to strFilter.iComp
44186>>>>>>>                Get _LogReadValueSource aValues (&iPos) to strFilter.strRightValue
44187>>>>>>>            End_Function
44188>>>>>>>            
44188>>>>>>>            Function _LogReadOrderingSegment String[] aValues Integer ByRef iPos Returns tTQOrderBySegment
44190>>>>>>>                tTQOrderBySegment strSegment
44190>>>>>>>                tTQOrderBySegment strSegment
44190>>>>>>>                Get _NextValueInArray aValues (&iPos) to strSegment.bDescending
44191>>>>>>>                Get _NextValueInArray aValues (&iPos) to strSegment.bUppercase
44192>>>>>>>                Get _LogReadValueSource aValues (&iPos) to strSegment.strValueSource
44193>>>>>>>            End_Function
44194>>>>>>>        
44194>>>>>>>        Function TableQueryDeserializedFromLog String sValue Returns tTableQuery
44196>>>>>>>            Integer iPos iItem iMax
44196>>>>>>>            tTableQuery strQuery 
44196>>>>>>>            tTableQuery strQuery 
44196>>>>>>>            tTQFilterSegment strFilter
44196>>>>>>>            tTQFilterSegment strFilter
44196>>>>>>>            tTQOrderBySegment strSegment
44196>>>>>>>            tTQOrderBySegment strSegment
44196>>>>>>>            String[] aValues
44197>>>>>>>            Send SplitString of oStringFunctions sValue (Character(10)) False False (&aValues)
44198>>>>>>>            If (SizeOfArray(aValues)>1) Begin
44200>>>>>>>                Move 1 to iPos
44201>>>>>>>                If (aValues[0]="V1.0") Begin
44203>>>>>>>                    Get _NextValueInArray aValues (&iPos) to strQuery.iTable
44204>>>>>>>                    Get _NextValueInArray aValues (&iPos) to strQuery.bNoESQL
44205>>>>>>>                    Get _NextValueInArray aValues (&iPos) to strQuery.bForcePrefetch
44206>>>>>>>                    Get _NextValueInArray aValues (&iPos) to strQuery.iForceIndex   
44207>>>>>>>                    Get _NextValueInArray aValues (&iPos) to strQuery.iLimit        
44208>>>>>>>                    // Filters:
44208>>>>>>>                    Get _NextValueInArray aValues (&iPos) to iMax
44209>>>>>>>                    For iItem from 0 to iMax
44215>>>>>>>>
44215>>>>>>>                        Get _LogReadFilter aValues (&iPos) to strFilter
44216>>>>>>>                        Move strFilter to strQuery.aFilters[iItem]    
44217>>>>>>>                    Loop
44218>>>>>>>>
44218>>>>>>>                    // Ordering:
44218>>>>>>>                    Get _NextValueInArray aValues (&iPos) to iMax
44219>>>>>>>                    For iItem from 0 to iMax
44225>>>>>>>>
44225>>>>>>>                        Get _LogReadOrderingSegment aValues (&iPos) to strSegment
44226>>>>>>>                        Move strSegment to strQuery.aOrdering[iItem]    
44227>>>>>>>                    Loop
44228>>>>>>>>
44228>>>>>>>                End
44228>>>>>>>>
44228>>>>>>>            End
44228>>>>>>>>
44228>>>>>>>            Function_Return strQuery
44229>>>>>>>        End_Function
44230>>>>>>>
44230>>>>>>>    Procedure OnLogStatus tTableQuery strQuery
44232>>>>>>>        Boolean bVal
44232>>>>>>>        Integer iLogTable iSize iValue
44232>>>>>>>        String sModule sValue
44232>>>>>>>        Get LogTableHandle strQuery to iLogTable
44233>>>>>>>        If (iLogTable>0) Begin
44235>>>>>>>            Clear iLogTable
44236>>>>>>>
44236>>>>>>>            Get SystemTimeToString23 of oDateFunctions (SystemTimeMilliSeconds(oDateFunctions)) to sValue
44237>>>>>>>            Set_Field_Value iLogTable 1 to sValue
44240>>>>>>>            Set_Field_Value iLogTable 3 to strQuery._strControlBlock.sLogTag
44243>>>>>>>            Get TableQueryUser to sValue
44244>>>>>>>            Set_Field_Value iLogTable 4 to sValue  // (TableQueryUser(Self))
44247>>>>>>>            Get Module_Name to sModule
44248>>>>>>>            Set_Field_Value iLogTable 5 to sModule
44251>>>>>>>            Get ModuleStartTime of oDateFunctions to sValue
44252>>>>>>>            Set_Field_Value iLogTable 6 to sValue
44255>>>>>>>            Move (SizeOfArray(strQuery._strCompiled.aJumpInValues)=0 and SizeOfArray(strQuery._strCompiled.aJumpOutValues)=0 and strQuery.iLimit=0) to bVal
44256>>>>>>>            Set_Field_Value iLogTable 7 to bVal // Full table scan
44259>>>>>>>            Set_Field_Value iLogTable 8 to strQuery._strControlBlock.iFindCount
44262>>>>>>>            Set_Field_Value iLogTable 9 to strQuery._strControlBlock.iSelectCount
44265>>>>>>>            Move (SizeOfArray(strQuery._strCompiled.aOtherConditions)) to iSize
44266>>>>>>>            Set_Field_Value iLogTable 10 to iSize // Unused filters
44269>>>>>>>            Set_Field_Value iLogTable 11 to strQuery._strCompiled.iIndex
44272>>>>>>>            Move (strQuery.iForceIndex<>-1) to iValue
44273>>>>>>>            Set_Field_Value iLogTable 12 to iValue
44276>>>>>>>            Set_Field_Value iLogTable 13 to strQuery.bForcePrefetch
44279>>>>>>>            Set_Field_Value iLogTable 14 to strQuery.iLimit
44282>>>>>>>            Set_Field_Value iLogTable 15 to (not(strQuery._strControlBlock.bBreakScan))
44285>>>>>>>            Get TableQuerySerializedForLog strQuery to sValue
44286>>>>>>>            Set_Field_Value iLogTable 16 to sValue
44289>>>>>>>            
44289>>>>>>>            SaveRecord iLogTable
44290>>>>>>>        End
44290>>>>>>>>
44290>>>>>>>    End_Procedure
44291>>>>>>>        
44291>>>>>>>    Procedure OnComplete tTableQuery strQuery
44293>>>>>>>    End_Procedure
44294>>>>>>>    
44294>>>>>>>        Procedure _RelateMainRecord tTableQuery ByRef strQuery
44296>>>>>>>            Integer iItem iItemMax
44296>>>>>>>            Move (SizeOfArray(strQuery.aColumnSources)-1) to iItemMax
44297>>>>>>>            For iItem from 0 to iItemMax
44303>>>>>>>>
44303>>>>>>>                Send _RelateToTable (&strQuery) strQuery.aColumnSources[iItem].iTable
44304>>>>>>>            Loop
44305>>>>>>>>
44305>>>>>>>        End_Procedure
44306>>>>>>>
44306>>>>>>>    Function FindRecord tTableQuery ByRef strQuery Returns Boolean
44308>>>>>>>        Boolean bFound bInitialize
44308>>>>>>>
44308>>>>>>>        Move False to bInitialize
44309>>>>>>>
44309>>>>>>>        If (strQuery._strControlBlock.bCompiled) Begin
44311>>>>>>>            If (not(strQuery._strControlBlock.bInitialized)) Begin
44313>>>>>>>                Move True to bInitialize // Initialize!
44314>>>>>>>            End
44314>>>>>>>>
44314>>>>>>>        End
44314>>>>>>>>
44314>>>>>>>        Else Begin
44315>>>>>>>            Get _CompileQuery (&strQuery) to bInitialize // If it compiles we will initialize it
44316>>>>>>>        End
44316>>>>>>>>
44316>>>>>>>
44316>>>>>>>        If (bInitialize) Begin
44318>>>>>>>            If (_InitializeQuery(Self,&strQuery)) Begin
44320>>>>>>>                Move True to strQuery._strControlBlock.bInitialized
44321>>>>>>>                Get _FindFirstRecord (&strQuery) to bFound
44322>>>>>>>            End
44322>>>>>>>>
44322>>>>>>>            Else Begin
44323>>>>>>>                Move False to bFound
44324>>>>>>>            End
44324>>>>>>>>
44324>>>>>>>            Move True to strQuery._strControlBlock.bFirstRecord
44325>>>>>>>        End
44325>>>>>>>>
44325>>>>>>>        Else Begin
44326>>>>>>>            // This is the mechanism that enforces iLimit. However, if the record set is pre-fetched
44326>>>>>>>            // this has already been taken care of.
44326>>>>>>>            if (strQuery._strCompiled._iLimit<>0) Begin
44328>>>>>>>                If (not(strQuery._strCompiled.bPrefetch) and ;                    strQuery._strControlBlock.iSelectCount>=strQuery._strCompiled._iLimit) Begin
44330>>>>>>>                    Move True to strQuery._strControlBlock.bBreakScan
44331>>>>>>>                End
44331>>>>>>>>
44331>>>>>>>            End
44331>>>>>>>>
44331>>>>>>>
44331>>>>>>>            Get _FindNextRecord (&strQuery) to bFound
44332>>>>>>>            Move False to strQuery._strControlBlock.bFirstRecord
44333>>>>>>>        End
44333>>>>>>>>
44333>>>>>>>
44333>>>>>>>        If (bFound) Begin
44335>>>>>>>            If (strQuery._strControlBlock.iQueryMethod=tqDATAFLEX) Begin
44337>>>>>>>                // If we are in embedded mode we must find all parent related records specified by the aSelectedColumns member.
44337>>>>>>>                Send _RelateMainRecord (&strQuery)
44338>>>>>>>            End
44338>>>>>>>>
44338>>>>>>>            Else Begin
44339>>>>>>>                // If we are in ESQL mode we expect the fetch-record mechnism to have already done this
44339>>>>>>>            End
44339>>>>>>>>
44339>>>>>>>        End
44339>>>>>>>>
44339>>>>>>>        Else Begin
44340>>>>>>>            If (not(strQuery.bForcePrefetch)) Begin
44342>>>>>>>                Send PurgeResultSet (&strQuery) // if we didn't ask for it we'll get rid of it here (if it's there at all)
44343>>>>>>>            End
44343>>>>>>>>
44343>>>>>>>            If (_giTQLogState=2 or ( _giTQLogState=1 and strQuery._strControlBlock.sLogTag<>"")) Begin
44345>>>>>>>                Send OnLogStatus strQuery
44346>>>>>>>            End
44346>>>>>>>>
44346>>>>>>>            Send _DeinitializeQuery (&strQuery) // Get rid of SQL handles (if emploid)
44347>>>>>>>            Send OnComplete strQuery
44348>>>>>>>            If (strQuery.bRestoreRecordBuffersOnQueryCompletion) Begin
44350>>>>>>>                Send _PopNoneFixedBuffers strQuery // restore buffers of tables that were possibly changed by the query
44351>>>>>>>            End
44351>>>>>>>>
44351>>>>>>>            // This is where we _*ALWAYS*_ exit the FindRecord loop
44351>>>>>>>        End
44351>>>>>>>>
44351>>>>>>>
44351>>>>>>>        Function_Return bFound
44352>>>>>>>    End_Function
44353>>>>>>>
44353>>>>>>>    Function IsFirstRecord tTableQuery strQuery Returns Boolean
44355>>>>>>>        Function_Return strQuery._strControlBlock.bFirstRecord
44356>>>>>>>    End_Function
44357>>>>>>>    
44357>>>>>>>    //> Returns the current row number of the result set.
44357>>>>>>>    Function ResultRowNumber tTableQuery strQuery Returns Integer
44359>>>>>>>        If (strQuery._strCompiled.bPrefetch) Begin
44361>>>>>>>            Function_Return (strQuery.strResultSet._iCurrentRowPointer+1)
44362>>>>>>>        End
44362>>>>>>>>
44362>>>>>>>        Function_Return strQuery._strControlBlock.iFindCount
44363>>>>>>>    End_Function
44364>>>>>>>
44364>>>>>>>    Function HasData tTableQuery strQuery Returns Boolean
44366>>>>>>>        Boolean bHasData
44366>>>>>>>        tTQOrderBySegment[] aEmpty
44366>>>>>>>        tTQOrderBySegment[] aEmpty
44367>>>>>>>        If (strQuery._strControlBlock.bInitialized) Begin
44369>>>>>>>            // If the query has already been initialized the function will return whether or 
44369>>>>>>>            // not any records have been selected yet (this would only ever be relevant to a
44369>>>>>>>            // person subclassing the cTableQuery class). More relevant is the fact that this
44369>>>>>>>            // means that you can query HasData after loop completion and get to know if the 
44369>>>>>>>            // loop was ever executed.
44369>>>>>>>            Function_Return (strQuery._strControlBlock.iSelectCount<>0)
44370>>>>>>>        End
44370>>>>>>>>
44370>>>>>>>        Else Begin
44371>>>>>>>            // If the loop hasn't yet been initialized we will produce the simplest
44371>>>>>>>            // possible query to find out if the loop will have any data.
44371>>>>>>>            Move False to strQuery.bForcePrefetch // Prefetch would be stupid
44372>>>>>>>            Move aEmpty to strQuery.aOrdering // Do not dictate the ordering
44373>>>>>>>            Move 1 to strQuery.iLimit // This will prevent the complete set being built.
44374>>>>>>>            Move -1 to strQuery.iForceIndex // Do not force any particular index
44375>>>>>>>            
44375>>>>>>>            // Dilemma! If there are no non-optimizable filters then it's faster to not use
44375>>>>>>>            //          ESQL. But then I have to compile the query before executing the loop.
44375>>>>>>>            //          I just haven't gotten around to that yet.
44375>>>>>>>            // Move True to strQuery.bNoESQL // (do not use ESQL)
44375>>>>>>>            
44375>>>>>>>            Move False to bHasData
44376>>>>>>>            While (FindRecord(Self,&strQuery))
44380>>>>>>>                Move True to bHasData
44381>>>>>>>            Loop
44382>>>>>>>>
44382>>>>>>>        End
44382>>>>>>>>
44382>>>>>>>        Function_Return bHasData
44383>>>>>>>    End_Function
44384>>>>>>>    
44384>>>>>>>    Function QueryToRowIdArray tTableQuery ByRef strQuery Returns RowID[]
44386>>>>>>>        Integer iTable iCount
44386>>>>>>>        RowID[] aRecords
44387>>>>>>>        Move strQuery.iTable to iTable
44388>>>>>>>        Move 0 to iCount
44389>>>>>>>        While (FindRecord(Self,&strQuery))
44393>>>>>>>            Move (GetRowID(iTable)) to aRecords[iCount]
44394>>>>>>>            Increment iCount
44395>>>>>>>        Loop
44396>>>>>>>>
44396>>>>>>>        Function_Return aRecords    
44397>>>>>>>    End_Function
44398>>>>>>>    
44398>>>>>>>    Function DeleteRecords tTableQuery strQuery Returns Boolean
44400>>>>>>>        Integer iTable
44400>>>>>>>        String sStatement
44400>>>>>>>        tSQLStatementHandle strStatement
44400>>>>>>>        tSQLStatementHandle strStatement
44400>>>>>>>        
44400>>>>>>>        If (strQuery.iLimit<>0) Begin
44402>>>>>>>            Send OnError 742 "Limit not allowed on delete statement"
44403>>>>>>>        End
44403>>>>>>>>
44403>>>>>>>        Else Begin
44404>>>>>>>
44404>>>>>>>            Send ResetOrdering (&strQuery)               // Ordering irrelevant!
44405>>>>>>>            Send ResetResultSetColumns (&strQuery)       // Resultset irrelevant!
44406>>>>>>>            
44406>>>>>>>            If (_QueryMethodSQL(Self,strQuery)) Begin // ESQL
44408>>>>>>>
44408>>>>>>>                If (OpenStatementOnTable(oSQLStatementHandles,strQuery.iTable,&strStatement)) Begin
44410>>>>>>>
44410>>>>>>>                    Move strStatement to strQuery._strControlBlock.strSQLStatementHandle // Is used during the generating of the SQL statement.
44411>>>>>>>
44411>>>>>>>                    Send _TableRelateStatesReset (&strQuery)
44412>>>>>>>                    Get SQLDeleteStatement strQuery Self to sStatement
44413>>>>>>>                    Move (ToANSI(sStatement)) to sStatement
44414>>>>>>>                    If (sStatement<>"") Begin
44416>>>>>>>                        Send SQLExecDirect of strStatement.hHandle sStatement
44417>>>>>>>                    End
44417>>>>>>>>
44417>>>>>>>                    Send CloseStatement of oSQLStatementHandles strStatement
44418>>>>>>>                    
44418>>>>>>>                End
44418>>>>>>>>
44418>>>>>>>            End
44418>>>>>>>>
44418>>>>>>>            Else Begin
44419>>>>>>>                Move strQuery.iTable to iTable
44420>>>>>>>                While (FindRecord(Self,&strQuery))
44424>>>>>>>                    Delete iTable
44425>>>>>>>                Loop
44426>>>>>>>>
44426>>>>>>>            End
44426>>>>>>>>
44426>>>>>>>        End
44426>>>>>>>>
44426>>>>>>>        Function_Return False
44427>>>>>>>    End_Function
44428>>>>>>>
44428>>>>>>>
44428>>>>>>>        Function _TableRootNameStripDriver String sRootName Returns String
44430>>>>>>>            Integer iPos
44430>>>>>>>            Move (Pos(":",sRootName)) to iPos
44431>>>>>>>            If (iPos>2) Begin
44433>>>>>>>                Move (Remove(sRootName,1,iPos)) to sRootName
44434>>>>>>>            End
44434>>>>>>>>
44434>>>>>>>            Function_Return sRootName
44435>>>>>>>        End_Function
44436>>>>>>>
44436>>>>>>>        Function _TableAnalysisFileName Integer iTable Returns String
44438>>>>>>>            String sFolder sTableName
44438>>>>>>>            Get VdfFolderPath of oFileFunctions VDF_FILELIST to sFolder
44439>>>>>>>            Get_Attribute DF_FILE_ROOT_NAME of iTable to sTableName
44442>>>>>>>            Get _TableRootNameStripDriver sTableName to sTableName
44443>>>>>>>            Get PathStripType of oFileFunctions sTableName to sTableName
44444>>>>>>>            Get AppendPath of oFileFunctions sFolder (sTableName+".tq") to sTableName
44445>>>>>>>            Function_Return sTableName
44446>>>>>>>        End_Function
44447>>>>>>>
44447>>>>>>>            Function _TableAnalysisReadIndex Integer iChannel Returns _tTQIndexAnalysis
44449>>>>>>>                Integer iItem iMax
44449>>>>>>>                _tTQIndexAnalysis strIndexA
44449>>>>>>>                _tTQIndexAnalysis strIndexA
44449>>>>>>>                Readln iMax
44450>>>>>>>                For iItem from 0 to iMax
44456>>>>>>>>
44456>>>>>>>                    Get Readln of oFileFunctions iChannel to strIndexA.aSegmentReductions[iItem]
44457>>>>>>>                Loop
44458>>>>>>>>
44458>>>>>>>                Function_Return strIndexA
44459>>>>>>>            End_Function
44460>>>>>>>        
44460>>>>>>>        Function TableAnalysisRead Integer iTable tTQTableAnalysis ByRef strA Returns Boolean
44462>>>>>>>            Integer iChannel iItem iMax
44462>>>>>>>            String sFile
44462>>>>>>>            tTQTableAnalysis strEmpty
44462>>>>>>>            tTQTableAnalysis strEmpty
44462>>>>>>>            Move strEmpty to strA
44463>>>>>>>            Get _TableAnalysisFileName iTable to sFile
44464>>>>>>>            Get DirectInput of oFileFunctions sFile to iChannel
44465>>>>>>>            If (iChannel>=0) Begin
44467>>>>>>>                If (Readln(oFileFunctions,iChannel)="VER 1.0") Begin
44469>>>>>>>                    Get StringToDateTime of oDateFunctions (Readln(oFileFunctions,iChannel)) DF_DATE_MILITARY to strA.dtAnalysisDateTime
44470>>>>>>>                    Readln channel iChannel strA.nNumberOfRecords
44472>>>>>>>                    Readln strA.sTimeToComplete
44473>>>>>>>                    Readln iMax
44474>>>>>>>                    For iItem from 0 to iMax
44480>>>>>>>>
44480>>>>>>>                        Get _TableAnalysisReadIndex iChannel to strA.aIndices[iItem]
44481>>>>>>>                    Loop
44482>>>>>>>>
44482>>>>>>>                    Send CloseInput of oFileFunctions iChannel
44483>>>>>>>                    Function_Return True
44484>>>>>>>                End
44484>>>>>>>>
44484>>>>>>>                Else Begin
44485>>>>>>>                    Send OnError 737 ("TQ cache file not recognized ("+sFile+")")
44486>>>>>>>                End
44486>>>>>>>>
44486>>>>>>>                Send CloseInput of oFileFunctions iChannel
44487>>>>>>>            End
44487>>>>>>>>
44487>>>>>>>            Function_Return False
44488>>>>>>>        End_Function
44489>>>>>>>        
44489>>>>>>>        Procedure _TableAnalysisSaveIndex Integer iChannel _tTQIndexAnalysis strIndexA
44491>>>>>>>            Integer iMax iItem
44491>>>>>>>            Move (SizeOfArray(strIndexA.aSegmentReductions)-1) to iMax
44492>>>>>>>            Writeln channel iChannel iMax
44495>>>>>>>            For iItem from 0 to iMax
44501>>>>>>>>
44501>>>>>>>                Writeln strIndexA.aSegmentReductions[iItem]
44503>>>>>>>            Loop
44504>>>>>>>>
44504>>>>>>>        End_Procedure
44505>>>>>>>        
44505>>>>>>>    Function TableAnalysisSave Integer iTable tTQTableAnalysis strA Returns Boolean
44507>>>>>>>        Integer iChannel iItem iMax
44507>>>>>>>        String sFile
44507>>>>>>>        Get _TableAnalysisFileName iTable to sFile
44508>>>>>>>        Get DirectOutput of oFileFunctions sFile to iChannel
44509>>>>>>>        If (iChannel>=0) Begin
44511>>>>>>>            Writeln channel iChannel "VER 1.0"
44514>>>>>>>            Writeln (DateTimeToString(oDateFunctions,strA.dtAnalysisDateTime,DF_DATE_MILITARY,True,"-"))
44516>>>>>>>            Writeln strA.nNumberOfRecords
44518>>>>>>>            Writeln strA.sTimeToComplete
44520>>>>>>>            Move (SizeOfArray(strA.aIndices)-1) to iMax
44521>>>>>>>            Writeln iMax
44523>>>>>>>            For iItem from 0 to iMax
44529>>>>>>>>
44529>>>>>>>                Send _TableAnalysisSaveIndex iChannel strA.aIndices[iItem]
44530>>>>>>>            Loop
44531>>>>>>>>
44531>>>>>>>            Send CloseOutput of oFileFunctions iChannel
44532>>>>>>>            Function_Return True
44533>>>>>>>        End
44533>>>>>>>>
44533>>>>>>>        Function_Return False
44534>>>>>>>    End_Function
44535>>>>>>>    
44535>>>>>>>        Function _TableAnalysisDefault Integer iTable Returns tTQTableAnalysis
44537>>>>>>>            Integer iIndex iItem iMax 
44537>>>>>>>            Integer iSegment iSegments
44537>>>>>>>            Integer[] aIndices
44538>>>>>>>            Number nRecordCount nFactor
44538>>>>>>>            tocIndex strIndex
44538>>>>>>>            tocIndex strIndex
44538>>>>>>>            tTQTableAnalysis strA
44538>>>>>>>            tTQTableAnalysis strA
44538>>>>>>>
44538>>>>>>>            Get IndexSet of oIndexFunctions iTable 3 to aIndices // 3 means all online indices
44539>>>>>>>            Get_Attribute DF_FILE_RECORDS_USED of iTable 0 0 to nRecordCount
44542>>>>>>>            
44542>>>>>>>            Move (SizeOfArray(aIndices)-1) to iMax
44543>>>>>>>            For iItem from 0 to iMax
44549>>>>>>>>
44549>>>>>>>                Move aIndices[iItem] to iIndex
44550>>>>>>>                Get IndexDefinition of oOverlapColumnFunctions iTable iIndex to strIndex
44551>>>>>>>                Move (SizeOfArray(strIndex.aSegments)) to iSegments
44552>>>>>>>                
44552>>>>>>>                Move (nRecordCount^(1.0/iSegments)) to nFactor
44553>>>>>>>                Move (1.0/nFactor) to nFactor
44554>>>>>>>                
44554>>>>>>>                Decrement iSegments
44555>>>>>>>                For iSegment from 0 to iSegments
44561>>>>>>>>
44561>>>>>>>                    Move nFactor to strA.aIndices[iIndex].aSegmentReductions[iSegment]
44562>>>>>>>                Loop
44563>>>>>>>>
44563>>>>>>>            Loop
44564>>>>>>>>
44564>>>>>>>            Function_Return strA 
44565>>>>>>>        End_Function
44566>>>>>>>    
44566>>>>>>>    //> The TableAnalysis returns a struct that contains information that helps the index analyzer
44566>>>>>>>    //> to make informed guesses about which index seeds the best. VDFxray can be used to generate
44566>>>>>>>    //> a small text file for each table with this information. If this is the case then function
44566>>>>>>>    //> TableAnalysis will read that file and return the by now much mentioned information. And if not 
44566>>>>>>>    //> the best possible guess is calculated and returned. Actually, in addition to being returned
44566>>>>>>>    //> by the function it is also copied to a global cache so subsequent calls will take no time. 
44566>>>>>>>    Function TableAnalysis Integer iTable Returns tTQTableAnalysis
44568>>>>>>>        tTQTableAnalysis strA
44568>>>>>>>        tTQTableAnalysis strA
44568>>>>>>>        
44568>>>>>>>        Move False to strA.bInitialized
44569>>>>>>>        If (SizeOfArray(_gTQaTableAnalysis)>iTable and _gTQaTableAnalysis[iTable].bInitialized) Begin
44571>>>>>>>            Move _gTQaTableAnalysis[iTable] to strA
44572>>>>>>>        End
44572>>>>>>>>
44572>>>>>>>        Else Begin
44573>>>>>>>            If (not(TableAnalysisRead(Self,iTable,&strA))) Begin
44575>>>>>>>                Get _TableAnalysisDefault iTable to strA // Calculate one    
44576>>>>>>>            End
44576>>>>>>>>
44576>>>>>>>            Move True to strA.bInitialized
44577>>>>>>>            Move strA to _gTQaTableAnalysis[iTable]
44578>>>>>>>        End
44578>>>>>>>>
44578>>>>>>>        Function_Return strA
44579>>>>>>>    End_Function
44580>>>>>>>    
44580>>>>>>>    //> Information about configuration of indices for a table. A caching mechanism makes sure that
44580>>>>>>>    //> this configuration is not read on subsequent calls to the function.
44580>>>>>>>    Function TableMeta Integer iTable Returns tTQTableMeta
44582>>>>>>>        tTQTableMeta strM
44582>>>>>>>        tTQTableMeta strM
44582>>>>>>>        Move 0 to strM._iIsInitialized
44583>>>>>>>                                                
44583>>>>>>>        If (SizeOfArray(_gTQaTableMeta)>iTable and _gTQaTableMeta[iTable]._iIsInitialized<>0) Begin
44585>>>>>>>            Move _gTQaTableMeta[iTable] to strM
44586>>>>>>>        End
44586>>>>>>>>
44586>>>>>>>        Else Begin
44587>>>>>>>            Get IndexSet of oIndexFunctions iTable 3 to strM.aIndices // 3 means all on-line indices
44588>>>>>>>            Move 1 to strM._iIsInitialized
44589>>>>>>>            Move strM to _gTQaTableMeta[iTable]
44590>>>>>>>        End
44590>>>>>>>>
44590>>>>>>>        
44590>>>>>>>        Function_Return strM
44591>>>>>>>    End_Function
44592>>>>>>>    
44592>>>>>>>    Function TableIndices Integer iTable Returns Integer[]
44594>>>>>>>        tTQTableMeta strM
44594>>>>>>>        tTQTableMeta strM
44594>>>>>>>        Get TableMeta iTable to strM
44595>>>>>>>        Function_Return strM.aIndices
44596>>>>>>>    End_Function
44597>>>>>>>
44597>>>>>>>    //> This majesticly named procedure clears all cached values and closes
44597>>>>>>>    //> any log tables that might have been opened.
44597>>>>>>>    Procedure ClearTableQueryMetaDataGlobalArraysAndCloseLogFiles
44599>>>>>>>        Integer iItem iMax iLogTable
44599>>>>>>>        Move (SizeOfArray(_gaTQLogTables)-1) to iMax
44600>>>>>>>        For iItem from 0 to iMax
44606>>>>>>>>
44606>>>>>>>            Move _gaTQLogTables[iItem] to iLogTable
44607>>>>>>>            If (iLogTable>0) Begin
44609>>>>>>>                Send CloseTable of oTableAccessFunctions iLogTable
44610>>>>>>>            End
44610>>>>>>>>
44610>>>>>>>        Loop
44611>>>>>>>>
44611>>>>>>>        Move (ResizeArray(_gTQaTableMeta,0)) to _gTQaTableMeta
44612>>>>>>>        Move (ResizeArray(_gTQaTableAnalysis,0)) to _gTQaTableAnalysis
44613>>>>>>>        Move (ResizeArray(_gaTQLogTables,0)) to _gaTQLogTables
44614>>>>>>>    End_Procedure
44615>>>>>>>
44615>>>>>>>End_Class // cTableQueryFunctions
44616>>>>>>>
44616>>>>>>>
44616>>>>>>>Global_Variable Integer oTQ // Holder of the global singleton object.
44616>>>>>>>
44616>>>>>>>Object _oTQ is a cTableQueryFunctions
44618>>>>>>>    Move Self to oTQ
44619>>>>>>>    // Is called by VDFXray when new WS is selected (TableQuery.pkg is used by VDFXray)
44619>>>>>>>    Procedure OnNewFilelistSelected
44622>>>>>>>        Send ClearTableQueryMetaDataGlobalArraysAndCloseLogFiles  
44623>>>>>>>    End_Procedure
44624>>>>>>>End_Object
44625>>>>>>>
44625>>>>>>>
44625>>>>>>>Class cTableQueryAnalyzer is a cObject
44626>>>>>>>        Function _BreakLevel String[] aNewValues String[] aOldValues Returns Integer
44628>>>>>>>            Integer iMax iItem
44628>>>>>>>            Move (SizeOfArray(aNewValues)-1) to iMax
44629>>>>>>>            For iItem from 0 to iMax
44635>>>>>>>>
44635>>>>>>>                If (aNewValues[iItem]<>aOldValues[iItem]) Begin
44637>>>>>>>                    Function_Return iItem
44638>>>>>>>                End
44638>>>>>>>>
44638>>>>>>>            Loop
44639>>>>>>>>
44639>>>>>>>            Function_Return -1 // no break
44640>>>>>>>        End_Function
44641>>>>>>>
44641>>>>>>>        Procedure _IncrementBreakCounter Integer[] ByRef aBreakCounters Integer iLevel
44643>>>>>>>            Integer iMax iItem
44643>>>>>>>            If (iLevel>=0) Begin
44645>>>>>>>                Move (SizeOfArray(aBreakCounters)-1) to iMax
44646>>>>>>>                For iItem from 0 to iMax
44652>>>>>>>>
44652>>>>>>>                    If (iItem>=iLevel) Begin
44654>>>>>>>                        Move (aBreakCounters[iItem]+1) to aBreakCounters[iItem]
44655>>>>>>>                    End
44655>>>>>>>>
44655>>>>>>>                Loop
44656>>>>>>>>
44656>>>>>>>            End
44656>>>>>>>>
44656>>>>>>>        End_Procedure
44657>>>>>>>
44657>>>>>>>        Procedure _AnalyseTableIndexAux _tTQIndexAnalysis ByRef strIndexA Integer iTable Integer iIndex Integer[] aBreakCounters
44659>>>>>>>            Integer iMax iItem
44659>>>>>>>            Number nFactor
44659>>>>>>>            Move (ResizeArray(strIndexA.aSegmentReductions,0)) to strIndexA.aSegmentReductions
44660>>>>>>>            Move (SizeOfArray(aBreakCounters)-1) to iMax
44661>>>>>>>            For iItem from 0 to iMax
44667>>>>>>>>
44667>>>>>>>                If (iItem=0) Begin
44669>>>>>>>                    Move (1.0/aBreakCounters[iItem]) to nFactor
44670>>>>>>>                End
44670>>>>>>>>
44670>>>>>>>                Else Begin // 211 644 2200 11331 => 1/211, 211/644, 644/2200, 2200/11331
44671>>>>>>>                    Move (Number(aBreakCounters[iItem-1])/aBreakCounters[iItem]) to nFactor
44672>>>>>>>                End
44672>>>>>>>>
44672>>>>>>>                Move nFactor to strIndexA.aSegmentReductions[iItem]
44673>>>>>>>            Loop
44674>>>>>>>>
44674>>>>>>>        End_Procedure
44675>>>>>>>    
44675>>>>>>>    Procedure _AnalyseTableIndex _tTQIndexAnalysis ByRef strIndexA Integer iTable Integer iIndex
44677>>>>>>>        Integer iCount iLevel iMax
44677>>>>>>>        String[] aNewValues aOldValues
44679>>>>>>>        Integer[] aBreakCounters
44680>>>>>>>        tocIndex strIndex
44680>>>>>>>        tocIndex strIndex
44680>>>>>>>        _tTQIndexAnalysis strEmpty
44680>>>>>>>        _tTQIndexAnalysis strEmpty
44680>>>>>>>        tTableQuery strQ
44680>>>>>>>        tTableQuery strQ
44680>>>>>>>        
44680>>>>>>>        Get IndexDefinition of oOverlapColumnFunctions iTable iIndex to strIndex
44681>>>>>>>        
44681>>>>>>>        Move 0 to iCount
44682>>>>>>>        Get_Attribute DF_FILE_RECORDS_USED of iTable to iMax
44685>>>>>>>
44685>>>>>>>        Get NewQuery of oTQ iTable to strQ
44686>>>>>>>        Send SetOrderByToIndex of oTQ (&strQ) iIndex
44687>>>>>>>        
44687>>>>>>>        While (FindRecord(oTQ,&strQ))
44691>>>>>>>            Increment iCount
44692>>>>>>>            
44692>>>>>>>            Get IndexSegmentValueArray of oIndexFunctions iTable iIndex to aNewValues
44693>>>>>>>            If (iCount=1) Begin
44695>>>>>>>                Move (ResizeArray(aBreakCounters,SizeOfArray(aNewValues))) to aBreakCounters
44696>>>>>>>                Move aNewValues to aOldValues // No break on the first one
44697>>>>>>>            End
44697>>>>>>>>
44697>>>>>>>
44697>>>>>>>            If (((iCount/5000)*5000)=iCount) Begin
44699>>>>>>>                Send OnAnalyseIndexProgress iTable iCount iMax
44700>>>>>>>            End
44700>>>>>>>>
44700>>>>>>>
44700>>>>>>>            Get _BreakLevel aNewValues aOldValues to iLevel
44701>>>>>>>            If (iLevel>=0) Begin
44703>>>>>>>                Send _IncrementBreakCounter (&aBreakCounters) iLevel
44704>>>>>>>            End
44704>>>>>>>>
44704>>>>>>>
44704>>>>>>>            Move aNewValues to aOldValues
44705>>>>>>>        Loop
44706>>>>>>>>
44706>>>>>>>
44706>>>>>>>        Send OnAnalyseIndexProgress iTable iCount iCount
44707>>>>>>>
44707>>>>>>>        If (iCount<>0) Begin
44709>>>>>>>            Send _IncrementBreakCounter (&aBreakCounters) 0
44710>>>>>>>        End
44710>>>>>>>>
44710>>>>>>>
44710>>>>>>>        Move strEmpty to strIndexA
44711>>>>>>>        Send _AnalyseTableIndexAux (&strIndexA) iTable iIndex aBreakCounters
44712>>>>>>>    End_Procedure
44713>>>>>>>
44713>>>>>>>    Procedure OnAnalyseTableIndex Integer iTable Integer iIndex Integer iIndexIndex Integer IndexCount
44715>>>>>>>    End_Procedure
44716>>>>>>>
44716>>>>>>>    Procedure OnAnalyseTable Integer iTable Integer iIndexCount
44718>>>>>>>    End_Procedure
44719>>>>>>>
44719>>>>>>>    Procedure OnAnalyseIndexProgress Integer iTable Integer iCount Integer iMax
44721>>>>>>>    End_Procedure
44722>>>>>>>
44722>>>>>>>    Procedure AnalyzeTable tTQTableAnalysis ByRef strTableA Integer iTable
44724>>>>>>>        Integer iItem iMax iIndex
44724>>>>>>>        Integer[] aIndices
44725>>>>>>>        Number nElapsed nRecords
44725>>>>>>>        tSystemTimeMS strStart strStop
44725>>>>>>>        tSystemTimeMS strStart strStop
44725>>>>>>>        tTQTableAnalysis strEmptyTable
44725>>>>>>>        tTQTableAnalysis strEmptyTable
44725>>>>>>>        _tTQIndexAnalysis strIndexA
44725>>>>>>>        _tTQIndexAnalysis strIndexA
44725>>>>>>>        Move strEmptyTable to strTableA
44726>>>>>>>        Get_Attribute DF_FILE_RECORDS_USED of iTable to nRecords
44729>>>>>>>
44729>>>>>>>        If (nRecords>100) Begin
44731>>>>>>>            Get SystemTimeMilliSeconds of oDateFunctions to strStart
44732>>>>>>>
44732>>>>>>>            Get_Attribute DF_FILE_RECORDS_USED of iTable to strTableA.nNumberOfRecords
44735>>>>>>>            Get IndexSet of oIndexFunctions iTable 3 to aIndices // All on-line indices
44736>>>>>>>            Move (SizeOfArray(aIndices)-1) to iMax
44737>>>>>>>
44737>>>>>>>            Send OnAnalyseTable iTable (iMax+1)
44738>>>>>>>
44738>>>>>>>            For iItem from 0 to iMax
44744>>>>>>>>
44744>>>>>>>                Move aIndices[iItem] to iIndex
44745>>>>>>>                Send OnAnalyseTableIndex iTable iIndex iItem (iMax+1)
44746>>>>>>>                Send _AnalyseTableIndex (&strIndexA) iTable iIndex
44747>>>>>>>                Move strIndexA to strTableA.aIndices[iIndex]
44748>>>>>>>            Loop
44749>>>>>>>>
44749>>>>>>>            Send OnAnalyseTableIndex iTable iIndex (iMax+1) (iMax+1)
44750>>>>>>>            Get SystemTimeMilliSeconds of oDateFunctions to strStop
44751>>>>>>>            Get SystemTimeMilliSecondsElapsed of oDateFunctions strStart strStop to nElapsed
44752>>>>>>>            Get MilliSecondsToTimeString of oDateFunctions nElapsed to strTableA.sTimeToComplete
44753>>>>>>>
44753>>>>>>>            Get SystemDateTime of oDateFunctions to strTableA.dtAnalysisDateTime
44754>>>>>>>        End
44754>>>>>>>>
44754>>>>>>>    End_Procedure
44755>>>>>>>
44755>>>>>>>    Procedure DeleteAnalysis Integer[] aTables
44757>>>>>>>        Integer iItem iMax iFailure
44757>>>>>>>        String sFile
44757>>>>>>>        Move (SizeOfArray(aTables)-1) to iMax
44758>>>>>>>        For iItem from 0 to iMax
44764>>>>>>>>
44764>>>>>>>            Get _TableAnalysisFileName of oTQ aTables[iItem] to sFile
44765>>>>>>>            If (FileExists(oFileFunctions,sFile)=1) Begin
44767>>>>>>>                Get DeleteFileNew of oFileFunctions sFile True to iFailure
44768>>>>>>>            End
44768>>>>>>>>
44768>>>>>>>        Loop
44769>>>>>>>>
44769>>>>>>>    End_Procedure
44770>>>>>>>
44770>>>>>>>End_Class
44771>>>>>>>
44771>>>>>>>Class cTableQueryTester is a cObject
44772>>>>>>>    // Based on a tTableQuery value strQ, TestSuite will return
44772>>>>>>>    // an array of all queries that should return the same resultset.
44772>>>>>>>    Function TestSuite tTableQuery strQ Returns tTableQuery[]
44774>>>>>>>        Integer iForcePrefetch iItem iMax
44774>>>>>>>        tTableQuery[] aQueries
44774>>>>>>>        tTableQuery[] aQueries
44775>>>>>>>        Integer[] aIndices
44776>>>>>>>        Send ReUse of oTQ (&strQ)
44777>>>>>>>        Move False to strQ._strControlBlock.bCompiled
44778>>>>>>>        Get TableIndices of oTQ strQ.iTable to aIndices
44779>>>>>>>        Move (SizeOfArray(aIndices)-1) to iMax
44780>>>>>>>        For iForcePrefetch from 0 to 1
44786>>>>>>>>
44786>>>>>>>            Move (iForcePrefetch=1) to strQ.bForcePrefetch
44787>>>>>>>            For iItem from 0 to iMax
44793>>>>>>>>
44793>>>>>>>                Send ForceIndex of oTQ (&strQ) aIndices[iItem]
44794>>>>>>>                Move strQ to aQueries[SizeOfArray(aQueries)]
44795>>>>>>>            Loop
44796>>>>>>>>
44796>>>>>>>        Loop
44797>>>>>>>>
44797>>>>>>>        Function_Return aQueries
44798>>>>>>>    End_Function
44799>>>>>>>
44799>>>>>>>        Function CompareRowID RowID ri1 RowID ri2 Returns Integer
44801>>>>>>>            If (IsSameRowID(ri1,ri2)) Function_Return (EQ)
44804>>>>>>>            Function_Return (GT)
44805>>>>>>>        End_Function
44806>>>>>>>
44806>>>>>>>        Function ResultSetsIdentical RowID[] aResult1 RowID[] aResult2 Returns Boolean
44808>>>>>>>            Integer iMax iItem iItem2
44808>>>>>>>            Move (SizeOfArray(aResult1)-1) to iMax
44809>>>>>>>            If (iMax=(SizeOfArray(aResult2)-1)) Begin
44811>>>>>>>                For iItem from 0 to iMax
44817>>>>>>>>
44817>>>>>>>                    Move (SearchArray(aResult1[iItem],aResult2,Self,GET_CompareRowID)) to iItem2
44818>>>>>>>                    If (iItem2=-1) Begin
44820>>>>>>>                        Function_Return False
44821>>>>>>>                    End
44821>>>>>>>>
44821>>>>>>>                Loop
44822>>>>>>>>
44822>>>>>>>                Function_Return True
44823>>>>>>>            End
44823>>>>>>>>
44823>>>>>>>            Function_Return False
44824>>>>>>>        End_Function
44825>>>>>>>
44825>>>>>>>        Procedure OnNotIdentical tTableQuery strQ1 tTableQuery strQ2
44827>>>>>>>        End_Procedure
44828>>>>>>>
44828>>>>>>>    Function RunSuite tTableQuery[] ByRef aQueries Returns RowID[][]
44830>>>>>>>        Integer iItem iMax
44830>>>>>>>        Boolean bIdentical
44830>>>>>>>        RowID[] aResult
44831>>>>>>>        RowID[][] aMatrix // An array of result-arrays
44832>>>>>>>        Move (SizeOfArray(aQueries)-1) to iMax
44833>>>>>>>        For iItem from 0 to iMax
44839>>>>>>>>
44839>>>>>>>            Get QueryToRowIdArray of oTQ (&aQueries[iItem]) to aResult
44840>>>>>>>            Move aResult to aMatrix[iItem]
44841>>>>>>>        Loop
44842>>>>>>>>
44842>>>>>>>        Function_Return aMatrix
44843>>>>>>>    End_Function
44844>>>>>>>End_Class // cTableQueryTester
44845>>>>>>>//
44845>>>>>>>//
44845>>>>>>>//
44845>>>>>>>//
44845>>>>>>>//Struct tTQTestBedInput
44845>>>>>>>//    tTableQuery      strPQ
44845>>>>>>>//    tTableQuery      strCQ
44845>>>>>>>//    tTQTableRelation strRel
44845>>>>>>>//    String sName // Is used as part of a file name
44845>>>>>>>//    Boolean bNoESQL
44845>>>>>>>//    Boolean bRubQueries
44845>>>>>>>//End_Struct
44845>>>>>>>//
44845>>>>>>>//Struct tTQTestBedRowID
44845>>>>>>>//    String sRowID
44845>>>>>>>//    String[] aColumnSourceValues
44845>>>>>>>//    tTQTestBedRowID[] aChildRowIDs
44845>>>>>>>//End_Struct
44845>>>>>>>//
44845>>>>>>>//Struct tTQTestBedOutput
44845>>>>>>>//    tTQTestBedInput strInput
44845>>>>>>>//    tTQTestBedRowID[] aResultRowIDs
44845>>>>>>>//    Number nExecMs
44845>>>>>>>//End_Struct
44845>>>>>>>//
44845>>>>>>>//Class cTableQueryTestBed is a cObject
44845>>>>>>>//    Function RunTest tTQTestBedInput strIn Returns tTQTestBedOutput
44845>>>>>>>//        Integer iChildResultIndex iParentResultIndex iParentMaxColumn iChildMaxColumn iItem
44845>>>>>>>//        tTQTestBedOutput strOut
44845>>>>>>>//        _tTQValueSource strValueSource
44845>>>>>>>//
44845>>>>>>>//        Move strIn.bNoESQL to strIn.strPQ.bNoESQL
44845>>>>>>>//
44845>>>>>>>//        Move strIn to strOut.strInput
44845>>>>>>>//        Move 0 to iParentResultIndex
44845>>>>>>>//
44845>>>>>>>//        Move (SizeOfArray(strIn.strPQ.aColumnSources)-1) to iParentMaxColumn
44845>>>>>>>//        Move (SizeOfArray(strIn.strCQ.aColumnSources)-1) to iChildMaxColumn
44845>>>>>>>//
44845>>>>>>>//        While (FindRecord(oTQ,&strIn.strPQ))
44845>>>>>>>//            Move (SerializeRowID(FileRowId(strIn.strPQ.iTable))) to strOut.aResultRowIDs[iParentResultIndex].sRowID
44845>>>>>>>//            For iItem from 0 to iParentMaxColumn
44845>>>>>>>//                Move strIn.strPQ.aColumnSources[iItem] to strValueSource
44845>>>>>>>//                Get ResultColumnValue of oTQ (&strIn.strPQ) strValueSource.iTable strValueSource.iColumn to strOut.aResultRowIDs[iParentResultIndex].aColumnSourceValues[iItem]
44845>>>>>>>//            Loop
44845>>>>>>>//
44845>>>>>>>//            Move 0 to iChildResultIndex
44845>>>>>>>//            While (FindRecord(oTQ,&strIn.strCQ))
44845>>>>>>>//                Move (SerializeRowID(FileRowId(strIn.strCQ.iTable))) to strOut.aResultRowIDs[iParentResultIndex].aChildRowIDs[iChildResultIndex].sRowID
44845>>>>>>>//                For iItem from 0 to iChildMaxColumn
44845>>>>>>>//                    Move strIn.strCQ.aColumnSources[iItem] to strValueSource
44845>>>>>>>//                    Get ResultColumnValue of oTQ (&strIn.strCQ) strValueSource.iTable strValueSource.iColumn to strOut.aResultRowIDs[iParentResultIndex].aChildRowIDs[iChildResultIndex].aColumnSourceValues[iItem]
44845>>>>>>>//                Loop
44845>>>>>>>//                Increment iChildResultIndex
44845>>>>>>>//            Loop
44845>>>>>>>//            Increment iParentResultIndex
44845>>>>>>>//        Loop
44845>>>>>>>//
44845>>>>>>>//        Get SystemTimeMilliSecondsElapsed of oDateFunctions strIn.strPQ._strControlBlock.strStartTime strIn.strPQ._strControlBlock.strStopTime to strOut.nExecMs
44845>>>>>>>//
44845>>>>>>>//        Function_Return strOut
44845>>>>>>>//    End_Function
44845>>>>>>>//
44845>>>>>>>//    Procedure AddAutoRelation tTQTestBedInput ByRef strIn
44845>>>>>>>//        Send AddTableRelationAutoFixed of oTQ (&strIn.strCQ) strIn.strCQ.iTable strIn.strPQ.iTable
44845>>>>>>>//    End_Procedure
44845>>>>>>>//End_Class
44845>>>>>>>
44845>>>>>Use XmlBuilder.pkg
Including file: XmlBuilder.pkg    (Z:\VmShare\Projects\WebQuery18-0\StureApsPublicLib\AppSrc\XmlBuilder.pkg)
44845>>>>>>>//> The cXmlBuilder class may be used for adding elements to an XML DOM tree in a way that relieves
44845>>>>>>>//> you of having to deal with a myriad of handle type variables in your code and the house keeping
44845>>>>>>>//> of destroying all the element objects again.
44845>>>>>>>//>
44845>>>>>>>//> As an alternative it may be used to write directly to a sequential file without building
44845>>>>>>>//> a DOM object in memory. It is a question of which method you use for initiating the
44845>>>>>>>//> XML builing:
44845>>>>>>>//>
44845>>>>>>>//>    send XmlToDOM iNode // Add to XML DOM object
44845>>>>>>>//>
44845>>>>>>>//>    send XmlToChannel iChannel // Write to sequential channel
44845>>>>>>>//>
44845>>>>>>>//>    send XmlToWebApp // Send output directly to the WebApp output stream.
44845>>>>>>>//>
44845>>>>>>>//>
44845>>>>>>>//> <tip legend="Writing XHTML code">
44845>>>>>>>//> If used in the sequential file output mode, all output is written by the write method. I use this
44845>>>>>>>//> when I write XTHML directly from within a WebApp application because I can augment just one
44845>>>>>>>//> method and have it write to the WebApp output stream..
44845>>>>>>>//> </tip>
44845>>>>>>>//>
44845>>>>>>>//> This piece of code:
44845>>>>>>>//> <pkgdoc:code>
44845>>>>>>>//> Use FileFunctions.pkg // Define oFileFunctions object
44845>>>>>>>//>
44845>>>>>>>//> Object oTestBuilder is a cXmlBuilder
44845>>>>>>>//>
44845>>>>>>>//>   Procedure DoTest
44845>>>>>>>//>     Integer iChannel
44845>>>>>>>//>     Get DirectOutput of oFileFunctions "test.xml" to iChannel
44845>>>>>>>//>     If (iChannel>=0) begin
44845>>>>>>>//>       // Manually write this line:
44845>>>>>>>//>       Write channel iChannel '<?xml version="1.0" encoding="iso-8859-1"?>'
44845>>>>>>>//>       Send XmlToChannel iChannel //
44845>>>>>>>//>       Send AddOpenElement "response"
44845>>>>>>>//>            Send AddAttribute "xmlns:service" "http://www.sture.dk/2012/service/"
44845>>>>>>>//>       Send AddOpenElement   "function"
44845>>>>>>>//>            Send AddAttribute "name" "login"
44845>>>>>>>//>       Send AddOpenElement     "result"
44845>>>>>>>//>       Send AddOpenElement       "fieldset"
44845>>>>>>>//>       Send AddElement       "legend" "Login"
44845>>>>>>>//>       Send AddElement       "span" "UserName"
44845>>>>>>>//>       Send AddOpenElement         "span"
44845>>>>>>>//>            Send AddElement         "input" ""
44845>>>>>>>//>            Send AddAttribute "type" "text"
44845>>>>>>>//>       Send CloseElement            // "span"
44845>>>>>>>//>       Send AddElement       "span" "Password"
44845>>>>>>>//>       Send AddOpenElement         "span"
44845>>>>>>>//>            Send AddElement         "input" ""
44845>>>>>>>//>            Send AddAttribute  "type" "password"
44845>>>>>>>//>       Send CloseElement            // span
44845>>>>>>>//>       Send CloseElement          // fieldset
44845>>>>>>>//>       Send CloseElement        // result
44845>>>>>>>//>       Send CloseElement      // function
44845>>>>>>>//>       Send CloseElement    // response
44845>>>>>>>//>       Send EndXml
44845>>>>>>>//>       Send CloseOutput of oFileFunctions iChannel
44845>>>>>>>//>     End
44845>>>>>>>//>   End_procedure
44845>>>>>>>//>
44845>>>>>>>//>   Send DoTest
44845>>>>>>>//>
44845>>>>>>>//> End_Object
44845>>>>>>>//> </pkgdoc:code>
44845>>>>>>>//>
44845>>>>>>>//> will write this to a file called test.xml:
44845>>>>>>>//>
44845>>>>>>>//> <pkgdoc:code>
44845>>>>>>>//> <?xml version="1.0" encoding="iso-8859-1"?>
44845>>>>>>>//> <response xmlns:service="http://www.sture.dk/2004/service/">
44845>>>>>>>//>   <function name="login">
44845>>>>>>>//>     <result>
44845>>>>>>>//>       <fieldset>
44845>>>>>>>//>         <legend>Login</legend>
44845>>>>>>>//>         <span>Username</span>
44845>>>>>>>//>         <span><input type="text" /></span>
44845>>>>>>>//>         <span>Password</span>
44845>>>>>>>//>         <span><input type="password" /></span>
44845>>>>>>>//>       </fieldset>>
44845>>>>>>>//>     </result>
44845>>>>>>>//>   </function>
44845>>>>>>>//> </response>
44845>>>>>>>//> </pkgdoc:code>
44845>>>>>>>//>
44845>>>>>>>//> (line feeds and indentation has been added for readability)
44845>>>>>>>//>
44845>>>>>>>//> <pkgdoc:note>
44845>>>>>>>//> This class is not able to handle mixed-content elements except by the use of the
44845>>>>>>>//> pbProtectValueData property.
44845>>>>>>>//> </pkgdoc:note>
44845>>>>>>>//>
44845>>>>>>>//> pkgdoc.end
44845>>>>>>>
44845>>>>>>>
44845>>>>>>>
44845>>>>>>>Use VdfBase.pkg // DAW package. Provides low level support expected of all VDF applications (windows and webapp)
44845>>>>>>>Use FleXML.pkg // DAW interface package for FLEXML.DLL
44845>>>>>>>
44845>>>>>>>Use StackFunctions.pkg // Define oStackFunctions object
44845>>>>>>>Use DateFunctions.pkg // Define oDateFunctions object
44845>>>>>>>
44845>>>>>>>Global_Variable String[] _gaXmlBuildToString // Array for collecting XML as one string
44845>>>>>>>Global_Variable Integer  _giXmlBuildToString
44845>>>>>>>Global_Variable Boolean  _gbXmlBuildToString
44845>>>>>>>Move False to _gbXmlBuildToString // Not in use
44846>>>>>>>
44846>>>>>>>Enum_List // XML modes
44846>>>>>>>    Define XM_DOM // Build DOM
44846>>>>>>>    Define XM_SEQ // Write to sequential channel
44846>>>>>>>    Define XM_WEB // Write to WebApp output stream
44846>>>>>>>    Define XM_STR // Build XML string
44846>>>>>>>    Define XM_DWR // Delete calls to write
44846>>>>>>>End_Enum_List
44846>>>>>>>
44846>>>>>>>Class cXmlBuilder is a cObject
44847>>>>>>>    Procedure Construct_Object
44849>>>>>>>        Forward Send Construct_Object
44851>>>>>>>        Property Integer piOutputMode       //  XM_DOM, XM_SEQ, XM_WEB or XM_STR
44852>>>>>>>
44852>>>>>>>        Property Integer _channel       //
44853>>>>>>>        Property Handle  _CurrentNode   // While building DOM trees this property holds the "current node"
44854>>>>>>>        Property Boolean _ClosedElement // Has AddElement been called after the most recent FlushBuffers?
44855>>>>>>>        Property String  _WriteBuffer   // Used for building the attributes string while writing to sequential file
44856>>>>>>>        Property Boolean _OpenElement   // While writing to sequential files this property indicates that the last element added was an open one
44857>>>>>>>
44857>>>>>>>        Property Handle[] paNodes           // Node stack
44858>>>>>>>        Property String[] paElements        // Element stack
44859>>>>>>>        Property Integer[] paCDATAs         // CDATA? stack
44860>>>>>>>        
44860>>>>>>>        Property Boolean   pbTagSelfClosingEnabled True
44861>>>>>>>        
44861>>>>>>>        //> This property has been introduced because the textarea element in (X)HTML is not allowed to be closed
44861>>>>>>>        //> in this way "<textarea />" when it's empty. Totally not understandable! But it must be written as
44861>>>>>>>        //> "<textarea></textarea>".
44861>>>>>>>        Property Integer pbTextAreaException  False
44862>>>>>>>        //> This property has been introduced because the script element in (X)HTML is not allowed to be closed
44862>>>>>>>        //> in this way "<script />" when it's empty. Must be written as "<script></script>". IE 6 problem
44862>>>>>>>        Property Integer pbScriptException    False
44863>>>>>>>        //> The pbProtectValueData property controls whether <, > and & characters written to the XML as data
44863>>>>>>>        //> is HTML encoded ("&lt;", "&gt;" and "&amp;") or not. Its default value is to do this encoding (true).
44863>>>>>>>        //> The reason for (temporarily) setting it to false when generating XHTML code is making it able to handle
44863>>>>>>>        //> when the data itself represents XHTML code. In this case it is not OK to encode these characters.
44863>>>>>>>        Property Integer pbProtectValueData   True
44864>>>>>>>    
44864>>>>>>>        Property String[] _paAttr
44865>>>>>>>        Property String[] _paAttrValue
44866>>>>>>>    End_Procedure
44867>>>>>>>
44867>>>>>>>    //> If XML is not being added to DOM all output will be sent to this procedure.
44867>>>>>>>    Procedure Write String sValue
44869>>>>>>>        Integer iMode
44869>>>>>>>        String[] aOutput
44870>>>>>>>        Get piOutputMode to iMode
44871>>>>>>>        
44871>>>>>>>        If (iMode=XM_SEQ) Begin
44873>>>>>>>            Write channel (_channel(Self)) sValue
44875>>>>>>>        End
44875>>>>>>>>
44875>>>>>>>        Else If (iMode=XM_WEB) Begin
44878>>>>>>>              Send OutputString to ghInetSession sValue
44879>>>>>>>        End
44879>>>>>>>>
44879>>>>>>>        Else If (iMode=XM_STR) Begin
44882>>>>>>>            Move sValue to _gaXmlBuildToString[_giXmlBuildToString]
44883>>>>>>>            Increment _giXmlBuildToString
44884>>>>>>>        End
44884>>>>>>>>
44884>>>>>>>        Else If (iMode=XM_DWR) Begin
44887>>>>>>>            Delegate Send Write sValue // Somebody outside will handle it
44889>>>>>>>        End
44889>>>>>>>>
44889>>>>>>>    End_Procedure
44890>>>>>>>
44890>>>>>>>    Procedure Stream String sValue // Not for DOM building!
44892>>>>>>>        If (piOutputMode(Self)<>XM_DOM) Begin
44894>>>>>>>            Send FlushBuffer
44895>>>>>>>            Send Write sValue
44896>>>>>>>        End
44896>>>>>>>>
44896>>>>>>>        Else Begin
44897>>>>>>>            Error 312 "XmlBuilder: Illegal invocation of Stream method"
44898>>>>>>>>
44898>>>>>>>        End
44898>>>>>>>>
44898>>>>>>>    End_Procedure
44899>>>>>>>
44899>>>>>>>                Procedure PushNode Handle hValue // Private
44901>>>>>>>                    Handle[] aNodes
44902>>>>>>>                    Get paNodes to aNodes
44903>>>>>>>                    Send HandlePush of oStackFunctions hValue (&aNodes)
44904>>>>>>>                    Set paNodes to aNodes
44905>>>>>>>                End_Procedure
44906>>>>>>>
44906>>>>>>>                Function PopNode Returns Handle // Private
44908>>>>>>>                    Handle hValue
44908>>>>>>>                    Handle[] aNodes
44909>>>>>>>                    Get paNodes to aNodes
44910>>>>>>>                    Get HandlePop of oStackFunctions (&aNodes) to hValue
44911>>>>>>>                    Set paNodes to aNodes
44912>>>>>>>                    Function_Return hValue
44913>>>>>>>                End_Function
44914>>>>>>>
44914>>>>>>>                Procedure PushString String sValue // Private
44916>>>>>>>                    String[] aElements
44917>>>>>>>                    Get paElements to aElements
44918>>>>>>>                    Send StringPush of oStackFunctions sValue (&aElements)
44919>>>>>>>                    Set paElements to aElements
44920>>>>>>>                End_Procedure
44921>>>>>>>                
44921>>>>>>>                Function PopString Returns String // Private
44923>>>>>>>                    String sValue
44923>>>>>>>                    String[] aElements
44924>>>>>>>                    Get paElements to aElements
44925>>>>>>>                    Get StringPop of oStackFunctions (&aElements) to sValue
44926>>>>>>>                    Set paElements to aElements
44927>>>>>>>                    Function_Return sValue
44928>>>>>>>                End_Function
44929>>>>>>>
44929>>>>>>>                Procedure PushInteger Integer iValue // Private
44931>>>>>>>                    Integer[] aCDATAs
44932>>>>>>>                    Get paCDATAs to aCDATAs
44933>>>>>>>                    Send IntegerPush of oStackFunctions iValue (&aCDATAs)
44934>>>>>>>                    Set paCDATAs to aCDATAs
44935>>>>>>>                End_Procedure
44936>>>>>>>
44936>>>>>>>                Function PopInteger Returns Integer // Private
44938>>>>>>>                    Integer iValue
44938>>>>>>>                    Integer[] aCDATAs
44939>>>>>>>                    Get paCDATAs to aCDATAs
44940>>>>>>>                    Get IntegerPop of oStackFunctions (&aCDATAs) to iValue
44941>>>>>>>                    Set paCDATAs to aCDATAs
44942>>>>>>>                    Function_Return iValue
44943>>>>>>>                End_Function
44944>>>>>>>    
44944>>>>>>>                Procedure FlushBuffer // Private
44946>>>>>>>                    Boolean bException
44946>>>>>>>                    Boolean bCDATA
44946>>>>>>>                    String sBuffer sValue sElement
44946>>>>>>>                    If (piOutputMode(Self)=XM_DOM) Begin
44948>>>>>>>                        If (_ClosedElement(Self)) Begin
44950>>>>>>>                            Send destroy of (_CurrentNode(Self))
44951>>>>>>>                            Set _CurrentNode to (PopNode(Self))
44952>>>>>>>                            Set _ClosedElement to False
44953>>>>>>>                        End
44953>>>>>>>>
44953>>>>>>>                    End
44953>>>>>>>>
44953>>>>>>>                    Else Begin
44954>>>>>>>                        Get _WriteBuffer to sBuffer
44955>>>>>>>                        If (sBuffer<>"") Begin // If there's anything in the buffer
44957>>>>>>>                            If (_Openelement(Self)) Begin
44959>>>>>>>                                Send Write (sBuffer+">") // If we're writing an opening tag
44960>>>>>>>                            End
44960>>>>>>>>
44960>>>>>>>                            Else Begin // We're dealing with writing a data element (including a closing tag)
44961>>>>>>>                                Get PopInteger to bCDATA
44962>>>>>>>                                Get PopString to sElement
44963>>>>>>>                                Get PopString to sValue
44964>>>>>>>                                If (sValue="" and pbTagSelfClosingEnabled(Self) and ;                                     ((Lowercase(sElement)<>"textarea" or pbTextAreaException(Self)=0) and ;                                      (Lowercase(sElement)<>"script" or pbScriptException(Self)=0) )) Begin
44966>>>>>>>                                    Send Write (sBuffer+" />") // If no value, we're writing the shorthand open-close tag.
44967>>>>>>>                                End
44967>>>>>>>>
44967>>>>>>>                                Else Begin
44968>>>>>>>                                    If bCDATA Begin
44970>>>>>>>                                        Send Write (sBuffer+"><![CDATA["+sValue+"]]></"+sElement+">")
44971>>>>>>>                                    End
44971>>>>>>>>
44971>>>>>>>                                    Else Begin
44972>>>>>>>                                        If (pbProtectValueData(Self)) Begin
44974>>>>>>>                                            Move (replaces("&",sValue,"&amp;")) to sValue
44975>>>>>>>                                            Move (replaces("<",sValue,"&lt;")) to sValue
44976>>>>>>>                                            Move (replaces(">",sValue,"&gt;")) to sValue
44977>>>>>>>                                        End
44977>>>>>>>>
44977>>>>>>>                                        Send Write (sBuffer+">"+sValue+"</"+sElement+">")
44978>>>>>>>                                    End
44978>>>>>>>>
44978>>>>>>>                                End
44978>>>>>>>>
44978>>>>>>>                            End
44978>>>>>>>>
44978>>>>>>>                            Set _WriteBuffer to ""
44979>>>>>>>                        End
44979>>>>>>>>
44979>>>>>>>
44979>>>>>>>                    End
44979>>>>>>>>
44979>>>>>>>                End_Procedure
44980>>>>>>>                
44980>>>>>>>    //> Send this to initiate the process of adding to XML a DOM node.
44980>>>>>>>    Procedure XmlToDOM Integer iNode
44982>>>>>>>        Integer[] aNodes
44983>>>>>>>        Set piOutputMode to XM_DOM
44984>>>>>>>        Set _CurrentNode to iNode
44985>>>>>>>        Set paNodes to aNodes // Reset paNodes
44986>>>>>>>        Set _ClosedElement to False
44987>>>>>>>    End_Procedure
44988>>>>>>>
44988>>>>>>>    //> Send this to initiate the process of writing XML to a sequential channel.
44988>>>>>>>    Procedure XmlToChannel Integer iChannel
44990>>>>>>>        Set piOutputMode to XM_SEQ
44991>>>>>>>        Set _channel to iChannel
44992>>>>>>>        Set _WriteBuffer to ""
44993>>>>>>>    End_Procedure
44994>>>>>>>
44994>>>>>>>    //> Only use this from within an WebApp.
44994>>>>>>>    Procedure XmlToWebApp
44996>>>>>>>        Set piOutputMode to XM_WEB
44997>>>>>>>        Set _WriteBuffer to ""
44998>>>>>>>    End_Procedure
44999>>>>>>>
44999>>>>>>>  //> If you want the XML to be returned as a string you should use this method to initate the process.
44999>>>>>>>    Procedure XmlToString
45001>>>>>>>        String[] aValues
45002>>>>>>>        If (not(_gbXmlBuildToString)) Begin
45004>>>>>>>            Set piOutputMode to XM_STR
45005>>>>>>>            Set _WriteBuffer to ""
45006>>>>>>>            Move aValues to _gaXmlBuildToString
45007>>>>>>>            Move 0 to _giXmlBuildToString
45008>>>>>>>            Move True to _gbXmlBuildToString
45009>>>>>>>        End
45009>>>>>>>>
45009>>>>>>>        Else Begin
45010>>>>>>>            Error DFERR_PROGRAM "XmlBuilder can only build one string at a time (XmlBuilder.pkg)"
45011>>>>>>>>
45011>>>>>>>        End
45011>>>>>>>>
45011>>>>>>>    End_Procedure
45012>>>>>>>    
45012>>>>>>>    Procedure XmlToDelegatedWrite
45014>>>>>>>        Set piOutputMode to XM_DWR
45015>>>>>>>        Set _WriteBuffer to ""
45016>>>>>>>    End_Procedure
45017>>>>>>>    
45017>>>>>>>        Procedure _AddPreadvisedAttributes
45019>>>>>>>            Integer iIndex iMax
45019>>>>>>>            String[] aAttr aAttrValue
45021>>>>>>>            Get _paAttr to aAttr
45022>>>>>>>            Move (SizeOfArray(aAttr)-1) to iMax
45023>>>>>>>            If (iMax>=0) Begin
45025>>>>>>>                Get _paAttrValue to aAttrValue
45026>>>>>>>                For iIndex from 0 to iMax
45032>>>>>>>>
45032>>>>>>>                   Send AddAttribute aAttr[iIndex] aAttrValue[iIndex]
45033>>>>>>>                Loop
45034>>>>>>>>
45034>>>>>>>                Move (ResizeArray(aAttr,0)) to aAttr
45035>>>>>>>                Set _paAttr to aAttr
45036>>>>>>>                Set _paAttrValue to aAttr
45037>>>>>>>            End
45037>>>>>>>>
45037>>>>>>>        End_Procedure
45038>>>>>>>
45038>>>>>>>    //> Adds an element that contains other elements. The element must ultimately be closed by sending the CloseElement message.
45038>>>>>>>    Procedure AddOpenElement String sElement
45040>>>>>>>        Handle hParent hChild
45040>>>>>>>        if (piOutputMode(self)=XM_DOM) Begin
45042>>>>>>>            Send FlushBuffer
45043>>>>>>>            Get _CurrentNode to hParent
45044>>>>>>>            Get AddElement of hParent sElement "" to hChild
45045>>>>>>>            Send PushNode hParent
45046>>>>>>>            Set _CurrentNode to hChild
45047>>>>>>>        End
45047>>>>>>>>
45047>>>>>>>        Else Begin
45048>>>>>>>            Send FlushBuffer
45049>>>>>>>            Set _WriteBuffer to ("<"+sElement)
45050>>>>>>>            Send PushString sElement
45051>>>>>>>            Set _OpenElement to True
45052>>>>>>>        End
45052>>>>>>>>
45052>>>>>>>        Send _AddPreadvisedAttributes
45053>>>>>>>    End_Procedure
45054>>>>>>>    
45054>>>>>>>    //> Adds a data element (an element with no children)
45054>>>>>>>    Procedure AddElement String sElement String sValue
45056>>>>>>>        Handle hParent hChild
45056>>>>>>>        if (piOutputMode(self)=XM_DOM) Begin
45058>>>>>>>            Send FlushBuffer
45059>>>>>>>            Get _CurrentNode to hParent
45060>>>>>>>            Get AddElement of hParent sElement sValue to hChild
45061>>>>>>>            Send PushNode hParent
45062>>>>>>>            Set _CurrentNode to hChild
45063>>>>>>>            Set _ClosedElement to True
45064>>>>>>>        End
45064>>>>>>>>
45064>>>>>>>        Else Begin
45065>>>>>>>            Send FlushBuffer
45066>>>>>>>            Set _WriteBuffer to ("<"+sElement)
45067>>>>>>>            Send PushString sValue
45068>>>>>>>            Send PushString sElement
45069>>>>>>>            Send PushInteger 0 // not CDATA
45070>>>>>>>            Set _OpenElement to False
45071>>>>>>>        End
45071>>>>>>>>
45071>>>>>>>        Send _AddPreadvisedAttributes
45072>>>>>>>    End_Procedure
45073>>>>>>>
45073>>>>>>>    //> Same as AddElement but marks up the data in sValue as CDATA
45073>>>>>>>    Procedure AddCDATAElement String sElement String sValue
45075>>>>>>>        Handle hParent hChild
45075>>>>>>>        if (piOutputMode(self)=XM_DOM) Begin
45077>>>>>>>            Send FlushBuffer
45078>>>>>>>            Get _CurrentNode to hParent
45079>>>>>>>            Get AddElement of hParent sElement "" to hChild
45080>>>>>>>            Send AddCDataSection of hChild sValue
45081>>>>>>>            Send PushNode hParent
45082>>>>>>>            Set _CurrentNode to hChild
45083>>>>>>>            Set _ClosedElement to True
45084>>>>>>>        End
45084>>>>>>>>
45084>>>>>>>        Else Begin
45085>>>>>>>            Send FlushBuffer
45086>>>>>>>            Set _WriteBuffer to ("<"+sElement)
45087>>>>>>>            Send PushString sValue
45088>>>>>>>            Send PushString sElement
45089>>>>>>>            Send PushInteger 1 // CDATA
45090>>>>>>>            Set _OpenElement to False
45091>>>>>>>        End
45091>>>>>>>>
45091>>>>>>>    End_Procedure
45092>>>>>>>
45092>>>>>>>    //> Same as AddElement but formats the number with "." as decimal separator
45092>>>>>>>    Procedure AddNumberElement String sElement Number nValue
45094>>>>>>>        Send AddElement sElement (replace(",",String(nValue),"."))
45095>>>>>>>    End_Procedure
45096>>>>>>>
45096>>>>>>>    //> Same as AddElement but formats the date according to ISO 8601 (YYYY-MM-DD)
45096>>>>>>>    Procedure AddDateElement String sElement Date dValue                                                      
45098>>>>>>>        Send AddElement sElement (DateToString(oDateFunctions,dValue,DF_DATE_MILITARY,True,"-")) // International Standard ISO 8601
45099>>>>>>>    End_Procedure
45100>>>>>>>
45100>>>>>>>    //> Close an element previously added by the AddOpenElement method
45100>>>>>>>    Procedure CloseElement
45102>>>>>>>        String sElement
45102>>>>>>>        if (piOutputMode(self)=XM_DOM) Begin
45104>>>>>>>            Send FlushBuffer
45105>>>>>>>            Send destroy of (_CurrentNode(Self))
45106>>>>>>>            Set _CurrentNode to (PopNode(Self))
45107>>>>>>>        End
45107>>>>>>>>
45107>>>>>>>        Else Begin
45108>>>>>>>            Send FlushBuffer
45109>>>>>>>            Get PopString to sElement
45110>>>>>>>            Send Write ("</"+sElement+">")
45111>>>>>>>        End
45111>>>>>>>>
45111>>>>>>>    End_Procedure
45112>>>>>>>
45112>>>>>>>    //> Add an attribute to the element that was most recently added (whether it is an open or a closed element)
45112>>>>>>>    Procedure AddAttribute String sAttr String sValue
45114>>>>>>>        String sBuffer
45114>>>>>>>        If (piOutputMode(Self)=XM_DOM) Begin
45116>>>>>>>            Send AddAttribute of (_CurrentNode(Self)) sAttr sValue
45117>>>>>>>        End
45117>>>>>>>>
45117>>>>>>>        Else Begin
45118>>>>>>>            Get _WriteBuffer to sBuffer
45119>>>>>>>            Move (sBuffer+" ") to sBuffer
45120>>>>>>>            Move (sBuffer+sAttr) to sBuffer
45121>>>>>>>            Move (sBuffer+"=") to sBuffer
45122>>>>>>>            Move (sBuffer+'"') to sBuffer
45123>>>>>>>            Move (sBuffer+sValue) to sBuffer
45124>>>>>>>            Move (sBuffer+'"') to sBuffer
45125>>>>>>>            Set _WriteBuffer to sBuffer
45126>>>>>>>//            Set _WriteBuffer to (sBuffer+' '+sAttr+'="'+sValue+'"')
45126>>>>>>>        End
45126>>>>>>>>
45126>>>>>>>    End_Procedure
45127>>>>>>>
45127>>>>>>>    //> Adding attributes with this message will attach them to the next
45127>>>>>>>    //> element being added.
45127>>>>>>>    Procedure AddAttributeToNextElement String sAttr String sValue
45129>>>>>>>        Integer iIndex
45129>>>>>>>        String[] aAttr aAttrValue
45131>>>>>>>        Get _paAttr to aAttr
45132>>>>>>>        Get _paAttrValue to aAttrValue
45133>>>>>>>        Move (SizeOfArray(aAttr)) to iIndex
45134>>>>>>>        Move sAttr to aAttr[iIndex]
45135>>>>>>>        Move sValue to aAttrValue[iIndex]
45136>>>>>>>        Set _paAttr to aAttr
45137>>>>>>>        Set _paAttrValue to aAttrValue
45138>>>>>>>    End_Procedure
45139>>>>>>>
45139>>>>>>>    //> Send this to conclude the process of building the XML sequence.
45139>>>>>>>    Procedure EndXml
45141>>>>>>>        String[] aEmpty
45142>>>>>>>        Send FlushBuffer
45143>>>>>>>        Set _paAttr to aEmpty
45144>>>>>>>        Set _paAttrValue to aEmpty
45145>>>>>>>        If (piOutputMode(Self)=XM_STR) Begin
45147>>>>>>>            Move False to _gbXmlBuildToString // Means that a new string can be built
45148>>>>>>>        End
45148>>>>>>>>
45148>>>>>>>    End_Procedure
45149>>>>>>>
45149>>>>>>>    //> If the XML building was initiated by the XmlToString message you can use this function to retrieve the value. Calling this
45149>>>>>>>    //> function resets the content of the internal array.
45149>>>>>>>    Function XmlStringValue Returns String
45151>>>>>>>        String sRval
45151>>>>>>>        Integer iItm iMax
45151>>>>>>>        Send FlushBuffer
45152>>>>>>>        Move (SizeOfArray(_gaXmlBuildToString)-1) to iMax
45153>>>>>>>        Move "" to sRval
45154>>>>>>>        For iItm from 0 to iMax
45160>>>>>>>>
45160>>>>>>>            Move (sRval+_gaXmlBuildToString[iItm]) to sRval
45161>>>>>>>        Loop
45162>>>>>>>>
45162>>>>>>>        Move (ResizeArray(_gaXmlBuildToString,0)) to _gaXmlBuildToString // You can only get its value once.
45163>>>>>>>        Function_Return sRval
45164>>>>>>>    End_Function
45165>>>>>>>
45165>>>>>>>    Function XmlStringValueLength Returns Integer
45167>>>>>>>        Integer iLength iIndex iMax
45167>>>>>>>        Move (SizeOfArray(_gaXmlBuildToString)-1) to iMax
45168>>>>>>>        Move 0 to iLength
45169>>>>>>>        For iIndex from 0 to iMax
45175>>>>>>>>
45175>>>>>>>            Move (iLength+Length(_gaXmlBuildToString[iIndex])) to iLength
45176>>>>>>>        Loop
45177>>>>>>>>
45177>>>>>>>        Function_Return iLength
45178>>>>>>>    End_Function
45179>>>>>>>End_Class // cXmlBuilder
45180>>>>>>>
45180>>>>>>>Class cXmlBuilderProxyMixin is a Mixin
45181>>>>>>>    Procedure Define_cXmlBuilderProxyMixin Integer hXmlBuilder
45183>>>>>>>        Property Integer phXMLBuilder
45184>>>>>>>    End_Procedure
45185>>>>>>>
45185>>>>>>>    Procedure Write String sValue
45187>>>>>>>        Send Write of (phXMLBuilder(Self)) sValue
45188>>>>>>>    End_Procedure
45189>>>>>>>
45189>>>>>>>    Procedure Stream String sValue // Only for DOM building
45191>>>>>>>        Send Stream of (phXMLBuilder(Self)) sValue
45192>>>>>>>    End_Procedure
45193>>>>>>>
45193>>>>>>>    Procedure XmlToDOM Integer iNode //> Send this to initiate the process of adding to XML a DOM node.
45195>>>>>>>        Send XmlToDOM of (phXMLBuilder(Self)) iNode
45196>>>>>>>    End_Procedure
45197>>>>>>>
45197>>>>>>>    Procedure XmlToChannel Integer iChannel //> Send this to initiate the process of writing XML to a sequential channel.
45199>>>>>>>        Send XmlToChannel of (phXMLBuilder(Self)) iChannel
45200>>>>>>>    End_Procedure
45201>>>>>>>
45201>>>>>>>    Procedure XmlToWebApp //> Only use this from within an WebApp.
45203>>>>>>>        Send XmlToWebApp of (phXMLBuilder(Self))
45204>>>>>>>    End_Procedure
45205>>>>>>>
45205>>>>>>>    Procedure XmlToString //> If you want the XML to be returned as a string you should use this method to initate the process.
45207>>>>>>>        Send XmlToString of (phXMLBuilder(Self))
45208>>>>>>>    End_Procedure
45209>>>>>>>
45209>>>>>>>    Procedure XmlToDelegatedWrite //> If you want the encapsulating object to handle the Write method.
45211>>>>>>>        Send XmlToDelegatedWrite of (phXMLBuilder(Self))
45212>>>>>>>    End_Procedure
45213>>>>>>>
45213>>>>>>>    Procedure AddOpenElement String sElement //> Adds an element that contains other elements. The element must ultimately be closed by sending the CloseElement message.
45215>>>>>>>        Send AddOpenElement of (phXMLBuilder(Self)) sElement
45216>>>>>>>    End_Procedure
45217>>>>>>>
45217>>>>>>>    Procedure AddElement String sElement String sValue //> Adds a data element (an element with no children)
45219>>>>>>>        Send AddElement of (phXMLBuilder(Self)) sElement sValue
45220>>>>>>>    End_Procedure
45221>>>>>>>
45221>>>>>>>    Procedure AddCDATAElement String sElement String sValue //> Same as AddElement but marks up the data in sValue as CDATA
45223>>>>>>>        Send AddCDATAElement of (phXMLBuilder(Self)) sElement sValue
45224>>>>>>>    End_Procedure
45225>>>>>>>
45225>>>>>>>    Procedure AddNumberElement String sElement Number nValue //> Same as AddElement but formats the number with "." as decimal separator
45227>>>>>>>        Send AddNumberElement of (phXMLBuilder(Self)) sElement nValue
45228>>>>>>>    End_Procedure
45229>>>>>>>
45229>>>>>>>    Procedure AddDateElement String sElement Date dValue //> Same as AddElement but formats the date according to ISO 8601 (YYYY-MM-DD)
45231>>>>>>>        Send AddDateElement of (phXMLBuilder(Self)) sElement dValue
45232>>>>>>>    End_Procedure
45233>>>>>>>
45233>>>>>>>    Procedure CloseElement //> Close an element previously added by the AddOpenElement method
45235>>>>>>>        Send CloseElement of (phXMLBuilder(Self))
45236>>>>>>>    End_Procedure
45237>>>>>>>
45237>>>>>>>    Procedure AddAttribute String sAttr String sValue //> Add an attribute to the element that was most recently added (whether it is an open or a closed element)
45239>>>>>>>        Send AddAttribute of (phXMLBuilder(Self)) sAttr sValue
45240>>>>>>>    End_Procedure
45241>>>>>>>
45241>>>>>>>    Procedure AddAttributeToNextElement String sAttr String sValue //> Adding attributes with this message will attach them to the next element being added.
45243>>>>>>>        Send AddAttributeToNextElement of (phXMLBuilder(Self)) sAttr sValue
45244>>>>>>>    End_Procedure
45245>>>>>>>
45245>>>>>>>    Procedure EndXml //> Send this to conclude the process of building the XML sequence.
45247>>>>>>>        Send EndXml of (phXMLBuilder(Self))
45248>>>>>>>    End_Procedure
45249>>>>>>>
45249>>>>>>>    Function XmlStringValue Returns String //> If the XML building was initiated by the XmlToString message you can use this function to retrieve the value. Calling this function resets the content of the internal array.
45251>>>>>>>        Function_Return (XmlStringValue(phXMLBuilder(Self)))
45252>>>>>>>    End_Function
45253>>>>>>>    
45253>>>>>>>    Function XmlStringValueLength Returns Integer
45255>>>>>>>        Function_Return (XmlStringValueLength(phXMLBuilder(Self)))
45256>>>>>>>    End_Function
45257>>>>>>>End_Class
45258>>>>>
45258>>>>>Use wqSelectionOperators.wo
Including file: wqSelectionOperators.wo    (Z:\VmShare\Projects\WebQuery18-0\AppSrc\wqSelectionOperators.wo)
45258>>>>>>>Use cWebModalDialog
45258>>>>>>>Use cWebPanel.pkg
45258>>>>>>>Use cWebButton.pkg
45258>>>>>>>Use cWebForm.pkg
45258>>>>>>>Use cWebList.pkg
45258>>>>>>>Use cWebColumn.pkg
45258>>>>>>>
45258>>>>>>>Enum_List
45258>>>>>>>    Define C_wqEQ for 0
45258>>>>>>>    Define C_wqLT
45258>>>>>>>    Define C_wqLE
45258>>>>>>>    Define C_wqGR
45258>>>>>>>    Define C_wqGT
45258>>>>>>>    Define C_wqNE
45258>>>>>>>    Define C_wqIN
45258>>>>>>>    Define C_wqCIN
45258>>>>>>>    Define C_wqBT
45258>>>>>>>    Define C_wqCBT
45258>>>>>>>    Define C_wqINL
45258>>>>>>>    Define C_wqEndSelOps
45258>>>>>>>End_Enum_List
45258>>>>>>>
45258>>>>>>>Struct wqSelType
45258>>>>>>>    String  sCode
45258>>>>>>>    String  sDesc
45258>>>>>>>End_Struct  // wqSelType
45258>>>>>>>
45258>>>>>>>Object oWqSelectionTypes is a cObject
45260>>>>>>>    Property wqSelType[] paSelTypes
45262>>>>>>>    
45262>>>>>>>    Procedure LoadTypes
45265>>>>>>>        wqSelType[] aTypes
45265>>>>>>>        wqSelType[] aTypes
45266>>>>>>>        Integer i
45266>>>>>>>        
45266>>>>>>>        For i from 0 to (C_wqEndSelOps - 1)
45272>>>>>>>>
45272>>>>>>>            If (i =  0) Move "="                        to aTypes[i].sCode
45275>>>>>>>            If (i =  1) Move "<"                        to aTypes[i].sCode
45278>>>>>>>            If (i =  2) Move "<="                       to aTypes[i].sCode
45281>>>>>>>            If (i =  3) Move ">="                       to aTypes[i].sCode
45284>>>>>>>            If (i =  4) Move ">"                        to aTypes[i].sCode
45287>>>>>>>            If (i =  5) Move "<>"                       to aTypes[i].sCode
45290>>>>>>>            If (i =  6) Move "IN"                       to aTypes[i].sCode
45293>>>>>>>            If (i =  7) Move "CIN"                      to aTypes[i].sCode
45296>>>>>>>            If (i =  8) Move "x-y"                      to aTypes[i].sCode
45299>>>>>>>            If (i =  9) Move "CBT"                      to aTypes[i].sCode
45302>>>>>>>            If (i = 10) Move "in list"                  to aTypes[i].sCode
45305>>>>>>>            If (i =  0) Move "Equal to"                 to aTypes[i].sDesc
45308>>>>>>>            If (i =  1) Move "Less than"                to aTypes[i].sDesc
45311>>>>>>>            If (i =  2) Move "Less than or equal to"    to aTypes[i].sDesc
45314>>>>>>>            If (i =  3) Move "Greater than or equal to" to aTypes[i].sDesc
45317>>>>>>>            If (i =  4) Move "Greater than"             to aTypes[i].sDesc
45320>>>>>>>            If (i =  5) Move "Not equal to"             to aTypes[i].sDesc
45323>>>>>>>            If (i =  6) Move "String includes"          to aTypes[i].sDesc
45326>>>>>>>            If (i =  7) Move "String does not include"  to aTypes[i].sDesc
45329>>>>>>>            If (i =  8) Move "Between"                  to aTypes[i].sDesc
45332>>>>>>>            If (i =  9) Move "Outside interval"         to aTypes[i].sDesc
45335>>>>>>>            If (i = 10) Move "in list"                  to aTypes[i].sDesc
45338>>>>>>>        Loop
45339>>>>>>>>
45339>>>>>>>        
45339>>>>>>>        Set paSelTypes to aTypes
45340>>>>>>>    End_Procedure  // LoadTypes
45341>>>>>>>    
45341>>>>>>>    Function SelCode Integer i Returns String
45344>>>>>>>        wqSelType[] aTypes
45344>>>>>>>        wqSelType[] aTypes
45345>>>>>>>        
45345>>>>>>>        If (i => C_wqEndSelOps) Function_Return ""
45348>>>>>>>        
45348>>>>>>>        Get paSelTypes to aTypes
45349>>>>>>>        Function_Return aTypes[i].sCode
45350>>>>>>>    End_Function  // SelCode
45351>>>>>>>    
45351>>>>>>>    Function SelDesc Integer i Returns String
45354>>>>>>>        wqSelType[] aTypes
45354>>>>>>>        wqSelType[] aTypes
45355>>>>>>>        
45355>>>>>>>        If (i => C_wqEndSelOps) Function_Return ""
45358>>>>>>>        
45358>>>>>>>        Get paSelTypes to aTypes
45359>>>>>>>        Function_Return aTypes[i].sDesc
45360>>>>>>>    End_Function  // SelDesc
45361>>>>>>>    
45361>>>>>>>    Function SelDescFromType String sType Returns String
45364>>>>>>>        Integer i
45364>>>>>>>        wqSelType[] aTypes
45364>>>>>>>        wqSelType[] aTypes
45365>>>>>>>        
45365>>>>>>>        Get paSelTypes to aTypes
45366>>>>>>>        
45366>>>>>>>        For i from 0 to (SizeOfArray(aTypes) - 1)
45372>>>>>>>>
45372>>>>>>>            If (sType = aTypes[i].sCode) Function_Return aTypes[i].sDesc
45375>>>>>>>        Loop
45376>>>>>>>>
45376>>>>>>>
45376>>>>>>>        Function_Return ""        
45377>>>>>>>    End_Function  // SelDescFromType
45378>>>>>>>
45378>>>>>>>    Send LoadTypes    
45379>>>>>>>End_Object  // oWqSelectionTypes
45380>>>>>>>
45380>>>>>>>Object oWqSelectionOperators is a cWebModalDialog
45382>>>>>>>    Property Integer wpiOperation
45386>>>>>>>    
45386>>>>>>>    Set psCaption           to "Chose selection operator"
45387>>>>>>>    Set piMinWidth          to 240
45388>>>>>>>    Set piMinHeight         to 410
45389>>>>>>>    Set pbResizable         to False
45390>>>>>>>    Set pbServerOnSubmit    to True    // enable the OnSubmit event
45391>>>>>>>    
45391>>>>>>>    Object oSelOpsMain is a cWebPanel
45393>>>>>>>        Set piColumnCount to 1
45394>>>>>>>        
45394>>>>>>>        Object oOpsList is a cWebList
45396>>>>>>>            Set piColumnSpan     to 0
45397>>>>>>>            Set pbFillHeight     to True
45398>>>>>>>            Set pbDataAware      to False
45399>>>>>>>            Set pbColumnSortable to False
45400>>>>>>>            
45400>>>>>>>            Object oOperatorsCol is a cWebColumn
45402>>>>>>>                Set psCaption to "Selection Operators"
45403>>>>>>>            End_Object
45404>>>>>>>            
45404>>>>>>>            Procedure OnManualLoadData tWebRow[] ByRef aTheRows String ByRef sCurrentRowID
45407>>>>>>>                Integer i
45407>>>>>>>                Handle  hoST
45407>>>>>>>                
45407>>>>>>>                Forward Send OnManualLoadData (&aTheRows) (&sCurrentRowID)
45409>>>>>>>                Move (oWqSelectionTypes(Self)) to hoST
45410>>>>>>>                
45410>>>>>>>                For i from 0 to (C_wqEndSelOps - 1)
45416>>>>>>>>
45416>>>>>>>//                    Move i                                                  to aTheRows[i].aValues[0]
45416>>>>>>>//                    Move (SelDesc(hoST, i) * "(" + SelCode(hoST, i) + ")")  to aTheRows[i].aValues[1]
45416>>>>>>>                    Move i                                                  to aTheRows[i].sRowID
45417>>>>>>>                    Move (SelDesc(hoST, i) * "(" + SelCode(hoST, i) + ")")  to aTheRows[i].aCells[0].sValue
45418>>>>>>>                Loop
45419>>>>>>>>
45419>>>>>>>                
45419>>>>>>>            End_Procedure  // OnManualLoadData
45420>>>>>>>            
45420>>>>>>>            Procedure OnLoad
45423>>>>>>>                Send GridRefresh
45424>>>>>>>            End_Procedure  // OnLoad
45425>>>>>>>            
45425>>>>>>>        End_Object  // OpsList
45426>>>>>>>        
45426>>>>>>>    End_Object 
45427>>>>>>>    
45427>>>>>>>    Object oSelOpsBottom is a cWebPanel
45429>>>>>>>        Set piColumnCount to 3
45430>>>>>>>        Set peRegion to prBottom
45431>>>>>>>
45431>>>>>>>        Object oSelOpsOkBtn is a cWebButton
45433>>>>>>>            Set psCaption to C_$OK
45434>>>>>>>            Set piColumnSpan to 1
45435>>>>>>>            Set piColumnIndex to 1
45436>>>>>>>
45436>>>>>>>            Procedure OnClick
45439>>>>>>>                Send Ok
45440>>>>>>>            End_Procedure
45441>>>>>>>        End_Object 
45442>>>>>>>
45442>>>>>>>        Object oSelOpsCancelBtn is a cWebButton
45444>>>>>>>            Set psCaption to C_$Cancel
45445>>>>>>>            Set piColumnSpan to 1
45446>>>>>>>            Set piColumnIndex to 2
45447>>>>>>>
45447>>>>>>>            Procedure OnClick
45450>>>>>>>                Send Cancel
45451>>>>>>>            End_Procedure
45452>>>>>>>            
45452>>>>>>>        End_Object 
45453>>>>>>>        
45453>>>>>>>    End_Object 
45454>>>>>>>
45454>>>>>>>    Procedure OnSubmit
45457>>>>>>>        Send Ok
45458>>>>>>>    End_Procedure
45459>>>>>>>    
45459>>>>>>>    Procedure DoPopup Handle hoObj Integer eOp
45462>>>>>>>        WebSet wpiOperation to eOp
45463>>>>>>>        
45463>>>>>>>        Send Popup hoObj
45464>>>>>>>    End_Procedure  // DoPopup 
45465>>>>>>>    
45465>>>>>>>    Function SelectedOperator Returns Integer
45468>>>>>>>        Integer iOp
45468>>>>>>>        
45468>>>>>>>        WebGet psCurrentRowID of oOpsList to iOp
45469>>>>>>>        Function_Return iOp
45470>>>>>>>    End_Function  // SelectedOperator
45471>>>>>>>    
45471>>>>>>>    Function Operation Returns Integer
45474>>>>>>>        Integer eOp
45474>>>>>>>        
45474>>>>>>>        WebGet wpiOperation to eOp
45475>>>>>>>        Function_Return eOp
45476>>>>>>>    End_Function  // Operation
45477>>>>>>>    
45477>>>>>>>End_Object  // oWqSelectionOperators
45478>>>>>Use cWqExprParser.pkg
Including file: cWqExprParser.pkg    (Z:\VmShare\Projects\WebQuery18-0\AppSrc\cWqExprParser.pkg)
45478>>>>>>>Use cExpressionParser.pkg
45478>>>>>>>
45478>>>>>>>Class cWqExprParser is a cExpressionParser
45479>>>>>>>
45479>>>>>>>    // Overridden _fAnd and _fOr to allow for booleans - Sture will probably fix soon
45479>>>>>>>    Function _fAnd tXPValue[] aParameters Returns tXPValue
45481>>>>>>>        tXPValue strRval strParameter1 strParameter2
45481>>>>>>>        tXPValue strRval strParameter1 strParameter2
45481>>>>>>>        Number nVal1 nVal2
45481>>>>>>>        Move aParameters[0] to strParameter1
45482>>>>>>>        Move aParameters[1] to strParameter2
45483>>>>>>>        If ((strParameter1.iValueType=XP_Integer or strParameter1.iValueType=XP_Numeric) and (strParameter2.iValueType=XP_Integer or strParameter2.iValueType=XP_Numeric)) Begin
45485>>>>>>>            Move XP_Boolean to strRval.iValueType
45486>>>>>>>            Move strParameter1.sValue to nVal1
45487>>>>>>>            Move strParameter2.sValue to nVal2
45488>>>>>>>            Move (nVal1<>0 and nVal2<>0) to strRval.sValue
45489>>>>>>>        End
45489>>>>>>>>
45489>>>>>>>        Else Begin
45490>>>>>>>            Move XP_Error to strRval.iValueType
45491>>>>>>>            Error DFERR_OPERATOR "ExprParser: Illegal parameter passed to 'and'"
45492>>>>>>>>
45492>>>>>>>        End
45492>>>>>>>>
45492>>>>>>>        Function_Return strRval
45493>>>>>>>    End_Function
45494>>>>>>>    
45494>>>>>>>    Function _fOr tXPValue[] aParameters Returns tXPValue
45496>>>>>>>        tXPValue strRval strParameter1 strParameter2
45496>>>>>>>        tXPValue strRval strParameter1 strParameter2
45496>>>>>>>        Number nVal1 nVal2
45496>>>>>>>        Move aParameters[0] to strParameter1
45497>>>>>>>        Move aParameters[1] to strParameter2
45498>>>>>>>        If ((strParameter1.iValueType=XP_Integer or strParameter1.iValueType=XP_Numeric) and (strParameter2.iValueType=XP_Integer or strParameter2.iValueType=XP_Numeric)) Begin
45500>>>>>>>            Move XP_Boolean to strRval.iValueType
45501>>>>>>>            Move strParameter1.sValue to nVal1
45502>>>>>>>            Move strParameter2.sValue to nVal2
45503>>>>>>>            Move (nVal1<>0 or nVal2<>0) to strRval.sValue
45504>>>>>>>        End
45504>>>>>>>>
45504>>>>>>>        Else Begin
45505>>>>>>>            Move XP_Error to strRval.iValueType
45506>>>>>>>            Error DFERR_OPERATOR "ExprParser: Illegal parameter passed to 'or'"
45507>>>>>>>>
45507>>>>>>>        End
45507>>>>>>>>
45507>>>>>>>        Function_Return strRval
45508>>>>>>>    End_Function
45509>>>>>>>    // End overrides
45509>>>>>>>    
45509>>>>>>>    Function _fInteger tXPValue[] aParameters Returns tXPValue
45511>>>>>>>        tXPValue strRval
45511>>>>>>>        tXPValue strRval
45511>>>>>>>        
45511>>>>>>>        Move (Integer(aParameters[0].sValue)) to strRval.sValue
45512>>>>>>>        Move XP_Integer                       to strRval.iValueType
45513>>>>>>>        Function_Return strRval
45514>>>>>>>    End_Function
45515>>>>>>>
45515>>>>>>>    Function _fString tXPValue[] aParameters Returns tXPValue
45517>>>>>>>        tXPValue strRval
45517>>>>>>>        tXPValue strRval
45517>>>>>>>        
45517>>>>>>>        Move (String(aParameters[0].sValue)) to strRval.sValue
45518>>>>>>>        Move XP_String                       to strRval.iValueType
45519>>>>>>>        Function_Return strRval
45520>>>>>>>    End_Function
45521>>>>>>>
45521>>>>>>>    Function _fNumber tXPValue[] aParameters Returns tXPValue
45523>>>>>>>        tXPValue strRval
45523>>>>>>>        tXPValue strRval
45523>>>>>>>        
45523>>>>>>>        Move (Number(aParameters[0].sValue)) to strRval.sValue
45524>>>>>>>        Move XP_Numeric                      to strRval.iValueType
45525>>>>>>>        Function_Return strRval
45526>>>>>>>    End_Function
45527>>>>>>>
45527>>>>>>>    Function _fDate tXPValue[] aParameters Returns tXPValue
45529>>>>>>>        tXPValue strRval
45529>>>>>>>        tXPValue strRval
45529>>>>>>>        
45529>>>>>>>        Move (Date(aParameters[0].sValue)) to strRval.sValue
45530>>>>>>>        Move XP_Date                       to strRval.iValueType
45531>>>>>>>        Function_Return strRval
45532>>>>>>>    End_Function
45533>>>>>>>    
45533>>>>>>>    Function _fConcat tXPValue[] aParameters Returns tXPValue
45535>>>>>>>        tXPValue strRval
45535>>>>>>>        tXPValue strRval
45535>>>>>>>        
45535>>>>>>>        Move (String(aParameters[0].sValue) + String(aParameters[1].sValue)) to strRval.sValue
45536>>>>>>>        Move XP_String to strRval.iValueType
45537>>>>>>>        Function_Return strRval
45538>>>>>>>    End_Function
45539>>>>>>>    
45539>>>>>>>    Function _fAmp tXPValue[] aParameters Returns tXPValue
45541>>>>>>>        tXPValue tRet
45541>>>>>>>        tXPValue tRet
45541>>>>>>>        
45541>>>>>>>        Move (String(aParameters[0].sValue) + String(aParameters[1].sValue)) to tRet.sValue
45542>>>>>>>        Move XP_String to tRet.iValueType
45543>>>>>>>        
45543>>>>>>>        Function_Return tRet
45544>>>>>>>    End_Function
45545>>>>>>>    
45545>>>>>>>    Function _fDateAsTextEU tXPValue[] aParameters Returns tXPValue
45547>>>>>>>        tXPValue tRetVal
45547>>>>>>>        tXPValue tRetVal
45547>>>>>>>        
45547>>>>>>>        Get DateToText of oDateFunctions aParameters[0].sValue "#D #MN #Y4" to tRetVal.sValue
45548>>>>>>>        Move XP_String to tRetVal.iValueType
45549>>>>>>>        Function_Return tRetVal
45550>>>>>>>    End_Function
45551>>>>>>>    
45551>>>>>>>    Function _fDateAsTextUS tXPValue[] aParameters Returns tXPValue
45553>>>>>>>        tXPValue tRetVal
45553>>>>>>>        tXPValue tRetVal
45553>>>>>>>        
45553>>>>>>>        Get DateToText of oDateFunctions aParameters[0].sValue "#MN #D #Y4" to tRetVal.sValue
45554>>>>>>>        Move XP_String to tRetVal.iValueType
45555>>>>>>>        Function_Return tRetVal
45556>>>>>>>    End_Function
45557>>>>>>>    
45557>>>>>>>    Function _fDateFormatText tXPValue[] aParameters Returns tXPValue
45559>>>>>>>        tXPValue tRetVal
45559>>>>>>>        tXPValue tRetVal
45559>>>>>>>        
45559>>>>>>>        Get DateToText of oDateFunctions aParameters[0].sValue aParameters[1].sValue to tRetVal.sValue
45560>>>>>>>        Move XP_String to tRetVal.iValueType
45561>>>>>>>        Function_Return tRetVal
45562>>>>>>>    End_Function
45563>>>>>>>    
45563>>>>>>>    Function _fFirstDayInMonth tXPValue[] aParameters Returns tXPValue
45565>>>>>>>        tXPValue tRetVal
45565>>>>>>>        tXPValue tRetVal
45565>>>>>>>        Date     dDate
45565>>>>>>>        
45565>>>>>>>        Move aParameters[0].sValue        to dDate
45566>>>>>>>        Move (Date(DateSetDay(dDate, 1))) to tRetVal.sValue
45567>>>>>>>        Move XP_Date                      to tRetVal.iValueType
45568>>>>>>>        Function_Return tRetVal
45569>>>>>>>    End_Function
45570>>>>>>>    
45570>>>>>>>    // ToDo: Ensure that all WebQuery functions are defined and working
45570>>>>>>>    
45570>>>>>>>    // Augmented OnDefineFunctions to add in the extras we want.
45570>>>>>>>    // Take them (and any implementations above) out as and when they
45570>>>>>>>    // become available in Sture's cExpressionParser
45570>>>>>>>    Procedure OnDefineFunctions tXPGrammar ByRef strGrammar 
45572>>>>>>>        Forward Send OnDefineFunctions (&strGrammar)
45574>>>>>>>        
45574>>>>>>>        Send DefineFunction (&strGrammar) "DateAsTextEU"      1 XP_Date    (RefFunc(_fDateAsTextEU))
45575>>>>>>>        Send DefineFunction (&strGrammar) "DateAsTextUS"      1 XP_Date    (RefFunc(_fDateAsTextUS))
45576>>>>>>>        Send DefineFunction (&strGrammar) "DateFormatText"  2 XP_Date    (RefFunc(_fDateFormatText))
45577>>>>>>>        Send DefineFunction (&strGrammar) "Integer"         1 XP_Integer (RefFunc(_fInteger))
45578>>>>>>>        Send DefineFunction (&strGrammar) "String"          1 XP_String  (RefFunc(_fString))
45579>>>>>>>        Send DefineFunction (&strGrammar) "Number"          1 XP_Numeric (RefFunc(_fNumber))
45580>>>>>>>        Send DefineFunction (&strGrammar) "Date"            1 XP_Date    (RefFunc(_fDate))
45581>>>>>>>        Send DefineFunction (&strGrammar) "Concat"          2 XP_String  (RefFunc(_fConcat))
45582>>>>>>>//        Send DefineFunction (&strGrammar) "DateIncrement"   3 XP_Date    (RefFunc(_fDateIncrement))
45582>>>>>>>        Send DefineFunction (&strGrammar) "FirstDayInMonth" 1 XP_Date    (RefFunc(_fFirstDayInMonth))
45583>>>>>>>//        Send DefineFunction (&strGrammar) "If_Int"          3 XP_Boolean (RefFunc(_fIf_Int))
45583>>>>>>>//        Send DefineFunction (&strGrammar) "If_Num"          3 XP_Boolean (RefFunc(_fIf_Num))
45583>>>>>>>//        Send DefineFunction (&strGrammar) "If_Str"          3 XP_Boolean (RefFunc(_fIf_Str))
45583>>>>>>>//        Send DefineFunction (&strGrammar) "If_Dat"          3 XP_Boolean (RefFunc(_fIf_Dat))
45583>>>>>>>    End_Procedure
45584>>>>>>>    
45584>>>>>>>    Procedure OnDefineOperators tXPGrammar byref strGrammar
45586>>>>>>>        Forward Send OnDefineOperators (&strGrammar)
45588>>>>>>>        
45588>>>>>>>        Send DefineOperator (&strGrammar) "&" 2 0 0 (RefFunc(_fAmp))
45589>>>>>>>    End_Procedure
45590>>>>>>>
45590>>>>>>>End_Class
45591>>>>>
45591>>>>>Struct wqDir
45591>>>>>    Boolean bDir
45591>>>>>    String  sName
45591>>>>>End_Struct
45591>>>>>
45591>>>>>Struct wqTableInfo
45591>>>>>    Integer iNum
45591>>>>>    String  sDispName
45591>>>>>    String  sDFName
45591>>>>>    String  sRootName
45591>>>>>End_Struct
45591>>>>>
45591>>>>>Global_Variable Handle ghoWebQry
45591>>>>>Global_Variable Handle ghoWQF
45591>>>>>
45591>>>>>Enum_List
45591>>>>>    Define C_wqAppendRow for 0
45591>>>>>    Define C_wqInsertRow
45591>>>>>    Define C_wqDeleteRow
45591>>>>>    Define C_wqAddExpression
45591>>>>>    Define C_wqInsertExpression 
45591>>>>>    Define C_wqEditExpression
45591>>>>>    Define C_wqSelectExpr
45591>>>>>    Define C_wqAssembleSave
45591>>>>>    Define C_wqAssembleRun
45591>>>>>    Define C_wqMoveRowUp
45591>>>>>    Define C_wqMoveRowDown
45591>>>>>    Define C_wqNoOp
45591>>>>>    Define C_wqSaveData
45591>>>>>    Define C_wqGetIndexInfo
45591>>>>>End_Enum_List
45591>>>>>
45591>>>>>Enum_List
45591>>>>>    Define C_wqModalWin for 0
45591>>>>>    Define C_wqNewTab
45591>>>>>    Define C_wqNewWin
45591>>>>>    Define C_wqDownload
45591>>>>>End_Enum_List
45591>>>>>
45591>>>>>Enum_List
45591>>>>>    Define C_wqViewOutput
45591>>>>>    Define C_wqDownloadOutput
45591>>>>>End_Enum_List
45591>>>>>
45591>>>>>Enum_List
45591>>>>>    Define C_wqOutputHtml
45591>>>>>    Define C_wqOutputText
45591>>>>>    Define C_wqOutputCSV
45591>>>>>    Define C_wqOutputXML
45591>>>>>End_Enum_List
45591>>>>>
45591>>>>>Struct wqPrintField
45591>>>>>    Boolean bCalc
45591>>>>>    Integer iTable
45591>>>>>    Integer iColumn
45591>>>>>    String  sUserName
45591>>>>>    Boolean bSum
45591>>>>>    Boolean bCR
45591>>>>>    String  sExpression
45591>>>>>    String  sLongLabel
45591>>>>>    Integer iWidth
45591>>>>>    Integer iType
45591>>>>>    Integer iDecimals
45591>>>>>End_Struct
45591>>>>>
45591>>>>>Struct wqTableDetail
45591>>>>>    Integer  iTabNum
45591>>>>>    String   sName
45591>>>>>    String[] asFieldNames
45591>>>>>End_Struct
45591>>>>>
45591>>>>>Struct wqSelections
45591>>>>>    Integer iTable
45591>>>>>    Integer iColumn
45591>>>>>    String  sUserName
45591>>>>>    String  sType
45591>>>>>    String  sValue
45591>>>>>    Integer iType
45591>>>>>End_Struct
45591>>>>>
45591>>>>>Struct wqSelsForTQ
45591>>>>>    wqSelections Selection
45591>>>>>    wqSelections Selection
45591>>>>>    Boolean  bUseTQ
45591>>>>>    Boolean  bInList
45591>>>>>    String   sStartR
45591>>>>>    String   sEndR
45591>>>>>    String[] aList
45591>>>>>End_Struct
45591>>>>>
45591>>>>>Struct wqIndexSeg
45591>>>>>    Integer iTable
45591>>>>>    Integer iField
45591>>>>>    Boolean bBreak
45591>>>>>    Boolean bUC
45591>>>>>    Boolean bDesc
45591>>>>>    String  sName
45591>>>>>End_Struct
45591>>>>>
45591>>>>>Struct wqWebQuery
45591>>>>>    String  sTitle
45591>>>>>    Handle  hMainTable
45591>>>>>    String  sSelectExpression
45591>>>>>    wqPrintField[] aPrintFields
45591>>>>>    wqPrintField[] aPrintFields
45591>>>>>    wqSelections[] aSelections
45591>>>>>    wqSelections[] aSelections
45591>>>>>    wqIndexSeg[]   aSegments
45591>>>>>    wqIndexSeg[]   aSegments
45591>>>>>    Integer iIndex
45591>>>>>    Integer iSearchOrd
45591>>>>>    String  sTextBefore
45591>>>>>    String  sTextAfter
45591>>>>>    String  sTypeface
45591>>>>>    String  sFontSize
45591>>>>>    String  sTextColour
45591>>>>>    String  sBGColour
45591>>>>>    Boolean bHighlightAlt
45591>>>>>    String  sHighlightColour
45591>>>>>    Boolean bPrintSels
45591>>>>>    Boolean bTotalsOnly
45591>>>>>    Boolean bPrintCount
45591>>>>>    Integer iDestination
45591>>>>>    Integer iOutputFormat
45591>>>>>    Boolean bColHeads
45591>>>>>    Boolean bGeneratedLine
45591>>>>>    Boolean bUseSQL
45591>>>>>End_Struct
45591>>>>>
45591>>>>>Struct wqColour
45591>>>>>    Integer iRed
45591>>>>>    Integer iGreen
45591>>>>>    Integer iBlue
45591>>>>>End_Struct
45591>>>>>
45591>>>>>Struct wqBreakpoint
45591>>>>>    Integer iTable
45591>>>>>    Integer iColumn
45591>>>>>    String  sName
45591>>>>>    String  sPrevValue
45591>>>>>End_Struct
45591>>>>>
45591>>>>>Struct wqPrintColumn
45591>>>>>    String   sName
45591>>>>>    Integer  iTable
45591>>>>>    Integer  iColumn
45591>>>>>    Integer  iType
45591>>>>>    Integer  iWidth
45591>>>>>    Integer  iDecimals
45591>>>>>    Integer  iPrintWidth
45591>>>>>    String   sExpr
45591>>>>>    Boolean  bCR
45591>>>>>    Boolean  bCalc
45591>>>>>    String   sCurVal
45591>>>>>    Boolean  bSum
45591>>>>>    Number[] anSum
45591>>>>>End_Struct
45591>>>>>
45591>>>>>Struct wqPrintRowPart
45591>>>>>    wqPrintColumn[] aColumns
45591>>>>>    wqPrintColumn[] aColumns
45591>>>>>End_Struct
45591>>>>>
45591>>>>>Struct wqPrintRowLayout
45591>>>>>    wqPrintRowPart[] aParts
45591>>>>>    wqPrintRowPart[] aParts
45591>>>>>    Integer iMaxCols
45591>>>>>    Integer iCount
45591>>>>>End_Struct
45591>>>>>
45591>>>>>Struct wqTableField
45591>>>>>    Handle  hTable
45591>>>>>    Integer iField
45591>>>>>End_Struct
45591>>>>>
45591>>>>>Define C_wqValidXmlChars   for "ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890_"
45591>>>>>Define C_wqInvalidDirChars for '/\?%*:|"<>'
45591>>>>>Define C_wqPublicDir       for "\Public"
45591>>>>>
45591>>>>>Register_Function phLoggedInFunc   Returns Boolean
45591>>>>>Register_Function phUserNameFunc   Returns String
45591>>>>>Register_Function pbAllowRawOutput Returns Boolean
45591>>>>>
45591>>>>>Object oWqExprPar is a cWqExprParser
45593>>>>>End_Object
45594>>>>>
45594>>>>>Object oWqXml is a cXmlBuilder
45596>>>>>End_Object
45597>>>>>
45597>>>>>Class cWebQueryFunctions is a cObject
45598>>>>>    
45598>>>>>    Procedure Construct_Object
45600>>>>>        Forward Send Construct_Object
45602>>>>>        
45602>>>>>        Property Handle[]       pahExcludedTables
45603>>>>>        Property wqTableField[] patExcludedFields
45604>>>>>        Property Integer        piChannel
45605>>>>>    End_Procedure
45606>>>>>    
45606>>>>>    Function StrAddQuotes String sVal Returns String
45608>>>>>        Function_Return ('"' + Trim(sVal) + '"')
45609>>>>>    End_Function
45610>>>>>    
45610>>>>>    Function StrDelQuotes String sVal Returns String
45612>>>>>        If (Left(sVal, 1) = '"')  Move (Right(sVal, (Length(sVal) - 1)))    to sVal
45615>>>>>        If (Right(sVal, 1) = '"') Move  (Left(sVal,  (Length(sVal) - 1)))   to sVal
45618>>>>>        Function_Return sVal
45619>>>>>    End_Function
45620>>>>>    
45620>>>>>    Function XmlTag String sName Returns String
45622>>>>>        Integer i iLen
45622>>>>>        
45622>>>>>        Move (Trim(sName))   to sName
45623>>>>>        Move (Length(sName)) to iLen
45624>>>>>        
45624>>>>>        For i from 1 to iLen
45630>>>>>>
45630>>>>>            If not (C_wqValidXmlChars contains Uppercase(Mid(sName, 1, i))) Move (Overstrike("_", sName, i)) to sName 
45633>>>>>        Loop
45634>>>>>>
45634>>>>>        
45634>>>>>        Function_Return sName
45635>>>>>    End_Function
45636>>>>>    
45636>>>>>    Function UpperChar String sData Integer iChar Returns String
45638>>>>>        Function_Return (Overstrike(Uppercase(Mid(sData, 1, iChar)), sData, iChar))
45639>>>>>    End_Function
45640>>>>>    
45640>>>>>    Function NiceFieldName Handle hTab Integer iCol Returns String
45642>>>>>        String  sName
45642>>>>>        Integer i
45642>>>>>        
45642>>>>>        Open hTab
45644>>>>>        Get_Attribute DF_FIELD_NAME of hTab iCol    to sName
45647>>>>>        Move (Replaces("_", sName, " "))            to sName
45648>>>>>        Move (Lowercase(sName))                     to sName
45649>>>>>        
45649>>>>>        For i from 1 to (Length(sName))
45655>>>>>>
45655>>>>>            If ((i = 1) or (Mid(sName, 1, (i - 1)) = " ")) Move (UpperChar(Self, sName, i)) to sName
45658>>>>>        Loop
45659>>>>>>
45659>>>>>        
45659>>>>>        Function_Return sName        
45660>>>>>    End_Function
45661>>>>>    
45661>>>>>    Function TableLoaded tWebRow[] ByRef aRows Handle hTab Returns Boolean
45663>>>>>        Integer i
45663>>>>>        
45663>>>>>        For i from 0 to (SizeOfArray(aRows) - 1)
45669>>>>>>
45669>>>>>//            If (aRows[i].aValues[0] = hTab) Function_Return True
45669>>>>>            If (aRows[i].sRowID = hTab) Function_Return True
45672>>>>>        Loop
45673>>>>>>
45673>>>>>        
45673>>>>>        Function_Return False
45674>>>>>    End_Function
45675>>>>>    
45675>>>>>    Function TableMissing Handle hTab Returns Boolean
45677>>>>>        Handle hNext
45677>>>>>        
45677>>>>>        Get_Attribute DF_FILE_NEXT_EMPTY of (hTab - 1) to hNext
45680>>>>>        Function_Return (hNext = hTab)
45681>>>>>    End_Function
45682>>>>>    
45682>>>>>    Function ExcludedTable Handle hTable Returns Boolean
45684>>>>>        Handle[] ahExcluded
45685>>>>>        Integer  i
45685>>>>>        
45685>>>>>        Get pahExcludedTables to ahExcluded
45686>>>>>        
45686>>>>>        For i from 0 to (SizeOfArray(ahExcluded) - 1)
45692>>>>>>
45692>>>>>            If (hTable = ahExcluded[i]) Function_Return True
45695>>>>>        Loop
45696>>>>>>
45696>>>>>        
45696>>>>>        Function_Return False
45697>>>>>    End_Function
45698>>>>>    
45698>>>>>    Function ExcludedField Handle hTable Integer iField Returns Boolean
45700>>>>>        wqTableField[] atExcluded
45700>>>>>        wqTableField[] atExcluded
45701>>>>>        Integer i
45701>>>>>        
45701>>>>>        Get patExcludedFields to atExcluded
45702>>>>>        
45702>>>>>        For i from 0 to (SizeOfArray(atExcluded) - 1)
45708>>>>>>
45708>>>>>            If ((hTable = atExcluded[i].hTable) and ;                (iField = atExcluded[i].iField)) Function_Return True
45711>>>>>        Loop
45712>>>>>>
45712>>>>>        
45712>>>>>        Function_Return False
45713>>>>>    End_Function
45714>>>>>    
45714>>>>>    Procedure RelatedFiles tWebRow[] ByRef aRows Handle hTab
45716>>>>>        Integer iFlds iFld iNext
45716>>>>>        Handle  hRel
45716>>>>>        
45716>>>>>        If (hTab = 0)                 Procedure_Return
45719>>>>>        If (TableMissing(Self, hTab)) Procedure_Return
45722>>>>>        
45722>>>>>        Move (SizeOfArray(aRows)) to iNext
45723>>>>>    
45723>>>>>        Open hTab
45725>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTab to iFlds
45728>>>>>        Move hTab                                   to aRows[iNext].sRowID
45729>>>>>        Get_Attribute DF_FILE_DISPLAY_NAME  of hTab to aRows[iNext].aCells[0].sValue
45732>>>>>        
45732>>>>>        For iFld from 1 to iFlds
45738>>>>>>
45738>>>>>            Get_Attribute DF_FIELD_RELATED_FILE of hTab iFld to hRel
45741>>>>>            If (hRel and not(TableLoaded(Self, &aRows, hRel)) and ;                         not(ExcludedTable(Self, hRel))) Send RelatedFiles (&aRows) hRel
45744>>>>>        Loop
45745>>>>>>
45745>>>>>    
45745>>>>>    End_Procedure
45746>>>>>    
45746>>>>>    Function TableOpened Handle hTab wqTableDetail[] ByRef ahOpened Returns Boolean
45748>>>>>        Integer i
45748>>>>>        
45748>>>>>        For i from 0 to (SizeOfArray(ahOpened) - 1)
45754>>>>>>
45754>>>>>            If (ahOpened[i].iTabNum = hTab) Function_Return True
45757>>>>>        Loop
45758>>>>>>
45758>>>>>        
45758>>>>>        Function_Return False
45759>>>>>    End_Function
45760>>>>>    
45760>>>>>    Procedure CollectColumns tWebRow[] ByRef aRows Handle hTab
45762>>>>>        Integer iCols iCol iType iIdx
45762>>>>>        String  sName
45762>>>>>        
45762>>>>>        If not hTab Procedure_Return
45765>>>>>        
45765>>>>>        Open hTab
45767>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTab to iCols
45770>>>>>        Move 0 to iIdx
45771>>>>>        
45771>>>>>        For iCol from 1 to iCols
45777>>>>>>
45777>>>>>            Get_Attribute DF_FIELD_NAME of hTab iCol to sName
45780>>>>>            Get_Attribute DF_FIELD_TYPE of hTab iCol to iType
45783>>>>>            
45783>>>>>            If ((Left(sName, 1) <> "@") and (iType <> DF_OVERLAP) and ;                (iType <> DF_BINARY) and not(ExcludedField(Self, hTab, iCol))) Begin
45785>>>>>                Move iCol                               to aRows[iIdx].sRowID
45786>>>>>                Move (NiceFieldName(Self, hTab, iCol))  to aRows[iIdx].aCells[0].sValue
45787>>>>>                Increment iIdx
45788>>>>>            End
45788>>>>>>
45788>>>>>            
45788>>>>>        Loop
45789>>>>>>
45789>>>>>        
45789>>>>>    End_Procedure
45790>>>>>    
45790>>>>>    Function WebDataType Integer iType Returns Integer
45792>>>>>        If (iType = DF_BCD)         Function_Return typeNumber
45795>>>>>        If (iType = DF_DATE)        Function_Return typeDate
45798>>>>>        If (iType = DF_DATETIME)    Function_Return typeDateTime
45801>>>>>        Function_Return                             typeASCII
45802>>>>>    End_Function
45803>>>>>    
45803>>>>>    Function StorePath Returns String
45805>>>>>        String  sPath
45805>>>>>        
45805>>>>>        Get psStoreDirectory of ghoWebQry to sPath
45806>>>>>                
45806>>>>>        Function_Return sPath
45807>>>>>    End_Function
45808>>>>>    
45808>>>>>    Function PublicPath Returns String
45810>>>>>        Function_Return (StorePath(Self) + C_wqPublicDir)
45811>>>>>    End_Function
45812>>>>>    
45812>>>>>    Function PrivatePath Returns String
45814>>>>>        String  sUser
45814>>>>>        Boolean bLoggedIn
45814>>>>>        Handle  hoSess hLoggedInFunc hUserNameFunc
45814>>>>>        
45814>>>>>        Get phoSessionObj of ghoWebQry to hoSess
45815>>>>>        
45815>>>>>        If hoSess Begin
45817>>>>>            Get phLoggedInFunc of ghoWebQry to hLoggedInFunc
45818>>>>>            Get phUserNameFunc of ghoWebQry to hUserNameFunc
45819>>>>>            
45819>>>>>            If (hLoggedInFunc and hUserNameFunc) Begin
45821>>>>>                Get hLoggedInFunc of hoSess to bLoggedIn
45822>>>>>                
45822>>>>>                If bLoggedIn Begin
45824>>>>>                    Get hUserNameFunc of hoSess to sUser
45825>>>>>                    Move (Trim(sUser)) to sUser
45826>>>>>                    Function_Return (StorePath(Self) + "\" + sUser)
45827>>>>>                End
45827>>>>>>
45827>>>>>                
45827>>>>>            End
45827>>>>>>
45827>>>>>            
45827>>>>>        End
45827>>>>>>
45827>>>>>        
45827>>>>>        Function_Return ""
45828>>>>>    End_Function
45829>>>>>    
45829>>>>>    Procedure MakeDirectories
45831>>>>>        Integer iChn
45831>>>>>        String  sPrivPath
45831>>>>>        
45831>>>>>        Get Seq_New_Channel to iChn
45832>>>>>        
45832>>>>>        Direct_Input channel iChn  ("dir:" + StorePath(Self))
45834>>>>>        
45834>>>>>        If (SeqEof) Begin
45836>>>>>            Make_Directory (StorePath(Self))
45837>>>>>            Make_Directory (PublicPath(Self))
45838>>>>>        End
45838>>>>>>
45838>>>>>        
45838>>>>>        Close_Input channel iChn
45840>>>>>        
45840>>>>>        Get PrivatePath to sPrivPath
45841>>>>>        
45841>>>>>        If (sPrivPath <> "") Begin
45843>>>>>            Direct_Input channel iChn ("dir:" + PrivatePath(Self))
45845>>>>>        
45845>>>>>            If (SeqEof) Make_Directory (PrivatePath(Self))
45848>>>>>        
45848>>>>>            Close_Input channel iChn
45850>>>>>        End
45850>>>>>>
45850>>>>>        
45850>>>>>        Send Seq_Release_Channel iChn
45851>>>>>    End_Procedure
45852>>>>>    
45852>>>>>    Function FileMatch String sFile String sFilter Returns Boolean
45854>>>>>        Integer iPos
45854>>>>>        String  sName sExt sNSpec sESpec
45854>>>>>        
45854>>>>>        Move (Pos(".", sFile)) to iPos
45855>>>>>        
45855>>>>>        If iPos Begin
45857>>>>>            Move (Left(sFile, (iPos - 1)))              to sName
45858>>>>>            Move (Right(sFile, (Length(sFile) - iPos))) to sExt
45859>>>>>        End
45859>>>>>>
45859>>>>>        Else Begin
45860>>>>>            Move sFile to sName
45861>>>>>            Move ""    to sExt 
45862>>>>>        End
45862>>>>>>
45862>>>>>        
45862>>>>>        Move (Pos(".", sFilter)) to iPos
45863>>>>>        
45863>>>>>        If iPos Begin
45865>>>>>            Move (Left(sFilter, (iPos - 1)))                to sNSpec
45866>>>>>            Move (Right(sFilter, (Length(sFilter) - iPos))) to sESpec
45867>>>>>        End
45867>>>>>>
45867>>>>>        Else Begin
45868>>>>>            Move sFilter to sNSpec
45869>>>>>            Move ""      to sESpec
45870>>>>>        End
45870>>>>>>
45870>>>>>        
45870>>>>>        Function_Return ((sName matches sNSpec) and ((sExt matches sESpec) or (sESpec = ""))) 
45871>>>>>    End_Function
45872>>>>>    
45872>>>>>    Function DirectoryContents String sPath String sFilter Returns wqDir[]
45874>>>>>        Integer iChn i
45874>>>>>        String  sVal
45874>>>>>        Boolean bDir bMatch
45874>>>>>        wqDir[] aContents
45874>>>>>        wqDir[] aContents
45875>>>>>        
45875>>>>>        Get Seq_New_Channel to iChn
45876>>>>>        
45876>>>>>        Move 0 to i
45877>>>>>        Direct_Input channel iChn ("dir:" + sPath)
45879>>>>>        
45879>>>>>        While not (SeqEof)
45883>>>>>            Readln sVal
45884>>>>>            
45884>>>>>            If (not(SeqEof) and (sVal <> "[.]") and (sVal <> "[..]")) Begin
45886>>>>>                Move (Left(sVal, 1) = "[")    to bDir
45887>>>>>                Move (Replace("[", sVal, "")) to sVal
45888>>>>>                Move (Replace("]", sVal, "")) to sVal
45889>>>>>                
45889>>>>>                If not bDir Move (FileMatch(Self, sVal, sFilter)) to bMatch
45892>>>>>                
45892>>>>>                If (bDir or bMatch) Begin
45894>>>>>                    Move bDir to aContents[i].bDir
45895>>>>>                    Move sVal to aContents[i].sName
45896>>>>>                    Increment i
45897>>>>>                End
45897>>>>>>
45897>>>>>                
45897>>>>>            End
45897>>>>>>
45897>>>>>            
45897>>>>>        Loop
45898>>>>>>
45898>>>>>        
45898>>>>>        Close_Input
45899>>>>>        Send Seq_Release_Channel iChn
45900>>>>>        
45900>>>>>        Function_Return aContents
45901>>>>>    End_Function
45902>>>>>    
45902>>>>>    Function FilenameFromPath String sValue Returns String
45904>>>>>        Integer iPos
45904>>>>>        
45904>>>>>        Repeat
45904>>>>>>
45904>>>>>            Move (Pos("\", sValue)) to iPos
45905>>>>>            If iPos Move (Right(sValue, (Length(sValue) - iPos))) to sValue
45908>>>>>        Until (iPos <= 0)
45910>>>>>                
45910>>>>>        Function_Return sValue        
45911>>>>>    End_Function
45912>>>>>    
45912>>>>>    Function TableInfo Returns wqTableInfo[]
45914>>>>>        Handle  hTab
45914>>>>>        Integer i
45914>>>>>        String  sDisp
45914>>>>>        wqTableInfo[] tTabs
45914>>>>>        wqTableInfo[] tTabs
45915>>>>>        
45915>>>>>        Move 0 to hTab
45916>>>>>        Move 0 to i
45917>>>>>        
45917>>>>>        Repeat
45917>>>>>>
45917>>>>>            Get_Attribute DF_FILE_NEXT_USED of hTab to hTab
45920>>>>>            
45920>>>>>            If hTab Begin
45922>>>>>                Get_Attribute DF_FILE_DISPLAY_NAME of hTab to sDisp
45925>>>>>                
45925>>>>>                If ((Left(sDisp, 1) <> "@") and not(ExcludedTable(Self, hTab))) Begin
45927>>>>>                    Move hTab                                   to tTabs[i].iNum
45928>>>>>                    Move sDisp                                  to tTabs[i].sDispName
45929>>>>>                    Get_Attribute DF_FILE_LOGICAL_NAME of hTab  to tTabs[i].sDFName
45932>>>>>                    Get_Attribute DF_FILE_ROOT_NAME    of hTab  to tTabs[i].sRootName
45935>>>>>                    Increment i
45936>>>>>                End
45936>>>>>>
45936>>>>>                
45936>>>>>            End
45936>>>>>>
45936>>>>>            
45936>>>>>        Until not hTab
45938>>>>>        
45938>>>>>        Function_Return tTabs
45939>>>>>    End_Function
45940>>>>>    
45940>>>>>    Function SerializeField wqPrintField tField Returns String
45942>>>>>        String  sField
45942>>>>>        
45942>>>>>        Get VariantToString of oStructFunctions tField to sField
45943>>>>>        Function_Return sField
45944>>>>>    End_Function
45945>>>>>    
45945>>>>>    Function DeSerializeField String sField Returns wqPrintField
45947>>>>>        tValueTree tVT
45947>>>>>        tValueTree tVT
45947>>>>>        wqPrintField tField
45947>>>>>        wqPrintField tField
45947>>>>>        
45947>>>>>        Get StringToValueTree of oStructFunctions sField to tVT
45948>>>>>        ValueTreeDeserializeParameter tVT to tField
45949>>>>>        Function_Return tField
45950>>>>>    End_Function
45951>>>>>    
45951>>>>>    Function DeserializeFields String sData Returns wqPrintField[]
45953>>>>>        wqPrintField[] aFields
45953>>>>>        wqPrintField[] aFields
45954>>>>>        tValueTree tVT
45954>>>>>        tValueTree tVT
45954>>>>>        
45954>>>>>        Get StringToValueTree of oStructFunctions sData to tVT
45955>>>>>        ValueTreeDeserializeParameter tVT to aFields
45956>>>>>        
45956>>>>>        Function_Return aFields                
45957>>>>>    End_Function
45958>>>>>    
45958>>>>>    Procedure TableDetails Handle hTab wqTableDetail[] ByRef atTabDets
45960>>>>>        Integer iFlds iFld iIdx
45960>>>>>        Handle  hRel
45960>>>>>        
45960>>>>>        If (hTab = 0)                 Procedure_Return
45963>>>>>        If (TableMissing(Self, hTab)) Procedure_Return
45966>>>>>
45966>>>>>        Move (SizeOFArray(atTabDets)) to iIdx
45967>>>>>        
45967>>>>>        Open hTab
45969>>>>>        Move hTab                                  to atTabDets[iIdx].iTabNum
45970>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTab to atTabDets[iIdx].sName
45973>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTab to iFlds
45976>>>>>        
45976>>>>>        For iFld from 1 to iFlds
45982>>>>>>
45982>>>>>            Get_Attribute DF_FIELD_NAME         of hTab iFld to atTabDets[iIdx].asFieldNames[iFld]
45985>>>>>            Get_Attribute DF_FIELD_RELATED_FILE of hTab iFld to hRel
45988>>>>>            If (hRel and not (TableOpened(Self, hRel, &atTabDets))) Send TableDetails hRel (&atTabDets)
45991>>>>>        Loop
45992>>>>>>
45992>>>>>        
45992>>>>>    End_Procedure
45993>>>>>    
45993>>>>>    Function TableIdx String sTab wqTableDetail[] ByRef atTabDets Returns Integer
45995>>>>>        Integer i
45995>>>>>        
45995>>>>>        For i from 0 to (SizeOFArray(atTabDets) - 1)
46001>>>>>>
46001>>>>>            If (Uppercase(sTab) = Uppercase(atTabDets[i].sName)) Function_Return i
46004>>>>>        Loop
46005>>>>>>
46005>>>>>        
46005>>>>>        Function_Return -1
46006>>>>>    End_Function
46007>>>>>
46007>>>>>    Function FieldIdx Integer iTab String sCol wqTableDetail[] ByRef atTabDets Returns Integer
46009>>>>>        Integer i
46009>>>>>        
46009>>>>>        For i from 0 to (SizeOFArray(atTabDets[iTab].asFieldNames) - 1)
46015>>>>>>
46015>>>>>            If (Uppercase(sCol) = Uppercase(atTabDets[iTab].asFieldNames[i])) Function_Return i
46018>>>>>        Loop
46019>>>>>>
46019>>>>>      
46019>>>>>        Function_Return -1
46020>>>>>    End_Function
46021>>>>>    
46021>>>>>    Function MilDate2Date String sDate Returns String
46023>>>>>        Integer iFmt iLen iSep
46023>>>>>        String  sRes sSep
46023>>>>>        
46023>>>>>        Get_Attribute DF_DATE_FORMAT    to iFmt
46026>>>>>        Get_Attribute DF_DATE_SEPARATOR to iSep
46029>>>>>        Move (Character(iSep))          to sSep
46030>>>>>        Move (Trim(sDate))              to sDate
46031>>>>>        Move (Length(sDate))            to iLen
46032>>>>>        
46032>>>>>        // Just not a valid length - return the input unchanged
46032>>>>>        If not ((iLen = 8) or (iLen = 10)) Function_Return sDate
46035>>>>>        
46035>>>>>        // If the format is military, just return the input
46035>>>>>        If (iFmt = DF_DATE_MILITARY) Function_Return sDate
46038>>>>>        
46038>>>>>        If (iFmt = DF_DATE_EUROPEAN) Begin
46040>>>>>            If (iLen = 10) Move (Right(sDate, 2) + sSep + Mid(sDate, 2, 6) + sSep + Left(sDate, 4)) to sRes
46043>>>>>            Else           Move (Right(sDate, 2) + sSep + Mid(sDate, 2, 4) + sSep + Left(sDate, 2)) to sRes
46045>>>>>        End
46045>>>>>>
46045>>>>>        Else If (iFmt = DF_DATE_USA) Begin
46048>>>>>            If (iLen = 10) Move (Mid(sDate, 2, 6) + sSep + Right(sDate, 2) + sSep + Left(sDate, 4)) to sRes
46051>>>>>            Else           Move (Mid(sDate, 2, 4) + sSep + Right(sDate, 2) + sSep + Left(sDate, 2)) to sRes
46053>>>>>        End
46053>>>>>>
46053>>>>>        
46053>>>>>        Function_Return sRes
46054>>>>>    End_Function
46055>>>>>    
46055>>>>>    Function Date2MilDate String sDate Returns String
46057>>>>>        Integer iFmt iLen
46057>>>>>        String  sRes sSep
46057>>>>>        
46057>>>>>        Get_Attribute DF_DATE_FORMAT    to iFmt
46060>>>>>        Move "-"                        to sSep
46061>>>>>        Move (Trim(sDate))              to sDate
46062>>>>>        Move (Length(sDate))            to iLen
46063>>>>>        
46063>>>>>        // Just not a valid length - return the input unchanged
46063>>>>>        If not ((iLen = 8) or (iLen = 10)) Function_Return sDate
46066>>>>>        
46066>>>>>        // If the format is military, just return the input
46066>>>>>        If (iFmt = DF_DATE_MILITARY) Function_Return sDate
46069>>>>>        
46069>>>>>        If (iFmt = DF_DATE_EUROPEAN) Begin
46071>>>>>            If (iLen = 10) Move (Right(sDate, 4) + sSep + Mid(sDate, 2, 4) + sSep + Left(sDate, 2)) to sRes
46074>>>>>            Else           Move (Right(sDate, 2) + sSep + Mid(sDate, 2, 4) + sSep + Left(sDate, 2)) to sRes
46076>>>>>        End
46076>>>>>>
46076>>>>>        Else If (iFmt = DF_DATE_USA) Begin
46079>>>>>            If (iLen = 10) Move (Right(sDate, 4) + sSep + Left(sDate, 2) + sSep + Mid(sDate, 2, 4)) to sRes
46082>>>>>            Else           Move (Right(sDate, 2) + sSep + Left(sDate, 2) + sSep + Mid(sDate, 2, 4)) to sRes
46084>>>>>        End
46084>>>>>>
46084>>>>>        
46084>>>>>        Function_Return sRes
46085>>>>>    End_Function
46086>>>>>        
46086>>>>>    Function NameToColour String sName Returns wqColour
46088>>>>>        wqColour tCol
46088>>>>>        wqColour tCol
46088>>>>>        
46088>>>>>        Move (Lowercase(sName)) to sName
46089>>>>>        
46089>>>>>        If (sName = "white") Begin
46091>>>>>            Move 255 to tCol.iRed
46092>>>>>            Move 255 to tCol.iGreen
46093>>>>>            Move 255 to tCol.iBlue
46094>>>>>        End
46094>>>>>>
46094>>>>>        Else If (sName = "silver") Begin
46097>>>>>            Move 192 to tCol.iRed
46098>>>>>            Move 192 to tCol.iGreen
46099>>>>>            Move 192 to tCol.iBlue
46100>>>>>        End
46100>>>>>>
46100>>>>>        Else If (sName = "gray") Begin
46103>>>>>            Move 128 to tCol.iRed
46104>>>>>            Move 128 to tCol.iGreen
46105>>>>>            Move 128 to tCol.iBlue
46106>>>>>        End
46106>>>>>>
46106>>>>>        Else If (sName = "red") Begin
46109>>>>>            Move 255 to tCol.iRed
46110>>>>>            Move   0 to tCol.iGreen
46111>>>>>            Move   0 to tCol.iBlue
46112>>>>>        End
46112>>>>>>
46112>>>>>        Else If (sName = "maroon") Begin
46115>>>>>            Move 128 to tCol.iRed
46116>>>>>            Move   0 to tCol.iGreen
46117>>>>>            Move   0 to tCol.iBlue
46118>>>>>        End
46118>>>>>>
46118>>>>>        Else If (sName = "yellow") Begin
46121>>>>>            Move 255 to tCol.iRed
46122>>>>>            Move 255 to tCol.iGreen
46123>>>>>            Move   0 to tCol.iBlue
46124>>>>>        End
46124>>>>>>
46124>>>>>        Else If (sName = "olive") Begin
46127>>>>>            Move 128 to tCol.iRed
46128>>>>>            Move 128 to tCol.iGreen
46129>>>>>            Move   0 to tCol.iBlue
46130>>>>>        End
46130>>>>>>
46130>>>>>        Else If (sName = "lime") Begin
46133>>>>>            Move   0 to tCol.iRed
46134>>>>>            Move 255 to tCol.iGreen
46135>>>>>            Move   0 to tCol.iBlue
46136>>>>>        End
46136>>>>>>
46136>>>>>        Else If (sName = "green") Begin
46139>>>>>            Move   0 to tCol.iRed
46140>>>>>            Move 128 to tCol.iGreen
46141>>>>>            Move   0 to tCol.iBlue
46142>>>>>        End
46142>>>>>>
46142>>>>>        Else If (sName = "aqua") Begin
46145>>>>>            Move   0 to tCol.iRed
46146>>>>>            Move 255 to tCol.iGreen
46147>>>>>            Move 255 to tCol.iBlue
46148>>>>>        End
46148>>>>>>
46148>>>>>        Else If (sName = "teal") Begin
46151>>>>>            Move   0 to tCol.iRed
46152>>>>>            Move 128 to tCol.iGreen
46153>>>>>            Move 128 to tCol.iBlue
46154>>>>>        End
46154>>>>>>
46154>>>>>        Else If (sName = "blue") Begin
46157>>>>>            Move   0 to tCol.iRed
46158>>>>>            Move   0 to tCol.iGreen
46159>>>>>            Move 255 to tCol.iBlue
46160>>>>>        End
46160>>>>>>
46160>>>>>        Else If (sName = "navy") Begin
46163>>>>>            Move   0 to tCol.iRed
46164>>>>>            Move   0 to tCol.iGreen
46165>>>>>            Move 128 to tCol.iBlue
46166>>>>>        End
46166>>>>>>
46166>>>>>        Else If (sName = "fushia") Begin
46169>>>>>            Move 255 to tCol.iRed
46170>>>>>            Move   0 to tCol.iGreen
46171>>>>>            Move 255 to tCol.iBlue
46172>>>>>        End
46172>>>>>>
46172>>>>>        Else If (sName = "purple") Begin
46175>>>>>            Move 128 to tCol.iRed
46176>>>>>            Move   0 to tCol.iGreen
46177>>>>>            Move 128 to tCol.iBlue
46178>>>>>        End
46178>>>>>>
46178>>>>>        Else Begin
46179>>>>>            Move   0 to tCol.iRed
46180>>>>>            Move   0 to tCol.iGreen
46181>>>>>            Move   0 to tCol.iBlue
46182>>>>>        End
46182>>>>>>
46182>>>>>        
46182>>>>>        Function_Return tCol
46183>>>>>    End_Function
46184>>>>>    
46184>>>>>//==============================================================================    
46184>>>>>// Report output methods
46184>>>>>//==============================================================================    
46184>>>>>    
46184>>>>>    Function OpenOutput Integer iDest Integer iFormat String ByRef sPath String ByRef sFile Returns Integer
46186>>>>>        Integer iChn
46186>>>>>        String  sDir
46186>>>>>        
46186>>>>>        Get Seq_New_Channel                                         to iChn
46187>>>>>        Get RandomHexUUID                                           to sFile
46188>>>>>        If      (iFormat = C_wqOutputHtml) Move (sFile + ".html")   to sFile
46191>>>>>        Else If (iFormat = C_wqOutputText) Move (sFile + ".txt")    to sFile
46195>>>>>        Else If (iFormat = C_wqOutputCSV)  Move (sFile + ".csv")    to sFile
46199>>>>>        Else If (iFormat = C_wqOutputXML)  Move (sFile + ".xml")    to sFile
46203>>>>>        
46203>>>>>        If (iDest = C_wqDownload) Begin
46205>>>>>            Get psDownloadDirectory of ghoWebQry                to sPath
46206>>>>>        End
46206>>>>>>
46206>>>>>        Else Begin
46207>>>>>            Get psAppHtmlPath of (phoWorkspace(oApplication))   to sPath
46208>>>>>            Get psOutputDirectory of ghoWebQry                  to sDir
46209>>>>>//        Get psHome of (phoWorkspace(oApplication))                  to sPath
46209>>>>>//        Get psOutputDirectory of ghoWebQry                          to sPath
46209>>>>>            Move (sPath + "/" + sDir)                           to sPath
46210>>>>>        End
46210>>>>>>
46210>>>>>        
46210>>>>>        Direct_Input channel iChn ("dir:" + sPath)
46212>>>>>        If (SeqEOF) Make_Directory sPath
46215>>>>>        Close_Input channel iChn
46217>>>>>        
46217>>>>>        Direct_Output channel iChn (sPath + "\" + sFile)
46219>>>>>        Set piChannel to iChn
46220>>>>>        
46220>>>>>        Function_Return iChn
46221>>>>>    End_Function
46222>>>>>    
46222>>>>>    Procedure CreateLayout wqWebQuery ByRef tQuery wqPrintRowLayout ByRef tLay wqBreakpoint[] ByRef aBreaks
46224>>>>>        Integer i iFld iRow iCol iLen
46224>>>>>        
46224>>>>>        Move 0 to tLay.iMaxCols
46225>>>>>        Move 0 to tLay.iCount
46226>>>>>        Move 0 to iRow
46227>>>>>        Move 0 to iCol
46228>>>>>        
46228>>>>>        For iFld from 0 to (SizeOfArray(tQuery.aPrintFields) - 1)
46234>>>>>>
46234>>>>>            
46234>>>>>            If (tQuery.aPrintFields[iFld].bCR) Begin
46236>>>>>                Move 0 to iCol
46237>>>>>                Increment iRow
46238>>>>>            End
46238>>>>>>
46238>>>>>            
46238>>>>>            Move tQuery.aPrintFields[iFld].iTable       to tLay.aParts[iRow].aColumns[iCol].iTable
46239>>>>>            Move tQuery.aPrintFields[iFld].iColumn      to tLay.aParts[iRow].aColumns[iCol].iColumn
46240>>>>>            Move tQuery.aPrintFields[iFld].sUserName    to tLay.aParts[iRow].aColumns[iCol].sName
46241>>>>>            Move tQuery.aPrintFields[iFld].bCR          to tLay.aParts[iRow].aColumns[iCol].bCR
46242>>>>>            Move tQuery.aPrintFields[iFld].bSum         to tLay.aParts[iRow].aColumns[iCol].bSum
46243>>>>>            Move tQuery.aPrintFields[iFld].sExpression  to tLay.aParts[iRow].aColumns[iCol].sExpr
46244>>>>>            Move tQuery.aPrintFields[iFld].iType        to tLay.aParts[iRow].aColumns[iCol].iType
46245>>>>>            Move tQuery.aPrintFields[iFld].iWidth       to tLay.aParts[iRow].aColumns[iCol].iWidth
46246>>>>>            Move tQuery.aPrintFields[iFld].iDecimals    to tLay.aParts[iRow].aColumns[iCol].iDecimals
46247>>>>>            Move tQuery.aPrintFields[iFld].bCalc        to tLay.aParts[iRow].aColumns[iCol].bCalc
46248>>>>>            
46248>>>>>            If (tLay.aParts[iRow].aColumns[iCol].iType = DF_BCD) Begin
46250>>>>>                Move (tLay.aParts[iRow].aColumns[iCol].iWidth * 2)                      to iLen         // digits
46251>>>>>                If (tLay.aParts[iRow].aColumns[iCol].iDecimals > 0)                     Increment iLen  // point
46254>>>>>                Move (iLen + Integer(((tLay.aParts[iRow].aColumns[iCol].iWidth * 2) - ;                                      tLay.aParts[iRow].aColumns[iCol].iDecimals) / 3)) to iLen         // commas
46255>>>>>            End
46255>>>>>>
46255>>>>>            Else If (tLay.aParts[iRow].aColumns[iCol].iType = DF_DATE) Begin
46258>>>>>                Move 10 to iLen                                                                         // dates are 10 wide
46259>>>>>            End
46259>>>>>>
46259>>>>>            Else If (tLay.aParts[iRow].aColumns[iCol].iType = DF_TEXT) Begin
46262>>>>>                Move (tLay.aParts[iRow].aColumns[iCol].iWidth - 2) to iLen                              // Text is 2 bytes less than size
46263>>>>>            End
46263>>>>>>
46263>>>>>            Else Begin
46264>>>>>                Move tLay.aParts[iRow].aColumns[iCol].iWidth to iLen
46265>>>>>            End
46265>>>>>>
46265>>>>>            
46265>>>>>            Move (iLen max Length(tLay.aParts[iRow].aColumns[iCol].sName)) to tLay.aParts[iRow].aColumns[iCol].iPrintWidth
46266>>>>>            
46266>>>>>            For i from 0 to (SizeOfArray(aBreaks))  // Note: NOT -1, because 0 is the overall total
46272>>>>>>
46272>>>>>                Move 0                                  to tLay.aParts[iRow].aColumns[iCol].anSum[i]
46273>>>>>            Loop
46274>>>>>>
46274>>>>>            
46274>>>>>            Increment iCol
46275>>>>>            Move (tLay.iMaxCols max (iCol + 1)) to tLay.iMaxCols
46276>>>>>        Loop
46277>>>>>>
46277>>>>>        
46277>>>>>    End_Procedure
46278>>>>>    
46278>>>>>    Procedure AddTqRelations tTableQuery ByRef tTQ Handle hTab Handle[] ByRef ahTabs
46280>>>>>        Integer i iFields
46280>>>>>        Handle  hRel
46280>>>>>        
46280>>>>>        If not hTab                   Procedure_Return
46283>>>>>        If (TableMissing(Self, hTab)) Procedure_Return
46286>>>>>        
46286>>>>>        // Is this table already in the list?  If so, skip it
46286>>>>>        For i from 0 to (SizeOfArray(ahTabs) - 1)
46292>>>>>>
46292>>>>>            If (hTab = ahTabs[i]) Procedure_Return
46295>>>>>        Loop
46296>>>>>>
46296>>>>>        
46296>>>>>        // Now put it in the list
46296>>>>>        Move hTab to ahTabs[(SizeOfArray(ahTabs))]
46297>>>>>        
46297>>>>>        Open hTab
46299>>>>>        Send AddResultTable of oTQ (&tTQ) hTab                          // Put it here instead of in the loop (see below)
46300>>>>>        Get_Attribute DF_FILE_NUMBER_FIELDS of hTab to iFields
46303>>>>>        
46303>>>>>        For i from 1 to iFields
46309>>>>>>
46309>>>>>            Get_Attribute DF_FIELD_RELATED_FILE of hTab i to hRel
46312>>>>>            
46312>>>>>            If hRel Begin
46314>>>>>                Send AddTableRelationAuto of oTQ (&tTQ) hTab hRel
46315>>>>>//                Send AddResultTable of oTQ (&tTQ) hTab                // Remove from loop a put in body of procedure so that this is done for the main table as well
46315>>>>>                Send AddTqRelations              (&tTQ) hRel (&ahTabs)
46316>>>>>            End
46316>>>>>>
46316>>>>>            
46316>>>>>        Loop
46317>>>>>>
46317>>>>>        
46317>>>>>    End_Procedure  // AddTqRelations
46318>>>>>    
46318>>>>>    Function WqOpToTqOp String sWqOp Returns Integer
46320>>>>>        If (sWqOp = "<")  Function_Return tqLT
46323>>>>>        If (sWqOp = "<=") Function_Return tqLE
46326>>>>>        If (sWqOp = "=")  Function_Return tqEQ
46329>>>>>        If (sWqOp = ">=") Function_Return tqGE
46332>>>>>        If (sWqOp = ">")  Function_Return tqGT
46335>>>>>        If (sWqOp = "<>") Function_Return tqNE
46338>>>>>//        If (sWqOp = "IN") Function_Return tqIN
46338>>>>>        Function_Return -1
46339>>>>>    End_Function
46340>>>>>    
46340>>>>>    Procedure AddSelections wqWebQuery ByRef tQuery tTableQuery ByRef tTQ  wqSelsForTQ[] ByRef aTQSels
46342>>>>>        Integer i j iOp iPos
46342>>>>>        String  sList sRange
46342>>>>>        
46342>>>>>        // First move the selections to a different array, so that we can set
46342>>>>>        // a flag on it to see if (a) it is a filter that TableQuery will handle
46342>>>>>        // and (b) if there is more than one filter on the same field (which TQ
46342>>>>>        // does not allow.
46342>>>>>        //
46342>>>>>        // (Also, until Sture fixes it, if there is an "in list" filter on a
46342>>>>>        // related-to table rather than the main table.)
46342>>>>>        
46342>>>>>        For i from 0 to (SizeOfArray(tQuery.aSelections) - 1)
46348>>>>>>
46348>>>>>            Move tQuery.aSelections[i] to aTQSels[i].Selection
46349>>>>>            Move True to aTQSels[i].bUseTQ
46350>>>>>            Get WqOpToTqOp aTQSels[i].Selection.sType to iOp
46351>>>>>            If (iOp = -1) Move False to aTQSels[i].bUseTQ  // Not handled by TQ
46354>>>>>            
46354>>>>>            For j from 0 to (i - 1)
46360>>>>>>
46360>>>>>                If ((aTQSels[j].Selection.iTable  = aTQSels[i].Selection.iTable) and ;                    (aTQSels[j].Selection.iColumn = aTQSels[i].Selection.iColumn)) ;                    Move False to aTQSels[i].bUseTQ  // Only one filter per column in TQ
46363>>>>>            Loop
46364>>>>>>
46364>>>>>            
46364>>>>>// Sture says this should work - wonder what I'm doing wrong?
46364>>>>>//            If ((aTQSels[i].Selection.sType = "in list") and (aTQSels[i].Selection.iTable <> hMain)) ;
46364>>>>>//                    Move False to aTQSels[i].bUseTQ
46364>>>>>
46364>>>>>            Move (aTQSels[i].Selection.sType = "in list") to aTQSels[i].bInList
46365>>>>>            
46365>>>>>            If ((aTQSels[i].Selection.sType = "x-y") or ;                (aTQSels[i].Selection.sType = "CBT")) Begin
46367>>>>>                Move (Trim(Replace(" (both incl)", aTQSels[i].Selection.sValue, ""))) to sRange
46368>>>>>                Move (Pos(" - ", sRange))                           to iPos
46369>>>>>                Move (Left(sRange, (iPos - 1)))                     to aTQSels[i].sStartR
46370>>>>>                Move (Right(sRange, (Length(sRange) - iPos) - 2))   to aTQSels[i].sEndR
46371>>>>>            End
46371>>>>>>
46371>>>>>            
46371>>>>>            If (aTQSels[i].bInList) Begin
46373>>>>>                Move True to aTQSels[i].bUseTQ
46374>>>>>                Move 0 to j
46375>>>>>                Move aTQSels[i].Selection.sValue to sList
46376>>>>>                
46376>>>>>                Repeat
46376>>>>>>
46376>>>>>                    Move (Trim(sList)) to sList
46377>>>>>                    If (sList = "") Break
46380>>>>>                    
46380>>>>>                    Move (Pos(";", sList)) to iPos
46381>>>>>                    
46381>>>>>                    If (iPos > 0) Begin
46383>>>>>                        Move (Left(sList, (iPos - 1))) to aTQSels[i].aList[j]
46384>>>>>                        Move (Right(sList, (Length(sList) - iPos))) to sList
46385>>>>>                    End
46385>>>>>>
46385>>>>>                    Else If (sList <> "") Move sList to aTQSels[i].aList[j]
46389>>>>>                    
46389>>>>>                    Increment j
46390>>>>>                Until not iPos
46392>>>>>                    
46392>>>>>            End
46392>>>>>>
46392>>>>>            
46392>>>>>        Loop
46393>>>>>>
46393>>>>>        
46393>>>>>        // Add TQ Filters
46393>>>>>        For i from 0 to (SizeOfArray(aTQSels) - 1)
46399>>>>>>
46399>>>>>        
46399>>>>>            If (aTQSels[i].bUseTQ) Begin
46401>>>>>
46401>>>>>                If (aTQSels[i].bInList) Begin
46403>>>>>                    Send AddFilterOrList of oTQ (&tTQ) aTQSels[i].Selection.iTable ;                                                       aTQSels[i].Selection.iColumn ;                                                       aTQSels[i].aList
46404>>>>>                End
46404>>>>>>
46404>>>>>                Else Begin
46405>>>>>                    Send AddFilter of oTQ (&tTQ) aTQSels[i].Selection.iTable ;                                                 aTQSels[i].Selection.iColumn iOp ;                           (StrDelQuotes(Self, aTQSels[i].Selection.sValue))
46406>>>>>                End
46406>>>>>>
46406>>>>>                
46406>>>>>            End
46406>>>>>>
46406>>>>>            
46406>>>>>        Loop
46407>>>>>>
46407>>>>>    End_Procedure
46408>>>>>    
46408>>>>>    Procedure SetupBreaks wqWebQuery ByRef tQuery wqBreakpoint[] ByRef aBreaks
46410>>>>>        Integer i j k
46410>>>>>        
46410>>>>>        Move 0 to j
46411>>>>>        
46411>>>>>        For i from 0 to (SizeOfArray(tQuery.aSegments) - 1)
46417>>>>>>
46417>>>>>            
46417>>>>>            If (tQuery.aSegments[i].bBreak) Begin
46419>>>>>                Move tQuery.aSegments[i].iTable to aBreaks[j].iTable
46420>>>>>                Move tQuery.aSegments[i].iField to aBreaks[j].iColumn
46421>>>>>                Move tQuery.aSegments[i].sName  to aBreaks[j].sName
46422>>>>>                Move ""                         to aBreaks[j].sPrevValue
46423>>>>>                Increment j
46424>>>>>            End
46424>>>>>>
46424>>>>>            
46424>>>>>        Loop
46425>>>>>>
46425>>>>>        
46425>>>>>    End_Procedure
46426>>>>>    
46426>>>>>    Procedure AddOrdering wqIndexSeg[] ByRef atSegments tTableQuery ByRef tTQ
46428>>>>>        Integer i
46428>>>>>        
46428>>>>>        For i from 0 to (SizeOfArray(atSegments) - 1)
46434>>>>>>
46434>>>>>            Send AddOrderBy of oTQ (&tTQ) atSegments[i].iTable ;                                          atSegments[i].iField ;                                          atSegments[i].bDesc ;                                          atSegments[i].bUC
46435>>>>>        Loop
46436>>>>>>
46436>>>>>        
46436>>>>>    End_Procedure
46437>>>>>    
46437>>>>>    Procedure WriteHtmlStart wqWebQuery ByRef tQuery Integer iChn
46439>>>>>        String  sTitle
46439>>>>>        
46439>>>>>        If (tQuery.sTitle = "") Get_Attribute DF_FILE_DISPLAY_NAME of tQuery.hMainTable to sTitle
46444>>>>>        Else Move tQuery.sTitle                                                         to sTitle
46446>>>>>        
46446>>>>>        WriteLn channel iChn "<" (Character(33)) "DOCTYPE HTML>"
46451>>>>>        Send XmlToChannel of oWqXml iChn
46452>>>>>        Send AddOpenElement of oWqXml "html"
46453>>>>>        Send AddOpenElement of oWqXml "head"
46454>>>>>        Send AddElement of oWqXml "title" sTitle
46455>>>>>        Send CloseElement of oWqXml  // head
46456>>>>>        Send AddOpenElement of oWqXml "body"
46457>>>>>        Send AddAttribute of oWqXml "style" ("font-family:" * tQuery.sTypeface + ";" * ;                                             "font-size:" * tQuery.sFontSize + ";" * ;                                             "color:" * tQuery.sTextColour + ";" * ;                                             "background-color:" * tQuery.sBGColour + ";")
46458>>>>>        
46458>>>>>        If (tQuery.sTextBefore <> "") Send Stream of oWqXml ;                (Replaces(Character(10), tQuery.sTextBefore, "<br>"))
46461>>>>>        
46461>>>>>        Send AddElement of oWqXml "h1" sTitle
46462>>>>>        Send AddAttribute of oWqXml "align" "left"
46463>>>>>    End_Procedure
46464>>>>>    
46464>>>>>    Procedure WriteCSVStart wqWebQuery ByRef tQuery wqPrintRowLayout ByRef tLay Integer iChn
46466>>>>>        Integer i
46466>>>>>        
46466>>>>>        If (tQuery.bColHeads) Begin
46468>>>>>            
46468>>>>>            For i from 0 to (SizeOfArray(tQuery.aPrintFields) - 1)
46474>>>>>>
46474>>>>>                If (i > 0) Write ","
46477>>>>>                Write '"' (Replaces('"', tQuery.aPrintFields[i].sUserName, "'")) '"'
46480>>>>>            Loop
46481>>>>>>
46481>>>>>            
46481>>>>>            WriteLn
46482>>>>>        End
46482>>>>>>
46482>>>>>        
46482>>>>>    End_Procedure
46483>>>>>    
46483>>>>>    Procedure WriteTextStart wqWebQuery ByRef tQuery wqPrintRowLayout ByRef tLay Integer iChn
46485>>>>>        String  sTitle
46485>>>>>        Integer iRow iCol iLen
46485>>>>>        
46485>>>>>        If (tQuery.sTextBefore <> "") Begin
46487>>>>>            WriteLn channel iChn tQuery.sTextBefore
46490>>>>>            WriteLn
46491>>>>>        End
46491>>>>>>
46491>>>>>        
46491>>>>>        Move tQuery.sTitle to sTitle
46492>>>>>        
46492>>>>>        If (sTitle = "") Begin
46494>>>>>            Get_Attribute DF_FILE_DISPLAY_NAME of tQuery.hMainTable to sTitle
46497>>>>>        End
46497>>>>>>
46497>>>>>        
46497>>>>>        WriteLn sTitle
46499>>>>>        WriteLn (Repeat("=", Length(sTitle)))
46501>>>>>        WriteLn
46502>>>>>        
46502>>>>>        For iRow from 0 to (SizeOfArray(tLay.aParts) - 1)
46508>>>>>>
46508>>>>>            Write (Repeat("   ", iRow))
46509>>>>>        
46509>>>>>            For iCol from 0 to (SizeOfArray(tLay.aParts[iRow].aColumns) - 1)
46515>>>>>>
46515>>>>>                If (iCol > 0) Write "  "
46518>>>>>                
46518>>>>>                If (tLay.aParts[iRow].aColumns[iCol].iType = DF_BCD) Begin
46520>>>>>                    Write (Repeat(" ", (tLay.aParts[iRow].aColumns[iCol].iPrintWidth - Length(tLay.aParts[iRow].aColumns[iCol].sName))))
46521>>>>>                    Write tLay.aParts[iRow].aColumns[iCol].sName
46522>>>>>                End
46522>>>>>>
46522>>>>>                Else Begin
46523>>>>>                    Write (Pad(tLay.aParts[iRow].aColumns[iCol].sName, tLay.aParts[iRow].aColumns[iCol].iPrintWidth))
46524>>>>>                End
46524>>>>>>
46524>>>>>                
46524>>>>>            Loop
46525>>>>>>
46525>>>>>            
46525>>>>>            WriteLn
46526>>>>>            
46526>>>>>            Write (Repeat("   ", iRow))
46527>>>>>        
46527>>>>>            For iCol from 0 to (SizeOfArray(tLay.aParts[iRow].aColumns) - 1)
46533>>>>>>
46533>>>>>                If (iCol > 0) Write "  "
46536>>>>>                
46536>>>>>                If (tLay.aParts[iRow].aColumns[iCol].iType = DF_BCD) Begin
46538>>>>>                    Write (Repeat(" ", (tLay.aParts[iRow].aColumns[iCol].iPrintWidth - Length(tLay.aParts[iRow].aColumns[iCol].sName))))
46539>>>>>                    Write (Repeat("=", Length(tLay.aParts[iRow].aColumns[iCol].sName)))
46540>>>>>                End
46540>>>>>>
46540>>>>>                Else Begin
46541>>>>>                    Write (Pad(Repeat("=", Length(tLay.aParts[iRow].aColumns[iCol].sName)), tLay.aParts[iRow].aColumns[iCol].iPrintWidth))
46542>>>>>                End
46542>>>>>>
46542>>>>>                
46542>>>>>            Loop
46543>>>>>>
46543>>>>>            
46543>>>>>            WriteLn
46544>>>>>        Loop
46545>>>>>>
46545>>>>>        
46545>>>>>    End_Procedure
46546>>>>>    
46546>>>>>    Procedure WriteXmlStart wqWebQuery ByRef tQuery wqPrintRowLayout ByRef tLay Integer iChn
46548>>>>>        String  sTitle
46548>>>>>        
46548>>>>>        
46548>>>>>        If (tQuery.sTitle = "") Get_Attribute DF_FILE_DISPLAY_NAME of tQuery.hMainTable to sTitle
46553>>>>>        Else Move tQuery.sTitle                                                         to sTitle
46555>>>>>        
46555>>>>>        Move (XmlTag(Self, sTitle)) to sTitle
46556>>>>>        
46556>>>>>        Write channel iChn '<?xml version="1.0" encoding="iso-8859-1"?>'
46558>>>>>        Send XmlToChannel of oWqXml iChn
46559>>>>>        Send AddOpenElement of oWqXml sTitle
46560>>>>>    End_Procedure
46561>>>>>    
46561>>>>>    Procedure WriteRemoveScript String sFile Integer iChn
46563>>>>>        Send Stream of oWqXml ""
46564>>>>>        WriteLn channel iChn
46566>>>>>        WriteLn '<script id="delRep">'
46568>>>>>        WriteLn 'var xmlHttpRequestFactory = null;'
46570>>>>>        WriteLn 'function createXMLHTTPObject() {'
46572>>>>>        WriteLn '   var xmlHttp = false;'
46574>>>>>        WriteLn '   if (! xmlHttpRequestFactory) {'
46576>>>>>        WriteLn '      var factories = ['
46578>>>>>        WriteLn '         function () {return new XMLHttpRequest(); },'
46580>>>>>        WriteLn '         function () {return new ActiveXObject("Msxml2.XMLHTTP"); },'
46582>>>>>        WriteLn '         function () {return new ActiveXObject("Msxml3.XMLHTTP"); },'
46584>>>>>        WriteLn '         function () {return new ActiveXObject("Microsoft.XMLHTTP"); }'
46586>>>>>        WriteLn '      ];'
46588>>>>>        WriteLn '      for (var i = 0; i < factories.length; i++) {'
46590>>>>>        WriteLn '         try {'
46592>>>>>        WriteLn '            xmlHttp = factories[i]();'
46594>>>>>        WriteLn '         }'
46596>>>>>        WriteLn '         catch (e) {'
46598>>>>>        WriteLn '            continue;'
46600>>>>>        WriteLn '         }'
46602>>>>>        WriteLn '         if (xmlHttp) {'
46604>>>>>        WriteLn '            xmlHttpRequestFactory = factories[i];'
46606>>>>>        WriteLn '         }'
46608>>>>>        WriteLn '         break;'
46610>>>>>        WriteLn '      }'
46612>>>>>        WriteLn '   }'
46614>>>>>        WriteLn '   return (xmlHttpRequestFactory) ? xmlHttpRequestFactory() : null;'
46616>>>>>        WriteLn '}'
46618>>>>>        WriteLn
46619>>>>>        WriteLn 'function removeFile() {'
46621>>>>>        WriteLn '   var arr = [], req;'
46623>>>>>        Writeln '   arr.push("{\"ActionRequest\":{\"Header\":{");'
46625>>>>>        WriteLn '   arr.push("\"sFocus\": \"\",");'
46627>>>>>        WriteLn '   arr.push("\"aDDODefs\":[],");'
46629>>>>>        WriteLn '   arr.push("\"aSyncProps\":[]");'
46631>>>>>        WriteLn '   arr.push("},");'
46633>>>>>        WriteLn '   arr.push("\"aActions\":[{");'
46635>>>>>        WriteLn '   arr.push("\"sTarget\": \"oWebQuery\",");'
46637>>>>>        WriteLn '   arr.push("\"sAction\": \"RemoveReport\",");'
46639>>>>>        WriteLn '   arr.push("\"aParams\": [\"' sFile '\"],");'
46643>>>>>        Writeln '   arr.push("\"tData\":null}]");'
46645>>>>>        WriteLn '   arr.push("}");'
46647>>>>>        WriteLn '   arr.push("}");'
46649>>>>>        WriteLn '   req = createXMLHTTPObject();'
46651>>>>>        WriteLn '   req.open("POST", "../WebServiceDispatcher.wso/CallAction/JSON", true);'
46653>>>>>        WriteLn '   req.setRequestHeader("Content-Type", "application/json");'
46655>>>>>        WriteLn '   req.send(arr.join(""));'
46657>>>>>        WriteLn '   document.body.removeChild(document.getElementById("delRep"));'
46659>>>>>        WriteLn '}'
46661>>>>>        WriteLn 'window.onload=removeFile;'
46663>>>>>        WriteLn '</script>'
46665>>>>>        WriteLn
46666>>>>>    End_Procedure
46667>>>>>    
46667>>>>>    Procedure WriteStartTable wqWebQuery ByRef tQuery wqPrintRowLayout ByRef tLay Integer iChn
46669>>>>>        Integer iRow iCol iPad
46669>>>>>        
46669>>>>>        Send AddOpenElement of oWqXml "table"
46670>>>>>        Send AddAttribute of oWqXml "style" ("width: 100%; border: none; font-size:" * tQuery.sFontSize)
46671>>>>>
46671>>>>>        For iRow from 0 to (SizeOfArray(tLay.aParts) - 1)
46677>>>>>>
46677>>>>>            Send AddOpenElement of oWqXml "tr"
46678>>>>>            Send AddAttribute of oWqXml "style" "font-weight: bold"
46679>>>>>            
46679>>>>>            For iCol from 0 to (SizeOfArray(tLay.aParts[iRow].aColumns) - 1)
46685>>>>>>
46685>>>>>                Send AddElement of oWqXml "td" tLay.aParts[iRow].aColumns[iCol].sName
46686>>>>>                If      (tLay.aParts[iRow].aColumns[iCol].iType = DF_BCD)  Send AddAttribute of oWqXml "style" "text-align: right"
46689>>>>>                Else If (tLay.aParts[iRow].aColumns[iCol].iType = DF_DATE) Send AddAttribute of oWqXml "style" "text-align: center"
46693>>>>>            Loop
46694>>>>>>
46694>>>>>            
46694>>>>>            Move (tLay.iMaxCols - SizeOfArray(tLay.aParts[iRow].aColumns) - 1) to iPad
46695>>>>>            
46695>>>>>            If iPad Begin
46697>>>>>                Send AddElement of oWqXml "td" ""  // possibly "&nbsp;" is more correct, but also more HTML
46698>>>>>                Send AddAttribute of oWqXml "colspan" iPad
46699>>>>>            End
46699>>>>>>
46699>>>>>            
46699>>>>>            Send CloseElement of oWqXml  // tr        
46700>>>>>        Loop
46701>>>>>>
46701>>>>>        
46701>>>>>    End_Procedure
46702>>>>>    
46702>>>>>    Procedure WriteEndTable wqWebQuery ByRef tQuery wqPrintRowLayout ByRef tLay Integer iChn
46704>>>>>        Integer iRow iCol iPad
46704>>>>>        Boolean bTots
46704>>>>>        String  sTot
46704>>>>>        
46704>>>>>        // Write Totals if present
46704>>>>>        Move False to bTots
46705>>>>>        
46705>>>>>        For iRow from 0 to (SizeOfArray(tQuery.aPrintFields) - 1)
46711>>>>>>
46711>>>>>            If (tQuery.aPrintFields[iRow].bSum) Move True to bTots
46714>>>>>            If bTots Break
46717>>>>>        Loop
46718>>>>>>
46718>>>>>        
46718>>>>>        If bTots Begin
46720>>>>>            
46720>>>>>            For iRow from 0 to (SizeOfArray(tLay.aParts) - 1)
46726>>>>>>
46726>>>>>                Send AddOpenElement of oWqXml "tr" ""
46727>>>>>                
46727>>>>>                For iCol from 0 to (SizeOfArray(tLay.aParts[iRow].aColumns) - 1)
46733>>>>>>
46733>>>>>                    
46733>>>>>                    If (tLay.aParts[iRow].aColumns[iCol].bSum) Begin
46735>>>>>                        Move (NumberToString(oStringFunctions, ;                                             tLay.aParts[iRow].aColumns[iCol].anSum[0], ;                                             tLay.aParts[iRow].aColumns[iCol].iDecimals)) to sTot
46736>>>>>                        Send AddOpenElement of oWqXml "td"
46737>>>>>                        Send AddAttribute   of oWqXml "style" "text-align: right;"
46738>>>>>                        Send AddElement     of oWqXml "hr" ""
46739>>>>>                        Send AddElement     of oWqXml "b"  sTot
46740>>>>>                        Send CloseElement   of oWqXml  // b
46741>>>>>                    End
46741>>>>>>
46741>>>>>                    Else Send AddElement of oWqXml "td" ""
46743>>>>>                    
46743>>>>>                Loop
46744>>>>>>
46744>>>>>                
46744>>>>>                Move (tLay.iMaxCols - SizeOfArray(tLay.aParts[iRow].aColumns) - 1) to iPad
46745>>>>>                
46745>>>>>                If iPad Begin
46747>>>>>                    Send AddElement of oWqXml "td" ""
46748>>>>>                    Send AddAttribute of oWqXml "colspan" iPad
46749>>>>>                End
46749>>>>>>
46749>>>>>                
46749>>>>>                Send CloseElement of oWqXml  // tr
46750>>>>>            Loop
46751>>>>>>
46751>>>>>            
46751>>>>>        End
46751>>>>>>
46751>>>>>        
46751>>>>>        // Write end of table
46751>>>>>        Send CloseElement of oWqXml  // table
46752>>>>>    End_Procedure
46753>>>>>    
46753>>>>>    Procedure WriteTextTotals wqWebQuery ByRef tQuery wqPrintRowLayout ByRef tLay Integer iChn
46755>>>>>        Integer iRow iCol iPad
46755>>>>>        Boolean bTots
46755>>>>>        String  sTot
46755>>>>>        
46755>>>>>        // Write Totals if present
46755>>>>>        Move False to bTots
46756>>>>>        
46756>>>>>        For iRow from 0 to (SizeOfArray(tQuery.aPrintFields) - 1)
46762>>>>>>
46762>>>>>            If (tQuery.aPrintFields[iRow].bSum) Move True to bTots
46765>>>>>            If bTots Break
46768>>>>>        Loop
46769>>>>>>
46769>>>>>        
46769>>>>>        If bTots Begin
46771>>>>>            
46771>>>>>            For iRow from 0 to (SizeOfArray(tLay.aParts) - 1)
46777>>>>>>
46777>>>>>                Write channel iChn (Repeat("   ", iRow))
46779>>>>>                
46779>>>>>                For iCol from 0 to (SizeOfArray(tLay.aParts[iRow].aColumns) - 1)
46785>>>>>>
46785>>>>>                    If (iCol > 0) Write channel iChn "  "
46789>>>>>
46789>>>>>                    If (tLay.aParts[iRow].aColumns[iCol].bSum) Begin
46791>>>>>                        Write channel iChn (Repeat("=", tLay.aParts[iRow].aColumns[iCol].iPrintWidth))
46793>>>>>                    End
46793>>>>>>
46793>>>>>                    Else Write channel iChn (Repeat(" ", tLay.aParts[iRow].aColumns[iCol].iPrintWidth))
46796>>>>>                    
46796>>>>>                Loop
46797>>>>>>
46797>>>>>                
46797>>>>>                WriteLn channel iChn
46799>>>>>//            Loop
46799>>>>>//
46799>>>>>//            For iRow from 0 to (SizeOfArray(tLay.aParts) - 1)
46799>>>>>                Write channel iChn (Repeat("   ", iRow))
46801>>>>>                
46801>>>>>                For iCol from 0 to (SizeOfArray(tLay.aParts[iRow].aColumns) - 1)
46807>>>>>>
46807>>>>>                    If (iCol > 0) Write channel iChn "  "
46811>>>>>
46811>>>>>                    If (tLay.aParts[iRow].aColumns[iCol].bSum) Begin
46813>>>>>                        Move (NumberToStringRTS(oStringFunctions, ;                                             tLay.aParts[iRow].aColumns[iCol].anSum[0], ;                                             tLay.aParts[iRow].aColumns[iCol].iDecimals, ;                                             tLay.aParts[iRow].aColumns[iCol].iPrintWidth)) to sTot
46814>>>>>                        Write channel iChn (Repeat(" ", (tLay.aParts[iRow].aColumns[iCol].iPrintWidth - Length(sTot))))
46816>>>>>                        Write channel iChn sTot
46818>>>>>                    End
46818>>>>>>
46818>>>>>                    Else Write channel iChn (Repeat(" ", (tLay.aParts[iRow].aColumns[iCol].iPrintWidth)))
46821>>>>>                    
46821>>>>>                Loop
46822>>>>>>
46822>>>>>                
46822>>>>>                WriteLn channel iChn
46824>>>>>            Loop
46825>>>>>>
46825>>>>>            
46825>>>>>        End
46825>>>>>>
46825>>>>>        
46825>>>>>    End_Procedure
46826>>>>>    
46826>>>>>    Procedure WriteHtmlEnd wqWebQuery ByRef tQuery wqPrintRowLayout ByRef tLay Integer iChn
46828>>>>>        Integer i
46828>>>>>        
46828>>>>>        Send Stream of oWqXml ""
46829>>>>>        
46829>>>>>        If (tQuery.bPrintSels) Begin
46831>>>>>            
46831>>>>>            If ((SizeOFArray(tQuery.aSelections) = 0) and ;                (tQuery.sSelectExpression = "")) Begin
46833>>>>>                WriteLn "No selection criteria applied <br>"
46835>>>>>            End
46835>>>>>>
46835>>>>>            Else Begin
46836>>>>>                WriteLn channel iChn "<br>Selection criteria:<br>"
46839>>>>>                
46839>>>>>                For i from 0 to (SizeOfArray(tQuery.aSelections) - 1)
46845>>>>>>
46845>>>>>                    Write (tQuery.aSelections[i].sUserName + ", ")
46846>>>>>                    Write (Lowercase(SelDescFromType(oWqSelectionTypes, tQuery.aSelections[i].sType)))
46847>>>>>                    WriteLn (": " + tQuery.aSelections[i].sValue + "<br>")
46849>>>>>                Loop
46850>>>>>>
46850>>>>>                
46850>>>>>                If (tQuery.sSelectExpression <> "") WriteLn tQuery.sSelectExpression "<br>"
46855>>>>>            End
46855>>>>>>
46855>>>>>            
46855>>>>>        End
46855>>>>>>
46855>>>>>        
46855>>>>>        If (tQuery.bPrintCount) ;            WriteLn channel iChn ("<br>Records:" *  NumberToString(oStringFunctions, tLay.iCount, 0) + "<br>")
46860>>>>>                
46860>>>>>        If (tQuery.sTextAfter <> "") WriteLn channel iChn  ("<br>" + Replaces(Character(10), tQuery.sTextAfter, "<br>"))
46865>>>>>        
46865>>>>>        If (tQuery.bGeneratedLine) Begin
46867>>>>>            Send AddElement of oWqXml "p" ("Generated on:" * String(SystemDate(oDateFunctions)) + "," * SystemTimeString(oDateFunctions))
46868>>>>>            Send AddAttribute of oWqXml "style" "text-align: center; font-size: small"
46869>>>>>        End
46869>>>>>>
46869>>>>>        
46869>>>>>        Send CloseElement of oWqXml  // body
46870>>>>>        Send CloseElement of oWqXml  // html
46871>>>>>        Send EndXml       of oWqXml
46872>>>>>    End_Procedure
46873>>>>>    
46873>>>>>    Procedure WriteTextEnd wqWebQuery ByRef tQuery wqPrintRowLayout ByRef tLay Integer iChn
46875>>>>>        Integer i
46875>>>>>        
46875>>>>>        If (tQuery.bPrintSels) Begin
46877>>>>>            WriteLn channel iChn
46879>>>>>            
46879>>>>>            If ((SizeOFArray(tQuery.aSelections) = 0) and ;                (tQuery.sSelectExpression = "")) Begin
46881>>>>>                WriteLn channel iChn "No selection criteria applied"
46884>>>>>            End
46884>>>>>>
46884>>>>>            Else Begin
46885>>>>>                WriteLn channel iChn "Selection criteria:"
46888>>>>>                
46888>>>>>                For i from 0 to (SizeOfArray(tQuery.aSelections) - 1)
46894>>>>>>
46894>>>>>                    Write channel iChn (tQuery.aSelections[i].sUserName + ", ")
46896>>>>>                    Write channel iChn (Lowercase(SelDescFromType(oWqSelectionTypes, tQuery.aSelections[i].sType)))
46898>>>>>                    WriteLn channel iChn (": " + tQuery.aSelections[i].sValue)
46901>>>>>                Loop
46902>>>>>>
46902>>>>>                
46902>>>>>                If (tQuery.sSelectExpression <> "") WriteLn channel iChn tQuery.sSelectExpression
46907>>>>>            End
46907>>>>>>
46907>>>>>            
46907>>>>>        End
46907>>>>>>
46907>>>>>        
46907>>>>>        If (tQuery.bPrintCount) Begin
46909>>>>>            WriteLn channel iChn 
46911>>>>>            WriteLn channel iChn ("Records:" *  NumberToString(oStringFunctions, tLay.iCount, 0))
46914>>>>>        End
46914>>>>>>
46914>>>>>        
46914>>>>>        If (tQuery.sTextAfter <> "") Begin
46916>>>>>            WriteLn channel iChn 
46918>>>>>            WriteLn channel iChn tQuery.sTextAfter
46921>>>>>        End
46921>>>>>>
46921>>>>>        
46921>>>>>        If (tQuery.bGeneratedLine) Begin
46923>>>>>            WriteLn channel iChn 
46925>>>>>            WriteLn channel iChn ("Generated on:" * String(SystemDate(oDateFunctions)) + "," * SystemTimeString(oDateFunctions))
46928>>>>>        End
46928>>>>>>
46928>>>>>        
46928>>>>>    End_Procedure
46929>>>>>    
46929>>>>>    Procedure WriteXmlEnd
46931>>>>>        Send CloseElement of oWqXml  // root
46932>>>>>        Send EndXml       of oWqXml
46933>>>>>    End_Procedure
46934>>>>>    
46934>>>>>    Procedure StartOutput wqWebQuery ByRef tQuery wqPrintRowLayout ByRef tLay Integer iChn
46936>>>>>        
46936>>>>>        If (tQuery.iOutputFormat = C_wqOutputHtml) Begin
46938>>>>>            Send WriteHtmlStart (&tQuery) iChn
46939>>>>>            Send WriteStartTable (&tQuery) (&tLay) 
46940>>>>>        End
46940>>>>>>
46940>>>>>        Else If (tQuery.iOutputFormat = C_wqOutputCSV) Begin
46943>>>>>            Send WriteCSVStart (&tQuery) (&tLay) iChn
46944>>>>>        End
46944>>>>>>
46944>>>>>        Else If (tQuery.iOutputFormat = C_wqOutputText) Begin
46947>>>>>            Send WriteTextStart (&tQuery) (&tLay) iChn
46948>>>>>        End
46948>>>>>>
46948>>>>>        Else If (tQuery.iOutputFormat = C_wqOutputXML) Begin
46951>>>>>            Send WriteXmlStart (&tQuery) (&tLay) iChn
46952>>>>>        End
46952>>>>>>
46952>>>>>        
46952>>>>>    End_Procedure
46953>>>>>    
46953>>>>>    Function BreakLevel wqBreakpoint[] ByRef aBreaks Returns Integer
46955>>>>>        Integer i
46955>>>>>        String  sVal
46955>>>>>        
46955>>>>>        For i from 0 to (SizeOfArray(aBreaks) - 1)
46961>>>>>>
46961>>>>>            Get_Field_Value aBreaks[i].iTable aBreaks[i].iColumn to sVal
46964>>>>>            If (sVal <> aBreaks[i].sPrevValue) Function_Return i
46967>>>>>        Loop
46968>>>>>>
46968>>>>>        
46968>>>>>        Function_Return -1
46969>>>>>    End_Function
46970>>>>>    
46970>>>>>    Procedure HtmlBreak wqPrintRowLayout ByRef tLay String sOutput Integer iLevel
46972>>>>>        Send AddOpenElement of oWqXml "tr"
46973>>>>>        Send AddOpenElement of oWqXml "td"
46974>>>>>        Send AddAttribute   of oWqXml "colspan" tLay.iMaxCols
46975>>>>>        Send AddElement     of oWqXml ("h" + String(iLevel + 2)) sOutput
46976>>>>>        Send CloseElement   of oWqXml  // td
46977>>>>>        Send CloseElement   of oWqXml  // tr
46978>>>>>    End_Procedure
46979>>>>>    
46979>>>>>    Procedure TextBreak wqPrintRowLayout ByRef tLay String sOutput Integer iLevel
46981>>>>>        Integer iChn
46981>>>>>        
46981>>>>>        Get piChannel to iChn
46982>>>>>        Move (Trim(sOutput)) to sOutput
46983>>>>>        WriteLn
46984>>>>>        Write channel iChn (Repeat("   ", iLevel))
46986>>>>>        WriteLn channel iChn sOutput
46989>>>>>        Write channel iChn (Repeat("   ", iLevel))
46991>>>>>        WriteLn channel iChn (Repeat("=", Length(sOutput)))
46994>>>>>    End_Procedure
46995>>>>>    
46995>>>>>    Procedure DoBreaks wqWebQuery ByRef tQuery wqPrintRowLayout ByRef tLay wqBreakpoint[] ByRef aBreaks Integer iLevel
46997>>>>>        Integer i j iPrev
46997>>>>>        String  sVal sName sOutput
46997>>>>>        Boolean bAddIn
46997>>>>>        wqBreakpoint tThisBreak tPrevBreak
46997>>>>>        wqBreakpoint tThisBreak tPrevBreak
46997>>>>>        
46997>>>>>        For i from iLevel to (SizeOfArray(aBreaks) - 1)
47003>>>>>>
47003>>>>>            
47003>>>>>            If (i > 0) Begin
47005>>>>>                Move aBreaks[i]     to tThisBreak
47006>>>>>                Move aBreaks[i - 1] to tPrevBreak
47007>>>>>                Move False          to bAddIn
47008>>>>>                Move ""             to sOutput
47009>>>>>                
47009>>>>>                For j from 0 to (SizeOfArray(tQuery.aSegments) - 1)
47015>>>>>>
47015>>>>>                    If (tQuery.aSegments[j].bBreak and ;                        (tQuery.aSegments[j].iTable = tThisBreak.iTable) and ;                        (tQuery.aSegments[j].iField = tThisBreak.iColumn)) Break
47018>>>>>                    
47018>>>>>                    If bAddIn Begin
47020>>>>>                        Get_Field_Value tQuery.aSegments[j].iTable tQuery.aSegments[j].iField to sVal
47023>>>>>                        If (sOutput <> "") Move (sOUtput + ", ") to sOutput
47026>>>>>                        Move (sOutput + tQuery.aSegments[j].sName * sVal) to sOutput
47027>>>>>                    End
47027>>>>>>
47027>>>>>                    
47027>>>>>                    If (tQuery.aSegments[j].bBreak and ;                        (tQuery.aSegments[j].iTable = tPrevBreak.iTable) and ;                        (tQuery.aSegments[j].iField = tPrevBreak.iColumn)) Move True to bAddIn
47030>>>>>                    
47030>>>>>                Loop
47031>>>>>>
47031>>>>>                
47031>>>>>            End
47031>>>>>>
47031>>>>>            
47031>>>>>            Get_Field_Value aBreaks[i].iTable aBreaks[i].iColumn to sVal
47034>>>>>            If (sOutput <> "") Move (sOutput + ", ") to sOutput
47037>>>>>            Move (sOutput + aBreaks[i].sName * sVal) to sOutput
47038>>>>>            
47038>>>>>            If (tQuery.iOutputFormat = C_wqOutputHtml) Begin
47040>>>>>                Send HtmlBreak (&tLay) sOutput i
47041>>>>>            End
47041>>>>>>
47041>>>>>            Else If (tQuery.iOutputFormat = C_wqOutputText) Begin
47044>>>>>                Send TextBreak (&tLay) sOutput i
47045>>>>>            End
47045>>>>>>
47045>>>>>            
47045>>>>>            Move sVal to aBreaks[i].sPrevValue
47046>>>>>        Loop
47047>>>>>>
47047>>>>>        
47047>>>>>    End_Procedure
47048>>>>>    
47048>>>>>    Procedure HtmlSubTotal wqPrintRowPart ByRef tRow Integer iLev
47050>>>>>        String  sTot
47050>>>>>        Integer iCol
47050>>>>>        
47050>>>>>        Send AddOpenElement of oWqXml "tr" ""
47051>>>>>            
47051>>>>>        For iCol from 0 to (SizeOfArray(tRow.aColumns) - 1)
47057>>>>>>
47057>>>>>            
47057>>>>>            If (tRow.aColumns[iCol].bSum) Begin
47059>>>>>                Move (NumberToString(oStringFunctions, ;                                     tRow.aColumns[iCol].anSum[iLev], ;                                     tRow.aColumns[iCol].iDecimals)) to sTot
47060>>>>>                Send AddOpenElement of oWqXml "td"
47061>>>>>                Send AddAttribute   of oWqXml "style" "text-align: right;"
47062>>>>>                Send AddElement     of oWqXml "hr" ""
47063>>>>>                Send AddElement     of oWqXml "b"  sTot
47064>>>>>                Move 0 to tRow.aColumns[iCol].anSum[iLev]
47065>>>>>                Send CloseElement   of oWqXml  // td
47066>>>>>            End
47066>>>>>>
47066>>>>>            Else Send AddElement of oWqXml "td" ""
47068>>>>>            
47068>>>>>        Loop
47069>>>>>>
47069>>>>>        
47069>>>>>        Send CloseElement of oWqXml  // tr
47070>>>>>    End_Procedure
47071>>>>>    
47071>>>>>    Procedure TextSubTotal wqPrintRowPart ByRef tRow Integer iLev Integer iRow
47073>>>>>        String  sTot
47073>>>>>        Integer iCol iChn
47073>>>>>        
47073>>>>>        Get piChannel to iChn
47074>>>>>        
47074>>>>>        Write Channel iChn (Repeat("   ", iRow))
47076>>>>>        
47076>>>>>        For iCol from 0 to (SizeOfArray(tRow.aColumns) - 1)
47082>>>>>>
47082>>>>>            
47082>>>>>            If (tRow.aColumns[iCol].bSum) Begin
47084>>>>>                Write channel iChn (Repeat("-", tRow.aColumns[iCol].iPrintWidth))
47086>>>>>            End
47086>>>>>>
47086>>>>>            Else Begin
47087>>>>>               Write channel iChn (Repeat(" ", (tRow.aColumns[iCol].iPrintWidth + 2)))
47089>>>>>            End
47089>>>>>>
47089>>>>>            
47089>>>>>        Loop
47090>>>>>>
47090>>>>>        
47090>>>>>        WriteLn channel iChn
47092>>>>>        Write Channel iChn (Repeat("   ", iRow))
47094>>>>>        
47094>>>>>        For iCol from 0 to (SizeOfArray(tRow.aColumns) - 1)
47100>>>>>>
47100>>>>>            
47100>>>>>            If (tRow.aColumns[iCol].bSum) Begin
47102>>>>>                Move (NumberToStringRTS(oStringFunctions, ;                                     tRow.aColumns[iCol].anSum[iLev], ;                                     tRow.aColumns[iCol].iDecimals, ;                                     tRow.aColumns[iCol].iPrintWidth)) to sTot
47103>>>>>                Write channel iChn (Repeat(" ", (tRow.aColumns[iCol].iPrintWidth - Length(sTot)))) sTot
47106>>>>>                Move 0 to tRow.aColumns[iCol].anSum[iLev]
47107>>>>>            End
47107>>>>>>
47107>>>>>            Else Begin 
47108>>>>>               Write channel iChn (Repeat(" ", (tRow.aColumns[iCol].iPrintWidth + 2)))
47110>>>>>            End
47110>>>>>>
47110>>>>>            
47110>>>>>        Loop
47111>>>>>>
47111>>>>>        
47111>>>>>        WriteLn channel iChn
47113>>>>>    End_Procedure
47114>>>>>
47114>>>>>    Procedure DoSubtotals wqWebQuery ByRef tQuery wqPrintRowLayout ByRef tLay wqBreakpoint[] ByRef aBreaks Integer iLevel
47116>>>>>        Integer i iLast iLev iRow iCol
47116>>>>>        String  sTot
47116>>>>>        
47116>>>>>        Move (SizeOfArray(aBreaks) - 1) to iLast
47117>>>>>        
47117>>>>>        For i from 0 to (iLast - iLevel)
47123>>>>>>
47123>>>>>            Move (iLast - i + 1) to iLev
47124>>>>>            
47124>>>>>            For iRow from 0 to (SizeOfArray(tLay.aParts) - 1)
47130>>>>>>
47130>>>>>                
47130>>>>>                If (tQuery.iOutputFormat = C_wqOutputHtml) Begin
47132>>>>>                    Send AddOpenElement of oWqXml "tr" ""
47133>>>>>                    Send HtmlSubTotal (&tLay.aParts[iRow]) iLev
47134>>>>>                    Send CloseElement of oWqXml  // tr
47135>>>>>                End
47135>>>>>>
47135>>>>>                Else If (tQuery.iOutputFormat = C_wqOutputText) Begin
47138>>>>>                    Send TextSubTotal (&tLay.aParts[iRow]) iLev iRow
47139>>>>>                End
47139>>>>>>
47139>>>>>                
47139>>>>>            Loop
47140>>>>>>
47140>>>>>            
47140>>>>>        Loop
47141>>>>>>
47141>>>>>        
47141>>>>>    End_Procedure
47142>>>>>    
47142>>>>>    Procedure OutputHtmlRow wqWebQuery ByRef tQuery wqPrintRowLayout ByRef tLay Boolean bHighlight
47144>>>>>        Integer iRow iCol iPad iChn
47144>>>>>        String  sVal sText
47144>>>>>
47144>>>>>        Get piChannel to iChn
47145>>>>>        
47145>>>>>        For iRow from 0 to (SizeOfArray(tLay.aParts) - 1)
47151>>>>>>
47151>>>>>            Send AddOpenElement of oWqXml "tr"
47152>>>>>            If bHighlight Send AddAttribute of oWqXml "style" ("background-color:" * tQuery.sHighlightColour)
47155>>>>>            
47155>>>>>            For iCol from 0 to (SizeOfArray(tLay.aParts[iRow].aColumns) - 1)
47161>>>>>>
47161>>>>>                Move tLay.aParts[iRow].aColumns[iCol].sCurVal to sVal
47162>>>>>                
47162>>>>>                If (tLay.aParts[iRow].aColumns[iCol].iType = DF_BCD) ;                     Move (NumberToString(oStringFunctions, sVal, tLay.aParts[iRow].aColumns[iCol].iDecimals))  to sText
47165>>>>>                Else Move sVal                                                                                  to sText
47167>>>>>                
47167>>>>>                If (pbAllowRawOutput(ghoWebQry)) Begin
47169>>>>>                    Send AddOpenElement of oWqXml "td"
47170>>>>>                    If      (tLay.aParts[iRow].aColumns[iCol].iType = DF_BCD)  Send AddAttribute of oWqXml "style" "text-align: right"
47173>>>>>                    Else If (tLay.aParts[iRow].aColumns[iCol].iType = DF_DATE) Send AddAttribute of oWqXml "style" "text-align: center"
47177>>>>>                    Send Stream of oWqXml ""
47178>>>>>                    Write channel iChn sText
47180>>>>>                    Send CloseElement of oWqXml
47181>>>>>                End
47181>>>>>>
47181>>>>>                Else Begin
47182>>>>>                    Send AddElement of oWqXml "td" sText
47183>>>>>                    If      (tLay.aParts[iRow].aColumns[iCol].iType = DF_BCD)  Send AddAttribute of oWqXml "style" "text-align: right"
47186>>>>>                    Else If (tLay.aParts[iRow].aColumns[iCol].iType = DF_DATE) Send AddAttribute of oWqXml "style" "text-align: center"
47190>>>>>                End
47190>>>>>>
47190>>>>>            Loop
47191>>>>>>
47191>>>>>            
47191>>>>>            Move (tLay.iMaxCols - SizeOfArray(tLay.aParts[iRow].aColumns) - 1) to iPad
47192>>>>>            
47192>>>>>            If iPad Begin
47194>>>>>                Send AddElement of oWqXml "td" ""  // possibly "&nbsp;" is more correct, but also more HTML
47195>>>>>                Send AddAttribute of oWqXml "colspan" iPad
47196>>>>>            End
47196>>>>>>
47196>>>>>            
47196>>>>>            Send CloseElement of oWqXml  // tr
47197>>>>>        Loop
47198>>>>>>
47198>>>>>        
47198>>>>>    End_Procedure
47199>>>>>    
47199>>>>>    Procedure OutputTextRow wqWebQuery ByRef tQuery wqPrintRowLayout ByRef tLay
47201>>>>>        Integer iRow iCol iChn
47201>>>>>        
47201>>>>>        Get piChannel to iChn
47202>>>>>        
47202>>>>>        For iRow from 0 to (SizeOfArray(tLay.aParts) - 1)
47208>>>>>>
47208>>>>>            Write channel iChn (Repeat("   ", iRow))
47210>>>>>            
47210>>>>>            For iCol from 0 to (SizeOfArray(tLay.aParts[iRow].aColumns) - 1)
47216>>>>>>
47216>>>>>                If (iCol > 0) Write channel iChn "  "
47220>>>>>                
47220>>>>>                If (tLay.aParts[iRow].aColumns[iCol].iType = DF_BCD) Begin
47222>>>>>                    Write channel iChn (NumberToStringRTS(oStringFunctions, ;                                                          tLay.aParts[iRow].aColumns[iCol].sCurVal, ;                                                          tLay.aParts[iRow].aColumns[iCol].iDecimals, ;                                                          tLay.aParts[iRow].aColumns[iCol].iPrintWidth))
47224>>>>>                End
47224>>>>>>
47224>>>>>                Else Begin
47225>>>>>                    Write channel iChn (Pad(tLay.aParts[iRow].aColumns[iCol].sCurVal, tLay.aParts[iRow].aColumns[iCol].iPrintWidth))
47227>>>>>                End
47227>>>>>>
47227>>>>>                    
47227>>>>>            Loop
47228>>>>>>
47228>>>>>            
47228>>>>>            WriteLn channel iChn
47230>>>>>        Loop
47231>>>>>>
47231>>>>>
47231>>>>>    End_Procedure
47232>>>>>    
47232>>>>>    Procedure OutputCSVRow wqWebQuery ByRef tQuery wqPrintRowLayout ByRef tLay
47234>>>>>        Integer iRow iCol iChn
47234>>>>>        
47234>>>>>        Get piChannel to iChn
47235>>>>>        
47235>>>>>        For iRow from 0 to (SizeOfArray(tLay.aParts) - 1)
47241>>>>>>
47241>>>>>            
47241>>>>>            For iCol from 0 to (SizeOfArray(tLay.aParts[iRow].aColumns) - 1)
47247>>>>>>
47247>>>>>                If (iCol > 0) Write channel iChn ","
47251>>>>>                
47251>>>>>                If ((tLay.aParts[iRow].aColumns[iCol].iType = DF_ASCII) or ;                    (tLay.aParts[iRow].aColumns[iCol].iType = DF_TEXT)) Begin
47253>>>>>                    Write channel iChn '"'
47255>>>>>                    Write channel iChn (Replaces('"', tLay.aParts[iRow].aColumns[iCol].sCurVal, "'"))
47257>>>>>                    Write channel iChn '"'
47259>>>>>                End
47259>>>>>>
47259>>>>>                Else Write channel iChn tLay.aParts[iRow].aColumns[iCol].sCurVal    
47262>>>>>            Loop
47263>>>>>>
47263>>>>>            
47263>>>>>            WriteLn channel iChn
47265>>>>>        Loop
47266>>>>>>
47266>>>>>
47266>>>>>    End_Procedure
47267>>>>>    
47267>>>>>    Procedure OutputXmlRow wqWebQuery ByRef tQuery wqPrintRowLayout ByRef tLay
47269>>>>>        Integer iRow iCol
47269>>>>>        
47269>>>>>        For iRow from 0 to (SizeOfArray(tLay.aParts) - 1)
47275>>>>>>
47275>>>>>            Send AddOpenElement of oWqXml "record"
47276>>>>>            
47276>>>>>            For iCol from 0 to (SizeOfArray(tLay.aParts[iRow].aColumns) - 1)
47282>>>>>>
47282>>>>>                Send AddElement of oWqXml (XmlTag(Self, tLay.aParts[iRow].aColumns[iCol].sName)) tLay.aParts[iRow].aColumns[iCol].sCurVal
47283>>>>>            Loop
47284>>>>>>
47284>>>>>            
47284>>>>>            Send CloseElement of oWqXml  // record
47285>>>>>        Loop
47286>>>>>>
47286>>>>>        
47286>>>>>    End_Procedure
47287>>>>>    
47287>>>>>    Procedure OutputRow wqWebQuery ByRef tQuery wqPrintRowLayout ByRef tLay wqBreakpoint[] ByRef aBreaks Boolean bHighlight
47289>>>>>        Integer iRow iCol i iBrLev
47289>>>>>        String  sVal
47289>>>>>        tXPGrammar tExpGram
47289>>>>>        tXPGrammar tExpGram
47289>>>>>        tXPToken[] aExpSyms
47289>>>>>        tXPToken[] aExpSyms
47290>>>>>        tXPError   tExpErr
47290>>>>>        tXPError   tExpErr
47290>>>>>        tXPValue   tExpRes
47290>>>>>        tXPValue   tExpRes
47290>>>>>        
47290>>>>>        Get BreakLevel (&aBreaks) to iBrLev
47291>>>>>        
47291>>>>>        If (iBrLev > -1) Begin
47293>>>>>            If (tLay.iCount > 0) Send DoSubtotals (&tQuery) (&tLay) (&aBreaks) iBrLev
47296>>>>>            Send DoBreaks (&tQuery) (&tLay) (&aBreaks) iBrLev
47297>>>>>        End
47297>>>>>>
47297>>>>>
47297>>>>>        Increment tLay.iCount
47298>>>>>        
47298>>>>>        // Get values and add in to any totals
47298>>>>>        For iRow from 0 to (SizeOfArray(tLay.aParts) - 1)
47304>>>>>>
47304>>>>>            
47304>>>>>            For iCol from 0 to (SizeOfArray(tLay.aParts[iRow].aColumns) - 1)
47310>>>>>>
47310>>>>>                
47310>>>>>                If (tLay.aParts[iRow].aColumns[iCol].bCalc) Begin
47312>>>>>                    Get NewGrammar            of oWqExprPar                              to tExpGram
47313>>>>>                    Get TokenizeString        of oWqExprPar tExpGram tLay.aParts[iRow].aColumns[iCol].sExpr (&tExpErr) ;                                                                                         to aExpSyms
47314>>>>>                    Get ReversePolishNotation of oWqExprPar tExpGram aExpSyms (&tExpErr) to aExpSyms
47315>>>>>                    Get Evaluate              of oWqExprPar tExpGram aExpSyms (&tExpErr) to tExpRes
47316>>>>>                    Move tExpRes.sValue                                                  to sVal
47317>>>>>                End
47317>>>>>>
47317>>>>>                Else Begin
47318>>>>>                    Get_Field_Value tLay.aParts[iRow].aColumns[iCol].iTable ;                                    tLay.aParts[iRow].aColumns[iCol].iColumn to sVal
47321>>>>>                End
47321>>>>>>
47321>>>>>                
47321>>>>>                Move (Trim(sVal)) to tLay.aParts[iRow].aColumns[iCol].sCurVal
47322>>>>>                
47322>>>>>                If ((tLay.aParts[iRow].aColumns[iCol].bSum) and ;                    (tLay.aParts[iRow].aColumns[iCol].iType = DF_BCD)) Begin
47324>>>>>                    
47324>>>>>                    For i from 0 to (SizeOfArray(aBreaks))  // NOT -1 because 0 is the overall total
47330>>>>>>
47330>>>>>                        Move (tLay.aParts[iRow].aColumns[iCol].anSum[i] + ;                              Number(tLay.aParts[iRow].aColumns[iCol].sCurVal)) to ;                              tLay.aParts[iRow].aColumns[iCol].anSum[i]
47331>>>>>                    Loop
47332>>>>>>
47332>>>>>                    
47332>>>>>                End
47332>>>>>>
47332>>>>>                    
47332>>>>>            Loop
47333>>>>>>
47333>>>>>            
47333>>>>>        Loop
47334>>>>>>
47334>>>>>        
47334>>>>>        If Not (tQuery.bTotalsOnly) Begin
47336>>>>>        
47336>>>>>            // For each row send the appropriate format start row
47336>>>>>            If (tQuery.iOutputFormat = C_wqOutputHtml) Begin
47338>>>>>                Send OutputHtmlRow (&tQuery) (&tLay) bHighlight
47339>>>>>            End
47339>>>>>>
47339>>>>>            Else If (tQuery.iOutputFormat = C_wqOutputText) Begin 
47342>>>>>                Send OutputTextRow (&tQuery) (&tLay)
47343>>>>>            End
47343>>>>>>
47343>>>>>            Else If (tQuery.iOutputFormat = C_wqOutputCSV) Begin
47346>>>>>                Send OutputCSVRow (&tQuery) (&tLay)
47347>>>>>            End
47347>>>>>>
47347>>>>>            Else If (tQuery.iOutputFormat = C_wqOutputXML) Begin
47350>>>>>                Send OutputXmlRow (&tQuery) (&tLay)
47351>>>>>            End
47351>>>>>>
47351>>>>>            
47351>>>>>        End
47351>>>>>>
47351>>>>>        
47351>>>>>    End_Procedure
47352>>>>>    
47352>>>>>    Procedure EndOutput wqWebQuery ByRef tQuery wqPrintRowLayout ByRef tLay Integer iChn String sFile
47354>>>>>        
47354>>>>>        If (tQuery.iOutputFormat = C_wqOutputHtml) Begin
47356>>>>>            Send WriteEndTable (&tQuery) (&tLay)
47357>>>>>            If (tQuery.iDestination <> C_wqDownload) Send WriteRemoveScript sFile iChn
47360>>>>>            Send WriteHtmlEnd (&tQuery) (&tLay) iChn
47361>>>>>        End
47361>>>>>>
47361>>>>>        Else If (tQuery.iOutputFormat = C_wqOutputText) Begin
47364>>>>>            Send WriteTextTotals (&tQuery) (&tLay) iChn
47365>>>>>            Send WriteTextEnd    (&tQuery) (&tLay) iChn
47366>>>>>        End
47366>>>>>>
47366>>>>>        Else If (tQuery.iOutputFormat = C_wqOutputXML) Begin
47369>>>>>            Send WriteXmlEnd
47370>>>>>        End
47370>>>>>>
47370>>>>>    
47370>>>>>        Close_Output channel iChn
47372>>>>>        Send Seq_Release_Channel iChn
47373>>>>>    End_Procedure
47374>>>>>    
47374>>>>>    // This handles those filters which TableQuery does not.
47374>>>>>    Function IsExcluded wqWebQuery ByRef tQuery wqSelsForTQ[] ByRef aTQSels Returns Boolean
47376>>>>>        Integer i iType
47376>>>>>        String  sVal
47376>>>>>        
47376>>>>>        For i from 0 to (SizeOfArray(aTQSels) - 1)
47382>>>>>>
47382>>>>>            
47382>>>>>            If not (aTQSels[i].bUseTQ) Begin
47384>>>>>                Get_Field_Value aTQSels[i].Selection.iTable aTQSels[i].Selection.iColumn to sVal
47387>>>>>                
47387>>>>>                If (aTQSels[i].Selection.sType = "CIN") Begin
47389>>>>>                    If (aTQSels[i].Selection.sValue contains sVal) Function_Return True
47392>>>>>                End
47392>>>>>>
47392>>>>>                
47392>>>>>                If (aTQSels[i].Selection.sType = "x-y") Begin
47394>>>>>                    Move aTQSels[i].Selection.iType to iType
47395>>>>>                    
47395>>>>>                    If ((iType = DF_ASCII) or (iType = DF_TEXT)) Begin
47397>>>>>                        If ((sVal < aTQSels[i].sStartR) or ;                            (sVal > aTQSels[i].sEndR)) Function_Return True
47400>>>>>                    End
47400>>>>>>
47400>>>>>                    Else If (iType = DF_BCD) Begin
47403>>>>>                        If ((Number(sVal) < Number(aTQSels[i].sStartR)) or ;                            (Number(sVal) > Number(aTQSels[i].sEndR))) Function_Return True
47406>>>>>                    End
47406>>>>>>
47406>>>>>                    Else If ((iType = DF_DATE) or (iType = DF_DATETIME)) Begin
47409>>>>>                        If ((Date(sVal) < Date(aTQSels[i].sStartR)) or ;                            (Date(sVal) > Date(aTQSels[i].sEndR))) Function_Return True
47412>>>>>                    End
47412>>>>>>
47412>>>>>                    
47412>>>>>                End
47412>>>>>>
47412>>>>>                
47412>>>>>                If (aTQSels[i].Selection.sType = "CBT") Begin
47414>>>>>                    Move aTQSels[i].Selection.iType to iType
47415>>>>>                    
47415>>>>>                    If ((iType = DF_ASCII) or (iType = DF_TEXT)) Begin
47417>>>>>                        If ((sVal >= aTQSels[i].sStartR) or ;                            (sVal <= aTQSels[i].sEndR)) Function_Return True
47420>>>>>                    End
47420>>>>>>
47420>>>>>                    Else If (iType = DF_BCD) Begin
47423>>>>>                        If ((Number(sVal) >= Number(aTQSels[i].sStartR)) or ;                            (Number(sVal) <= Number(aTQSels[i].sEndR))) Function_Return True
47426>>>>>                    End
47426>>>>>>
47426>>>>>                    Else If ((iType = DF_DATE) or (iType = DF_DATETIME)) Begin
47429>>>>>                        If ((Date(sVal) >= Date(aTQSels[i].sStartR)) or ;                            (Date(sVal) <= Date(aTQSels[i].sEndR))) Function_Return True
47432>>>>>                    End
47432>>>>>>
47432>>>>>                    
47432>>>>>                End
47432>>>>>>
47432>>>>>                
47432>>>>>            End
47432>>>>>>
47432>>>>>            
47432>>>>>        Loop
47433>>>>>>
47433>>>>>        
47433>>>>>        Function_Return False
47434>>>>>    End_Function
47435>>>>>    
47435>>>>>    Procedure ProcessRecords wqWebQuery ByRef tQuery tTableQuery ByRef tTQ wqSelsForTQ[] ByRef aTQSels wqBreakpoint[] ByRef aBreaks wqPrintRowLayout ByRef tLay
47437>>>>>        Boolean bSkipRec bHighlight
47437>>>>>        tXPGrammar tSelGram
47437>>>>>        tXPGrammar tSelGram
47437>>>>>        tXPToken[] aSelSyms
47437>>>>>        tXPToken[] aSelSyms
47438>>>>>        tXPError   tSelErr
47438>>>>>        tXPError   tSelErr
47438>>>>>        tXPValue   tSelRes
47438>>>>>        tXPValue   tSelRes
47438>>>>>        
47438>>>>>        // Prepare select expression
47438>>>>>        If (tQuery.sSelectExpression <> "") Begin
47440>>>>>            Get NewGrammar of oWqExprPar                                                  to tSelGram
47441>>>>>            Get TokenizeString of oWqExprPar tSelGram tQuery.sSelectExpression (&tSelErr) to aSelSyms
47442>>>>>            Get ReversePolishNotation of oWqExprPar tSelGram aSelSyms  (&tSelErr)         to aSelSyms
47443>>>>>        End
47443>>>>>>
47443>>>>>
47443>>>>>        If not (tQuery.bUseSQL) Begin
47445>>>>>            Send ForceNoESQL of oTQ (&tTQ) 5000 5000
47446>>>>>        End
47446>>>>>>
47446>>>>>        
47446>>>>>        // The TableQuery loop
47446>>>>>        While (FindRecord(oTQ, &tTQ))
47450>>>>>            Move False to bSkipRec
47451>>>>>        
47451>>>>>            Get IsExcluded tQuery aTQSels to bSkipRec
47452>>>>>            
47452>>>>>            If (Not(bSkipRec) and  (tQuery.sSelectExpression <> "")) Begin
47454>>>>>                Get Evaluate of oWqExprPar tSelGram aSelSyms (&tSelErr) to tSelRes
47455>>>>>                Move (Not(tSelRes.sValue))                              to bSkipRec
47456>>>>>            End
47456>>>>>>
47456>>>>>            
47456>>>>>            If not bSkipRec Begin
47458>>>>>                Move (tQuery.bHighlightAlt and (Mod(tLay.iCount, 2) <> 0)) to bHighlight                
47459>>>>>                Send OutputRow (&tQuery) (&tLay) (&aBreaks) bHighlight
47460>>>>>            End
47460>>>>>>
47460>>>>>            
47460>>>>>        Loop
47461>>>>>>
47461>>>>>
47461>>>>>        Send DoSubtotals (&tQuery) (&tLay) (&aBreaks) 0
47462>>>>>    End_Procedure
47463>>>>>    
47463>>>>>    Function OutputReport wqWebQuery ByRef tQuery Returns String
47465>>>>>        String  sFile sPath
47465>>>>>        Integer iChn
47465>>>>>        Boolean bSkipRec
47465>>>>>        Handle[] ahTabs
47466>>>>>        wqPrintRowLayout tLay
47466>>>>>        wqPrintRowLayout tLay
47466>>>>>        tTableQuery tTQ
47466>>>>>        tTableQuery tTQ
47466>>>>>        wqTableDetail[] atTabDets
47466>>>>>        wqTableDetail[] atTabDets
47467>>>>>        wqSelsForTQ[] aTQSels
47467>>>>>        wqSelsForTQ[] aTQSels
47468>>>>>        wqBreakpoint[] aBreaks
47468>>>>>        wqBreakpoint[] aBreaks
47469>>>>>        
47469>>>>>        // Initalisation
47469>>>>>        Set _pbInsertThousandsSeparators of oStringFunctions to True
47470>>>>>        Get OpenOutput tQuery.iDestination tQuery.iOutputFormat (&sPath) (&sFile) to iChn
47471>>>>>        Send SetupBreaks (&tQuery) (&aBreaks)
47472>>>>>        Send CreateLayout (&tQuery) (&tLay) (&aBreaks)
47473>>>>>        Send TableDetails tQuery.hMainTable (&atTabDets) // Opens tables
47474>>>>>        
47474>>>>>        // TableQuery setup
47474>>>>>        Get NewQuery of oTQ tQuery.hMainTable to tTQ
47475>>>>>        Send AddTqRelations (&tTQ) tQuery.hMainTable (&ahTabs)
47476>>>>>        Send AddSelections (&tQuery) (&tTQ) (&aTQSels)
47477>>>>>        Send AddOrdering (&tQuery.aSegments) (&tTQ)
47478>>>>>        
47478>>>>>        // Output report
47478>>>>>        Send StartOutput (&tQuery) (&tLay) iChn
47479>>>>>        Send ProcessRecords (&tQuery) (&tTQ) (&aTQSels) (&aBreaks) (&tLay) iChn
47480>>>>>        Send EndOutput (&tQuery) (&tLay) iChn sFile
47481>>>>>        
47481>>>>>        // Return file for URL
47481>>>>>        Function_Return sFile
47482>>>>>    End_Function
47483>>>>>    
47483>>>>>End_Class
47484>>>>>
47484>>>>>Object oWQFuncs is a cWebQueryFunctions
47486>>>>>    Move Self to ghoWQF
47487>>>>>End_Object
47488>>>Use wqTableSelection.wo
Including file: wqTableSelection.wo    (Z:\VmShare\Projects\WebQuery18-0\AppSrc\wqTableSelection.wo)
47488>>>>>Use cWebModalDialog
47488>>>>>Use cWebPanel.pkg
47488>>>>>Use cWebButton.pkg
47488>>>>>Use cWebForm.pkg
47488>>>>>Use cWebList.pkg
47488>>>>>Use cWebColumn.pkg
47488>>>>>Use cWebQueryFunctions.pkg
47488>>>>>
47488>>>>>Object oWqTableSelection is a cWebModalDialog
47490>>>>>    Set psCaption to "Select Table"
47491>>>>>    Set piMinWidth to 800
47492>>>>>    Set piMinHeight to 500
47493>>>>>    Set pbServerOnSubmit to true    // enable the OnSubmit event
47494>>>>>    Set pbServerOnShow to True
47495>>>>>    
47495>>>>>    Object oMainPanel is a cWebPanel
47497>>>>>        Set piColumnCount to 10
47498>>>>>
47498>>>>>        Object oTablesList is a cWebList
47500>>>>>            Set pbFillHeight to True
47501>>>>>            Set pbDataAware  to False
47502>>>>>            
47502>>>>>            Object oNumCol is a cWebColumn
47504>>>>>                Set psCaption to "Num"
47505>>>>>                Set piWidth to 5
47506>>>>>                Set peDataType to typeNumber
47507>>>>>            End_Object
47508>>>>>            
47508>>>>>            Object oDipCol is a cWebColumn
47510>>>>>                Set psCaption to "Display Name"
47511>>>>>                Set piWidth to 45
47512>>>>>            End_Object
47513>>>>>            
47513>>>>>            Object oDFCol is a cWebColumn
47515>>>>>                Set psCaption to "DF Name"
47516>>>>>                Set piWidth to 15
47517>>>>>            End_Object
47518>>>>>            
47518>>>>>            Object oRootCol is a cWebColumn
47520>>>>>                Set psCaption to "Root Name"
47521>>>>>                Set piWidth to 35
47522>>>>>            End_Object
47523>>>>>            
47523>>>>>            Procedure OnManualLoadData tWebRow[] ByRef aTheRows String ByRef sCurrentRowID
47526>>>>>                wqTableInfo[] tTabs
47526>>>>>                wqTableInfo[] tTabs
47527>>>>>                Integer i
47527>>>>>                
47527>>>>>                Get TableInfo of ghoWQF to tTabs
47528>>>>>                
47528>>>>>                For i from 0 to (SizeOFArray(tTabs) - 1)
47534>>>>>>
47534>>>>>                    Move tTabs[i].iNum      to aTheRows[i].sRowID
47535>>>>>                    Move tTabs[i].iNum      to aTheRows[i].aCells[0].sValue
47536>>>>>                    Move tTabs[i].sDispName to aTheRows[i].aCells[1].sValue
47537>>>>>                    Move tTabs[i].sDFName   to aTheRows[i].aCells[2].sValue
47538>>>>>                    Move tTabs[i].sRootName to aTheRows[i].aCells[3].sValue
47539>>>>>                Loop
47540>>>>>>
47540>>>>>                
47540>>>>>            End_Procedure  // OnManualLoadData
47541>>>>>            
47541>>>>>        End_Object
47542>>>>>        
47542>>>>>    End_Object 
47543>>>>>    
47543>>>>>    Object oBottomPanel is a cWebPanel
47545>>>>>        Set piColumnCount to 6
47546>>>>>        Set peRegion to prBottom
47547>>>>>
47547>>>>>        Object oOkButton is a cWebButton
47549>>>>>            Set psCaption to C_$OK
47550>>>>>            Set piColumnSpan to 1
47551>>>>>            Set piColumnIndex to 4
47552>>>>>
47552>>>>>            Procedure OnClick
47555>>>>>                Send Ok
47556>>>>>            End_Procedure
47557>>>>>            
47557>>>>>        End_Object 
47558>>>>>
47558>>>>>        Object oCancelButton is a cWebButton
47560>>>>>            Set psCaption to C_$Cancel
47561>>>>>            Set piColumnSpan to 1
47562>>>>>            Set piColumnIndex to 5
47563>>>>>
47563>>>>>            Procedure OnClick
47566>>>>>                Send Cancel
47567>>>>>            End_Procedure
47568>>>>>        End_Object 
47569>>>>>    End_Object 
47570>>>>>
47570>>>>>    Procedure OnSubmit
47573>>>>>        Send Ok
47574>>>>>    End_Procedure
47575>>>>>    
47575>>>>>    Procedure Ok
47578>>>>>        //  Do some calculations / saves / validations here ..
47578>>>>>        Forward Send Ok
47580>>>>>    End_Procedure
47581>>>>>
47581>>>>>    Procedure Cancel
47584>>>>>        Forward Send Cancel
47586>>>>>    End_Procedure
47587>>>>>    
47587>>>>>    Procedure TabListPopup Handle hObj
47590>>>>>        Send Popup hObj
47591>>>>>    End_Procedure  //TabListPopup
47592>>>>>    
47592>>>>>    Procedure OnShow
47595>>>>>        Send GridRefresh of oTablesList
47596>>>>>    End_Procedure  // OnShow
47597>>>>>    
47597>>>>>    Function TableSelected Returns Handle
47600>>>>>        Handle  hTab
47600>>>>>        
47600>>>>>        WebGet psCurrentRowID of oTablesList to hTab
47601>>>>>        Function_Return hTab
47602>>>>>    End_Function  // TableSelected
47603>>>>>    
47603>>>>>End_Object
47604>>>Use wqSelectionOperators.wo
47604>>>Use wqSelectionValues.wo
Including file: wqSelectionValues.wo    (Z:\VmShare\Projects\WebQuery18-0\AppSrc\wqSelectionValues.wo)
47604>>>>>Use cWebModalDialog
47604>>>>>Use cWebPanel.pkg
47604>>>>>Use cWebButton.pkg
47604>>>>>Use cWebForm.pkg
47604>>>>>Use cWebQueryFunctions.pkg
47604>>>>>
47604>>>>>Object oWqSelectionValues is a cWebModalDialog
47606>>>>>    Set psCaption to "Selection Value"
47607>>>>>    Set piMinWidth to 400
47608>>>>>    Set piMinHeight to 60
47609>>>>>    Set pbServerOnSubmit to True
47610>>>>>    
47610>>>>>    Property Integer wpiType
47614>>>>>    
47614>>>>>    Object oMainPanel is a cWebPanel
47616>>>>>        Set piColumnCount to 10
47617>>>>>
47617>>>>>        Object oSelectionValue is a cWebForm
47619>>>>>            Set piColumnSpan to 0
47620>>>>>            Set psLabel to ":"
47621>>>>>            Set peLabelAlign to alignRight
47622>>>>>            Set piLabelOffset to 160
47623>>>>>        End_Object
47624>>>>>        
47624>>>>>    End_Object 
47625>>>>>    
47625>>>>>    Object oBottomPanel is a cWebPanel
47627>>>>>        Set piColumnCount to 6
47628>>>>>        Set peRegion to prBottom
47629>>>>>
47629>>>>>        Object oOkButton is a cWebButton
47631>>>>>            Set psCaption to C_$OK
47632>>>>>            Set piColumnSpan to 1
47633>>>>>            Set piColumnIndex to 4
47634>>>>>
47634>>>>>            Procedure OnClick
47637>>>>>                Send Ok
47638>>>>>            End_Procedure
47639>>>>>            
47639>>>>>        End_Object 
47640>>>>>
47640>>>>>        Object oCancelButton is a cWebButton
47642>>>>>            Set psCaption to C_$Cancel
47643>>>>>            Set piColumnSpan to 1
47644>>>>>            Set piColumnIndex to 5
47645>>>>>
47645>>>>>            Procedure OnClick
47648>>>>>                Send Cancel
47649>>>>>            End_Procedure
47650>>>>>            
47650>>>>>        End_Object
47651>>>>>        
47651>>>>>    End_Object
47652>>>>>
47652>>>>>    Procedure OnSubmit
47655>>>>>        Send Ok
47656>>>>>    End_Procedure
47657>>>>>    
47657>>>>>    Procedure Ok
47660>>>>>        Forward Send Ok
47662>>>>>    End_Procedure
47663>>>>>
47663>>>>>    Procedure Cancel
47666>>>>>        Forward Send Cancel
47668>>>>>    End_Procedure
47669>>>>>    
47669>>>>>    Procedure PopupGetValue Handle hoRetObj String sField String sOp String sCurVal Integer iType
47672>>>>>        WebSet psLabel    of oSelectionValue to (sField * "(" + sOp + "):")
47673>>>>>        If (iType = typeASCII) Move (StrDelQuotes(ghoWQF, sCurVal)) to sCurVal
47676>>>>>        If (iType = typeDate)  Move (Date2MilDate(ghoWQF, sCurVal)) to sCurVal
47679>>>>>        WebSet psValue    of oSelectionValue to sCurVal
47680>>>>>        WebSet peDataType of oSelectionValue to iType
47681>>>>>        
47681>>>>>        Send Popup hoRetObj
47682>>>>>    End_Procedure
47683>>>>>    
47683>>>>>    Function ValueSelected Returns String
47686>>>>>        String  sVal
47686>>>>>        Integer iType
47686>>>>>        
47686>>>>>        WebGet peDataType of oSelectionValue to iType
47687>>>>>        WebGet psValue    of oSelectionValue to sVal
47688>>>>>        If (iType = typeASCII) Move (StrAddQuotes(ghoWQF, sVal)) to sVal
47691>>>>>        If (iType = typeDate)  Move (MilDate2Date(ghoWQF, sVal)) to sVal
47694>>>>>        Function_Return sVal
47695>>>>>    End_Function
47696>>>>>    
47696>>>>>End_Object
47697>>>Use wqSelectionRanges.wo
Including file: wqSelectionRanges.wo    (Z:\VmShare\Projects\WebQuery18-0\AppSrc\wqSelectionRanges.wo)
47697>>>>>
47697>>>>>Use cWebModalDialog
47697>>>>>Use cWebPanel.pkg
47697>>>>>Use cWebButton.pkg
47697>>>>>Use cWebForm.pkg
47697>>>>>Use cWebQueryFunctions.pkg
47697>>>>>
47697>>>>>Object oWqSelectionRanges is a cWebModalDialog
47699>>>>>    Set psCaption to "Selection Range"
47700>>>>>    Set piMinWidth to 400
47701>>>>>    Set piMinHeight to 100
47702>>>>>    Set pbServerOnSubmit to True
47703>>>>>    
47703>>>>>    Object oMainPanel is a cWebPanel
47705>>>>>        Set piColumnCount to 10
47706>>>>>
47706>>>>>        Object oStartRange is a cWebForm
47708>>>>>            Set piColumnSpan to 0
47709>>>>>            Set psLabel to "from:"
47710>>>>>            Set peLabelAlign to alignRight
47711>>>>>            Set piLabelOffset to 180
47712>>>>>        End_Object
47713>>>>>
47713>>>>>        Object oEndRange is a cWebForm
47715>>>>>            Set piColumnSpan to 0
47716>>>>>            Set psLabel to "to:"
47717>>>>>            Set peLabelAlign to alignRight
47718>>>>>            Set piLabelOffset to 180
47719>>>>>        End_Object
47720>>>>>        
47720>>>>>    End_Object 
47721>>>>>    
47721>>>>>    Object oBottomPanel is a cWebPanel
47723>>>>>        Set piColumnCount to 6
47724>>>>>        Set peRegion to prBottom
47725>>>>>
47725>>>>>        Object oOkButton is a cWebButton
47727>>>>>            Set psCaption to C_$OK
47728>>>>>            Set piColumnSpan to 1
47729>>>>>            Set piColumnIndex to 4
47730>>>>>
47730>>>>>            Procedure OnClick
47733>>>>>                Send Ok
47734>>>>>            End_Procedure
47735>>>>>            
47735>>>>>        End_Object 
47736>>>>>
47736>>>>>        Object oCancelButton is a cWebButton
47738>>>>>            Set psCaption to C_$Cancel
47739>>>>>            Set piColumnSpan to 1
47740>>>>>            Set piColumnIndex to 5
47741>>>>>
47741>>>>>            Procedure OnClick
47744>>>>>                Send Cancel
47745>>>>>            End_Procedure
47746>>>>>            
47746>>>>>        End_Object
47747>>>>>        
47747>>>>>    End_Object
47748>>>>>
47748>>>>>    Procedure OnSubmit
47751>>>>>        Send Ok
47752>>>>>    End_Procedure
47753>>>>>    
47753>>>>>    Procedure Ok
47756>>>>>        Forward Send Ok
47758>>>>>    End_Procedure
47759>>>>>
47759>>>>>    Procedure Cancel
47762>>>>>        Forward Send Cancel
47764>>>>>    End_Procedure
47765>>>>>    
47765>>>>>    Procedure PopupGetRange Handle hoRetObj String sField String sOp String sCurVal Integer iType
47768>>>>>        Integer iPos
47768>>>>>        String  sStR sEndR
47768>>>>>        
47768>>>>>        WebSet psLabel of oStartRange to (sField * "(" + sOp + ") - from:")
47769>>>>>        
47769>>>>>        Move (Replace(" (both incl)", sCurVal, ""))  to sCurVal
47770>>>>>        Move (Replace("No limitation", sCurVal, "")) to sCurVal
47771>>>>>        Move (Pos("-", sCurVal)) to iPos
47772>>>>>        
47772>>>>>        If iPos Begin
47774>>>>>            Move (Left(sCurVal, (iPos - 2)))                    to sStR
47775>>>>>            Move (Right(sCurVal, (Length(sCurVal) - iPos - 1))) to sEndR
47776>>>>>        End
47776>>>>>>
47776>>>>>        
47776>>>>>        WebSet peDataType of oStartRange to iType
47777>>>>>        WebSet peDataType of oEndRange   to iType
47778>>>>>        
47778>>>>>        If (iType = typeASCII) Begin
47780>>>>>            Move (StrDelQuotes(ghoWQF, sStR))  to sStR
47781>>>>>            Move (StrDelQuotes(ghoWQF, sEndR)) to sEndR
47782>>>>>        End
47782>>>>>>
47782>>>>>        
47782>>>>>        If (iType = typeDate) Begin
47784>>>>>            Get Date2MilDate of ghoWQF sStR  to sStR
47785>>>>>            Get Date2MilDate of ghoWQF sEndR to sEndR
47786>>>>>        End
47786>>>>>>
47786>>>>>        
47786>>>>>        WebSet psValue of oStartRange to sStR
47787>>>>>        WebSet psValue of oEndRange   to sEndR
47788>>>>>        
47788>>>>>        Send Popup hoRetObj
47789>>>>>    End_Procedure
47790>>>>>    
47790>>>>>    Function RangeSelected Returns String
47793>>>>>        String  sStR sEndR sSep
47793>>>>>        Integer iType iDateF
47793>>>>>        
47793>>>>>        WebGet psValue    of oStartRange to sStR
47794>>>>>        WebGet psValue    of oEndRange   to sEndR
47795>>>>>        WebGet peDataType of oStartRange to iType
47796>>>>>        
47796>>>>>        If (iType = typeASCII) Move (StrAddQuotes(ghoWQF, sStR))    to sStR
47799>>>>>        If (iType = typeASCII) Move (StrAddQuotes(ghoWQF, sEndR))   to sEndR
47802>>>>>        
47802>>>>>        // Seems to return dates in military format, so...
47802>>>>>        If (iType = typeDate) Begin
47804>>>>>            Get MilDate2Date of ghoWQF sStR  to sStR
47805>>>>>            Get MilDate2Date of ghoWQF sEndR to sEndR
47806>>>>>        End
47806>>>>>>
47806>>>>>            
47806>>>>>        Function_Return (sStR + " - " + sEndR + " (both incl)")
47807>>>>>    End_Function
47808>>>>>    
47808>>>>>End_Object
47809>>>Use wqSelectionList.wo
Including file: wqSelectionList.wo    (Z:\VmShare\Projects\WebQuery18-0\AppSrc\wqSelectionList.wo)
47809>>>>>Use cWebModalDialog
47809>>>>>Use cWebPanel.pkg
47809>>>>>Use cWebButton.pkg
47809>>>>>Use cWebForm.pkg
47809>>>>>Use cWebGrid.pkg
47809>>>>>Use cWebColumn.pkg
47809>>>>>
47809>>>>>Object oWqSelectionList is a cWebModalDialog
47811>>>>>    Set psCaption to "Selection in List"
47812>>>>>    Set piMinWidth to 400
47813>>>>>    Set piMinHeight to 300
47814>>>>>    Set pbServerOnSubmit to True
47815>>>>>    Set pbServerOnShow   to True
47816>>>>>    
47816>>>>>    Property String  wpsList
47820>>>>>    
47820>>>>>    Object oMainPanel is a cWebPanel
47822>>>>>        Set piColumnCount to 10
47823>>>>>
47823>>>>>        Object oValueList is a cWebGrid
47825>>>>>            Set pbShowLabel         to True
47826>>>>>            Set peLabelPosition     to lpTop
47827>>>>>            Set peLabelAlign        to alignLeft
47828>>>>>            Set pbDataAware         to False
47829>>>>>            Set pbOfflineEditing    to True
47830>>>>>            Set psLabel             to ":"
47831>>>>>            Set pbFillHeight        to True
47832>>>>>            Set pbAllowAppendRow    to True
47833>>>>>                        
47833>>>>>            Object oValueCol is a cWebColumn
47835>>>>>                Set psCaption to "Values"
47836>>>>>            End_Object
47837>>>>>            
47837>>>>>            Procedure OnManualLoadData tWebRow[] ByRef aTheRows String ByRef sCurrentRowID
47840>>>>>                String  sList sVal
47840>>>>>                Integer i iPos iType
47840>>>>>                
47840>>>>>                WebGet wpsList of oWqSelectionList to sList
47841>>>>>                WebGet peDataType of oValueCol     to iType
47842>>>>>                Move 0 to i
47843>>>>>                
47843>>>>>                Repeat
47843>>>>>>
47843>>>>>                    Move (Trim(sList)) to sList
47844>>>>>                    If (sList = "") Break
47847>>>>>                    
47847>>>>>                    Move (Pos(";", sList)) to iPos
47848>>>>>                    
47848>>>>>                    If (iPos > 0) Begin
47850>>>>>                        Move (Left(sList, (iPos - 1))) to sVal
47851>>>>>                        Move (Right(sList, (Length(sList) - iPos))) to sList
47852>>>>>                    End
47852>>>>>>
47852>>>>>                    Else If (sList <> "") Move sList to sVal
47856>>>>>                    
47856>>>>>                    If (iType = typeDate) Move (Date2MilDate(ghoWQF, sVal)) to sVal
47859>>>>>                    
47859>>>>>                    If (sVal <> "") Begin
47861>>>>>                        Move i    to aTheRows[i].sRowID
47862>>>>>                        Move sVal to aTheRows[i].aCells[0].sValue
47863>>>>>                        Increment i
47864>>>>>                    End
47864>>>>>>
47864>>>>>                    
47864>>>>>                Until (iPos < 1)
47866>>>>>                
47866>>>>>            End_Procedure
47867>>>>>            
47867>>>>>            Procedure OnProcessDataSet tWebRow[] aData Integer eOperation Integer iSelectedRowIndex
47870>>>>>                Integer i iType
47870>>>>>                String  sData sItem
47870>>>>>                
47870>>>>>                Move "" to sData
47871>>>>>                WebGet peDataType of oValueCol to iType
47872>>>>>                
47872>>>>>                For i from 0 to (SizeOFArray(aData) - 1)
47878>>>>>>
47878>>>>>                    If (i > 0) Move (sData + "; ") to sData
47881>>>>>                    Move aData[i].aCells[0].sValue to sItem
47882>>>>>                    If (iType = typeDate) Move (MilDate2Date(ghoWQF, sItem)) to sItem
47885>>>>>                    Move (sData + sItem) to sData
47886>>>>>                Loop
47887>>>>>>
47887>>>>>                
47887>>>>>                WebSet wpsList of oWqSelectionList to sData
47888>>>>>                Send OK
47889>>>>>            End_Procedure
47890>>>>>            
47890>>>>>        End_Object
47891>>>>>        
47891>>>>>    End_Object 
47892>>>>>    
47892>>>>>    Object oBottomPanel is a cWebPanel
47894>>>>>        Set piColumnCount to 6
47895>>>>>        Set peRegion to prBottom
47896>>>>>
47896>>>>>        Object oOkButton is a cWebButton
47898>>>>>            Set psCaption to C_$OK
47899>>>>>            Set piColumnSpan to 1
47900>>>>>            Set piColumnIndex to 4
47901>>>>>
47901>>>>>            Procedure OnClick
47904>>>>>                Send ProcessDataSet of oValueList 0
47905>>>>>            End_Procedure
47906>>>>>            
47906>>>>>        End_Object
47907>>>>>
47907>>>>>        Object oCancelButton is a cWebButton
47909>>>>>            Set psCaption to C_$Cancel
47910>>>>>            Set piColumnSpan to 1
47911>>>>>            Set piColumnIndex to 5
47912>>>>>
47912>>>>>            Procedure OnClick
47915>>>>>                Send Cancel
47916>>>>>            End_Procedure
47917>>>>>            
47917>>>>>        End_Object
47918>>>>>        
47918>>>>>    End_Object 
47919>>>>>
47919>>>>>    Procedure OnSubmit
47922>>>>>        Send Ok
47923>>>>>    End_Procedure
47924>>>>>    
47924>>>>>    Procedure Ok
47927>>>>>        Forward Send Ok
47929>>>>>    End_Procedure
47930>>>>>
47930>>>>>    Procedure Cancel
47933>>>>>        Forward Send Cancel
47935>>>>>    End_Procedure
47936>>>>>    
47936>>>>>    Procedure OnShow
47939>>>>>        Send GridRefresh  of oValueList
47940>>>>>    End_Procedure
47941>>>>>
47941>>>>>    Procedure PopupGetList Handle hoRetObj String sField String sOp String sCurVal Integer iType
47944>>>>>        Integer iPos
47944>>>>>        
47944>>>>>        WebSet psLabel of oValueList to (sField * "is one of:")
47945>>>>>        WebSet peDataType of oValueCol to iType
47946>>>>>        If (iType = typeASCII) Move (StrDelQuotes(ghoWQF, sCurVal)) to sCurVal
47949>>>>>        WebSet wpsList to sCurVal
47950>>>>>        Send Popup hoRetObj
47951>>>>>    End_Procedure
47952>>>>>    
47952>>>>>    Function ListSelected Returns String
47955>>>>>        String  sVals
47955>>>>>        
47955>>>>>        WebGet wpsList to sVals
47956>>>>>        Function_Return sVals
47957>>>>>    End_Function
47958>>>>>
47958>>>>>End_Object
47959>>>Use wqExpressionPopup.wo
Including file: wqExpressionPopup.wo    (Z:\VmShare\Projects\WebQuery18-0\AppSrc\wqExpressionPopup.wo)
47959>>>>>Use cWebModalDialog
47959>>>>>Use cWebPanel.pkg
47959>>>>>Use cWebButton.pkg
47959>>>>>Use cWebForm.pkg
47959>>>>>Use cWebEdit.pkg
47959>>>>>Use cWebList.pkg
47959>>>>>Use cWebColumn.pkg
47959>>>>>
47959>>>>>Use cWqWebEdit.pkg
Including file: cWqWebEdit.pkg    (Z:\VmShare\Projects\WebQuery18-0\AppSrc\cWqWebEdit.pkg)
47959>>>>>>>Use cWebEdit.pkg
47959>>>>>>>
47959>>>>>>>Class cWqWebEdit is a cWebEdit
47960>>>>>>>    
47960>>>>>>>    Procedure Construct_Object
47962>>>>>>>        Forward Send Construct_Object
47964>>>>>>>        
47964>>>>>>>        Property Integer piCaretPosition 0
47967>>>>>>>        
47967>>>>>>>        Set psJSClass to "df.wqWebEdit"
47968>>>>>>>    End_Procedure
47969>>>>>>>
47969>>>>>>>End_Class
47970>>>>>Use cWebQueryFunctions.pkg
47970>>>>>
47970>>>>>Struct wqExpressionReturn
47970>>>>>    String  sExpression
47970>>>>>    Integer iOp
47970>>>>>    Integer iField
47970>>>>>End_Struct
47970>>>>>
47970>>>>>Object oWqExpressionPopup is a cWebModalDialog
47972>>>>>    Set psCaption        to "Expression"
47973>>>>>    Set piMinWidth       to 800
47974>>>>>    Set piMinHeight      to 500
47975>>>>>    Set pbServerOnSubmit to True
47976>>>>>    Set pbServerOnShow   to True
47977>>>>>    
47977>>>>>    Property Integer wpiOp
47981>>>>>    Property Integer wpiField
47985>>>>>    Property Handle  wphMainTable
47989>>>>>    Property String  wpsExpression
47993>>>>>    Property String  wpsName
47997>>>>>    
47997>>>>>    Property Handle phSelectedTable
47999>>>>>    
47999>>>>>    Object oExprPanel is a cWebPanel
48001>>>>>        Set peRegion to prTop
48002>>>>>        Set piHeight to 200
48003>>>>>        
48003>>>>>        Object oExpression is a cWqWebEdit
48005>>>>>            Set piColumnSpan to 0
48006>>>>>            Set pbShowLabel to False
48007>>>>>            Set pbFillHeight to True
48008>>>>>        End_Object
48009>>>>>
48009>>>>>    End_Object
48010>>>>>
48010>>>>>    Object oListsPanel is a cWebPanel
48012>>>>>        Set pbFillHeight to True
48013>>>>>        Set piColumnCount to 20
48014>>>>>
48014>>>>>        Object oTablesList is a cWebList
48016>>>>>            Set piColumnIndex       to 0
48017>>>>>            Set piColumnSpan        to 4
48018>>>>>            Set pbFillHeight        to True
48019>>>>>            Set pbDataAware         to False
48020>>>>>            Set pbColumnSortable    to False
48021>>>>>            
48021>>>>>            Object oTableCol is a cWebColumn
48023>>>>>                Set psCaption to "Tables"
48024>>>>>            End_Object
48025>>>>>            
48025>>>>>            Procedure OnChangeCurrentRow String sFromRowID String sToRowID
48028>>>>>                Set phSelectedTable     to sToRowID
48029>>>>>                Send GridRefresh        of oFieldsList
48030>>>>>                WebSet psCurrentRowID   of oFieldsList to 1
48031>>>>>            End_Procedure  // OnChangeCurrentRow
48032>>>>>            
48032>>>>>            Procedure OnManualLoadData tWebRow[] ByRef aTheRows String ByRef sCurrentRowID
48035>>>>>                Handle hTab
48035>>>>>                
48035>>>>>                WebGet wphMainTable of oWqExpressionPopup to hTab                
48036>>>>>                Send RelatedFiles of ghoWQF (&aTheRows) hTab
48037>>>>>            End_Procedure
48038>>>>>            
48038>>>>>        End_Object
48039>>>>>
48039>>>>>        Object oFieldsList is a cWebList
48041>>>>>            Set piColumnIndex       to 4
48042>>>>>            Set piColumnSpan        to 6
48043>>>>>            Set pbFillHeight        to True
48044>>>>>            Set pbDataAware         to False
48045>>>>>            Set pbColumnSortable    to False
48046>>>>>            
48046>>>>>            Object oFieldCol is a cWebColumn
48048>>>>>                Set psCaption to "Fields"
48049>>>>>            End_Object
48050>>>>>            
48050>>>>>            Procedure OnManualLoadData tWebRow[] ByRef aTheRows String ByRef sCurrentRowID
48053>>>>>                Send CollectColumns of ghoWQF (&aTheRows) (phSelectedTable(oWqExpressionPopup))
48054>>>>>            End_Procedure
48055>>>>>            
48055>>>>>        End_Object
48056>>>>>
48056>>>>>        Object oFuncsList is a cWebList
48058>>>>>            Set piColumnIndex       to 10
48059>>>>>            Set piColumnSpan        to 0
48060>>>>>            Set pbFillHeight        to True
48061>>>>>            Set pbDataAware         to False
48062>>>>>            Set pbColumnSortable    to False
48063>>>>>            
48063>>>>>            Object oFuncCol is a cWebColumn
48065>>>>>                Set psCaption to "Functions"
48066>>>>>            End_Object
48067>>>>>            
48067>>>>>            Procedure OnManualLoadData tWebRow[] ByRef aRows String ByRef sCurrentRowID
48070>>>>>                Integer i
48070>>>>>                
48070>>>>>                Move "Mid(s, i, i)"         to aRows[(SizeOfArray(aRows))].aCells[0].sValue
48071>>>>>                Move "Left(s, i)"           to aRows[(SizeOfArray(aRows))].aCells[0].sValue
48072>>>>>                Move "Right(s, i)"          to aRows[(SizeOfArray(aRows))].aCells[0].sValue
48073>>>>>                Move "Uppercase(s)"         to aRows[(SizeOfArray(aRows))].aCells[0].sValue
48074>>>>>                Move "Lowercase(s)"         to aRows[(SizeOfArray(aRows))].aCells[0].sValue
48075>>>>>                Move "Concat(s, s)"         to aRows[(SizeOfArray(aRows))].aCells[0].sValue
48076>>>>>                Move "Length(s)"            to aRows[(SizeOfArray(aRows))].aCells[0].sValue
48077>>>>>                Move "Trim(s)"              to aRows[(SizeOfArray(aRows))].aCells[0].sValue
48078>>>>>                Move "Pos(s, s)"            to aRows[(SizeOfArray(aRows))].aCells[0].sValue
48079>>>>>                Move "Today()"              to aRows[(SizeOfArray(aRows))].aCells[0].sValue
48080>>>>>                Move "Month(d)"             to aRows[(SizeOfArray(aRows))].aCells[0].sValue
48081>>>>>                Move "Week(d)"              to aRows[(SizeOfArray(aRows))].aCells[0].sValue
48082>>>>>                Move "Year(d)"              to aRows[(SizeOfArray(aRows))].aCells[0].sValue
48083>>>>>                Move "Day(d)"               to aRows[(SizeOfArray(aRows))].aCells[0].sValue
48084>>>>>                Move "DayName(i)"           to aRows[(SizeOfArray(aRows))].aCells[0].sValue
48085>>>>>                Move "MonthName(i)"         to aRows[(SizeOfArray(aRows))].aCells[0].sValue
48086>>>>>//                Move "DateIncrement(d,i,i)" to aRows[(SizeOfArray(aRows))].aCells[0].sValue
48086>>>>>                Move "FirstDayInMonth(d)"   to aRows[(SizeOfArray(aRows))].aCells[0].sValue
48087>>>>>                Move "DateAsTextEU(d)"      to aRows[(SizeOfArray(aRows))].aCells[0].sValue
48088>>>>>                Move "DateAsTextUS(d)"      to aRows[(SizeOfArray(aRows))].aCells[0].sValue
48089>>>>>                Move "DateFormatText(d, s)" to aRows[(SizeOfArray(aRows))].aCells[0].sValue
48090>>>>>//                Move "If_Int(i,i,i)"        to aRows[(SizeOfArray(aRows))].aCells[0].sValue
48090>>>>>//                Move "If_Num(i,i,n)"        to aRows[(SizeOfArray(aRows))].aCells[0].sValue
48090>>>>>//                Move "If_Str(i,s,s)"        to aRows[(SizeOfArray(aRows))].aCells[0].sValue
48090>>>>>//                Move "If_Dat(i,d,d)"        to aRows[(SizeOfArray(aRows))].aCells[0].sValue
48090>>>>>                Move "Integer(i)"           to aRows[(SizeOfArray(aRows))].aCells[0].sValue
48091>>>>>                Move "String(s)"            to aRows[(SizeOfArray(aRows))].aCells[0].sValue
48092>>>>>                Move "Number(n)"            to aRows[(SizeOfArray(aRows))].aCells[0].sValue
48093>>>>>                Move "Date(d)"              to aRows[(SizeOfArray(aRows))].aCells[0].sValue
48094>>>>>                Move "not(i)"               to aRows[(SizeOfArray(aRows))].aCells[0].sValue
48095>>>>>                
48095>>>>>                For i from 0 to (SizeOfArray(aRows) - 1)
48101>>>>>>
48101>>>>>                    Move i to aRows[i].sRowID
48102>>>>>                Loop
48103>>>>>>
48103>>>>>                
48103>>>>>            End_Procedure
48104>>>>>            
48104>>>>>        End_Object
48105>>>>>            
48105>>>>>    End_Object
48106>>>>>    
48106>>>>>    Object oBottomPanel is a cWebPanel
48108>>>>>        Set piColumnCount to 8
48109>>>>>        Set peRegion to prBottom
48110>>>>>
48110>>>>>        Object oOkButton is a cWebButton
48112>>>>>            Set psCaption to C_$OK
48113>>>>>            Set piColumnSpan to 1
48114>>>>>            Set piColumnIndex to 5
48115>>>>>
48115>>>>>            Procedure OnClick
48118>>>>>                Send Ok
48119>>>>>            End_Procedure
48120>>>>>            
48120>>>>>        End_Object 
48121>>>>>
48121>>>>>        Object oClearButton is a cWebButton
48123>>>>>            Set psCaption to "Clear"
48124>>>>>            Set piColumnSpan to 1
48125>>>>>            Set piColumnIndex to 6
48126>>>>>
48126>>>>>            Procedure OnClick
48129>>>>>                Send ClearExpr
48130>>>>>            End_Procedure
48131>>>>>            
48131>>>>>        End_Object 
48132>>>>>
48132>>>>>        Object oCancelButton is a cWebButton
48134>>>>>            Set psCaption to C_$Cancel
48135>>>>>            Set piColumnSpan to 1
48136>>>>>            Set piColumnIndex to 7
48137>>>>>
48137>>>>>            Procedure OnClick
48140>>>>>                Send Cancel
48141>>>>>            End_Procedure
48142>>>>>            
48142>>>>>        End_Object 
48143>>>>>        
48143>>>>>    End_Object
48144>>>>>    
48144>>>>>    Procedure InsertFunction
48147>>>>>        Integer iPos iLen
48147>>>>>        String  sFunc sExpr
48147>>>>>        
48147>>>>>        WebGet psValue of oExpression to sExpr
48148>>>>>        WebGet piCaretPosition of oExpression to iPos
48149>>>>>        WebGet psValue of oFuncCol to sFunc
48150>>>>>        Move (Length(sExpr)) to iLen
48151>>>>>        
48151>>>>>        If (iPos > iLen) Move (sExpr + sFunc) to sExpr
48154>>>>>        Else Move (Left(sExpr, (iPos - 1)) + sFunc + Right(sExpr, (iLen - iPos + 1))) to sExpr
48156>>>>>        
48156>>>>>        WebSet psValue of oExpression to sExpr
48157>>>>>        WebSet piCaretPosition of oExpression to (iPos + Length(sFunc))
48158>>>>>    End_Procedure
48159>>>>>    
48159>>>>>    Procedure InsertField
48162>>>>>        Integer iPos iLen iFld
48162>>>>>        Handle  hTab
48162>>>>>        String  sExpr sTab sFld sFF
48162>>>>>        
48162>>>>>        WebGet psValue         of oExpression to sExpr
48163>>>>>        WebGet piCaretPosition of oExpression to iPos
48164>>>>>        WebGet psCurrentRowID  of oTablesList to hTab
48165>>>>>        WebGet psCurrentRowID  of oFieldsList to iFld
48166>>>>>        
48166>>>>>        Open hTab
48168>>>>>        Get_Attribute DF_FILE_LOGICAL_NAME of hTab      to sTab
48171>>>>>        Get_Attribute DF_FIELD_NAME        of hTab iFld to sFld
48174>>>>>        
48174>>>>>        Move (sTab + "." + sFld) to sFF        
48175>>>>>        Move (Length(sExpr))     to iLen
48176>>>>>        
48176>>>>>        If (iPos > iLen) Move (sExpr + sFF) to sExpr
48179>>>>>        Else Move (Left(sExpr, (iPos - 1)) + sFF + Right(sExpr, (iLen - iPos + 1))) to sExpr
48181>>>>>        
48181>>>>>        WebSet psValue of oExpression to sExpr
48182>>>>>        WebSet piCaretPosition of oExpression to (iPos + Length(sFF))
48183>>>>>    End_Procedure
48184>>>>>
48184>>>>>    Procedure OnSubmit
48187>>>>>        Handle  hoFoc
48187>>>>>        
48187>>>>>        Get FocusObject to hoFoc
48188>>>>>        
48188>>>>>        If (hoFoc = oFieldsList) Send InsertField
48191>>>>>        If (hoFoc = oFuncsList)  Send InsertFunction
48194>>>>>    End_Procedure
48195>>>>>    
48195>>>>>    Procedure ClearExpr
48198>>>>>        WebSet psValue of oExpression to ""
48199>>>>>    End_Procedure
48200>>>>>    
48200>>>>>    Procedure OnLoad
48203>>>>>        Send GridRefresh of oFuncsList
48204>>>>>    End_Procedure
48205>>>>>    
48205>>>>>    Procedure OnShow
48208>>>>>        String  sExpr sName
48208>>>>>        Integer iOp
48208>>>>>        
48208>>>>>        WebGet wpiOp   to iOp
48209>>>>>        WebGet wpsName to sName
48210>>>>>        
48210>>>>>        If (iOp = C_wqSelectExpr) WebSet psCaption to "Edit selection expression"
48213>>>>>        Else                      WebSet psCaption to ('Edit expression for calculated column "' + sName + '"')
48215>>>>>        
48215>>>>>        WebGet wpsExpression            to sExpr
48216>>>>>        WebSet psValue of oExpression   to sExpr
48217>>>>>        Send GridRefresh of oTablesList
48218>>>>>    End_Procedure
48219>>>>>    
48219>>>>>    Procedure Ok
48222>>>>>        String  sExpr
48222>>>>>        tXPGrammar tXPGram
48222>>>>>        tXPGrammar tXPGram
48222>>>>>        tXPToken[] aXPSyms
48222>>>>>        tXPToken[] aXPSyms
48223>>>>>        tXPError   tXPErr
48223>>>>>        tXPError   tXPErr
48223>>>>>        tXPValue   tXPRes
48223>>>>>        tXPValue   tXPRes
48223>>>>>        
48223>>>>>        WebGet psValue of oExpression to sExpr
48224>>>>>        
48224>>>>>        If (sExpr <> "") Begin
48226>>>>>            Get NewGrammar of oWqExprPar                                          to tXPGram
48227>>>>>            Get TokenizeString of oWqExprPar tXPGram sExpr (&tXPErr)              to aXPSyms
48228>>>>>            If (tXPErr.iPos = 0) ;                Get ReversePolishNotation of oWqExprPar tXPGram aXPSyms (&tXPErr) to aXPSyms
48231>>>>>        
48231>>>>>            If (tXPErr.iPos <> 0) Begin
48233>>>>>                Send ShowInfoBox ('Error in expression: "' + tXPErr.sErrorText + '"') "Expression Error"
48234>>>>>            End
48234>>>>>>
48234>>>>>            Else Forward Send Ok
48237>>>>>            
48237>>>>>        End
48237>>>>>>
48237>>>>>        Else Forward Send Ok
48240>>>>>        
48240>>>>>    End_Procedure
48241>>>>>
48241>>>>>    Procedure Cancel
48244>>>>>        Forward Send Cancel
48246>>>>>    End_Procedure
48247>>>>>    
48247>>>>>    Procedure DoPopup Handle hoObj String sExpr Integer iOp Integer iFld Handle hMainTab String sName
48250>>>>>        WebSet wpsExpression    to sExpr
48251>>>>>        WebSet wpiOp            to iOp
48252>>>>>        WebSet wpiField         to iFld  // ToDo: Don't think we need this...
48253>>>>>        WebSet wphMainTable     to hMainTab
48254>>>>>        WebSet wpsName          to sName
48255>>>>>                
48255>>>>>        Send Popup hoObj
48256>>>>>    End_Procedure
48257>>>>>    
48257>>>>>    Function ExprValue Returns wqExpressionReturn
48260>>>>>        wqExpressionReturn tExpr
48260>>>>>        wqExpressionReturn tExpr
48260>>>>>        
48260>>>>>        WebGet psValue of oExpression to tExpr.sExpression
48261>>>>>        WebGet wpiOp                  to tExpr.iOp
48262>>>>>        WebGet wpiField               to tExpr.iField
48263>>>>>        
48263>>>>>        Function_Return tExpr
48264>>>>>    End_Function
48265>>>>>    
48265>>>>>End_Object
48266>>>Use wqAddInsEdit.wo
Including file: wqAddInsEdit.wo    (Z:\VmShare\Projects\WebQuery18-0\AppSrc\wqAddInsEdit.wo)
48266>>>>>Use cWebModalDialog
48266>>>>>Use cWebPanel.pkg
48266>>>>>Use cWebButton.pkg
48266>>>>>Use cWebForm.pkg
48266>>>>>Use cWebMenuItem.pkg
48266>>>>>Use cWebMenuBar.pkg
48266>>>>>Use cWebImage.pkg
48266>>>>>Use cWebLabel.pkg
48266>>>>>Use cWebCommandbar.pkg
48266>>>>>
48266>>>>>Object oWqAddInsEdit is a cWebModalDialog
48268>>>>>    Property Integer piSelection
48270>>>>>    
48270>>>>>    Set psCaption           to "Expression"
48271>>>>>    Set piMinWidth          to 100
48272>>>>>    Set piMinHeight         to 100
48273>>>>>    Set pbShowClose         to False
48274>>>>>    Set pbResizable         to False
48275>>>>>    Set pbServerOnSubmit    to True    // enable the OnSubmit event
48276>>>>>    Set pbServerOnShow      to True
48277>>>>>
48277>>>>>    Object oAddButton is a cWebButton
48279>>>>>        Set piColumnSpan to 0
48280>>>>>        Set psCaption to "Add"
48281>>>>>    
48281>>>>>        Procedure OnClick
48284>>>>>            Set piSelection to C_wqAddExpression
48285>>>>>            Send Ok
48286>>>>>        End_Procedure
48287>>>>>    End_Object
48288>>>>>
48288>>>>>    Object oInsertButton is a cWebButton
48290>>>>>        Set piColumnSpan to 0
48291>>>>>        Set psCaption to "Insert"
48292>>>>>    
48292>>>>>        Procedure OnClick
48295>>>>>            Set piSelection to C_wqInsertExpression
48296>>>>>            Send Ok
48297>>>>>        End_Procedure
48298>>>>>    End_Object
48299>>>>>
48299>>>>>    Object oEditButton is a cWebButton
48301>>>>>        Set piColumnSpan to 0
48302>>>>>        Set psCaption to "Edit"
48303>>>>>    
48303>>>>>        Procedure OnClick
48306>>>>>            Set piSelection to C_wqEditExpression
48307>>>>>            Send Ok
48308>>>>>        End_Procedure
48309>>>>>    End_Object
48310>>>>>
48310>>>>>    Object oDismissButton is a cWebButton
48312>>>>>        Set piColumnSpan to 0
48313>>>>>        Set psCaption to "Dismiss"
48314>>>>>    
48314>>>>>        Procedure OnClick
48317>>>>>            Send Cancel
48318>>>>>        End_Procedure
48319>>>>>    End_Object
48320>>>>>
48320>>>>>//    Object oCmdBar is a cWebCommandBar
48320>>>>>//        
48320>>>>>//        Object oMenuBar is a cWebMenuBar
48320>>>>>//            
48320>>>>>//            Object oAddItem is a cWebMenuItem
48320>>>>>//                Set psCaption to "Add"
48320>>>>>//                
48320>>>>>//                Procedure OnClick
48320>>>>>//                    Set piSelection to C_wqAddExpression
48320>>>>>//                    Send Ok
48320>>>>>//                End_Procedure  // OnClick
48320>>>>>//                
48320>>>>>//            End_Object
48320>>>>>//            
48320>>>>>//            Object oInsertItem is a cWebMenuItem
48320>>>>>//                Set psCaption to "Insert"
48320>>>>>//                
48320>>>>>//                Procedure OnClick
48320>>>>>//                    Set piSelection to C_wqInsertExpression
48320>>>>>//                    Send Ok
48320>>>>>//                End_Procedure  // OnClick
48320>>>>>//                
48320>>>>>//            End_Object
48320>>>>>//            
48320>>>>>//            Object oEditItem is a cWebMenuItem
48320>>>>>//                Set psCaption to "Edit"
48320>>>>>//                
48320>>>>>//                Procedure OnClick
48320>>>>>//                    Set piSelection to C_wqEditExpression
48320>>>>>//                    Send Ok
48320>>>>>//                End_Procedure  // OnClick
48320>>>>>//                
48320>>>>>//            End_Object
48320>>>>>//            
48320>>>>>//            Object oExitItem is a cWebMenuItem
48320>>>>>//                Set psCaption to "Dismiss"
48320>>>>>//                
48320>>>>>//                Procedure OnClick
48320>>>>>//                    Send Cancel
48320>>>>>//                End_Procedure  // OnClick
48320>>>>>//                
48320>>>>>//            End_Object
48320>>>>>//            
48320>>>>>//        End_Object
48320>>>>>//        
48320>>>>>//    End_Object
48320>>>>>
48320>>>>>    Procedure OnSubmit
48323>>>>>        Send Ok
48324>>>>>    End_Procedure
48325>>>>>    
48325>>>>>    Procedure Ok
48328>>>>>        Forward Send Ok
48330>>>>>    End_Procedure
48331>>>>>
48331>>>>>    Procedure Cancel
48334>>>>>        Forward Send Cancel
48336>>>>>    End_Procedure
48337>>>>>    
48337>>>>>    Procedure OnEscape
48340>>>>>        Send Cancel
48341>>>>>    End_Procedure
48342>>>>>    
48342>>>>>    Procedure PopupOptions Handle hoObj Boolean bHaveRows Boolean bCalc
48345>>>>>        
48345>>>>>        WebSet pbEnabled of oEditButton   to (bHaveRows and bCalc)
48346>>>>>        WebSet pbEnabled of oInsertButton to bHaveRows
48347>>>>>        
48347>>>>>        Send Popup hoObj
48348>>>>>    End_Procedure  // PopupOptions
48349>>>>>    
48349>>>>>    Function ActionSelected Returns Integer
48352>>>>>        Function_Return (piSelection(Self))
48353>>>>>    End_Function  // Action_Selected
48354>>>>>    
48354>>>>>End_Object
48355>>>Use wqOpenQuery.wo
Including file: wqOpenQuery.wo    (Z:\VmShare\Projects\WebQuery18-0\AppSrc\wqOpenQuery.wo)
48355>>>>>Use cWebModalDialog
48355>>>>>Use cWebPanel.pkg
48355>>>>>Use cWebButton.pkg
48355>>>>>Use cWebForm.pkg
48355>>>>>Use cWebTreeView.pkg
48355>>>>>Use cWebCombo.pkg
48355>>>>>Use seq_chnl.pkg
48355>>>>>Use wqCreateDirectory.wo
Including file: wqCreateDirectory.wo    (Z:\VmShare\Projects\WebQuery18-0\AppSrc\wqCreateDirectory.wo)
48355>>>>>>>Use cWebModalDialog
48355>>>>>>>Use cWebPanel.pkg
48355>>>>>>>Use cWebButton.pkg
48355>>>>>>>Use cWebForm.pkg
48355>>>>>>>Use cWebQueryFunctions.pkg
48355>>>>>>>
48355>>>>>>>Object oWqCreateDirectory is a cWebModalDialog
48357>>>>>>>    Property String  wpsPath ""
48361>>>>>>>    
48361>>>>>>>    Set psCaption to "Create Directory"
48362>>>>>>>    Set piMinWidth to 500
48363>>>>>>>    Set piMinHeight to 80
48364>>>>>>>    Set pbServerOnSubmit to true    // enable the OnSubmit event
48365>>>>>>>    
48365>>>>>>>    Object oMainPanel is a cWebPanel
48367>>>>>>>        Set piColumnCount to 10
48368>>>>>>>
48368>>>>>>>        Object oDirName is a cWebForm
48370>>>>>>>            Set piColumnSpan to 0
48371>>>>>>>            Set psLabel to "Directory name:"
48372>>>>>>>        End_Object
48373>>>>>>>        
48373>>>>>>>    End_Object 
48374>>>>>>>    
48374>>>>>>>    Object oBottomPanel is a cWebPanel
48376>>>>>>>        Set piColumnCount to 6
48377>>>>>>>        Set peRegion to prBottom
48378>>>>>>>
48378>>>>>>>        Object oOkButton is a cWebButton
48380>>>>>>>            Set psCaption to C_$OK
48381>>>>>>>            Set piColumnSpan to 1
48382>>>>>>>            Set piColumnIndex to 4
48383>>>>>>>
48383>>>>>>>            Procedure OnClick
48386>>>>>>>                Send Ok
48387>>>>>>>            End_Procedure
48388>>>>>>>            
48388>>>>>>>        End_Object 
48389>>>>>>>
48389>>>>>>>        Object oCancelButton is a cWebButton
48391>>>>>>>            Set psCaption to C_$Cancel
48392>>>>>>>            Set piColumnSpan to 1
48393>>>>>>>            Set piColumnIndex to 5
48394>>>>>>>
48394>>>>>>>            Procedure OnClick
48397>>>>>>>                Send Cancel
48398>>>>>>>            End_Procedure
48399>>>>>>>            
48399>>>>>>>        End_Object
48400>>>>>>>        
48400>>>>>>>    End_Object 
48401>>>>>>>
48401>>>>>>>    Procedure OnSubmit
48404>>>>>>>        Send Ok
48405>>>>>>>    End_Procedure
48406>>>>>>>    
48406>>>>>>>    Procedure Ok
48409>>>>>>>        String  sName sPath
48409>>>>>>>        Integer i
48409>>>>>>>        Boolean bExists
48409>>>>>>>        
48409>>>>>>>        // 1. Check all characteras are legal
48409>>>>>>>        WebGet psValue of oDirName to sName
48410>>>>>>>        Move (Trim(sName))         to sName
48411>>>>>>>        
48411>>>>>>>        For i from 1 to (Length(sName))
48417>>>>>>>>
48417>>>>>>>            
48417>>>>>>>            If (C_wqInvalidDirChars contains Mid(sName, 1, i)) Begin
48419>>>>>>>                Send ShowInfoBox ("Directory name may not contain '" + Mid(sName, 1, i) + "'") "Invalid Character"
48420>>>>>>>                Procedure_Return
48421>>>>>>>            End
48421>>>>>>>>
48421>>>>>>>            
48421>>>>>>>        Loop
48422>>>>>>>>
48422>>>>>>>        
48422>>>>>>>        // 2. Check it doesn't already exist
48422>>>>>>>        WebGet wpsPath to sPath
48423>>>>>>>        Move (sPath + "\" + sName) to sPath
48424>>>>>>>        
48424>>>>>>>        File_Exist sPath bExists
48425>>>>>>>        
48425>>>>>>>        If bExists Begin
48427>>>>>>>            Send ShowInfoBox (sName * "already exists") "Cannot Create"
48428>>>>>>>            Procedure_Return
48429>>>>>>>        End
48429>>>>>>>>
48429>>>>>>>        
48429>>>>>>>        Forward Send Ok
48431>>>>>>>    End_Procedure
48432>>>>>>>    
48432>>>>>>>    Procedure Cancel
48435>>>>>>>        Forward Send Cancel
48437>>>>>>>    End_Procedure
48438>>>>>>>    
48438>>>>>>>    Procedure DoPopup Handle hoObj String sPath
48441>>>>>>>        WebSet wpsPath to sPath
48442>>>>>>>        
48442>>>>>>>        Send Popup hoObj
48443>>>>>>>    End_Procedure
48444>>>>>>>    
48444>>>>>>>    Function EnteredName Returns String
48447>>>>>>>        String  sName
48447>>>>>>>        
48447>>>>>>>        WebGet psValue of oDirName to sName
48448>>>>>>>        Function_Return sName
48449>>>>>>>    End_Function
48450>>>>>>>
48450>>>>>>>End_Object
48451>>>>>
48451>>>>>Enum_List
48451>>>>>    Define C_wqOpenQuery for 1
48451>>>>>    Define C_wqSaveQuery
48451>>>>>End_Enum_List
48451>>>>>
48451>>>>>Object oWqOpenQuery is a cWebModalDialog
48453>>>>>    Property Integer wpiMode
48457>>>>>    Property String  wpsSelection
48461>>>>>    Property String  wpsDefault
48465>>>>>    Property Integer wpiNextID
48469>>>>>    
48469>>>>>    Set psCaption           to "Open Query"
48470>>>>>    Set piMinWidth          to 500
48471>>>>>    Set piMinHeight         to 400
48472>>>>>    Set pbServerOnSubmit    to True
48473>>>>>    Set pbServerOnShow      to True
48474>>>>>    
48474>>>>>    Object oMainPanel is a cWebPanel
48476>>>>>        Set piColumnCount to 10
48477>>>>>
48477>>>>>        Object oDirectories is a cWebTreeView
48479>>>>>            Set piColumnSpan to 0
48480>>>>>            Set pbServerOnSelect to True
48481>>>>>            
48481>>>>>            Function OnLoadChildNodes String sId String sValue Integer iLevel Returns tWebTreeItem[]
48484>>>>>                tWebTreeItem[] aItems
48484>>>>>                tWebTreeItem[] aItems
48485>>>>>                wqDir[] aContents
48485>>>>>                wqDir[] aContents
48486>>>>>                Integer i iID
48486>>>>>                String  sFilter
48486>>>>>                
48486>>>>>                If (iLevel = 0) Begin
48488>>>>>                    Move "1d"                       to aItems[0].sId
48489>>>>>                    Move sId                        to aItems[0].sParentId
48490>>>>>                    Move "Public Queries"           to aItems[0].sName
48491>>>>>                    Move True                       to aItems[0].bLoadChildren
48492>>>>>                    Move True                       to aItems[0].bFolder
48493>>>>>                    Move (PublicPath(ghoWQF))       to aItems[0].sValue
48494>>>>>                    
48494>>>>>                    If (PrivatePath(ghoWQF) <> "") Begin
48496>>>>>                        Move "2d"                   to aItems[1].sId
48497>>>>>                        Move sId                    to aItems[1].sParentId
48498>>>>>                        Move "My Queries"           to aItems[1].sName
48499>>>>>                        Move True                   to aItems[1].bLoadChildren
48500>>>>>                        Move True                   to aItems[1].bFolder
48501>>>>>                        Move (PrivatePath(ghoWQF))  to aItems[1].sValue
48502>>>>>                        WebSet wpiNextID of oWqOpenQuery   to 3
48503>>>>>                    End
48503>>>>>>
48503>>>>>                    Else WebSet wpiNextID of oWqOpenQuery to 2
48505>>>>>                    
48505>>>>>                End
48505>>>>>>
48505>>>>>                Else Begin
48506>>>>>                    WebGet psValue        of oFileType              to sFilter
48507>>>>>                    Get DirectoryContents of ghoWQF sValue sFilter  to aContents
48508>>>>>                    WebGet wpiNextID of oWqOpenQuery                to iID
48509>>>>>                    
48509>>>>>                    For i from 0 to (SizeOfArray(aContents) - 1)
48515>>>>>>
48515>>>>>                        Move (String(iID) + If(aContents[i].bDir, "d", "f"))    to aItems[i].sId
48516>>>>>                        Move sID                                                to aItems[i].sParentId
48517>>>>>                        Move aContents[i].sName                                 to aItems[i].sName
48518>>>>>                        Move aContents[i].bDir                                  to aItems[i].bLoadChildren
48519>>>>>                        Move aContents[i].bDir                                  to aItems[i].bFolder
48520>>>>>                        If (not(aContents[i].bDir) and (Right(aContents[i].sName, 4) = ".wqr")) ;                            Move "Custom/report.png"                            to aItems[i].sIcon
48523>>>>>                        Move (sValue + "\" + aContents[i].sName)                to aItems[i].sValue
48524>>>>>                        Increment iID
48525>>>>>                    Loop
48526>>>>>>
48526>>>>>                    
48526>>>>>                    WebSet wpiNextID of oWqOpenQuery to iID
48527>>>>>                End
48527>>>>>>
48527>>>>>                
48527>>>>>                Function_Return aItems
48528>>>>>            End_Function
48529>>>>>            
48529>>>>>            Procedure OnSelect String sId String sValue Integer iLevel
48532>>>>>                Integer iMode
48532>>>>>                String  sFile
48532>>>>>                Boolean bDir
48532>>>>>                
48532>>>>>                Move (Right(sId, 1) = "d") to bDir
48533>>>>>                WebSet pbEnabled of oDeleteButton to (iLevel > 1)
48534>>>>>                WebSet pbEnabled of oCreateButton to (iLevel > 0)
48535>>>>>                WebGet wpiMode of oWqOpenQuery to iMode
48536>>>>>                
48536>>>>>                If (iMode = C_wqOpenQuery) Begin
48538>>>>>                    If bDir Procedure_Return
48541>>>>>                    
48541>>>>>                    WebSet wpsSelection of oWqOpenQuery     to sValue
48542>>>>>                    Get FilenameFromPath of ghoWQF sValue   to sFile
48543>>>>>                    WebSet psValue of oFileName             to sFile
48544>>>>>                End
48544>>>>>>
48544>>>>>                Else Begin
48545>>>>>                    If bDir WebSet wpsSelection of oWqOpenQuery to (sValue + "\")
48548>>>>>                    Else    WebSet wpsSelection of oWqOpenQuery to sValue
48550>>>>>                End
48550>>>>>>
48550>>>>>                
48550>>>>>            End_Procedure
48551>>>>>            
48551>>>>>        End_Object
48552>>>>>        
48552>>>>>    End_Object 
48553>>>>>    
48553>>>>>    Object oBottomPanel is a cWebPanel
48555>>>>>        Set piColumnCount to 6
48556>>>>>        Set peRegion to prBottom
48557>>>>>
48557>>>>>        Object oFileName is a cWebForm
48559>>>>>            Set piColumnSpan to 5
48560>>>>>            Set psLabel to "File name:"
48561>>>>>        End_Object
48562>>>>>
48562>>>>>        Object oOkButton is a cWebButton
48564>>>>>            Set psCaption to C_$OK
48565>>>>>            Set piColumnSpan to 1
48566>>>>>            Set piColumnIndex to 5
48567>>>>>
48567>>>>>            Procedure OnClick
48570>>>>>                Send Ok
48571>>>>>            End_Procedure
48572>>>>>            
48572>>>>>        End_Object 
48573>>>>>
48573>>>>>        Object oFileType is a cWebCombo
48575>>>>>            Set pbServerOnChange to True
48576>>>>>            Set piColumnSpan to 5
48577>>>>>            Set psLabel to "Files of type:"
48578>>>>>            
48578>>>>>            Procedure OnFill
48581>>>>>                Send AddComboItem "*.wqr" "Web Query Files (*.wqr)"
48582>>>>>                Send AddComboItem "*.*" "All Files (*.*)"
48583>>>>>            End_Procedure
48584>>>>>            
48584>>>>>            Procedure OnChange String sNewValue String sOldValue
48587>>>>>                
48587>>>>>                If (sNewValue <> sOldValue) Begin
48589>>>>>                    Send FullRefresh of oDirectories
48590>>>>>                    WebSet pbEnabled of oDeleteButton to False
48591>>>>>                    WebSet pbEnabled of oCreateButton to False
48592>>>>>                End
48592>>>>>>
48592>>>>>                
48592>>>>>            End_Procedure
48593>>>>>            
48593>>>>>        End_Object
48594>>>>>
48594>>>>>        Object oCancelButton is a cWebButton
48596>>>>>            Set psCaption to C_$Cancel
48597>>>>>            Set piColumnSpan to 1
48598>>>>>            Set piColumnIndex to 5
48599>>>>>
48599>>>>>            Procedure OnClick
48602>>>>>                Send Cancel
48603>>>>>            End_Procedure
48604>>>>>            
48604>>>>>        End_Object 
48605>>>>>
48605>>>>>        Object oCreateButton is a cWebButton
48607>>>>>            Set piColumnSpan  to 2
48608>>>>>            Set piColumnIndex to 3 
48609>>>>>            Set psCaption     to "Create Directory"
48610>>>>>            Set pbEnabled     to False
48611>>>>>        
48611>>>>>            Procedure OnClick
48614>>>>>                Send CreateDirectory
48615>>>>>            End_Procedure
48616>>>>>            
48616>>>>>        End_Object
48617>>>>>        
48617>>>>>        Object oDeleteButton is a cWebButton
48619>>>>>            Set piColumnSpan  to 0
48620>>>>>            Set psCaption     to "Delete"
48621>>>>>            Set piColumnSpan  to 1
48622>>>>>            Set piColumnIndex to 5
48623>>>>>            Set pbEnabled     to False
48624>>>>>        
48624>>>>>            Procedure OnClick
48627>>>>>                Send DeleteQuery
48628>>>>>            End_Procedure
48629>>>>>            
48629>>>>>        End_Object
48630>>>>>
48630>>>>>    End_Object 
48631>>>>>
48631>>>>>    Procedure OnSubmit
48634>>>>>        Send Ok
48635>>>>>    End_Procedure
48636>>>>>    
48636>>>>>    Procedure OverwriteCallback Integer eConfMode
48639>>>>>        If (eConfMode = cmYes) Forward Send Ok
48643>>>>>    End_Procedure
48644>>>>>    
48644>>>>>    WebPublishProcedure OverwriteCallback
48645>>>>>    
48645>>>>>    Procedure DeleteCallback Integer eConfMode
48648>>>>>        Boolean bExist
48648>>>>>        String  sFile
48648>>>>>        
48648>>>>>        If (eConfMode = cmYes) Begin
48650>>>>>            WebGet psSelectedValue of oDirectories to sFile
48651>>>>>            File_Exist sFile bExist
48652>>>>>            If bExist EraseFile sFile
48655>>>>>            Set pbEnabled of oDeleteButton to False
48656>>>>>            Set pbEnabled of oCreateButton to False
48657>>>>>            Send FullRefresh of oDirectories
48658>>>>>        End
48658>>>>>>
48658>>>>>        
48658>>>>>    End_Procedure
48659>>>>>
48659>>>>>    WebPublishProcedure DeleteCallback
48660>>>>>    
48660>>>>>    Procedure RemoveCallBack Integer eConfMode
48663>>>>>        String  sFile
48663>>>>>        Boolean bExist
48663>>>>>        wqDir[] aContents
48663>>>>>        wqDir[] aContents
48664>>>>>        
48664>>>>>        If (eConfMode = cmYes) Begin
48666>>>>>            WebGet psSelectedValue of oDirectories to sFile
48667>>>>>            File_Exist sFile bExist
48668>>>>>            If not bExist Procedure_Return
48671>>>>>            Get DirectoryContents of ghoWQF sFile "*"  to aContents
48672>>>>>            If (SizeOfArray(aContents) > 0) Procedure_Return            
48675>>>>>            Remove_Directory sFile
48676>>>>>            Set pbEnabled of oDeleteButton to False
48677>>>>>            Set pbEnabled of oCreateButton to False
48678>>>>>            Send FullRefresh of oDirectories
48679>>>>>        End        
48679>>>>>>
48679>>>>>                
48679>>>>>    End_Procedure
48680>>>>>    
48680>>>>>    WebPublishProcedure RemoveCallBack
48681>>>>>    
48681>>>>>    Procedure DeleteQuery
48684>>>>>        Boolean bExist bPub
48684>>>>>        String  sFile sName sPath sDir sID
48684>>>>>        Integer iPos
48684>>>>>        wqDir[] aContents
48684>>>>>        wqDir[] aContents
48685>>>>>        
48685>>>>>        WebGet psSelectedValue of oDirectories to sFile
48686>>>>>        WebGet psSelectedId    of oDirectories to sID
48687>>>>>        
48687>>>>>        If (Right(sID, 1) = "d") Begin
48689>>>>>            File_Exist sFile bExist
48690>>>>>            
48690>>>>>            If bExist Begin
48692>>>>>                Get StorePath of ghoWQF             to sPath
48693>>>>>                Move (Replace(sPath, sFile, ""))    to sName
48694>>>>>                Move (Pos("\", sName, 2))           to iPos
48695>>>>>                
48695>>>>>                If iPos Begin
48697>>>>>                    Move (Left(sName, (iPos - 1)))              to sDir
48698>>>>>                    Move (sDir = C_wqPublicDir)                 to bPub
48699>>>>>                    Move (Right(sName, (Length(sName) - iPos))) to sName
48700>>>>>                End
48700>>>>>>
48700>>>>>                
48700>>>>>                Get DirectoryContents of ghoWQF sFile "*"  to aContents
48701>>>>>                
48701>>>>>                If (SizeOfArray(aContents) > 0) Begin
48703>>>>>                    Send ShowInfoBox ;                        ("Cannot remove" * If(bPub, "public", "private") * ;                         "directory <<" *  sName * ">> as it has contents.\n\r" + ;                         "Delete the contents first.") ;                         "Cannot Remove"
48704>>>>>                    Procedure_Return
48705>>>>>                End
48705>>>>>>
48705>>>>>                Else Begin
48706>>>>>                    Send ShowYesNo Self ;                        (RefProc(RemoveCallBack)) ;                        ("Do you wish to REMOVE the" * If(bPub, "public", "private") * ;                        'directory <<' + sName + '>>?') "Remove directory?"
48707>>>>>                End
48707>>>>>>
48707>>>>>                
48707>>>>>            End
48707>>>>>>
48707>>>>>            
48707>>>>>        End
48707>>>>>>
48707>>>>>        Else Begin
48708>>>>>        
48708>>>>>            File_Exist sFile bExist
48709>>>>>            
48709>>>>>            If bExist Begin
48711>>>>>                // ToDo: This approach might not work with queries in subdirectories...
48711>>>>>                
48711>>>>>                Get StorePath of ghoWQF             to sPath
48712>>>>>                Move (Replace(sPath, sFile, ""))    to sName
48713>>>>>                Move (Pos("\", sName, 2))           to iPos
48714>>>>>                
48714>>>>>                If iPos Begin
48716>>>>>                    Move (Left(sName, (iPos - 1)))              to sDir
48717>>>>>                    Move (sDir = C_wqPublicDir)                 to bPub
48718>>>>>                    Move (Right(sName, (Length(sName) - iPos))) to sName
48719>>>>>                End
48719>>>>>>
48719>>>>>                
48719>>>>>                Send ShowYesNo Self (RefProc(DeleteCallback)) ;                                    ("Do you wish to DELETE the" * If(bPub, "public", "private") * 'saved query <<' + sName + '>>?') ;                                    "Delete?"
48720>>>>>            End
48720>>>>>>
48720>>>>>            
48720>>>>>        End
48720>>>>>>
48720>>>>>        
48720>>>>>    End_Procedure
48721>>>>>    
48721>>>>>    Function CurrentPath Returns String
48724>>>>>        String  sPath sID
48724>>>>>        Integer iPos
48724>>>>>        
48724>>>>>        WebGet psSelectedValue of oDirectories to sPath
48725>>>>>        WebGet psSelectedId    of oDirectories to sId
48726>>>>>        
48726>>>>>        If (Right(sId, 1) = "d") Begin
48728>>>>>            If (Right(sPath, 1) <> "\") Move (sPath + "\") to sPath
48731>>>>>        End
48731>>>>>>
48731>>>>>        Else Begin
48732>>>>>            Move (rPos(oStringFunctions, "\", sPath)) to iPos
48733>>>>>            If iPos Move (Left(sPath, iPos)) to sPath
48736>>>>>        End
48736>>>>>>
48736>>>>>        
48736>>>>>        Function_Return sPath
48737>>>>>    End_Function
48738>>>>>    
48738>>>>>    Procedure CreateDirectory
48741>>>>>        String  sPath
48741>>>>>        
48741>>>>>        Get CurrentPath to sPath
48742>>>>>        Send DoPopup of oWqCreateDirectory Self sPath
48743>>>>>    End_Procedure
48744>>>>>    
48744>>>>>    Procedure DoCreateDirectory
48747>>>>>        String  sName sPath
48747>>>>>        
48747>>>>>        Get EnteredName of oWqCreateDirectory to sName
48748>>>>>        Get CurrentPath                       to sPath
48749>>>>>        Make_Directory (sPath + sName)
48750>>>>>        Set pbEnabled of oDeleteButton to False
48751>>>>>        Set pbEnabled of oCreateButton to False
48752>>>>>        Send FullRefresh of oDirectories
48753>>>>>    End_Procedure
48754>>>>>    
48754>>>>>    Procedure OnCloseModalDialog Handle hoMD
48757>>>>>        If (hoMD = oWqCreateDirectory) Send DoCreateDirectory
48760>>>>>    End_Procedure
48761>>>>>    
48761>>>>>    Procedure Ok
48764>>>>>        Integer iMode
48764>>>>>        String  sFile sSel sId sPath
48764>>>>>        Boolean bExist
48764>>>>>        
48764>>>>>        WebGet wpiMode                          to iMode
48765>>>>>        WebGet psSelectedValue  of oDirectories to sSel
48766>>>>>        WebGet psSelectedId     of oDirectories to sID
48767>>>>>        WebGet psValue          of oFileName    to sFile
48768>>>>>        
48768>>>>>        If (sId = "") Begin
48770>>>>>            Send ShowInfoBox "No directory selected" "Select directory"
48771>>>>>            Procedure_Return
48772>>>>>        End
48772>>>>>>
48772>>>>>        
48772>>>>>        If (iMode = C_wqOpenQuery) Begin
48774>>>>>            
48774>>>>>            If (Right(sId, 1) = "d") Begin
48776>>>>>                Move (sSel + "\" + sFile)   to sPath
48777>>>>>                
48777>>>>>                File_Exist sPath bExist
48778>>>>>                
48778>>>>>                If bExist Begin
48780>>>>>                    WebSet wpsSelection to sPath
48781>>>>>                    Forward Send Ok
48783>>>>>                End
48783>>>>>>
48783>>>>>                Else Begin
48784>>>>>                    Send ShowInfoBox "No file selected" "Select file"
48785>>>>>                    Procedure_Return
48786>>>>>                End
48786>>>>>>
48786>>>>>                
48786>>>>>            End
48786>>>>>>
48786>>>>>            Else Begin
48787>>>>>                File_Exist sSel bExist
48788>>>>>                
48788>>>>>                If bExist Begin
48790>>>>>                    WebSet wpsSelection to sSel
48791>>>>>                    Forward Send Ok
48793>>>>>                End
48793>>>>>>
48793>>>>>                Else Begin
48794>>>>>                    Send ShowInfoBox "No file selected" "Select file"
48795>>>>>                    Procedure_Return
48796>>>>>                End
48796>>>>>>
48796>>>>>                
48796>>>>>            End
48796>>>>>>
48796>>>>>
48796>>>>>        End
48796>>>>>>
48796>>>>>        Else Begin
48797>>>>>            
48797>>>>>            If (Right(sId, 1) = "d") Begin
48799>>>>>                
48799>>>>>                If (sFile = "") Begin
48801>>>>>                    Send ShowInfoBox "No filename entered" "Enter filename"
48802>>>>>                    Procedure_Return
48803>>>>>                End
48803>>>>>>
48803>>>>>                
48803>>>>>                Move (sSel + "\" + sFile) to sPath
48804>>>>>            End
48804>>>>>>
48804>>>>>            Else Move sSel to sPath
48806>>>>>            
48806>>>>>            File_Exist sPath bExist
48807>>>>>            WebSet wpsSelection to sPath
48808>>>>>            
48808>>>>>            If bExist ;                Send ShowYesNo Self (RefProc(OverwriteCallback)) ;                                    ("File" * sFile * "already exists - do you wish to overwrite it?") ;                                    "Overwrite?"
48811>>>>>            Else Forward Send Ok
48814>>>>>            
48814>>>>>        End
48814>>>>>>
48814>>>>>                
48814>>>>>    End_Procedure
48815>>>>>    
48815>>>>>    Procedure Cancel
48818>>>>>        Forward Send Cancel
48820>>>>>    End_Procedure
48821>>>>>    
48821>>>>>    Procedure OnShow
48824>>>>>        Integer iMode
48824>>>>>        String  sDefault sFilename
48824>>>>>        
48824>>>>>        Send FullRefresh of oDirectories
48825>>>>>        WebSet pbEnabled of oDeleteButton to False
48826>>>>>        WebSet pbEnabled of oCreateButton to False
48827>>>>>        WebSet psValue   of oFileName     to ""
48828>>>>>        
48828>>>>>        WebGet wpiMode to iMode
48829>>>>>        
48829>>>>>        If (iMode = C_wqSaveQuery) Begin
48831>>>>>            WebGet psValue of oFileName to sFilename
48832>>>>>            WebGet wpsDefault to sDefault
48833>>>>>            If (sFilename = "") WebSet psValue of oFileName to (sDefault + ".wqr")
48836>>>>>        End
48836>>>>>>
48836>>>>>            
48836>>>>>    End_Procedure
48837>>>>>    
48837>>>>>    Procedure PopupDialog Handle hoObj Integer iMode String sDefault
48840>>>>>        
48840>>>>>        If (iMode = C_wqOpenQuery) WebSet psCaption to "Open Query"
48843>>>>>        If (iMode = C_wqSaveQuery) WebSet psCaption to "Save Query"
48846>>>>>        
48846>>>>>        Send MakeDirectories of ghoWQF
48847>>>>>        WebSet wpiMode    to iMode
48848>>>>>        WebSet wpsDefault to sDefault
48849>>>>>        WebSet wpiNextID  to 0
48850>>>>>        Send Popup hoObj
48851>>>>>    End_Procedure
48852>>>>>    
48852>>>>>    Function FileOpened Returns String
48855>>>>>        String  sFile
48855>>>>>        
48855>>>>>        WebGet wpsSelection to sFile
48856>>>>>        
48856>>>>>        Function_Return sFile
48857>>>>>    End_Function
48858>>>>>    
48858>>>>>    Procedure Clear
48861>>>>>        WebSet psValue of oFileName to ""
48862>>>>>        WebSet psValue of oFileType to "*.wqr"
48863>>>>>    End_Procedure
48864>>>>>    
48864>>>>>End_Object
48865>>>Use wqOutputModal.wo
Including file: wqOutputModal.wo    (Z:\VmShare\Projects\WebQuery18-0\AppSrc\wqOutputModal.wo)
48865>>>>>Use cWebModalDialog
48865>>>>>Use cWebPanel.pkg
48865>>>>>Use cWebButton.pkg
48865>>>>>Use cWebForm.pkg
48865>>>>>Use cWebHtmlBox.pkg
48865>>>>>
48865>>>>>Use StructFunctions.pkg
48865>>>>>Use cWebIFrame.pkg
48865>>>>>
48865>>>>>//Enum_List
48865>>>>>//    Define C_wqFirstPage for  1
48865>>>>>//    Define C_wqLastPage  for -1
48865>>>>>//End_Enum_List
48865>>>>>
48865>>>>>Object oWqOutputModal is a cWebModalDialog
48867>>>>>    Set psCaption           to "Report"
48868>>>>>    Set piMinWidth          to 800
48869>>>>>    Set piMinHeight         to 600
48870>>>>>    Set pbResizable         to True
48871>>>>>    
48871>>>>>    Object oMainPanel is a cWebPanel
48873>>>>>        Set piColumnCount to 10
48874>>>>>
48874>>>>>        Object oReportFrame is a cWebIFrame
48876>>>>>            Set pbFillHeight to True
48877>>>>>        End_Object  // oReportFrame
48878>>>>>
48878>>>>>    End_Object
48879>>>>>    
48879>>>>>    Object oBottomPanel is a cWebPanel
48881>>>>>        Set piColumnCount to 12
48882>>>>>        Set peRegion to prBottom
48883>>>>>
48883>>>>>        Object oCloseButton is a cWebButton
48885>>>>>            Set psCaption to C_$Close
48886>>>>>            Set piColumnSpan to 1
48887>>>>>            Set piColumnIndex to 11
48888>>>>>
48888>>>>>            Procedure OnClick
48891>>>>>                Send Ok
48892>>>>>            End_Procedure
48893>>>>>            
48893>>>>>        End_Object  // oCloseButton
48894>>>>>        
48894>>>>>    End_Object
48895>>>>>    
48895>>>>>    Procedure PopupOutput Handle hoObj String sFile String sTitle
48898>>>>>        WebSet psCaption to ("WebQuery:" * sTitle)
48899>>>>>        WebSet psUrl of oReportFrame to sFile
48900>>>>>        Send Popup hoObj
48901>>>>>    End_Procedure  //PopupReport
48902>>>>>    
48902>>>>>End_Object
48903>>>Use wqAdHocIndex.wo
Including file: wqAdHocIndex.wo    (Z:\VmShare\Projects\WebQuery18-0\AppSrc\wqAdHocIndex.wo)
48903>>>>>Use cWebModalDialog
48903>>>>>Use cWebPanel.pkg
48903>>>>>Use cWebButton.pkg
48903>>>>>Use cWebForm.pkg
48903>>>>>Use cWebQueryFunctions.pkg
48903>>>>>Use cWebHorizontalLine.pkg
48903>>>>>Use cWebList.pkg
48903>>>>>Use cWebGrid.pkg
48903>>>>>Use cWebColumn.pkg
48903>>>>>Use cWebColumnCheckbox.pkg
48903>>>>>
48903>>>>>Use StructFunctions.pkg
48903>>>>>
48903>>>>>Object oWqAdHocIndex is a cWebModalDialog
48905>>>>>    Property Handle  wphMainTable
48909>>>>>    Property Handle  wphNewTab
48913>>>>>    Property Integer wpiNewCol
48917>>>>>    Property String  wpsSegments
48921>>>>>    
48921>>>>>    Property Handle  phSelectedTable
48923>>>>>    Property wqIndexSeg[] paSegments
48925>>>>>    
48925>>>>>    Set psCaption to "Specify ad hoc index"
48926>>>>>    Set piMinWidth to 600
48927>>>>>    Set piMinHeight to 400
48928>>>>>    Set pbServerOnSubmit to True    // enable the OnSubmit event
48929>>>>>    Set pbServerOnShow   to True
48930>>>>>    
48930>>>>>    Object oMainPanel is a cWebPanel
48932>>>>>        Set piColumnCount to 10
48933>>>>>
48933>>>>>        Object oSelPanel is a cWebPanel
48935>>>>>            Set piColumnCount to 10
48936>>>>>            Set peRegion to prCenter
48937>>>>>            
48937>>>>>            Object oTabsList is a cWebList
48939>>>>>                Set pbFillHeight to True
48940>>>>>                Set pbDataAware to False
48941>>>>>                Set pbColumnSortable to False
48942>>>>>                
48942>>>>>                Object oTabCol is a cWebColumn
48944>>>>>                    Set psCaption to "Table"
48945>>>>>                End_Object
48946>>>>>                
48946>>>>>                Procedure OnChangeCurrentRow String sFromRowID String sToRowID
48949>>>>>                    Set phSelectedTable     to sToRowID
48950>>>>>                    Send GridRefresh        of oColList
48951>>>>>                    WebSet psCurrentRowID   of oColList to 1
48952>>>>>                End_Procedure  // OnChangeCurrentRow
48953>>>>>                
48953>>>>>                Procedure OnManualLoadData tWebRow[] ByRef aTheRows String ByRef sCurrentRowID
48956>>>>>                    Handle hTab
48956>>>>>                    
48956>>>>>                    WebGet wphMainTable of oWqAdHocIndex to hTab
48957>>>>>                    Send RelatedFiles of ghoWQF (&aTheRows) hTab
48958>>>>>                End_Procedure  // OnManualLoadData
48959>>>>>            
48959>>>>>            End_Object  // oTabsList
48960>>>>>        
48960>>>>>            Object oColList is a cWebList
48962>>>>>                Set pbFillHeight to True
48963>>>>>                Set pbDataAware to False
48964>>>>>                Set pbColumnSortable to False
48965>>>>>                
48965>>>>>                Object oFldCol is a cWebColumn
48967>>>>>                    Set psCaption to "Fields"
48968>>>>>                End_Object
48969>>>>>                
48969>>>>>                Procedure OnManualLoadData tWebRow[] ByRef aTheRows String ByRef sCurrentRowID
48972>>>>>                    Send CollectColumns of ghoWQF (&aTheRows) (phSelectedTable(oWqAdHocIndex))
48973>>>>>                End_Procedure  // OnManualLoadData
48974>>>>>            
48974>>>>>            End_Object  // oColList
48975>>>>>        
48975>>>>>        End_Object  // oSelPanel
48976>>>>>        
48976>>>>>        Object oIndexPanel is a cWebPanel
48978>>>>>            Set peRegion to prRight
48979>>>>>            Set piWidth to 400
48980>>>>>
48980>>>>>            Object oSelectedList is a cWebGrid
48982>>>>>                Set pbFillHeight        to True
48983>>>>>                Set pbDataAware         to False
48984>>>>>                Set pbOfflineEditing    to True
48985>>>>>                Set pbAllowAppendRow    to False
48986>>>>>                Set pbAllowInsertRow    to False
48987>>>>>                Set pbAllowDeleteRow    to False
48988>>>>>                
48988>>>>>                Object oNumCol is a cWebColumn
48990>>>>>                    Set psCaption to "Num"
48991>>>>>                    Set piWidth to 8
48992>>>>>                    Set pbEnabled to False
48993>>>>>                End_Object
48994>>>>>                
48994>>>>>                Object oNameCol is a cWebColumn
48996>>>>>                    Set psCaption to "Field"
48997>>>>>                    Set piWidth to 65
48998>>>>>                    Set pbEnabled to False
48999>>>>>                End_Object
49000>>>>>                
49000>>>>>                Object oCapsCol is a cWebColumnCheckbox
49002>>>>>                    Set psCaption to "Caps"
49003>>>>>                    Set piWidth to 12
49004>>>>>                End_Object
49005>>>>>                
49005>>>>>                Object oRevCol is a cWebColumnCheckbox
49007>>>>>                    Set psCaption to "Reverse"
49008>>>>>                    Set piWidth to 15
49009>>>>>                End_Object
49010>>>>>                
49010>>>>>                Object oTabCol is a cWebColumn
49012>>>>>                    Set pbRender to False
49013>>>>>                End_Object  // oTabCol
49014>>>>>                
49014>>>>>                Object oColCol is a cWebColumn
49016>>>>>                    Set pbRender to False
49017>>>>>                End_Object  // oColCol
49018>>>>>                
49018>>>>>                Procedure OnProcessDataSet tWebRow[] aData Integer eOp Integer iSelRow
49021>>>>>                    Send StoreTheData aData eOp iSelRow
49022>>>>>                End_Procedure  // OnProcessDataSet
49023>>>>>                
49023>>>>>                Procedure OnManualLoadData tWebRow[] ByRef aTheRows String ByRef sCurrentRowID
49026>>>>>                    Send LoadTheData (&aTheRows) (&sCurrentRowID)
49027>>>>>                End_Procedure  // OnManualLoadData
49028>>>>>
49028>>>>>            End_Object
49029>>>>>            
49029>>>>>        End_Object  // oSelectedList
49030>>>>>        
49030>>>>>    End_Object  // oIndexPanel
49031>>>>>    
49031>>>>>    Object oBottomPanel is a cWebPanel
49033>>>>>        Set piColumnCount to 16
49034>>>>>        Set peRegion to prBottom
49035>>>>>        
49035>>>>>        Object oAddSegBut is a cWebButton
49037>>>>>            Set psCaption to "Add"
49038>>>>>            Set piColumnSpan to 2
49039>>>>>            Set piColumnIndex to 6
49040>>>>>            
49040>>>>>            Procedure OnClick
49043>>>>>                Send AddSegment
49044>>>>>            End_Procedure
49045>>>>>            
49045>>>>>        End_Object  // oAddSegBut
49046>>>>>
49046>>>>>        Object oMoveUpBut is a cWebButton
49048>>>>>            Set psCaption to "Move up"
49049>>>>>            Set piColumnSpan to 3
49050>>>>>            Set piColumnIndex to 8
49051>>>>>
49051>>>>>            Procedure OnClick
49054>>>>>                Send MoveSegUp
49055>>>>>            End_Procedure
49056>>>>>            
49056>>>>>        End_Object // oMoveUpBut
49057>>>>>
49057>>>>>        Object oMoveDownBut is a cWebButton
49059>>>>>            Set psCaption to "Move down"
49060>>>>>            Set piColumnSpan to 3
49061>>>>>            Set piColumnIndex to 11
49062>>>>>
49062>>>>>            Procedure OnClick
49065>>>>>                Send MoveSegDown
49066>>>>>            End_Procedure
49067>>>>>            
49067>>>>>        End_Object // oMoveDownBut
49068>>>>>
49068>>>>>        Object oDeleteBut is a cWebButton
49070>>>>>            Set psCaption to "Delete"
49071>>>>>            Set piColumnSpan to 3
49072>>>>>            Set piColumnIndex to 14
49073>>>>>
49073>>>>>            Procedure OnClick
49076>>>>>                Send DeleteSegment
49077>>>>>            End_Procedure
49078>>>>>            
49078>>>>>        End_Object 
49079>>>>>
49079>>>>>        Object oWebHorizontalLine1 is a cWebHorizontalLine
49081>>>>>        End_Object
49082>>>>>
49082>>>>>        Object oOkButton is a cWebButton
49084>>>>>            Set psCaption to C_$OK
49085>>>>>            Set piColumnSpan to 3
49086>>>>>            Set piColumnIndex to 11
49087>>>>>
49087>>>>>            Procedure OnClick
49090>>>>>                Send Ok
49091>>>>>            End_Procedure
49092>>>>>            
49092>>>>>        End_Object  // oDeleteBut
49093>>>>>
49093>>>>>        Object oCancelButton is a cWebButton
49095>>>>>            Set psCaption to C_$Cancel
49096>>>>>            Set piColumnSpan to 3
49097>>>>>            Set piColumnIndex to 14
49098>>>>>
49098>>>>>            Procedure OnClick
49101>>>>>                Send Cancel
49102>>>>>            End_Procedure
49103>>>>>            
49103>>>>>        End_Object 
49104>>>>>        
49104>>>>>    End_Object
49105>>>>>    
49105>>>>>    Procedure AddSegment
49108>>>>>        Integer iCol
49108>>>>>        Handle  hTab
49108>>>>>        
49108>>>>>        WebGet psCurrentRowID of oTabsList to hTab
49109>>>>>        WebGet psCurrentRowID of oColList  to iCol
49110>>>>>        
49110>>>>>        If hTab Begin
49112>>>>>            WebSet wphNewTab to hTab
49113>>>>>            WebSet wpiNewCol to iCol
49114>>>>>            Send ProcessDataSet of oSelectedList C_wqAppendRow
49115>>>>>        End
49115>>>>>>
49115>>>>>        
49115>>>>>    End_Procedure  // AddSegment
49116>>>>>    
49116>>>>>    Procedure DeleteSegment
49119>>>>>        Send ProcessDataSet of oSelectedList C_wqDeleteRow
49120>>>>>    End_Procedure  // DeleteSegment
49121>>>>>    
49121>>>>>    Procedure MoveSegUp
49124>>>>>        Send ProcessDataSet of oSelectedList C_wqMoveRowUp
49125>>>>>    End_Procedure  // MoveSegUp
49126>>>>>    
49126>>>>>    Procedure MoveSegDown
49129>>>>>        Send ProcessDataSet of oSelectedList C_wqMoveRowDown
49130>>>>>    End_Procedure  // MoveSegDown
49131>>>>>
49131>>>>>    Procedure OnSubmit
49134>>>>>        Handle  hoFoc
49134>>>>>        
49134>>>>>        Get FocusObject to hoFoc
49135>>>>>        
49135>>>>>        If (hoFoc = oColList) Send AddSegment
49138>>>>>    End_Procedure
49139>>>>>    
49139>>>>>    Procedure StoreTheData tWebRow[] aData Integer eOp Integer iSelRow
49142>>>>>        wqIndexSeg[] aSegs
49142>>>>>        wqIndexSeg[] aSegs
49143>>>>>        wqIndexSeg   tSeg
49143>>>>>        wqIndexSeg   tSeg
49143>>>>>        Integer i iCol iRow iMax
49143>>>>>        Handle  hTab
49143>>>>>        String  sName sSegs
49143>>>>>        
49143>>>>>        For i from 0 to (SizeOfArray(aData) - 1)
49149>>>>>>
49149>>>>>            Move aData[i].aCells[1].sValue to aSegs[i].sName
49150>>>>>            Move aData[i].aCells[2].sValue to aSegs[i].bUC
49151>>>>>            Move aData[i].aCells[3].sValue to aSegs[i].bDesc
49152>>>>>            Move aData[i].aCells[4].sValue to aSegs[i].iTable
49153>>>>>            Move aData[i].aCells[5].sValue to aSegs[i].iField
49154>>>>>        Loop
49155>>>>>>
49155>>>>>        
49155>>>>>        If (eOp = C_wqAppendRow) Begin
49157>>>>>            WebGet wphNewTab to hTab
49158>>>>>            WebGet wpiNewCol to iCol
49159>>>>>            
49159>>>>>            If hTab Begin
49161>>>>>                Move hTab                                       to tSeg.iTable
49162>>>>>                Move iCol                                       to tSeg.iField
49163>>>>>                Move False                                      to tSeg.bBreak
49164>>>>>                Move False                                      to tSeg.bUC
49165>>>>>                Move False                                      to tSeg.bDesc
49166>>>>>                Move (NiceFieldName(ghoWQF, hTab, iCol) + ": ") to tSeg.sName
49167>>>>>                Move tSeg                                       to aSegs[(SizeOfArray(aSegs))]
49168>>>>>
49168>>>>>                WebGet piCurrentRowIndex of oColList to iRow
49169>>>>>                WebGet piRowCount        of oColList to iMax
49170>>>>>                If (iRow < (iMax - 1)) Send MoveToRow of oColList (iRow + 1)
49173>>>>>            End
49173>>>>>>
49173>>>>>            
49173>>>>>        End
49173>>>>>>
49173>>>>>        Else If (eOp = C_wqDeleteRow) Begin
49176>>>>>            If ((iSelRow => 0) and (iSelRow < SizeOfArray(aSegs))) ;                Move (RemoveFromArray(aSegs, iSelRow))                  to aSegs
49179>>>>>        End
49179>>>>>>
49179>>>>>        Else If (eOp = C_wqMoveRowUp) Begin
49182>>>>>            
49182>>>>>            If (iSelRow > 0) Begin
49184>>>>>                Move aSegs[iSelRow]                                     to tSeg
49185>>>>>                Move (RemoveFromArray(aSegs, iSelRow))                  to aSegs
49186>>>>>                Move (InsertInArray(aSegs, (iSelRow - 1), tSeg))        to aSegs
49187>>>>>                WebSet psCurrentRowID of oSelectedList                  to (iSelRow - 1)
49188>>>>>            End
49188>>>>>>
49188>>>>>            
49188>>>>>        End
49188>>>>>>
49188>>>>>        Else If (eOp = C_wqMoveRowDown) Begin
49191>>>>>            
49191>>>>>            If (iSelRow < (SizeOfArray(aData) - 1)) Begin
49193>>>>>                Move aSegs[iSelRow]                                     to tSeg
49194>>>>>                Move (RemoveFromArray(aSegs, iSelRow))                  to aSegs
49195>>>>>                If ((iSelRow + 1) => SizeOfArray(aSegs)) ;                     Move tSeg                                          to aSegs[(SizeOfArray(aSegs))]
49198>>>>>                Else Move (InsertInArray(aSegs, (iSelRow + 1), tSeg))   to aSegs
49200>>>>>                WebSet psCurrentRowID of oSelectedList                  to (iSelRow + 1)
49201>>>>>            End
49201>>>>>>
49201>>>>>            
49201>>>>>        End
49201>>>>>>
49201>>>>>        
49201>>>>>        Set paSegments to aSegs
49202>>>>>        If (SizeOFArray(aSegs)) ;            Get VariantToString of oStructFunctions aSegs to sSegs
49205>>>>>        WebSet wpsSegments to sSegs
49206>>>>>        If (eOp = C_wqSaveData) Forward Send Ok
49210>>>>>        Else                            Send GridRefresh of oSelectedList
49212>>>>>    End_Procedure  // StoreTheData
49213>>>>>    
49213>>>>>    Procedure LoadTheData tWebRow[] ByRef aRows String ByRef sCurrRowID
49216>>>>>        wqIndexSeg[] aSegs
49216>>>>>        wqIndexSeg[] aSegs
49217>>>>>        Integer i
49217>>>>>        String  sSegs
49217>>>>>        tValueTree tVT
49217>>>>>        tValueTree tVT
49217>>>>>        
49217>>>>>        WebGet wpsSegments to sSegs
49218>>>>>        
49218>>>>>        If (sSegs <> "") Begin
49220>>>>>            Get StringToValueTree of oStructFunctions sSegs to tVT
49221>>>>>            ValueTreeDeserializeParameter tVT to aSegs
49222>>>>>        End
49222>>>>>>
49222>>>>>        
49222>>>>>        For i from 0 to (SizeOfArray(aSegs) - 1)
49228>>>>>>
49228>>>>>            Move i                  to aRows[i].sRowID
49229>>>>>            Move (i + 1)            to aRows[i].aCells[0].sValue
49230>>>>>            Move aSegs[i].sName     to aRows[i].aCells[1].sValue
49231>>>>>            Move aSegs[i].bUC       to aRows[i].aCells[2].sValue
49232>>>>>            Move aSegs[i].bDesc     to aRows[i].aCells[3].sValue
49233>>>>>            Move aSegs[i].iTable    to aRows[i].aCells[4].sValue
49234>>>>>            Move aSegs[i].iField    to aRows[i].aCells[5].sValue
49235>>>>>        Loop
49236>>>>>>
49236>>>>>    
49236>>>>>    End_Procedure  // LoadTheData
49237>>>>>    
49237>>>>>    Procedure Ok
49240>>>>>        Send ProcessDataSet of oSelectedList C_wqSaveData
49241>>>>>    End_Procedure
49242>>>>>
49242>>>>>    Procedure Cancel
49245>>>>>        Forward Send Cancel
49247>>>>>    End_Procedure
49248>>>>>
49248>>>>>    Procedure OnShow
49251>>>>>        Send GridRefresh of oTabsList
49252>>>>>        Send GridRefresh of oSelectedList
49253>>>>>    End_Procedure  // OnLoad
49254>>>>>    
49254>>>>>    Procedure PopupAdHoc Handle hoObj Handle hMainTab wqIndexSeg[] aSegs
49257>>>>>        Integer i
49257>>>>>        String  sSegs
49257>>>>>        
49257>>>>>        If (SizeOfArray(aSegs)) ;            Get VariantToString of oStructFunctions aSegs to sSegs
49260>>>>>        WebSet wpsSegments to sSegs
49261>>>>>        WebSet wphMainTable             to hMainTab
49262>>>>>        
49262>>>>>        Send Popup hoObj
49263>>>>>    End_Procedure  // DoPopup
49264>>>>>
49264>>>>>    Function AdHocSegments Returns wqIndexSeg[]
49267>>>>>        wqIndexSeg[] aSegs
49267>>>>>        wqIndexSeg[] aSegs
49268>>>>>        tValueTree tVT
49268>>>>>        tValueTree tVT
49268>>>>>        String  sSegs
49268>>>>>        
49268>>>>>//        Get paSegments to aSegs
49268>>>>>        WebGet wpsSegments to sSegs
49269>>>>>        
49269>>>>>        If (sSegs <> "") Begin
49271>>>>>            Get StringToValueTree of oStructFunctions sSegs to tVT
49272>>>>>            ValueTreeDeserializeParameter tVT to aSegs
49273>>>>>        End
49273>>>>>>
49273>>>>>        
49273>>>>>        Function_Return aSegs
49274>>>>>    End_Function  // AdHocSegments
49275>>>>>    
49275>>>>>End_Object
49276>>>Use wqCalcColumn.wo
Including file: wqCalcColumn.wo    (Z:\VmShare\Projects\WebQuery18-0\AppSrc\wqCalcColumn.wo)
49276>>>>>Use cWebModalDialog
49276>>>>>Use cWebPanel.pkg
49276>>>>>Use cWebButton.pkg
49276>>>>>Use cWebForm.pkg
49276>>>>>Use cWebLabel.pkg
49276>>>>>Use cWebCombo.pkg
49276>>>>>Use cWebSpacer.pkg
49276>>>>>
49276>>>>>Define C_wqTypeText for -1
49276>>>>>
49276>>>>>Object oWqCalcColumn is a cWebModalDialog
49278>>>>>    Property Handle  wphMainTable
49282>>>>>    Property String  wpsExpression
49286>>>>>    Property Integer wpiAction
49290>>>>>    
49290>>>>>    Property Integer piOperation
49292>>>>>    Property Integer piField
49294>>>>>    
49294>>>>>    Set psCaption to "Calculated column"
49295>>>>>    Set piMinWidth to 400
49296>>>>>    Set piMinHeight to 180
49297>>>>>    Set pbServerOnSubmit to True
49298>>>>>    
49298>>>>>    Object oMainPanel is a cWebPanel
49300>>>>>        Set piColumnCount to 10
49301>>>>>
49301>>>>>        Object oLongLab is a cWebForm
49303>>>>>            Set piColumnSpan to 0
49304>>>>>            Set psLabel to "Long label:"
49305>>>>>            Set piLabelOffset to 90
49306>>>>>            Set pbServerOnChange to True
49307>>>>>            
49307>>>>>            
49307>>>>>            Procedure OnChange String sNewValue String sOldValue
49310>>>>>                String  sShort
49310>>>>>                
49310>>>>>                WebGet psValue of oShortLab to sShort
49311>>>>>                If ((sNewValue <> "") and (sShort = "")) WebSet psValue of oShortLab to sNewValue
49314>>>>>            End_Procedure
49315>>>>>            
49315>>>>>            
49315>>>>>        End_Object
49316>>>>>
49316>>>>>        Object oShortLab is a cWebForm
49318>>>>>            Set piColumnSpan to 0
49319>>>>>            Set psLabel to "Short label:"
49320>>>>>            Set piColumnSpan to 6
49321>>>>>            Set piLabelOffset to 90
49322>>>>>        End_Object
49323>>>>>
49323>>>>>        Object oWidth is a cWebForm
49325>>>>>            Set piColumnSpan to 0
49326>>>>>            Set psLabel to "Width:"
49327>>>>>            Set piColumnSpan to 4
49328>>>>>            Set peDataType to typeNumber
49329>>>>>            Set psValue to 10
49330>>>>>            Set piLabelOffset to 90
49331>>>>>        End_Object
49332>>>>>
49332>>>>>        Object oCharLab is a cWebLabel
49334>>>>>            Set psCaption to "characters"
49335>>>>>            Set piColumnIndex to 4
49336>>>>>            Set piColumnSpan to 0
49337>>>>>        End_Object
49338>>>>>
49338>>>>>        Object oRetType is a cWebCombo
49340>>>>>            Set piColumnSpan to 0
49341>>>>>            Set psLabel to "Return type:"
49342>>>>>            Set piColumnSpan to 5
49343>>>>>            Set piLabelOffset to 90
49344>>>>>            Set pbServerOnChange to True
49345>>>>>            
49345>>>>>            Procedure OnChange String sNewValue String sOldValue
49348>>>>>                WebSet pbEnabled of oDecimals to (sNewValue = typeNumber)
49349>>>>>            End_Procedure
49350>>>>>            
49350>>>>>            Procedure OnFill
49353>>>>>                Send AddComboItem typeNumber   "Numeric"
49354>>>>>                Send AddComboItem typeASCII    "String"
49355>>>>>                Send AddComboItem C_wqTypeText "Text"
49356>>>>>                Send AddComboItem typeDate     "Date"
49357>>>>>                Send AddComboItem typeDateTime "DateTime"
49358>>>>>            End_Procedure
49359>>>>>            
49359>>>>>        End_Object
49360>>>>>
49360>>>>>        Object oDecimals is a cWebForm
49362>>>>>            Set piColumnSpan to 0
49363>>>>>            Set psLabel to "Decimal places:"
49364>>>>>            Set piColumnIndex to 6
49365>>>>>            Set piColumnSpan to 4
49366>>>>>            Set peDataType to typeNumber
49367>>>>>            Set piLabelOffset to 100
49368>>>>>            Set psValue to 0
49369>>>>>        End_Object
49370>>>>>
49370>>>>>        Object oEditButton is a cWebButton
49372>>>>>            Set piColumnSpan to 0
49373>>>>>            Set psCaption to "Edit"
49374>>>>>            Set piColumnSpan to 2
49375>>>>>            Set piColumnIndex to 4
49376>>>>>        
49376>>>>>            Procedure OnClick
49379>>>>>                wqPrintField tField
49379>>>>>                wqPrintField tField
49379>>>>>                Handle  hTab
49379>>>>>                String  sExpr sName
49379>>>>>                Integer iAction
49379>>>>>                
49379>>>>>                WebGet wpsExpression of oWqCalcColumn to sExpr
49380>>>>>                WebGet wphMainTable  of oWqCalcColumn to hTab
49381>>>>>                WebGet wpiAction     of oWqCalcColumn to iAction
49382>>>>>                WebGet psValue       of oShortLab     to sName
49383>>>>>                
49383>>>>>                Send DoPopup of oWqExpressionPopup oWqCalcColumn sExpr iAction 0 hTab sName
49384>>>>>            End_Procedure
49385>>>>>            
49385>>>>>        End_Object
49386>>>>>        
49386>>>>>    End_Object 
49387>>>>>    
49387>>>>>    Object oBottomPanel is a cWebPanel
49389>>>>>        Set piColumnCount to 6
49390>>>>>        Set peRegion to prBottom
49391>>>>>
49391>>>>>        Object oOkButton is a cWebButton
49393>>>>>            Set psCaption to C_$OK
49394>>>>>            Set piColumnSpan to 1
49395>>>>>            Set piColumnIndex to 4
49396>>>>>
49396>>>>>            Procedure OnClick
49399>>>>>                Send Ok
49400>>>>>            End_Procedure
49401>>>>>        End_Object 
49402>>>>>
49402>>>>>        Object oCancelButton is a cWebButton
49404>>>>>            Set psCaption to C_$Cancel
49405>>>>>            Set piColumnSpan to 1
49406>>>>>            Set piColumnIndex to 5
49407>>>>>
49407>>>>>            Procedure OnClick
49410>>>>>                Send Cancel
49411>>>>>            End_Procedure
49412>>>>>        End_Object 
49413>>>>>        
49413>>>>>    End_Object 
49414>>>>>
49414>>>>>    Procedure OnSubmit
49417>>>>>        Send Ok
49418>>>>>    End_Procedure
49419>>>>>    
49419>>>>>    Procedure Ok
49422>>>>>        Forward Send Ok
49424>>>>>    End_Procedure
49425>>>>>
49425>>>>>    Procedure Cancel
49428>>>>>        Forward Send Cancel
49430>>>>>    End_Procedure
49431>>>>>    
49431>>>>>    Procedure OnCloseModalDialog Handle hoMD
49434>>>>>        wqExpressionReturn tExpr
49434>>>>>        wqExpressionReturn tExpr
49434>>>>>        
49434>>>>>        Get ExprValue of hoMD   to tExpr
49435>>>>>        Set piOperation         to tExpr.iOp
49436>>>>>        Set piField             to tExpr.iField
49437>>>>>        WebSet wpsExpression    to tExpr.sExpression
49438>>>>>        WebSet pbEnabled of oOkButton to (tExpr.sExpression <> "")
49439>>>>>    End_Procedure
49440>>>>>    
49440>>>>>    Procedure PopupCalcCol Handle hoObj wqPrintField tField Integer iAction Handle hMainTable
49443>>>>>        WebSet wphMainTable to hMainTable
49444>>>>>        WebSet wpiAction    to iAction
49445>>>>>        
49445>>>>>        If (iAction = C_wqEditExpression) Begin
49447>>>>>            WebSet wpsExpression            to tField.sExpression
49448>>>>>            WebSet psValue of   oLongLab    to tField.sLongLabel
49449>>>>>            WebSet psValue of   oShortLab   to tField.sUserName
49450>>>>>            WebSet psValue of   oWidth      to tField.iWidth
49451>>>>>            WebSet psValue of   oRetType    to tField.iType
49452>>>>>            WebSet psValue of   oDecimals   to tField.iDecimals
49453>>>>>            WebSet pbEnabled of oOkButton   to (tField.sExpression <> "")  // Probably certain to be True here
49454>>>>>        End
49454>>>>>>
49454>>>>>        Else Begin
49455>>>>>            WebSet wpsExpression            to ""
49456>>>>>            WebSet psValue   of oLongLab    to ""
49457>>>>>            WebSet psValue   of oShortLab   to ""
49458>>>>>            WebSet psValue   of oWidth      to 10
49459>>>>>            WebSet psValue   of oRetType    to "Numeric"
49460>>>>>            WebSet psValue   of oDecimals   to 0
49461>>>>>            WebSet pbEnabled of oOkButton   to False
49462>>>>>        End
49462>>>>>>
49462>>>>>        
49462>>>>>        If      (iAction = C_wqAddExpression)    WebSet psCaption to "Create calculated column"
49465>>>>>        Else If (iAction = C_wqInsertExpression) WebSet psCaption to "Create calculated column"
49469>>>>>        Else If (iAction = C_wqEditExpression)   WebSet psCaption to ('Edit calculated column "' * tField.sUserName + '"')
49473>>>>>        
49473>>>>>        Send Popup hoObj
49474>>>>>    End_Procedure
49475>>>>>    
49475>>>>>    Function CalcColInfo Returns wqPrintField
49478>>>>>        wqPrintField tField
49478>>>>>        wqPrintField tField
49478>>>>>        Integer iOp
49478>>>>>        
49478>>>>>        WebGet psValue of oLongLab  to tField.sLongLabel
49479>>>>>        WebGet psValue of oShortLab to tField.sUserName
49480>>>>>        WebGet psValue of oWidth    to tField.iWidth
49481>>>>>        WebGet psValue of oRetType  to tField.iType
49482>>>>>        WebGet psValue of oDecimals to tField.iDecimals
49483>>>>>        WebGet wpsExpression        to tField.sExpression
49484>>>>>        Move True                   to tField.bCalc
49485>>>>>        
49485>>>>>        WebGet wpiAction to iOp
49486>>>>>        Set piOperation  to iOp
49487>>>>>        
49487>>>>>        Function_Return tField
49488>>>>>    End_Function
49489>>>>>    
49489>>>>>End_Object
49490>>>Use wqColourPicker.wo
Including file: wqColourPicker.wo    (Z:\VmShare\Projects\WebQuery18-0\AppSrc\wqColourPicker.wo)
49490>>>>>Use cWebModalDialog
49490>>>>>Use cWebPanel.pkg
49490>>>>>Use cWebButton.pkg
49490>>>>>Use cWebForm.pkg
49490>>>>>Use cWebHtmlBox.pkg
49490>>>>>Use cWebSlider.pkg
49490>>>>>Use cWebQueryFunctions.pkg
49490>>>>>
49490>>>>>Object oWqColourPicker is a cWebModalDialog
49492>>>>>    Set psCaption to "Select Colour"
49493>>>>>    Set piMinWidth to 500
49494>>>>>    Set piMinHeight to 200
49495>>>>>    Set pbServerOnSubmit to true    // enable the OnSubmit event
49496>>>>>    Set pbServerOnShow   to True
49497>>>>>    
49497>>>>>    Property Handle  wphoTarget
49501>>>>>    Property Integer wpiRed
49505>>>>>    Property Integer wpiGreen
49509>>>>>    Property Integer wpiBlue
49513>>>>>    
49513>>>>>    Object oMainPanel is a cWebPanel
49515>>>>>        Set piColumnCount to 10
49516>>>>>        
49516>>>>>        Object oRedSlider is a cWebSlider
49518>>>>>            Set psLabel             to "Red:"
49519>>>>>            Set piColumnSpan        to 0
49520>>>>>            Set piLabelOffset       to 50
49521>>>>>            Set piMinValue          to 0
49522>>>>>            Set piMaxValue          to 255
49523>>>>>            Set pbShowValue         to True
49524>>>>>            Set piInterval          to 1
49525>>>>>            Set pbShowMarkers       to True
49526>>>>>            Set psValue             to 0
49527>>>>>            Set pbServerOnChange    to True
49528>>>>>            
49528>>>>>            Procedure OnChange String sNewValue String sOldValue
49531>>>>>                Send AdjustColour
49532>>>>>            End_Procedure  // EndProcedure
49533>>>>>            
49533>>>>>            Procedure OnFillLabels
49536>>>>>                Send AddLabel  0    0
49537>>>>>                Send AddLabel  32  32
49538>>>>>                Send AddLabel  64  64
49539>>>>>                Send AddLabel  96  96
49540>>>>>                Send AddLabel 128 128
49541>>>>>                Send AddLabel 160 160
49542>>>>>                Send AddLabel 192 192
49543>>>>>                Send AddLabel 224 224
49544>>>>>                Send AddLabel 255 255
49545>>>>>            End_Procedure
49546>>>>>            
49546>>>>>        End_Object               
49547>>>>>                
49547>>>>>        Object oGreenSlider is a cWebSlider
49549>>>>>            Set psLabel       to "Green:"
49550>>>>>            Set piColumnSpan  to 0
49551>>>>>            Set piLabelOffset to 50
49552>>>>>            Set piMinValue    to 0
49553>>>>>            Set piMaxValue    to 255
49554>>>>>            Set piInterval    to 1
49555>>>>>            Set pbShowValue   to True
49556>>>>>            Set pbShowMarkers to True
49557>>>>>            Set psValue       to 0
49558>>>>>            Set pbServerOnChange    to True
49559>>>>>            
49559>>>>>            Procedure OnChange String sNewValue String sOldValue
49562>>>>>                Send AdjustColour
49563>>>>>            End_Procedure  // EndProcedure
49564>>>>>            
49564>>>>>            Procedure OnFillLabels
49567>>>>>                Send AddLabel  0    0
49568>>>>>                Send AddLabel  32  32
49569>>>>>                Send AddLabel  64  64
49570>>>>>                Send AddLabel  96  96
49571>>>>>                Send AddLabel 128 128
49572>>>>>                Send AddLabel 160 160
49573>>>>>                Send AddLabel 192 192
49574>>>>>                Send AddLabel 224 224
49575>>>>>                Send AddLabel 255 255
49576>>>>>            End_Procedure
49577>>>>>            
49577>>>>>        End_Object               
49578>>>>>                
49578>>>>>        Object oBlueSlider is a cWebSlider
49580>>>>>            Set psLabel to "Blue:"
49581>>>>>            Set piColumnSpan to 0
49582>>>>>            Set piLabelOffset to 50
49583>>>>>            Set piMinValue    to 0
49584>>>>>            Set piMaxValue    to 255
49585>>>>>            Set piInterval    to 1
49586>>>>>            Set pbShowValue   to True
49587>>>>>            Set pbShowMarkers to True
49588>>>>>            Set psValue       to 0
49589>>>>>            Set pbServerOnChange    to True
49590>>>>>            
49590>>>>>            Procedure OnChange String sNewValue String sOldValue
49593>>>>>                Send AdjustColour
49594>>>>>            End_Procedure  // EndProcedure
49595>>>>>            
49595>>>>>            Procedure OnFillLabels
49598>>>>>                Send AddLabel  0    0
49599>>>>>                Send AddLabel  32  32
49600>>>>>                Send AddLabel  64  64
49601>>>>>                Send AddLabel  96  96
49602>>>>>                Send AddLabel 128 128
49603>>>>>                Send AddLabel 160 160
49604>>>>>                Send AddLabel 192 192
49605>>>>>                Send AddLabel 224 224
49606>>>>>                Send AddLabel 255 255
49607>>>>>            End_Procedure
49608>>>>>            
49608>>>>>        End_Object
49609>>>>>
49609>>>>>        Object oColourBox is a cWebHtmlBox
49611>>>>>            Set piColumnSpan to 4
49612>>>>>            Set piColumnIndex to 0
49613>>>>>            Set piHeight to 70
49614>>>>>            Set psHtml to "<br><div style='text-align: center; text-color: #000000; bgcolor: #FFFFFF'>#FFFFFF</div>"
49615>>>>>            Set psBackgroundColor to "#FFFFFF"
49616>>>>>            Set psLabel to "Colour:"
49617>>>>>            Set pbShowLabel to True
49618>>>>>            Set piLabelOffset to 60
49619>>>>>        End_Object
49620>>>>>        
49620>>>>>    End_Object 
49621>>>>>    
49621>>>>>    Object oBottomPanel is a cWebPanel
49623>>>>>        Set piColumnCount to 6
49624>>>>>        Set peRegion to prBottom
49625>>>>>
49625>>>>>        Object oOkButton is a cWebButton
49627>>>>>            Set psCaption to C_$OK
49628>>>>>            Set piColumnSpan to 1
49629>>>>>            Set piColumnIndex to 4
49630>>>>>
49630>>>>>            Procedure OnClick
49633>>>>>                Send Ok
49634>>>>>            End_Procedure
49635>>>>>        End_Object 
49636>>>>>
49636>>>>>        Object oCancelButton is a cWebButton
49638>>>>>            Set psCaption to C_$Cancel
49639>>>>>            Set piColumnSpan to 1
49640>>>>>            Set piColumnIndex to 5
49641>>>>>
49641>>>>>            Procedure OnClick
49644>>>>>                Send Cancel
49645>>>>>            End_Procedure
49646>>>>>        End_Object 
49647>>>>>        
49647>>>>>    End_Object 
49648>>>>>
49648>>>>>    Procedure OnSubmit
49651>>>>>        Send Ok
49652>>>>>    End_Procedure
49653>>>>>    
49653>>>>>    Procedure Ok
49656>>>>>        Forward Send Ok
49658>>>>>    End_Procedure
49659>>>>>
49659>>>>>    Procedure Cancel
49662>>>>>        Forward Send Cancel
49664>>>>>    End_Procedure
49665>>>>>    
49665>>>>>    Procedure AdjustColour
49668>>>>>        Integer iRed iGreen iBlue
49668>>>>>        String  sBG sText
49668>>>>>        
49668>>>>>        WebGet piSliderValue of oRedSlider   to iRed
49669>>>>>        WebGet piSliderValue of oGreenSlider to iGreen
49670>>>>>        WebGet piSliderValue of oBlueSlider  to iBlue
49671>>>>>        Move ("#" + ByteToHex(oStringFunctions, iRed) + ;                    ByteToHex(oStringFunctions, iGreen) + ;                    ByteToHex(oStringFunctions, iBlue)) to sBG
49672>>>>>        If (((iRed + iGreen + iBlue) / 3) > 128) Move "#000000" to sText
49675>>>>>        Else                                     Move "#FFFFFF" to sText
49677>>>>>        
49677>>>>>        WebSet psBackgroundColor of oColourBox to sBG
49678>>>>>        Send UpdateHtml of oColourBox ('<br><div style="text-align: center; color: ' + sText + '; font-size: x-large;">' + sBG + '</div>')
49679>>>>>    End_Procedure  // AdjustColour
49680>>>>>        
49680>>>>>    Procedure OnShow
49683>>>>>        Integer iRed iGreen iBlue
49683>>>>>        
49683>>>>>        WebGet wpiRed   to iRed
49684>>>>>        WebGet wpiGreen to iGreen
49685>>>>>        WebGet wpiBlue  to iBlue
49686>>>>>        
49686>>>>>        WebSet piSliderValue of oRedSlider      to iRed
49687>>>>>        WebSet piSliderValue of oGreenSlider    to iGreen
49688>>>>>        WebSet piSliderValue of oBlueSlider     to iBlue
49689>>>>>        Send AdjustColour
49690>>>>>    End_Procedure  // OnShow
49691>>>>>    
49691>>>>>    Procedure ColourPopup Handle hoObj String sVal Handle hoTarg
49694>>>>>        String  sRed sGreen sBlue
49694>>>>>        Integer iRed iGreen iBlue
49694>>>>>        wqColour tCol
49694>>>>>        wqColour tCol
49694>>>>>        
49694>>>>>        WebSet wphoTarget to hoTarg
49695>>>>>        
49695>>>>>        If (Left(sVal, 1) = "#") Begin
49697>>>>>            Move (Mid(sVal, 2, 2)) to sRed
49698>>>>>            Move (Mid(sVal, 2, 4)) to sGreen
49699>>>>>            Move (Mid(sVal, 2, 6)) to sBlue
49700>>>>>            Move (HexToByte(oStringFunctions, sRed))    to iRed
49701>>>>>            Move (HexToByte(oStringFunctions, sGreen))  to iGreen
49702>>>>>            Move (HexToByte(oStringFunctions, sBlue))   to iBlue
49703>>>>>        End
49703>>>>>>
49703>>>>>        Else Begin
49704>>>>>            Get NameToColour of ghoWQF sVal to tCol
49705>>>>>            Move tCol.iRed   to iRed
49706>>>>>            Move tCol.iGreen to iGreen
49707>>>>>            Move tCol.iBlue  to iBlue
49708>>>>>        End
49708>>>>>>
49708>>>>>        
49708>>>>>        WebSet wpiRed   to iRed
49709>>>>>        WebSet wpiGreen to iGreen
49710>>>>>        WebSet wpiBlue  to iBlue
49711>>>>>        
49711>>>>>        Send Popup hoObj
49712>>>>>    End_Procedure  // ColourPopup
49713>>>>>    
49713>>>>>    Function ColourValue Returns String
49716>>>>>        Integer iRed iGreen iBlue
49716>>>>>        String  sVal
49716>>>>>        
49716>>>>>        WebGet piSliderValue of oRedSlider   to iRed
49717>>>>>        WebGet piSliderValue of oGreenSlider to iGreen
49718>>>>>        WebGet piSliderValue of oBlueSlider  to iBlue
49719>>>>>        Move ("#" + ByteToHex(oStringFunctions, iRed) + ;                    ByteToHex(oStringFunctions, iGreen) + ;                    ByteToHex(oStringFunctions, iBlue)) to sVal
49720>>>>>                    
49720>>>>>        Function_Return sVal
49721>>>>>    End_Function  // ColourValue
49722>>>>>    
49722>>>>>    Function TargetObject Returns Handle
49725>>>>>        Handle hoObj
49725>>>>>        
49725>>>>>        WebGet wphoTarget to hoObj
49726>>>>>        Function_Return hoObj
49727>>>>>    End_Function  // TargetObject
49728>>>>>    
49728>>>>>End_Object
49729>>>Use wqDownload.wo
Including file: wqDownload.wo    (Z:\VmShare\Projects\WebQuery18-0\AppSrc\wqDownload.wo)
49729>>>>>Use cWebModalDialog
49729>>>>>Use cWebPanel.pkg
49729>>>>>Use cWebButton.pkg
49729>>>>>Use cWebIFrame.pkg
49729>>>>>
49729>>>>>Object oWqDownload is a cWebModalDialog
49731>>>>>    Set psCaption        to "Downloading Report..."
49732>>>>>    Set piMinWidth       to 200
49733>>>>>    Set piMinHeight      to 99
49734>>>>>    Set pbResizable      to False
49735>>>>>    Set pbShowClose      to False
49736>>>>>    Set pbServerOnSubmit to True
49737>>>>>    
49737>>>>>    Property String  wpsFile
49741>>>>>    
49741>>>>>    Object oMainPanel is a cWebPanel
49743>>>>>        Set piColumnCount to 5
49744>>>>>
49744>>>>>        Object oDownloadFrame is a cWebIFrame
49746>>>>>            Set piColumnIndex to 0
49747>>>>>            Set piColumnSpan  to 0
49748>>>>>            Set pbShowBorder  to False
49749>>>>>            Set piHeight      to 30
49750>>>>>        End_Object
49751>>>>>
49751>>>>>        Object oOkButton is a cWebButton
49753>>>>>            Set psCaption to "Click when done"
49754>>>>>            Set piColumnSpan to 3
49755>>>>>            Set piColumnIndex to 1
49756>>>>>
49756>>>>>            Procedure OnClick
49759>>>>>                Send Ok
49760>>>>>            End_Procedure
49761>>>>>            
49761>>>>>        End_Object 
49762>>>>>
49762>>>>>    End_Object 
49763>>>>>    
49763>>>>>    Procedure DoPopup Handle hoObj String sUrl String sFile
49766>>>>>        WebSet psUrl of oDownloadFrame to sUrl
49767>>>>>        WebSet wpsFile                 to sFile
49768>>>>>        Send Popup hoObj
49769>>>>>    End_Procedure
49770>>>>>    
49770>>>>>End_Object
49771>>>
49771>>>//==============================================================================
49771>>>//  The view
49771>>>//==============================================================================
49771>>>
49771>>>Object oWebQuery is a cWebView
49773>>>
49773>>>    //==========================================================================
49773>>>    //  Web properties
49773>>>    //==========================================================================
49773>>>    
49773>>>    Property String  wpsQuery
49777>>>    Property Handle  wphMainTable
49781>>>    Property Integer wpiIndex
49785>>>    Property String  wpsSegmentData
49789>>>    Property String  wpsFieldsData
49793>>>    Property String  wpsSaveFilename
49797>>>    Property String  wpsSelectExpression
49801>>>    Property String  wpsIndexSegments
49805>>>    
49805>>>    // Web properties used for inserting new rows in
49805>>>    // the Print Fields and Selection tables
49805>>>    Property String  wpsNewField    
49809>>>    Property Handle  wphNewTable
49813>>>    Property Integer wpiNewColumn
49817>>>    Property Integer wpiNewDataType
49821>>>    Property Boolean wpbNewAppend
49825>>>    Property Integer wpiNewOperator
49829>>>    
49829>>>    //==========================================================================
49829>>>    //  Normal properties
49829>>>    //==========================================================================
49829>>>    
49829>>>    Property String         psVersion "0.6 - beta 2"
49831>>>    
49831>>>    Property Handle         phSelectedTable
49833>>>    Property wqPrintField[] paFields
49835>>>    Property wqSelections[] paSelections
49837>>>    Property wqWebQuery     pQuery
49839>>>    Property Handle         phoSessionObj       ghoWebSessionManager
49841>>>    Property Handle         phLoggedInFunc      (RefFunc(IsLoggedIn))
49843>>>    Property Handle         phUserNameFunc      (RefFunc(psLoginName))
49845>>>    Property String         psOutputDirectory   "WebQuery"                                          // Where reports are written
49847>>>    Property String         psStoreDirectory    (psHome(phoWorkspace(oApplication)) + "WebQuery")   // Where queries are saved
49849>>>    Property String         psDownloadDirectory (psHome(phoWorkspace(oApplication)) + "WebQuery")   // Where downloads are written
49851>>>    Property Boolean        pbAllowRawOutput    False
49853>>>    Property Boolean        pbUseSqlDefault     False
49855>>>    
49855>>>    //==========================================================================
49855>>>    //  Initialisation
49855>>>    //==========================================================================
49855>>>    
49855>>>    Set piWidth             to 800
49856>>>    Set psCaption           to "WebQuery Definition"
49857>>>    Set pbFillHeight        to True
49858>>>    Set pbServerOnSubmit    to True
49859>>>    Set pbServerOnShow      to True
49860>>>    
49860>>>    Move Self to ghoWebQry
49861>>>    
49861>>>    //==========================================================================
49861>>>    //  Start of methods
49861>>>    //==========================================================================
49861>>>    
49861>>>    Procedure ExcludeTable Handle hTable
49864>>>        Handle[] ahExcluded
49865>>>        
49865>>>        Get pahExcludedTables of ghoWQF to ahExcluded
49866>>>        Move hTable to ahExcluded[(SizeOfArray(ahExcluded))]
49867>>>        Set pahExcludedTables of ghoWQF to ahExcluded
49868>>>    End_Procedure
49869>>>
49869>>>    Procedure ClearExcludedTables
49872>>>        Handle[] ahExcluded
49873>>>        
49873>>>        Set pahExcludedTables to ahExcluded
49874>>>    End_Procedure
49875>>>    
49875>>>    Procedure ExcludeField Handle hTable Integer iField
49878>>>        wqTableField[] atExcluded
49878>>>        wqTableField[] atExcluded
49879>>>        Integer i
49879>>>        
49879>>>        Get patExcludedFields of ghoWQF to atExcluded
49880>>>        Move (SizeOfArray(atExcluded))  to i
49881>>>        Move hTable to atExcluded[i].hTable
49882>>>        Move iField to atExcluded[i].iField
49883>>>        Set patExcludedFields of ghoWQF to atExcluded
49884>>>    End_Procedure
49885>>>    
49885>>>    Procedure ClearExcludedFields
49888>>>        wqTableField[] atExcluded
49888>>>        wqTableField[] atExcluded
49889>>>        
49889>>>        Set patExcludedFields of ghoWQF to atExcluded
49890>>>    End_Procedure
49891>>>    
49891>>>    Function PublicPath Returns String
49894>>>        Function_Return (PublicPath(ghoWQF))
49895>>>    End_Function
49896>>>    
49896>>>    Function PrivatePath Returns String
49899>>>        Function_Return (PrivatePath(ghoWQF))
49900>>>    End_Function
49901>>>    
49901>>>    Procedure Enableling
49904>>>        Handle  hTab
49904>>>        Boolean bEn
49904>>>        wqPrintField[] aFields
49904>>>        wqPrintField[] aFields
49905>>>        
49905>>>        WebGet wphMainTable to hTab
49906>>>        Move (hTab > 0)     to bEn
49907>>>        Get paFields        to aFields
49908>>>        
49908>>>        WebSet pbEnabled of oRunButton      to (bEn and (SizeOfArray(aFields) > 0))
49909>>>        WebSet pbEnabled of oQueryTitle     to bEn
49910>>>        WebSet pbEnabled of oTablesPage     to bEn
49911>>>        WebSet pbEnabled of oSelectionPage  to bEn
49912>>>        WebSet pbEnabled of oOrderingPage   to bEn
49913>>>        WebSet pbEnabled of oTextsPage      to bEn
49914>>>        WebSet pbEnabled of oOrderingPage   to bEn
49915>>>        WebSet pbEnabled of oOutputPage     to bEn
49916>>>        WebSet pbEnabled of oAddField       to bEn
49917>>>        WebSet pbEnabled of oInsertField    to bEn
49918>>>        WebSet pbEnabled of oDeleteField    to bEn
49919>>>        WebSet pbEnabled of oExprnField     to bEn
49920>>>//        WebSet pbEnabled of oAdjustField    to bEn
49920>>>        WebSet pbEnabled of oSelAddBtn      to bEn
49921>>>        WebSet pbEnabled of oSelInsertBtn   to bEn
49922>>>        WebSet pbEnabled of oSelDeleteBtn   to bEn
49923>>>        WebSet pbEnabled of oSelValueBtn    to bEn
49924>>>        WebSet pbEnabled of oSaveQry        to bEn
49925>>>        WebSet pbEnabled of oTablesList     to bEn
49926>>>        WebSet pbEnabled of oColumnsList    to bEn
49927>>>        WebSet pbEnabled of oPrintedFields  to bEn
49928>>>        WebSet pbEnabled of oSelTablesList  to bEn
49929>>>        WebSet pbEnabled of oSelColumnsList to bEn
49930>>>        WebSet pbEnabled of oSelections     to bEn
49931>>>        WebSet pbEnabled of oSelTables      to bEn
49932>>>        WebSet pbEnabled of oSelColumns     to bEn
49933>>>        WebSet pbEnabled of oFieldCol       to bEn
49934>>>        WebSet pbEnabled of oSumCol         to bEn
49935>>>        WebSet pbEnabled of oCRCol          to bEn
49936>>>    End_Procedure
49937>>>
49937>>>    // This is just a wrapper for RelatedFiles in cWebQueryFunctions 
49937>>>    // to kick it off with the correct main table
49937>>>    Procedure CollectRelated tWebRow[] ByRef aRows
49940>>>        Handle  hTab
49940>>>        
49940>>>        WebGet wphMainTable to hTab
49941>>>        If hTab Send RelatedFiles of ghoWQF (&aRows) hTab
49944>>>    End_Procedure
49945>>>    
49945>>>    // This is here to catch double-click events on the columns tables and use
49945>>>    // them to trigger "Add" events on the fields and selections.
49945>>>    Procedure OnSubmit
49948>>>        String  sFoc
49948>>>        Handle  hoFoc
49948>>>        
49948>>>        Get FocusObject to hoFoc
49949>>>        
49949>>>        If (hoFoc = oColumnsList)    Send AddPrintField True
49952>>>        If (hoFoc = oSelColumnsList) Send AddSelField   True
49955>>>    End_Procedure
49956>>>    
49956>>>    Procedure OnLoad
49959>>>        Send ClearQuery
49960>>>    End_Procedure
49961>>>
49961>>>// I don't think we really want to do this:    
49961>>>    Procedure OnShow
49964>>>        Send ClearQuery
49965>>>    End_Procedure
49966>>>    
49966>>>    Procedure ClearDependant
49969>>>        wqPrintField[] aFields
49969>>>        wqPrintField[] aFields
49970>>>        wqSelections[] aSels
49970>>>        wqSelections[] aSels
49971>>>
49971>>>        Set paFields                        to aFields
49972>>>        Set paSelections                    to aSels
49973>>>        Set phSelectedTable                 to 0
49974>>>        Send GridRefresh of oTablesList
49975>>>        Send GridRefresh of oSelTablesList
49976>>>        Send GridRefresh of oPrintedFields
49977>>>        Send GridRefresh of oSelections
49978>>>        Send GridRefresh of oColumnsList
49979>>>        Send GridRefresh of oSelColumnsList
49980>>>        WebSet wpsSelectExpression          to ""
49981>>>        Send Refill      of oOrder
49982>>>        WebSet wpsIndexSegments to ""
49983>>>        Send GridRefresh of oSegments
49984>>>        Send Clear       of oWqOpenQuery
49985>>>    End_Procedure
49986>>>    
49986>>>    Procedure ClearQuery
49989>>>        WebSet wphMainTable                 to 0
49990>>>        WebSet psValue of oMainFile         to 0
49991>>>        
49991>>>        Send Show of oTablesPage
49992>>>        Send ClearDependant
49993>>>        
49993>>>        WebSet wpiIndex                         to 0
49994>>>        Set phSelectedTable                     to 0
49995>>>        WebSet psValue of oQueryTitle           to ""
49996>>>        WebSet psValue of oTextBefore           to ""
49997>>>        WebSet psValue of oTextAfter            to ""
49998>>>        WebSet psValue of oFontCombo            to "Arial, Helvetica, sans-serif"
49999>>>        WebSet psValue of oFontSizeCombo        to "medium"
50000>>>        WebSet psValue of oIncSelections        to False
50001>>>        WebSet psValue of oTotalsOnly           to False
50002>>>        WebSet psValue of oPrintCount           to True
50003>>>        WebSet psValue of oTextColour           to "black"
50004>>>        WebSet psBackgroundColor of oTextCol    to "black"
50005>>>        WebSet psValue of oBGColour             to "white"
50006>>>        WebSet psBackgroundColor of oBGCol      to "white"
50007>>>        WebSet psValue of oAltRowHighlight      to True
50008>>>        WebSet psValue of oHighlightColour      to "#AAFFFF"
50009>>>        WebSet psBackgroundColor of oHLCol      to "#AAFFFF"
50010>>>        Send SetSelected of oOutModal
50011>>>        Send SetSelected of oViewOutput
50012>>>        Send SetSelected of oOutHTML
50013>>>        WebSet psValue   of oColHeads           to False
50014>>>        WebSet psValue   of oPrintGenLine       to True
50015>>>        WebSet psValue   of oUseSQL             to (pbUseSqlDefault(Self))
50016>>>        
50016>>>        Send ChangeOutput C_wqModalWin
50017>>>        
50017>>>//        Send Show of oTablesPage   // This does not work as advertised in the current situation
50017>>>//        Send Focus of oTablesPage  // And neither does this
50017>>>        
50017>>>        Send Enableling
50018>>>    End_Procedure
50019>>>    
50019>>>    Procedure MainTableSelected Handle hTab
50022>>>        Integer iIdx
50022>>>        
50022>>>        Send ClearDependant
50023>>>        
50023>>>        WebSet wphMainTable                             to hTab
50024>>>        
50024>>>        If hTab Begin
50026>>>            Send GridRefresh        of oTablesList
50027>>>            WebSet psCurrentRowID   of oTablesList      to hTab
50028>>>            Send FieldsTableSelected                       hTab
50029>>>            
50029>>>            Send GridRefresh        of oSelTablesList
50030>>>            WebSet psCurrentRowID   of oSelTablesList   to hTab
50031>>>            Send SelTableSelected                          hTab
50032>>>            
50032>>>            Send Refill             of oOrder
50033>>>            WebGet wpiIndex                             to iIdx
50034>>>            Send GridRefresh        of oSegments
50035>>>            WebSet psValue          of oOrder           to iIdx
50036>>>//            Send Refill of oSearchOrd
50036>>>        End
50036>>>>
50036>>>        
50036>>>        Send Enableling
50037>>>    End_Procedure
50038>>>        
50038>>>    Procedure FieldsTableSelected Handle hTab
50041>>>        Set phSelectedTable     to hTab
50042>>>        Send GridRefresh        of oColumnsList
50043>>>        WebSet psCurrentRowID   of oColumnsList to 1
50044>>>    End_Procedure
50045>>>    
50045>>>    Procedure SelTableSelected Handle hTab
50048>>>        Set phSelectedTable     to hTab
50049>>>        Send GridRefresh        of oSelColumnsList
50050>>>        WebSet psCurrentRowID   of oSelColumnsList to 1
50051>>>    End_Procedure
50052>>>    
50052>>>    Procedure IndexSelected Integer iIndex
50055>>>        wqIndexSeg[] aSegs
50055>>>        wqIndexSeg[] aSegs
50056>>>        String  sSegs
50056>>>        
50056>>>        WebSet wpiIndex to iIndex
50057>>>        Send GridRefresh of oSegments
50058>>>    End_Procedure
50059>>>
50059>>>    Procedure AddPrintField Boolean bAppend
50062>>>        Handle  hTable
50062>>>        Integer iColumn iRow
50062>>>        wqPrintField tField
50062>>>        wqPrintField tField
50062>>>        String  sField
50062>>>        
50062>>>        WebGet psCurrentRowID of oColumnsList to tField.iColumn
50063>>>        WebGet psCurrentRowID of oTablesList  to tField.iTable
50064>>>        Move False                            to tField.bCalc
50065>>>        
50065>>>        Open tField.iTable
50067>>>        Get_Attribute DF_FIELD_TYPE      of tField.iTable tField.iColumn to tField.iType
50070>>>        Get_Attribute DF_FIELD_LENGTH    of tField.iTable tField.iColumn to tField.iWidth
50073>>>        Get_Attribute DF_FIELD_PRECISION of tField.iTable tField.iColumn to tField.iDecimals
50076>>>        
50076>>>        Get VariantToString of oStructFunctions tField to sField
50077>>>        WebSet wpsNewField to sField
50078>>>        
50078>>>        Send ProcessDataSet of oPrintedFields (If(bAppend, C_wqAppendRow, C_wqInsertRow))
50079>>>    End_Procedure
50080>>>    
50080>>>    Procedure DeletePrintField
50083>>>        Send ProcessDataSet of oPrintedFields C_wqDeleteRow
50084>>>    End_Procedure
50085>>>    
50085>>>    Procedure FieldListReturned tWebRow[] ByRef aRows Integer eOp Integer iCurrRow
50088>>>        wqPrintField[] aFields
50088>>>        wqPrintField[] aFields
50089>>>        wqPrintField newField
50089>>>        wqPrintField newField
50089>>>        Integer i iRows iRowPos iRow iMax
50089>>>        String  sField
50089>>>        tValueTree tVT
50089>>>        tValueTree tVT
50089>>>        
50089>>>        Move (SizeOfArray(aRows)) to iRows
50090>>>        
50090>>>        For i from 0 to (iRows - 1)
50096>>>>
50096>>>            Move aRows[i].aCells[3].sValue  to sField
50097>>>            Get DeSerializeField of ghoWQF sField to aFields[i]
50098>>>            
50098>>>            Move aRows[i].aCells[0].sValue  to aFields[i].sUserName
50099>>>            Move aRows[i].aCells[1].sValue  to aFields[i].bSum
50100>>>            Move aRows[i].aCells[2].sValue  to aFields[i].bCR
50101>>>        Loop
50102>>>>
50102>>>        
50102>>>        WebGet wpsNewField to sField
50103>>>        Get StringToValueTree of oStructFunctions sField to tVT
50104>>>        ValueTreeDeserializeParameter tVT to newField
50105>>>        
50105>>>        If ((eOp = C_wqAppendRow) or (eOp = C_wqInsertRow)) Begin
50107>>>            Move False  to newField.bSum
50108>>>            Move False  to newField.bCR
50109>>>            Move (NiceFieldName(ghoWQF, newField.iTable, newField.iColumn)) ;                        to newField.sUserName
50110>>>                        
50110>>>            WebGet piCurrentRowIndex of oColumnsList to iRow
50111>>>            WebGet piRowCount        of oColumnsList to iMax
50112>>>            If (iRow < (iMax - 1)) Send MoveToRow of oColumnsList (iRow + 1)
50115>>>        End
50115>>>>
50115>>>        Else If ((eOp = C_wqAddExpression) or (eOp = C_wqInsertExpression)) Begin
50118>>>            Move False  to newField.bSum
50119>>>            Move False  to newField.bCR
50120>>>        End
50120>>>>
50120>>>        
50120>>>        If      (eOp = C_wqAppendRow) Begin
50122>>>            Move newField to aFields[iRows]
50123>>>        End
50123>>>>
50123>>>        Else If (eOp = C_wqInsertRow) Begin
50126>>>            If ((iCurrRow => 0) and (iCurrRow < iRows)) ;                Move (InsertInArray(aFields, iCurrRow, newField)) to aFields
50129>>>        End
50129>>>>
50129>>>        Else If (eOp = C_wqDeleteRow) Begin
50132>>>            If ((iCurrRow => 0) and (iCurrRow < iRows)) ;                Move (RemoveFromArray(aFields, iCurrRow)) to aFields
50135>>>        End
50135>>>>
50135>>>        Else If (eOp = C_wqAddExpression) Begin
50138>>>            Move newField to aFields[iRows]
50139>>>        End
50139>>>>
50139>>>        Else If (eOp = C_wqInsertExpression) Begin
50142>>>            If ((iCurrRow => 0) and (iCurrRow < iRows)) ;                Move (InsertInArray(aFields, iCurrRow, newField)) to aFields
50145>>>        End
50145>>>>
50145>>>        Else If (eOp = C_wqEditExpression) Begin
50148>>>            Move newField to aFields[iCurrRow]
50149>>>        End
50149>>>>
50149>>>        
50149>>>        Set paFields to aFields
50150>>>        Send Enableling
50151>>>        Send GridRefresh of oPrintedFields
50152>>>    End_Procedure
50153>>>    
50153>>>    Procedure AddSelField Boolean bAppend
50156>>>        Handle  hTable
50156>>>        Integer iColumn iRow iType
50156>>>        
50156>>>        WebGet psCurrentRowID of oSelTablesList  to hTable
50157>>>        WebGet psCurrentRowID of oSelColumnsList to iColumn
50158>>>        
50158>>>        If not hTable Procedure_Return
50161>>>        
50161>>>        Open hTable
50163>>>        Get_Attribute DF_FIELD_TYPE of hTable iColumn to iType
50166>>>        
50166>>>        WebSet wphNewTable      to hTable
50167>>>        WebSet wpiNewColumn     to iColumn
50168>>>        WebSet wpiNewDataType   to iType
50169>>>        WebSet wpbNewAppend     to bAppend
50170>>>        
50170>>>        Send DoPopup of oWqSelectionOperators Self (If(bAppend, C_wqAppendRow, C_wqInsertRow))
50171>>>    End_Procedure
50172>>>    
50172>>>    Procedure LoadPrintFields tWebRow[] ByRef aRows String ByRef sCurrentRowID
50175>>>        Integer i
50175>>>        wqPrintField[] aFields
50175>>>        wqPrintField[] aFields
50176>>>        String  sField
50176>>>        
50176>>>        Get paFields to aFields
50177>>>        
50177>>>        For i from 0 to (SizeOfArray(aFields) - 1)
50183>>>>
50183>>>            Move i                      to aRows[i].sRowID
50184>>>            Move aFields[i].sUserName   to aRows[i].aCells[0].sValue
50185>>>            Move aFields[i].bSum        to aRows[i].aCells[1].sValue
50186>>>            Move aFields[i].bCR         to aRows[i].aCells[2].sValue
50187>>>            Get SerializeField of ghoWQF aFields[i] to sField
50188>>>            Move sField                 to aRows[i].aCells[3].sValue
50189>>>        Loop
50190>>>>
50190>>>        
50190>>>    End_Procedure
50191>>>    
50191>>>    Procedure LoadSelections tWebRow[] ByRef aRows String ByRef sCurrentRowID
50194>>>        Integer iRows i
50194>>>        wqSelections[] aSels
50194>>>        wqSelections[] aSels
50195>>>        
50195>>>        Get paSelections of ghoWebQry to aSels
50196>>>        
50196>>>        For i from 0 to (SizeOfArray(aSels) - 1)
50202>>>>
50202>>>            Move i                  to aRows[i].sRowID
50203>>>            Move aSels[i].sUserName to aRows[i].aCells[0].sValue
50204>>>            Move aSels[i].sType     to aRows[i].aCells[1].sValue
50205>>>            Move aSels[i].sValue    to aRows[i].aCells[2].sValue
50206>>>            Move aSels[i].iTable    to aRows[i].aCells[3].sValue
50207>>>            Move aSels[i].iColumn   to aRows[i].aCells[4].sValue
50208>>>            Move aSels[i].iType     to aRows[i].aCells[5].sValue
50209>>>        Loop
50210>>>>
50210>>>        
50210>>>    End_Procedure
50211>>>    
50211>>>    Procedure TableSelected Handle hoObj
50214>>>        Handle  hTab
50214>>>        
50214>>>        Get TableSelected of oWqTableSelection to hTab
50215>>>        WebSet psValue of oMainFile to hTab
50216>>>        Send MainTableSelected hTab
50217>>>    End_Procedure
50218>>>    
50218>>>    Procedure SelsListReturned tWebRow[] ByRef aRows Integer eOp Integer iCurrRow
50221>>>        wqSelections[] aSels
50221>>>        wqSelections[] aSels
50222>>>        wqSelections   newSel
50222>>>        wqSelections   newSel
50222>>>        Integer i iRows iOp iType iCurr iRow iMax
50222>>>        Boolean bAppend
50222>>>                                
50222>>>        Move (SizeOfArray(aRows)) to iRows
50223>>>        
50223>>>        For i from 0 to (iRows - 1)
50229>>>>
50229>>>            Move aRows[i].aCells[0].sValue to aSels[i].sUserName
50230>>>            Move aRows[i].aCells[1].sValue to aSels[i].sType
50231>>>            Move aRows[i].aCells[2].sValue to aSels[i].sValue                                    
50232>>>            Move aRows[i].aCells[3].sValue to aSels[i].iTable
50233>>>            Move aRows[i].aCells[4].sValue to aSels[i].iColumn
50234>>>            Move aRows[i].aCells[5].sValue to aSels[i].iType
50235>>>        Loop
50236>>>>
50236>>>        
50236>>>        If ((eOp = C_wqAppendRow) or (eOp = C_wqInsertRow)) Begin
50238>>>            WebGet wphNewTable                      to newSel.iTable
50239>>>            WebGet wpiNewColumn                     to newSel.iColumn
50240>>>            WebGet wpiNewDataType                   to newSel.iType
50241>>>            WebGet wpiNewOperator                   to iOp
50242>>>            Move (SelCode(oWqSelectionTypes, iOp))  to newSel.sType
50243>>>            WebGet wpbNewAppend                     to bAppend
50244>>>        
50244>>>            Move "No limitation"                    to newSel.sValue
50245>>>            
50245>>>            Move (NiceFieldName(ghoWQF, newSel.iTable, newSel.iColumn)) to newSel.sUserName
50246>>>            
50246>>>            WebGet piCurrentRowIndex of oSelColumnsList to iRow
50247>>>            WebGet piRowCount        of oSelColumnsList to iMax
50248>>>            If (iRow < (iMax - 1)) Send MoveToRow of oSelColumnsList (iRow + 1)
50251>>>        End
50251>>>>
50251>>>        
50251>>>        WebGet piCurrentRowIndex of oSelections to iCurr
50252>>>        
50252>>>        If (eOp = C_wqAppendRow) Begin
50254>>>            Move newSel to aSels[iRows]
50255>>>        End
50255>>>>
50255>>>        Else If (eOp = C_wqInsertRow) Begin
50258>>>            If ((iCurr => 0) and (iCurr < iRows)) ;                Move (InsertInArray(aSels, iCurr, newSel)) to aSels
50261>>>        End
50261>>>>
50261>>>        Else If (eOp = C_wqDeleteRow) Begin
50264>>>            If ((iCurr => 0) and (iCurr < iRows)) ;                Move (RemoveFromArray(aSels, iCurr)) to aSels
50267>>>        End
50267>>>>
50267>>>        
50267>>>        Set paSelections to aSels
50268>>>        Send GridRefresh of oSelections
50269>>>    End_Procedure
50270>>>    
50270>>>    Procedure SelOpSelected Handle hoObj
50273>>>        Integer iOp eOp
50273>>>        
50273>>>        Get SelectedOperator of hoObj to iOp
50274>>>        Get Operation        of hoObj to eOp
50275>>>        WebSet wpiNewOperator to iOp
50276>>>        Send ProcessDataSet of oSelections eOp
50277>>>    End_Procedure
50278>>>    
50278>>>    Procedure SelectValue
50281>>>        Handle  hTab
50281>>>        Integer iCol iDT
50281>>>        String  sOp sName sVal
50281>>>        
50281>>>        WebGet psValue of oSelTabCol    to hTab
50282>>>        WebGet psValue of oSelColCol    to iCol
50283>>>        WebGet psValue of oSelType      to sOp
50284>>>        WebGet psValue of oSelField     to sName
50285>>>        WebGet psValue of oSelValue     to sVal
50286>>>        WebGet psValue of oSelDataType  to iDT
50287>>>        
50287>>>        Get WebDataType of ghoWQF iDT   to iDT
50288>>>        
50288>>>        If (sOp = "in list")                     Send PopupGetList  of oWqSelectionList   Self sName sOp sVal iDT
50291>>>        Else If ((sOp = "x-y") or (sOp = "CBT")) Send PopupGetRange of oWqSelectionRanges Self sName sOp sVal iDT
50295>>>        Else                                     Send PopupGetValue of oWqSelectionValues Self sName sOp sVal iDT
50297>>>    End_Procedure
50298>>>    
50298>>>    Procedure LoadSegments tWebRow[] ByRef aRows String ByRef sRowID
50301>>>        Handle  hTab
50301>>>        Integer iIdx iSegs i iFld iUC iDirn
50301>>>        String  sSegs
50301>>>        wqIndexSeg[] aSegs
50301>>>        wqIndexSeg[] aSegs
50302>>>        tValueTree tVT
50302>>>        tValueTree tVT
50302>>>        
50302>>>        WebGet wphMainTable to hTab
50303>>>        
50303>>>        If not hTab Procedure_Return
50306>>>        
50306>>>        Open hTab
50308>>>        WebGet wpiIndex             to iIdx
50309>>>        WebSet psValue of oOrder    to iIdx
50310>>>                
50310>>>        WebSet pbEnabled of oAdHocButton to (iIdx = -1)
50311>>>        
50311>>>        WebGet wpsIndexSegments to sSegs
50312>>>        
50312>>>        If (sSegs <> "") Begin
50314>>>            Get StringToValueTree of oStructFunctions sSegs to tVT
50315>>>            ValueTreeDeserializeParameter tVT to aSegs
50316>>>        
50316>>>            For i from 0 to (SizeOfArray(aSegs) - 1)
50322>>>>
50322>>>                Move i               to aRows[i].sRowID
50323>>>                Move aSegs[i].bBreak to aRows[i].aCells[0].sValue
50324>>>                Move aSegs[i].sName  to aRows[i].aCells[1].sValue
50325>>>                Move aSegs[i].iTable to aRows[i].aCells[2].sValue
50326>>>                Move aSegs[i].iField to aRows[i].aCells[3].sValue
50327>>>                Move aSegs[i].bUC    to aRows[i].aCells[4].sValue
50328>>>                Move aSegs[i].bDesc  to aRows[i].aCells[5].sValue
50329>>>            Loop
50330>>>>
50330>>>            
50330>>>        End
50330>>>>
50330>>>        Else If (iIdx <> -1) Begin
50333>>>            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTab iIdx to iSegs
50336>>>            
50336>>>            For i from 1 to iSegs
50342>>>>
50342>>>                Get_Attribute DF_INDEX_SEGMENT_FIELD     of hTab iIdx i to iFld
50345>>>                Get_Attribute DF_INDEX_SEGMENT_CASE      of hTab iIdx i to iUC
50348>>>                Get_Attribute DF_INDEX_SEGMENT_DIRECTION of hTab iIdx i to iDirn
50351>>>                
50351>>>                If (iFld > 0) Begin  // Don't add recnum to the segments...
50353>>>                    Move i                                          to aRows[i - 1].sRowID
50354>>>                    Move False                                      to aRows[i - 1].aCells[0].sValue
50355>>>                    Move (NiceFieldName(ghoWQF, hTab, iFld) + ": ") to aRows[i - 1].aCells[1].sValue
50356>>>                    WebGet wphMainTable                             to aRows[i - 1].aCells[2].sValue
50357>>>                    Move iFld                                       to aRows[i - 1].aCells[3].sValue
50358>>>                    Move (iUC = DF_CASE_IGNORED)                    to aRows[i - 1].aCells[4].sValue
50359>>>                    Move (iDirn = DF_DESCENDING)                    to aRows[i - 1].aCells[5].sValue
50360>>>                End
50360>>>>
50360>>>                
50360>>>            Loop
50361>>>>
50361>>>            
50361>>>        End
50361>>>>
50361>>>        
50361>>>        WebSet psValue of oOrder to iIdx
50362>>>    End_Procedure
50363>>>    
50363>>>    Procedure CalcField
50366>>>        Boolean bCalc bHaveRows
50366>>>        Integer iRows
50366>>>        String  sField
50366>>>        wqPrintField tField
50366>>>        wqPrintField tField
50366>>>
50366>>>        WebGet psValue of oFieldData to sField
50367>>>        If (sField <> "") Get DeSerializeField of ghoWQF sField to tField
50370>>>        WebGet piRowCount           of oPrintedFields   to iRows
50371>>>        
50371>>>        Move (iRows > 0) to bHaveRows
50372>>>        
50372>>>        Send PopupOptions of oWqAddInsEdit Self bHaveRows tField.bCalc
50373>>>    End_Procedure
50374>>>    
50374>>>    Procedure ExprAction
50377>>>        Integer iAct iRows
50377>>>        wqPrintField tField
50377>>>        wqPrintField tField
50377>>>        Handle  hTab
50377>>>        String  sField
50377>>>        
50377>>>        Get ActionSelected          of oWqAddInsEdit    to iAct
50378>>>        WebGet piRowCount           of oPrintedFields   to iRows        
50379>>>        WebGet wphMainTable                             to hTab
50380>>>        WebGet psValue              of oFieldData       to sField
50381>>>        If (sField <> "") Get DeSerializeField of ghoWQF sField to tField
50384>>>        
50384>>>        If (iAct = C_wqAddExpression) Begin
50386>>>            Send PopupCalcCol of oWqCalcColumn Self tField iAct hTab
50387>>>        End
50387>>>>
50387>>>        Else If (iAct = C_wqInsertExpression) Begin
50390>>>            If (iRows < 1) Procedure_Return
50393>>>            Send PopupCalcCol of oWqCalcColumn Self tField iAct hTab
50394>>>        End
50394>>>>
50394>>>        Else If (iAct = C_wqEditExpression) Begin
50397>>>            If (iRows < 1)        Procedure_Return
50400>>>            If not (tField.bCalc) Procedure_Return  // Shouldn't happen!
50403>>>            Send PopupCalcCol of oWqCalcColumn Self tField iAct hTab
50404>>>        End
50404>>>>
50404>>>        
50404>>>    End_Procedure
50405>>>    
50405>>>    Procedure CalcColReturn Handle hoObj
50408>>>        wqPrintField tField
50408>>>        wqPrintField tField
50408>>>        String  sField
50408>>>        Integer iOp iFld
50408>>>        
50408>>>        Get CalcColInfo of oWqCalcColumn to tField
50409>>>        Get piOperation of oWqCalcColumn to iOp
50410>>>        
50410>>>        Get VariantToString of oStructFunctions tField to sField
50411>>>        WebSet wpsNewField to sField
50412>>>        
50412>>>        Send ProcessDataSet of oPrintedFields iOp
50413>>>    End_Procedure
50414>>>    
50414>>>    Procedure EnterSelExpr
50417>>>        String  sExpr
50417>>>        Handle  hTab
50417>>>        
50417>>>        WebGet wpsSelectExpression to sExpr
50418>>>        WebGet wphMainTable        to hTab
50419>>>        
50419>>>        Send DoPopup of oWqExpressionPopup Self sExpr C_wqSelectExpr 0 hTab ""
50420>>>    End_Procedure
50421>>>    
50421>>>    Procedure ExprReturned  Handle hoExpr
50424>>>        wqExpressionReturn tExpr
50424>>>        wqExpressionReturn tExpr
50424>>>        wqPrintField tField
50424>>>        wqPrintField tField
50424>>>        String  sField
50424>>>        
50424>>>        Get ExprValue of hoExpr to tExpr
50425>>>        
50425>>>        If (tExpr.iOp = C_wqSelectExpr) WebSet wpsSelectExpression to tExpr.sExpression
50428>>>    End_Procedure
50429>>>    
50429>>>    Procedure SpecAdHoc
50432>>>        Send ProcessDataSet of oSegments C_wqGetIndexInfo
50433>>>    End_Procedure
50434>>>    
50434>>>    Procedure IndexDataReceived tWebRow[] ByRef aData Integer eOp Integer iSelRow
50437>>>        Handle  hTab
50437>>>        Integer i
50437>>>        String  sSegs
50437>>>        wqIndexSeg[] aSegs
50437>>>        wqIndexSeg[] aSegs
50438>>>        tValueTree tVT
50438>>>        tValueTree tVT
50438>>>        
50438>>>        WebGet wphMainTable  to hTab
50439>>>            
50439>>>        For i from 0 to (SizeOfArray(aData) - 1)
50445>>>>
50445>>>            Move aData[i].aCells[0].sValue to aSegs[i].bBreak
50446>>>            Move aData[i].aCells[1].sValue to aSegs[i].sName
50447>>>            Move aData[i].aCells[2].sValue to aSegs[i].iTable
50448>>>            Move aData[i].aCells[3].sValue to aSegs[i].iField
50449>>>            Move aData[i].aCells[4].sValue to aSegs[i].bUC
50450>>>            Move aData[i].aCells[5].sValue to aSegs[i].bDesc
50451>>>        Loop
50452>>>>
50452>>>        
50452>>>        Send PopupAdHoc of oWqAdHocIndex Self hTab aSegs
50453>>>    End_Procedure
50454>>>    
50454>>>    Procedure AdHocDefined Handle hObj
50457>>>        wqIndexSeg[] aSegs
50457>>>        wqIndexSeg[] aSegs
50458>>>        String  sSegs
50458>>>        
50458>>>        Get AdHocSegments of hObj to aSegs
50459>>>        Get VariantToString of oStructFunctions aSegs to sSegs
50460>>>        WebSet wpsIndexSegments to sSegs
50461>>>        Send GridRefresh of oSegments
50462>>>    End_Procedure
50463>>>    
50463>>>    Procedure ColourSelected Handle hoObj
50466>>>        String  sColour
50466>>>        Handle  hoTarg
50466>>>        
50466>>>        Get ColourValue  of hoObj  to sColour
50467>>>        Get TargetObject of hoObj  to hoTarg
50468>>>        WebSet psValue   of hoTarg to sColour
50469>>>        
50469>>>        If      (hoTarg = oTextColour)      WebSet psBackgroundColor of oTextCol to sColour
50472>>>        Else If (hoTarg = oBGColour)        WebSet psBackgroundColor of oBGCol   to sColour
50476>>>        Else If (hoTarg = oHighlightColour) WebSet psBackgroundColor of oHLCol   to sColour
50480>>>        
50480>>>    End_Procedure
50481>>>    
50481>>>    Procedure ChangeOutput String sVal
50484>>>        String  sFormat
50484>>>        
50484>>>        If (sVal = C_wqViewOutput) Begin
50486>>>            WebSet pbRender of oLabFormat   to False
50487>>>            WebSet pbRender of oOutHTML     to False
50488>>>            WebSet pbRender of oOutText     to False
50489>>>            WebSet pbRender of oOutCSV      to False
50490>>>            WebSet pbRender of oOutXML      to False
50491>>>            WebSet pbRender of oColHeads    to False
50492>>>            WebSet pbRender of oOutputLab   to True
50493>>>            WebSet pbRender of oOutModal    to True
50494>>>            WebSet pbRender of oOutTab      to True
50495>>>            WebSet pbRender of oOutWin      to True
50496>>>            WebSet pbRender of oNewWarning  to True
50497>>>        End
50497>>>>
50497>>>        Else Begin
50498>>>            WebSet pbRender of oOutputLab   to False
50499>>>            WebSet pbRender of oOutModal    to False
50500>>>            WebSet pbRender of oOutTab      to False
50501>>>            WebSet pbRender of oOutWin      to False
50502>>>            WebSet pbRender of oNewWarning  to False
50503>>>            WebSet pbRender of oLabFormat   to True
50504>>>            WebSet pbRender of oOutHTML     to True
50505>>>            WebSet pbRender of oOutText     to True
50506>>>            WebSet pbRender of oOutCSV      to True
50507>>>            WebSet pbRender of oOutXML      to True
50508>>>            WebSet pbRender of oColHeads    to True
50509>>>            WebGet psValue  of oOutCSV      to sFormat
50510>>>            WebSet pbEnabled of oColHeads   to (sFormat = C_wqOutputCSV)
50511>>>        End
50511>>>>
50511>>>        
50511>>>    End_Procedure
50512>>>    
50512>>>    Procedure ChangeFormat String sFormat
50515>>>        WebSet pbEnabled of oColHeads to (sFormat = C_wqOutputCSV)
50516>>>    End_Procedure
50517>>>    
50517>>>    Procedure OpenQuery
50520>>>        Send PopupDialog of oWqOpenQuery Self C_wqOpenQuery ""
50521>>>    End_Procedure
50522>>>    
50522>>>    Function QueryFileError String sFile Returns Boolean
50525>>>        String sFName
50525>>>        
50525>>>        Get FilenameFromPath of ghoWQF sFile to sFName
50526>>>        
50526>>>        Send ShowInfoBox ("The file" * sFName * "does not appear to be valid") "Invalid Query File"
50527>>>    End_Function
50528>>>    
50528>>>    Procedure PopulateUI
50531>>>        wqWebQuery tQuery
50531>>>        wqWebQuery tQuery
50531>>>        tValueTree tVT
50531>>>        tValueTree tVT
50531>>>        String  sSegs
50531>>>        Boolean bView
50531>>>        
50531>>>        Get pQuery to tQuery
50532>>>        
50532>>>        WebSet psValue      of oQueryTitle      to tQuery.sTitle
50533>>>        WebSet psValue      of oMainFile        to tQuery.hMainTable
50534>>>        Send MainTableSelected tQuery.hMainTable
50535>>>        Set paFields                            to tQuery.aPrintFields
50536>>>        Send GridRefresh    of oPrintedFields
50537>>>        Set paSelections                        to tQuery.aSelections
50538>>>        Send GridRefresh    of oSelections
50539>>>        WebSet psValue      of oOrder           to tQuery.iIndex
50540>>>        WebSet wpsSelectExpression              to tQuery.sSelectExpression
50541>>>        Send IndexSelected                         tQuery.iIndex
50542>>>        
50542>>>        Get VariantToString of oStructFunctions tQuery.aSegments to sSegs
50543>>>        WebSet wpsIndexSegments             to sSegs
50544>>>        
50544>>>        Send GridRefresh    of oSegments
50545>>>//        WebSet psValue      of oSearchOrd       to tQuery.iSearchOrd
50545>>>        WebSet psValue      of oTextBefore      to tQuery.sTextBefore
50546>>>        WebSet psValue      of oTextAfter       to tQuery.sTextAfter
50547>>>        WebSet psValue      of oFontCombo       to tQuery.sTypeface
50548>>>        WebSet psValue      of oFontSizeCombo   to tQuery.sFontSize
50549>>>        WebSet psValue      of oIncSelections   to tQuery.bPrintSels
50550>>>        WebSet psValue      of oTotalsOnly      to tQuery.bTotalsOnly
50551>>>        WebSet psValue      of oPrintCount      to tQuery.bPrintCount
50552>>>        WebSet psValue      of oTextColour      to tQuery.sTextColour
50553>>>        WebSet psBackgroundColor of oTextCol    to tQuery.sTextColour
50554>>>        WebSet psValue      of oBGColour        to tQuery.sBGColour
50555>>>        WebSet psBackgroundColor of oBGCol      to tQuery.sBGColour
50556>>>        WebSet psValue      of oAltRowHighlight to tQuery.bHighlightAlt
50557>>>        WebSet psValue      of oHighlightColour to tQuery.sHighlightColour
50558>>>        WebSet psBackgroundColor of oHLCol      to tQuery.sHighlightColour
50559>>>        WebSet psValue      of oOutModal        to tQuery.iDestination
50560>>>        WebSet psValue      of oOutHTML         to tQuery.iOutputFormat
50561>>>        
50561>>>        If (tQuery.iDestination = C_wqDownload) Begin
50563>>>            WebSet psValue  of oViewOutput      to C_wqDownloadOutput
50564>>>            Send ChangeOutput C_wqDownloadOutput
50565>>>        End
50565>>>>
50565>>>        Else Begin
50566>>>            WebSet psValue  of oViewOutput      to C_wqViewOutput
50567>>>            Send ChangeOutput C_wqViewOutput
50568>>>        End
50568>>>>
50568>>>        
50568>>>        WebSet psValue      of oColHeads        to tQuery.bColHeads
50569>>>        WebSet psValue      of oPrintGenLine    to tQuery.bGeneratedLine
50570>>>        WebSet psValue      of oUseSQL          to tQuery.bUseSQL
50571>>>        
50571>>>        Send Enableling
50572>>>    End_Procedure
50573>>>    
50573>>>    Procedure QueryOpened Handle hoObj
50576>>>        wqWebQuery tQuery
50576>>>        wqWebQuery tQuery
50576>>>        tValueTree tVT
50576>>>        tValueTree tVT
50576>>>        String  sFile String sFName
50576>>>        Integer iChn
50576>>>        Boolean bOK
50576>>>        
50576>>>        Get FileOpened of hoObj to sFile
50577>>>        Get FilenameFromPath of ghoWQF sFile to sFName
50578>>>        Get Seq_New_Channel     to iChn
50579>>>        Direct_Input channel iChn sFile
50581>>>        Move (not(SeqEof)) to bOK
50582>>>
50582>>>        If bOK Begin
50584>>>            Send ReadValueTree of oStructFunctions iChn (&tVT)
50585>>>            ValueTreeDeserializeParameter tVT to tQuery
50586>>>            Close_Input channel iChn
50588>>>            Send Seq_Release_Channel iChn
50589>>>            Set pQuery to tQuery
50590>>>            Send PopulateUI
50591>>>        End
50591>>>>
50591>>>        Else Begin
50592>>>            Close_Input channel iChn
50594>>>            Send Seq_Release_Channel iChn
50595>>>            Procedure_Return (QueryFileError(Self, sFile))
50596>>>        End
50596>>>>
50596>>>        
50596>>>    End_Procedure
50597>>>    
50597>>>    Procedure FileReturned Handle hoObj
50600>>>        Integer iMode
50600>>>        
50600>>>        WebGet wpiMode of hoObj to iMode
50601>>>        
50601>>>        If (iMode = C_wqOpenQuery) Send QueryOpened hoObj
50604>>>        If (iMode = C_wqSaveQuery) Send DoSave      hoObj
50607>>>    End_Procedure
50608>>>    
50608>>>    Procedure SaveQuery
50611>>>        String sDefault
50611>>>        Handle hTable
50611>>>        
50611>>>        WebGet psValue of oQueryTitle to sDefault
50612>>>        
50612>>>        If (sDefault = "") Begin
50614>>>            WebGet wphMainTable to hTable
50615>>>            Open hTable
50617>>>            Get_Attribute DF_FILE_DISPLAY_NAME of hTable to sDefault
50620>>>            If (sDefault = "") Procedure_Return
50623>>>        End
50623>>>>
50623>>>        
50623>>>        Send PopupDialog of oWqOpenQuery Self C_wqSaveQuery sDefault
50624>>>    End_Procedure
50625>>>    
50625>>>    Procedure DoSave Handle hoObj
50628>>>        String  sFile
50628>>>        
50628>>>        Get FileOpened of hoObj to sFile
50629>>>        WebSet wpsSaveFilename  to sFile
50630>>>        Send AssembleQuery C_wqAssembleSave
50631>>>    End_Procedure
50632>>>    
50632>>>    Procedure DoSaveQuery
50635>>>        wqWebQuery tQuery
50635>>>        wqWebQuery tQuery
50635>>>        String  sFile
50635>>>        Integer iChn
50635>>>        
50635>>>        WebGet wpsSaveFilename          to sFile
50636>>>        Get Seq_New_Channel to iChn
50637>>>        Direct_Output channel iChn sFile
50639>>>        Get pQuery to tQuery
50640>>>        Send WriteVariant of oStructFunctions iChn tQuery
50641>>>        Close_Output channel iChn
50643>>>        Send Seq_Release_Channel iChn
50644>>>    End_Procedure
50645>>>    
50645>>>    Procedure RunQuery
50648>>>        wqWebQuery tQuery
50648>>>        wqWebQuery tQuery
50648>>>        String   sFile sTitle sPath sDir sExt sUrl
50648>>>        String[] aParams
50649>>>        Handle   hTab
50649>>>
50649>>>        Get pQuery                              to tQuery
50650>>>        Get OutputReport of ghoWQF (&tQuery)    to sFile
50651>>>        
50651>>>        Move tQuery.sTitle to sTitle
50652>>>        
50652>>>        If (Trim(sTitle) = "") Begin
50654>>>            Move tQuery.hMainTable to hTab
50655>>>            Open hTab
50657>>>            Get_Attribute DF_FILE_DISPLAY_NAME of hTab to sTitle
50660>>>        End
50660>>>>
50660>>>        
50660>>>        If (tQuery.iDestination = C_wqDownload) Begin
50662>>>            If      (tQuery.iOutputFormat = C_wqOutputHtml) Move ".html"            to sExt
50665>>>            Else If (tQuery.iOutputFormat = C_wqOutputCSV)  Move ".csv"             to sExt
50669>>>            Else If (tQuery.iOutputFormat = C_wqOutputText) Move ".txt"             to sExt
50673>>>            Else If (tQuery.iOutputFormat = C_wqOutputXML)  Move ".xml"             to sExt
50677>>>            Else                                            Move ""                 to sExt
50679>>>            Move (sTitle - sExt)                                                    to sTitle
50680>>>            Get psDownloadDirectory                                                 to sDir
50681>>>            Move (sDir + "\" + sFile)                                               to sDir
50682>>>            Get CustomDownloadURL of ghoWebResourceManager sDir True sTitle True 0  to sUrl
50683>>>        End
50683>>>>
50683>>>        Else Begin
50684>>>            Get psOutputDirectory                                                   to sDir
50685>>>            Move (sDir + "/" + sFile)                                               to sPath
50686>>>        End
50686>>>>
50686>>>        
50686>>>        If (tQuery.iDestination = C_wqModalWin) Begin
50688>>>            Send PopupOutput of oWqOutputModal Self sPath sTitle
50689>>>        End
50689>>>>
50689>>>        Else If (tQuery.iDestination = C_wqNewTab) Begin
50692>>>            Send NavigateToPage of oWebApp sPath btNewTab
50693>>>        End
50693>>>>
50693>>>        Else If (tQuery.iDestination = C_wqNewWin) Begin
50696>>>            Set NewWindowOption to C_nwMenuBar    True
50697>>>            Set NewWindowOption to C_nwScrollBars True
50698>>>            Set NewWindowOption to C_nwStatusBar  False
50699>>>            Set NewWindowOption to C_nwTitleBar   True
50700>>>            Set NewWindowOption to C_nwToolBar    True
50701>>>            Set NewWindowOption to C_nwResizable  True
50702>>>            Send NavigateNewWindow  of oWebApp sPath 600 400
50703>>>        End
50703>>>>
50703>>>        Else If (tQuery.iDestination = C_wqDownload) Begin
50706>>>            Send DoPopup of oWqDownload Self sUrl sDir
50707>>>        End
50707>>>>
50707>>>        
50707>>>    End_Procedure
50708>>>    
50708>>>    Procedure LoadAndRun String sQueryFile
50711>>>        Integer iChn
50711>>>        Boolean bOK
50711>>>        tValueTree tVT
50711>>>        tValueTree tVT
50711>>>        wqWebQuery tQuery
50711>>>        wqWebQuery tQuery
50711>>>        
50711>>>        Get Seq_New_Channel     to iChn
50712>>>        Direct_Input channel iChn sQueryFile
50714>>>        Move (not(SeqEof)) to bOK
50715>>>
50715>>>        If bOK Begin
50717>>>            Send ReadValueTree of oStructFunctions iChn (&tVT)
50718>>>            ValueTreeDeserializeParameter tVT to tQuery
50719>>>            Close_Input channel iChn
50721>>>            Send Seq_Release_Channel iChn
50722>>>            Set pQuery to tQuery
50723>>>//            Send PopulateUI
50723>>>        End
50723>>>>
50723>>>        Else Begin
50724>>>            Close_Input channel iChn
50726>>>            Send Seq_Release_Channel iChn
50727>>>            Procedure_Return (QueryFileError(Self, sQueryFile))
50728>>>        End
50728>>>>
50728>>>        
50728>>>        Send RunQuery
50729>>>    End_Procedure
50730>>>    
50730>>>    //==========================================================================
50730>>>    //
50730>>>    // Assemble query process:
50730>>>    //
50730>>>    // Assemble Query involves a multi-step process because we have three sets
50730>>>    // of grid data to get back: Fields, Selections and Ordering, which we will
50730>>>    // do by serializing the index segment and print fields into web property
50730>>>    // strings before going onto the next step.
50730>>>    
50730>>>    Function SerializeSegments tWebRow[] ByRef aData Returns String
50733>>>        wqIndexSeg[] aSegs
50733>>>        wqIndexSeg[] aSegs
50734>>>        Integer i
50734>>>        String  sData
50734>>>        
50734>>>        For i from 0 to (SizeOfArray(aData) - 1)
50740>>>>
50740>>>            Move aData[i].aCells[0].sValue to aSegs[i].bBreak
50741>>>            Move aData[i].aCells[1].sValue to aSegs[i].sName
50742>>>            Move aData[i].aCells[2].sValue to aSegs[i].iTable
50743>>>            Move aData[i].aCells[3].sValue to aSegs[i].iField
50744>>>            Move aData[i].aCells[4].sValue to aSegs[i].bUC
50745>>>            Move aData[i].aCells[5].sValue to aSegs[i].bDesc
50746>>>        Loop
50747>>>>
50747>>>        
50747>>>        Get VariantToString of oStructFunctions aSegs to sData
50748>>>        
50748>>>        Function_Return sData
50749>>>    End_Function
50750>>>    
50750>>>    Function DeserializeSegments String sData Returns wqIndexSeg[]
50753>>>        wqIndexSeg[] aSegs
50753>>>        wqIndexSeg[] aSegs
50754>>>        tValueTree tVT
50754>>>        tValueTree tVT
50754>>>
50754>>>        Get StringToValueTree of oStructFunctions sData to tVT
50755>>>        ValueTreeDeserializeParameter tVT to aSegs
50756>>>        Function_Return aSegs
50757>>>    End_Function
50758>>>    
50758>>>    Function SerializeFields tWebRow[] ByRef aData Returns String
50761>>>        wqPrintField[] aFields
50761>>>        wqPrintField[] aFields
50762>>>        Integer i
50762>>>        String  sData
50762>>>        tValueTree tVT
50762>>>        tValueTree tVT
50762>>>
50762>>>        For i from 0 to (SizeOfArray(aData) - 1)
50768>>>>
50768>>>            Get DeSerializeField of ghoWQF aData[i].aCells[3].sValue to aFields[i]
50769>>>            Move aData[i].aCells[0].sValue  to aFields[i].sUserName
50770>>>            Move aData[i].aCells[1].sValue  to aFields[i].bSum
50771>>>            Move aData[i].aCells[2].sValue  to aFields[i].bCR
50772>>>        Loop
50773>>>>
50773>>>        
50773>>>        Get VariantToString of oStructFunctions aFields to sData
50774>>>        
50774>>>        Function_Return sData
50775>>>    End_Function
50776>>>    
50776>>>    Procedure AssembleQuery Integer eOp
50779>>>        Send ProcessDataSet of oSegments eOp
50780>>>    End_Procedure
50781>>>    
50781>>>    Procedure AssembleQuery2 tWebRow[] aData Integer eOp Integer iSelRowIndex
50784>>>        Integer i
50784>>>        String  sData
50784>>>        
50784>>>        Get SerializeSegments (&aData) to sData
50785>>>        WebSet wpsSegmentData to sData
50786>>>        Send ProcessDataSet of oPrintedFields eOp
50787>>>    End_Procedure
50788>>>    
50788>>>    Procedure AssembleQuery3 tWebRow[] ByRef aData Integer eOp Integer iSelRowIndex
50791>>>        String  sData
50791>>>        
50791>>>        Get SerializeFields (&aData) to sData
50792>>>        WebSet wpsFieldsData to sData
50793>>>        Send ProcessDataSet of oSelections eOp
50794>>>    End_Procedure
50795>>>    
50795>>>    Procedure AssembleQuery4 tWebRow[] ByRef aData Integer eOp Integer iSelRowIndex
50798>>>        wqWebQuery tQuery
50798>>>        wqWebQuery tQuery
50798>>>        Integer i iView
50798>>>        String  sData
50798>>>        
50798>>>        // Get the selection data first:
50798>>>        For i from 0 to (SizeOfArray(aData) - 1)
50804>>>>
50804>>>            Move aData[i].aCells[0].sValue      to tQuery.aSelections[i].sUserName
50805>>>            Move aData[i].aCells[1].sValue      to tQuery.aSelections[i].sType
50806>>>            Move aData[i].aCells[2].sValue      to tQuery.aSelections[i].sValue
50807>>>            Move aData[i].aCells[3].sValue      to tQuery.aSelections[i].iTable
50808>>>            Move aData[i].aCells[4].sValue      to tQuery.aSelections[i].iColumn
50809>>>            Move aData[i].aCells[5].sValue      to tQuery.aSelections[i].iType
50810>>>        Loop
50811>>>>
50811>>>        
50811>>>        WebGet wpsFieldsData                    to sData
50812>>>        Get DeserializeFields of ghoWQF sData   to tQuery.aPrintFields
50813>>>        WebGet wpsSegmentData                   to sData
50814>>>        Get DeserializeSegments sData           to tQuery.aSegments
50815>>>        WebGet wphMainTable                     to tQuery.hMainTable
50816>>>        WebGet psValue of oQueryTitle           to tQuery.sTitle
50817>>>        WebGet wpsSelectExpression              to tQuery.sSelectExpression
50818>>>        WebGet psValue of oOrder                to tQuery.iIndex
50819>>>//        WebGet psValue of oSearchOrd            to tQuery.iSearchOrd
50819>>>        WebGet psValue of oTextBefore           to tQuery.sTextBefore
50820>>>        WebGet psValue of oTextAfter            to tQuery.sTextAfter
50821>>>        WebGet psValue of oFontCombo            to tQuery.sTypeface
50822>>>        WebGet psValue of oFontSizeCombo        to tQuery.sFontSize
50823>>>        WebGet psValue of oAltRowHighlight      to tQuery.bHighlightAlt
50824>>>        WebGet psValue of oHighlightColour      to tQuery.sHighlightColour
50825>>>        WebGet psValue of oIncSelections        to tQuery.bPrintSels
50826>>>        WebGet psValue of oTotalsOnly           to tQuery.bTotalsOnly
50827>>>        WebGet psValue of oPrintCount           to tQuery.bPrintCount
50828>>>        WebGet psValue of oTextColour           to tQuery.sTextColour
50829>>>        WebGet psValue of oBGColour             to tQuery.sBGColour
50830>>>        
50830>>>        WebGet psValue of oViewOutput           to iView
50831>>>        
50831>>>        If (iView = C_wqDownloadOutput) Begin
50833>>>            Move   C_wqDownload                 to tQuery.iDestination
50834>>>            WebGet psValue of oOutHTML          to tQuery.iOutputFormat
50835>>>        End
50835>>>>
50835>>>        Else WebGet psValue of oOutModal        to tQuery.iDestination
50837>>>        
50837>>>        WebGet psValue of oColHeads             to tQuery.bColHeads
50838>>>        WebGet psValue of oPrintGenLine         to tQuery.bGeneratedLine
50839>>>        WebGet psValue of oUseSQL               to tQuery.bUseSQL
50840>>>        
50840>>>        Set pQuery to tQuery
50841>>>        
50841>>>        If (eOp = C_wqAssembleSave) Send DoSaveQuery
50844>>>        If (eOp = C_wqAssembleRun)  Send RunQuery
50847>>>    End_Procedure
50848>>>    
50848>>>    Function SerializeQuery Returns String
50851>>>        wqWebQuery tQuery
50851>>>        wqWebQuery tQuery
50851>>>        String  sQuery
50851>>>        
50851>>>        Get pQuery to tQuery
50852>>>        Get VariantToString of oStructFunctions tQuery to sQuery
50853>>>        
50853>>>        Function_Return sQuery
50854>>>    End_Procedure
50855>>>    
50855>>>    Procedure DeserializeQuery String sQuery
50858>>>        wqWebQuery tQuery
50858>>>        wqWebQuery tQuery
50858>>>        tValueTree tVT
50858>>>        tValueTree tVT
50858>>>        Boolean bOK
50858>>>        
50858>>>        Get StringToValueTree of oStructFunctions sQuery to tVT
50859>>>        ValueTreeDeserializeParameter tVT to tQuery
50860>>>        Set pQuery to tQuery
50861>>>    End_Procedure
50862>>>
50862>>>    Procedure RemoveReport String sFile
50865>>>        Boolean bExists
50865>>>        String  sPath sDir
50865>>>        
50865>>>        Move (psAppHtmlPath(phoWorkspace(oApplication)))    to sPath
50866>>>        Get  psOutputDirectory                              to sDir
50867>>>        Move (sPath + "\" + sDir + "\" + sFile)             to sPath
50868>>>
50868>>>        File_Exist sPath bExists
50869>>>        If bExists EraseFile sPath
50872>>>    End_Procedure
50873>>>    
50873>>>    WebPublishProcedure RemoveReport
50874>>>    
50874>>>    Procedure DoneDownload Handle hoObj
50877>>>        String  sFile
50877>>>        Boolean bExists
50877>>>        
50877>>>        WebGet wpsFile of hoObj to sFile
50878>>>        File_Exist sFile bExists
50879>>>        If bExists EraseFile sFile
50882>>>    End_Procedure
50883>>>    
50883>>>    //==========================================================================
50883>>>    
50883>>>    // Here we handle the return call from all modal dialogs, dispatching
50883>>>    // them to the correct method depending on the returned object handle.
50883>>>    Procedure OnCloseModalDialog Handle hoMD
50886>>>        If (hoMD = oWqSelectionOperators) Send SelOpSelected  hoMD
50889>>>        If (hoMD = oWqTableSelection)     Send TableSelected  hoMD
50892>>>        If (hoMD = oWqAddInsEdit)         Send ExprAction     hoMD
50895>>>        If (hoMD = oWqCalcColumn)         Send CalcColReturn  hoMD
50898>>>        If (hoMD = oWqSelectionValues)    WebSet psValue of oSelValue to (ValueSelected(hoMD))
50901>>>        If (hoMD = oWqSelectionRanges)    WebSet psValue of oSelValue to (RangeSelected(hoMD))
50904>>>        If (hoMD = oWqSelectionList)      WebSet psValue of oSelValue to (ListSelected(hoMD))
50907>>>        If (hoMD = oWqExpressionPopup)    Send ExprReturned   hoMD
50910>>>        If (hoMD = oWqAdHocIndex)         Send AdHocDefined   hoMD
50913>>>        If (hoMD = oWqOpenQuery)          Send FileReturned   hoMD
50916>>>        If (hoMD = oWqColourPicker)       Send ColourSelected hoMD
50919>>>        If (hoMD = oWqDownload)           Send DoneDownload   hoMD
50922>>>    End_Procedure
50923>>>    
50923>>>    //==========================================================================
50923>>>    //  End of methods
50923>>>    //==========================================================================
50923>>>    
50923>>>    //==========================================================================
50923>>>    //
50923>>>    //  User interfasce objects (try to keep logic code out of these where 
50923>>>    //  possible)
50923>>>    //
50923>>>    //==========================================================================
50923>>>
50923>>>    Object oWebMainPanel is a cWebPanel
50925>>>        Set piColumnCount to 20
50926>>>        Set pbFillHeight to True
50927>>>        
50927>>>        Object oMainFile is a cWebCombo
50929>>>            Set piColumnSpan            to 15
50930>>>            Set psLabel                 to "Main Table:"
50931>>>            Set peLabelAlign            to alignRight
50932>>>            Set pbServerOnChange        to True
50933>>>            
50933>>>            Procedure OnChange String sNewValue String sOldValue
50936>>>                If (sNewValue <> sOldValue) Send MainTableSelected sNewValue
50939>>>            End_Procedure
50940>>>            
50940>>>            Procedure OnFill
50943>>>                wqTableInfo[] tTabs
50943>>>                wqTableInfo[] tTabs
50944>>>                Integer i
50944>>>                
50944>>>                Send AddComboItem 0 ""
50945>>>                Get TableInfo of ghoWQF to tTabs
50946>>>                
50946>>>                For i from 0 to (SizeOfArray(tTabs) - 1)
50952>>>>
50952>>>                    Send AddComboItem tTabs[i].iNum tTabs[i].sDispName
50953>>>                Loop
50954>>>>
50954>>>                
50954>>>            End_Procedure
50955>>>            
50955>>>        End_Object
50956>>>        
50956>>>        Object oTabSel is a cWebButton
50958>>>            Set piColumnSpan  to 1
50959>>>            Set piColumnIndex to 16
50960>>>            Set piHeight      to 30
50961>>>            Set piWidth       to 24
50962>>>            Set psCaption     to " "
50963>>>            Set psTooltip     to "Table selector"
50964>>>            Set psTextColor   to (psBackgroundColor(Self))
50965>>>            Set psHtmlId      to "wqTabSelButton"
50966>>>        
50966>>>            Procedure OnClick
50969>>>                Send TabListPopup of oWqTableSelection ghoWebQry
50970>>>            End_Procedure
50971>>>            
50971>>>        End_Object
50972>>>
50972>>>        Object oOpenQry is a cWebButton
50974>>>            Set piColumnSpan  to 1
50975>>>            Set piColumnIndex to 17
50976>>>            Set piHeight      to 30
50977>>>            Set piWidth       to 24
50978>>>            Set psCaption     to " "
50979>>>            Set psTooltip     to "Open query definition"
50980>>>            Set psHtmlId      to "wqOpenQueryButton"
50981>>>        
50981>>>            Procedure OnClick
50984>>>                Send OpenQuery
50985>>>            End_Procedure
50986>>>            
50986>>>        End_Object
50987>>>
50987>>>        Object oSaveQry is a cWebButton
50989>>>            Set piColumnSpan  to 1
50990>>>            Set piColumnIndex to 18
50991>>>            Set piHeight      to 30
50992>>>            Set piWidth       to 24
50993>>>            Set psCaption     to " "
50994>>>            Set psTooltip     to "Save query definition"
50995>>>            Set psHtmlId      to "wqSaveQueryButton"
50996>>>            
50996>>>            Procedure OnClick
50999>>>                Send SaveQuery
51000>>>            End_Procedure
51001>>>            
51001>>>        End_Object
51002>>>
51002>>>        Object oNewQry is a cWebButton
51004>>>            Set piColumnSpan  to 1
51005>>>            Set piColumnIndex to 19
51006>>>            Set piHeight      to 30
51007>>>            Set piWidth       to 24
51008>>>            Set psCaption     to " "
51009>>>            Set psTooltip     to "Clear query"
51010>>>            Set psHtmlId      to "wqClearQueryButton"
51011>>>            
51011>>>            Procedure OnClick
51014>>>                Send ClearQuery
51015>>>            End_Procedure  // OnClick
51016>>>            
51016>>>        End_Object
51017>>>
51017>>>        Object oQueryTitle is a cWebForm
51019>>>            Set psCSSClass to "KeyField"
51020>>>            Set piColumnSpan to 15
51021>>>            Set psLabel to "Query Title:"
51022>>>            Set peLabelAlign to alignRight
51023>>>        End_Object
51024>>>
51024>>>        Object oQueryCriteria is a cWebTabContainer
51026>>>            Set pbFillHeight to True
51027>>>            
51027>>>            Object oTablesPage is a cWebTabPage
51029>>>                Set psCaption to "Fields"
51030>>>                Set piColumnCount to 10
51031>>>                
51031>>>                Object oFieldsPanel is a cWebPanel
51033>>>                    Set piHeight to 250
51034>>>                    
51034>>>                    Object oFieldSelect is a cWebPanel
51036>>>                        Set peRegion to prLeft
51037>>>                        Set piWidth  to 300
51038>>>
51038>>>                        Object oTablesList is a cWebList
51040>>>                            Set pbDataAware         to False
51041>>>                            Set piColumnIndex       to 0
51042>>>                            Set piColumnSpan        to 0
51043>>>                            Set pbFillHeight        to True
51044>>>                            Set pbColumnSortable    to False
51045>>>                            
51045>>>                            Object oFieldTables is a cWebColumn
51047>>>                                Set psCaption to "Tables"
51048>>>                            End_Object
51049>>>                            
51049>>>                            Procedure OnManualLoadData tWebRow[] ByRef aTheRows String ByRef sCurrentRowID
51052>>>                                Send CollectRelated of ghoWebQry (&aTheRows)  
51053>>>                            End_Procedure  // OnManualLoadData
51054>>>                            
51054>>>                            Procedure OnChangeCurrentRow String sFromRowID String sToRowID
51057>>>                                Send FieldsTableSelected sToRowID
51058>>>                            End_Procedure  // OnChangeCurrentRow
51059>>>                            
51059>>>                        End_Object
51060>>>        
51060>>>                        Object oColumnsList is a cWebList
51062>>>                            Property Handle  phTable 0
51064>>>                            
51064>>>                            Set pbDataAware         to False
51065>>>                            Set piColumnIndex       to 0
51066>>>                            Set piColumnSpan        to 0
51067>>>                            Set pbFillHeight        to True
51068>>>                            Set pbColumnSortable    to False
51069>>>                            
51069>>>                            Object oFieldsCol is a cWebColumn
51071>>>                                Set psCaption to "Fields"
51072>>>                            End_Object
51073>>>                            
51073>>>                            Procedure OnManualLoadData tWebRow[] ByRef aTheRows String ByRef sCurrentRowID
51076>>>                                Forward Send OnManualLoadData (&aTheRows) (&sCurrentRowID)
51078>>>                                Send CollectColumns of ghoWQF (&aTheRows) (phSelectedTable(ghoWebQry))
51079>>>                            End_Procedure
51080>>>                            
51080>>>                        End_Object
51081>>>
51081>>>                    End_Object
51082>>>                    
51082>>>                    Object oPrintFields is a cWebPanel
51084>>>                        Set peRegion to prCenter
51085>>>                        Set piColumnCount to 30
51086>>>                        
51086>>>                        Object oPrintedFields is a cWebGrid
51088>>>                            Set psLabel             to "Printed Fields:"
51089>>>                            Set peLabelPosition     to lpTop
51090>>>                            Set pbShowLabel         to True
51091>>>                            Set piColumnIndex       to 0
51092>>>                            Set piColumnSpan        to 0
51093>>>                            Set pbFillHeight        to True
51094>>>                            Set pbDataAware         to False
51095>>>                            Set pbOfflineEditing    to True
51096>>>                            Set pbAllowAppendRow    to False
51097>>>                            Set pbAllowInsertRow    to False
51098>>>                            Set pbAllowDeleteRow    to False
51099>>>                            
51099>>>                            Object oFieldCol is a cWebColumn
51101>>>                                Set psCaption           to "Field name"
51102>>>                                Set piWidth             to 120
51103>>>                                Set pbServerOnChange    to True
51104>>>                                
51104>>>                                Procedure OnChange String sNewValue String sOldValue
51107>>>                                    String  sField
51107>>>                                    wqPrintField tField
51107>>>                                    wqPrintField tField
51107>>>                                    
51107>>>                                    WebGet psValue of oFieldData to sField
51108>>>                                    
51108>>>                                    If (sField <> "") Begin
51110>>>                                        Get DeSerializeField of ghoWQF sField to tField
51111>>>                                        Move sNewValue to tField.sUserName
51112>>>                                        Get SerializeField of ghoWQF tField to sField
51113>>>                                        WebSet psValue of oFieldData to sField
51114>>>                                    End
51114>>>>
51114>>>                                    
51114>>>                                End_Procedure
51115>>>                                
51115>>>                            End_Object                                
51116>>>                            
51116>>>                            Object oSumCol is a cWebColumnCheckbox
51118>>>                                Set psCaption           to "Sum"
51119>>>                                Set piWidth             to 12
51120>>>                                Set pbServerOnChange    to True
51121>>>                                
51121>>>                                Procedure OnChange String sNewValue String sOldValue
51124>>>                                    String  sField
51124>>>                                    wqPrintField tField
51124>>>                                    wqPrintField tField
51124>>>                                    
51124>>>                                    WebGet psValue of oFieldData to sField
51125>>>                                    Get DeSerializeField of ghoWQF sField to tField
51126>>>                                    If (tField.iType <> DF_BCD) WebSet psValue to False
51129>>>                                End_Procedure
51130>>>                                
51130>>>                            End_Object                                
51131>>>                            
51131>>>                            Object oCRCol is a cWebColumnCheckbox
51133>>>                                Set psCaption           to "CR"
51134>>>                                Set piWidth             to 12
51135>>>                            End_Object
51136>>>                            
51136>>>                            // Hidden columns:
51136>>>                            Object oFieldData is a cWebColumn
51138>>>                                Set pbRender to False
51139>>>                            End_Object
51140>>>                            
51140>>>                            Procedure OnProcessDataSet tWebRow[] aData Integer eOp Integer iSelectedRowIndex
51143>>>                                If ((eOp = C_wqAssembleSave) or (eOp = C_wqAssembleRun)) ;                                     Send AssembleQuery3 (&aData) eOp iSelectedRowIndex
51146>>>                                Else Send FieldListReturned of ghoWebQry (&aData) eOp iSelectedRowIndex
51148>>>                            End_Procedure
51149>>>                            
51149>>>                            Procedure OnManualLoadData tWebRow[] ByRef aTheRows String ByRef sCurrentRowID
51152>>>                                Send LoadPrintFields of ghoWebQry (&aTheRows) (&sCurrentRowID)
51153>>>                            End_Procedure
51154>>>                            
51154>>>                        End_Object
51155>>>                        
51155>>>                        Object oAddField is a cWebButton
51157>>>                            Set piColumnIndex to 3
51158>>>                            Set piColumnSpan to 4
51159>>>                            Set psCaption to "Add"
51160>>>                        
51160>>>                            Procedure OnClick
51163>>>                                Send AddPrintField True
51164>>>                            End_Procedure
51165>>>                            
51165>>>                        End_Object
51166>>>                        
51166>>>                        Object oInsertField is a cWebButton
51168>>>                            Set piColumnIndex to 7
51169>>>                            Set piColumnSpan to 5
51170>>>                            Set psCaption to "Insert"
51171>>>                        
51171>>>                            Procedure OnClick
51174>>>                                Send AddPrintField False
51175>>>                            End_Procedure
51176>>>                            
51176>>>                        End_Object
51177>>>                        
51177>>>                        Object oDeleteField is a cWebButton
51179>>>                            Set piColumnIndex to 12
51180>>>                            Set piColumnSpan to 5
51181>>>                            Set psCaption to "Delete"
51182>>>                        
51182>>>                            Procedure OnClick
51185>>>                                Send DeletePrintField
51186>>>                            End_Procedure
51187>>>                            
51187>>>                        End_Object
51188>>>                        
51188>>>                        Object oExprnField is a cWebButton
51190>>>                            Set piColumnIndex to 17
51191>>>                            Set piColumnSpan to 6
51192>>>                            Set psCaption to "Expression"
51193>>>                        
51193>>>                            Procedure OnClick
51196>>>                                Send CalcField
51197>>>                            End_Procedure
51198>>>                            
51198>>>                        End_Object
51199>>>                        
51199>>>//                        Object oAdjustField is a cWebButton
51199>>>//                            Set piColumnIndex to 23
51199>>>//                            Set piColumnSpan to 7
51199>>>//                            Set psCaption to "Adjust Below"
51199>>>//                        
51199>>>//                            Procedure OnClick
51199>>>//                            End_Procedure
51199>>>//                            
51199>>>//                        End_Object
51199>>>                        
51199>>>                    End_Object
51200>>>
51200>>>                End_Object
51201>>>                
51201>>>            End_Object
51202>>>            
51202>>>            Object oSelectionPage is a cWebTabPage
51204>>>                Set psCaption to "Selection"
51205>>>                
51205>>>                Object oSelectPanel is a cWebPanel
51207>>>                    Set piHeight to 250
51208>>>                    
51208>>>                    Object oSelectionPanel is a cWebPanel
51210>>>                        Set peRegion to prLeft
51211>>>                        Set piWidth  to 300
51212>>>
51212>>>                        Object oSelTablesList is a cWebList
51214>>>                            Set pbDataAware         to False
51215>>>                            Set piColumnIndex       to 0
51216>>>                            Set piColumnSpan        to 0
51217>>>                            Set pbFillHeight        to True
51218>>>                            Set pbColumnSortable    to False
51219>>>                            
51219>>>                            Object oSelTables is a cWebColumn
51221>>>                                Set psCaption to "Tables"
51222>>>                            End_Object
51223>>>                            
51223>>>                            Procedure OnManualLoadData tWebRow[] ByRef aTheRows String ByRef sCurrentRowID
51226>>>                                Send CollectRelated of ghoWebQry (&aTheRows)  
51227>>>                            End_Procedure
51228>>>                            
51228>>>                            Procedure OnChangeCurrentRow String sFromRowID String sToRowID
51231>>>                                Send SelTableSelected of ghoWebQry sToRowID
51232>>>                            End_Procedure
51233>>>                            
51233>>>                        End_Object
51234>>>        
51234>>>                        Object oSelColumnsList is a cWebList
51236>>>                            Property Handle  phTable 0
51238>>>                            
51238>>>                            Set pbDataAware         to False
51239>>>                            Set piColumnIndex       to 0
51240>>>                            Set piColumnSpan        to 0
51241>>>                            Set pbFillHeight        to True
51242>>>                            Set pbColumnSortable    to False
51243>>>                            
51243>>>                            Object oSelColumns is a cWebColumn
51245>>>                                Set psCaption to "Fields"
51246>>>                            End_Object
51247>>>                            
51247>>>                            Procedure TableSelected Handle hTab
51250>>>                                Set phTable to hTab
51251>>>                                Send GridRefresh
51252>>>                                WebSet psCurrentRowID to 0
51253>>>                            End_Procedure
51254>>>                            
51254>>>                            Procedure OnManualLoadData tWebRow[] ByRef aTheRows String ByRef sCurrentRowID
51257>>>                                Forward Send OnManualLoadData (&aTheRows) (&sCurrentRowID)
51259>>>                                Send CollectColumns of ghoWQF (&aTheRows) (phSelectedTable(ghoWebQry))
51260>>>                            End_Procedure
51261>>>                            
51261>>>                       End_Object
51262>>>
51262>>>                    End_Object
51263>>>                    
51263>>>                    Object oSelectPanel is a cWebPanel
51265>>>                        Set peRegion to prCenter
51266>>>                        Set piColumnCount to 30
51267>>>                        
51267>>>                        Object oSelections is a cWebGrid
51269>>>                            Set piColumnIndex       to 0
51270>>>                            Set piColumnSpan        to 0
51271>>>                            Set pbFillHeight        to True
51272>>>                            Set pbDataAware         to False                            
51273>>>                            Set psLabel             to "Selections:"
51274>>>                            Set peLabelPosition     to lpTop
51275>>>                            Set pbShowLabel         to True
51276>>>                            Set pbOfflineEditing    to True
51277>>>                            Set pbAllowAppendRow    to False
51278>>>                            Set pbAllowInsertRow    to False
51279>>>                            Set pbAllowDeleteRow    to False
51280>>>                            
51280>>>                            Object oSelField is a cWebColumn
51282>>>                                Set psCaption to "Field name"
51283>>>                                Set piWidth   to 60
51284>>>                                Set pbEnabled to False
51285>>>                            End_Object                                
51286>>>                            
51286>>>                            Object oSelType is a cWebColumn
51288>>>                                Set psCaption to "Type"
51289>>>                                Set piWidth   to 15
51290>>>                                Set pbEnabled to False
51291>>>                            End_Object                                
51292>>>                            
51292>>>                            Object oSelValue is a cWebColumn
51294>>>                                Set psCaption to "Value"
51295>>>                                Set piWidth   to 60
51296>>>                                Set pbEnabled to False
51297>>>                            End_Object
51298>>>                            
51298>>>                            Object oSelTabCol is a cWebColumn
51300>>>                                Set pbRender to False
51301>>>                            End_Object
51302>>>                            
51302>>>                            Object oSelColCol is a cWebColumn
51304>>>                                Set pbRender to False
51305>>>                            End_Object
51306>>>                            
51306>>>                            Object oSelDataType is a cWebColumn
51308>>>                                Set pbRender to False
51309>>>                            End_Object
51310>>>                            
51310>>>                            Procedure OnProcessDataSet tWebRow[] aData Integer eOp Integer iSelectedRowIndex
51313>>>                                If ((eOp = C_wqAssembleRun) or (eOp = C_wqAssembleSave)) ;                                     Send AssembleQuery4   of ghoWebQry (&aData) eOp iSelectedRowIndex
51316>>>                                Else Send SelsListReturned of ghoWebQry (&aData) eOp iSelectedRowIndex
51318>>>                            End_Procedure
51319>>>                            
51319>>>                            Procedure OnManualLoadData tWebRow[] ByRef aTheRows String ByRef sCurrentRowID
51322>>>                                Send LoadSelections (&aTheRows) (sCurrentRowID)
51323>>>                            End_Procedure
51324>>>                            
51324>>>                        End_Object
51325>>>                        
51325>>>                        Object oSelAddBtn is a cWebButton
51327>>>                            Set piColumnIndex to 2
51328>>>                            Set piColumnSpan to 4
51329>>>                            Set psCaption to "Add"
51330>>>                        
51330>>>                            Procedure OnClick
51333>>>                                Send AddSelField True
51334>>>                            End_Procedure
51335>>>                            
51335>>>                        End_Object
51336>>>                        
51336>>>                        Object oSelInsertBtn is a cWebButton
51338>>>                            Set piColumnIndex to 6
51339>>>                            Set piColumnSpan to 5
51340>>>                            Set psCaption to "Insert"
51341>>>                        
51341>>>                            Procedure OnClick
51344>>>                                Send AddSelField False
51345>>>                            End_Procedure
51346>>>                            
51346>>>                        End_Object
51347>>>                        
51347>>>                        Object oSelDeleteBtn is a cWebButton
51349>>>                            Set piColumnIndex to 11
51350>>>                            Set piColumnSpan to 5
51351>>>                            Set psCaption to "Delete"
51352>>>                        
51352>>>                            Procedure OnClick
51355>>>                                Send ProcessDataSet of oSelections C_wqDeleteRow
51356>>>                            End_Procedure
51357>>>                            
51357>>>                        End_Object
51358>>>                        
51358>>>                        Object oSelExpressionBtn is a cWebButton
51360>>>                            Set piColumnIndex to 16
51361>>>                            Set piColumnSpan to 6
51362>>>                            Set psCaption to "Expression"
51363>>>                        
51363>>>                            Procedure OnClick
51366>>>                                Send EnterSelExpr
51367>>>                            End_Procedure
51368>>>                            
51368>>>                        End_Object
51369>>>                        
51369>>>                        Object oSelValueBtn is a cWebButton
51371>>>                            Set piColumnIndex to 22
51372>>>                            Set piColumnSpan to 8
51373>>>                            Set psCaption to "Default value"
51374>>>                        
51374>>>                            Procedure OnClick
51377>>>                                Send SelectValue of ghoWebQry
51378>>>                            End_Procedure
51379>>>                            
51379>>>                        End_Object
51380>>>                        
51380>>>                    End_Object
51381>>>                
51381>>>                End_Object
51382>>>                
51382>>>            End_Object
51383>>>            
51383>>>            Object oOrderingPage is a cWebTabPage
51385>>>                Set psCaption to "Ordering"
51386>>>                Set piColumnCount to 9
51387>>>                Set pbServerOnShow to True
51388>>>                
51388>>>                // Work-around for the psValue in oOrdering not getting set properly
51388>>>                //    see: http://support.dataaccess.com/Forums/showthread.php?51906-Setting-selected-value-in-a-cWebCombo                   
51388>>>                Procedure OnShow
51391>>>                    Integer  iIndex
51391>>>                    
51391>>>                    WebGet wpiIndex of ghoWebQry to iIndex
51392>>>                    WebSet psValue  of oOrder    to iIndex
51393>>>                End_Procedure
51394>>>                
51394>>>                Object oOrder is a cWebCombo
51396>>>                    Set piColumnIndex       to 0
51397>>>                    Set piColumnSpan        to 8
51398>>>                    Set psLabel             to "Ordering:"
51399>>>                    Set peLabelAlign        to alignRight
51400>>>                    Set piLabelOffset       to 100
51401>>>                    Set pbServerOnChange    to True
51402>>>                    Set pbServerOnShow      to True
51403>>>                
51403>>>                    Procedure OnChange String sNewValue String sOldValue
51406>>>                        If (sNewValue <> sOldValue) Send IndexSelected of ghoWebQry sNewValue
51409>>>                    End_Procedure  // OnChange
51410>>>                    
51410>>>                    Procedure OnFill
51413>>>                        Integer i j iInds iSegs iFld iFirst
51413>>>                        String  sDesc
51413>>>                        Handle  hTab
51413>>>                        Boolean bRNTab
51413>>>                        
51413>>>                        WebGet wphMainTable of ghoWebQry to hTab
51414>>>                        If not hTab Procedure_Return
51417>>>                        
51417>>>                        Open hTab
51419>>>                        Move 0 to iFirst
51420>>>                        
51420>>>                        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTab to iInds
51423>>>                        Get_Attribute DF_FILE_RECNUM_TABLE      of hTab to bRNTab
51426>>>                        
51426>>>                        For i from 1 to iInds
51432>>>>
51432>>>                            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTab i to iSegs
51435>>>                            
51435>>>                            Move "" to sDesc
51436>>>                        
51436>>>                            For j from 1 to iSegs
51442>>>>
51442>>>                                Get_Attribute DF_INDEX_SEGMENT_FIELD of hTab i j    to iFld
51445>>>                                If (j > 1) Move (sDesc + ", ")                      to sDesc
51448>>>                                Move (sDesc + NiceFieldName(ghoWQF, hTab, iFld))    to sDesc
51449>>>                            Loop
51450>>>>
51450>>>                            
51450>>>                            If (Length(sDesc)) Begin
51452>>>                                Send AddComboItem i sDesc
51453>>>                                If not iFirst Move i to iFirst
51456>>>                            End
51456>>>>
51456>>>                            
51456>>>                        Loop
51457>>>>
51457>>>                        
51457>>>                        If bRNTab Send AddComboItem i "Recnum"
51460>>>                        Send AddComboItem -1 "Ad hoc index"
51461>>>                        WebSet psValue               to iFirst
51462>>>                        WebSet wpiIndex of ghoWebQry to iFirst
51463>>>//                        WebSet psValue of oSearchOrd to iFirst
51463>>>                    End_Procedure
51464>>>                    
51464>>>                End_Object
51465>>>
51465>>>                Object oAdHocButton is a cWebButton
51467>>>                    Set piColumnSpan  to 0
51468>>>                    Set piColumnIndex to 8
51469>>>                    Set piColumnSpan  to 1
51470>>>                    Set psCaption     to "Ad hoc"
51471>>>                    Set pbEnabled     to False
51472>>>                
51472>>>                    Procedure OnClick
51475>>>                        Send SpecAdHoc
51476>>>                    End_Procedure
51477>>>                    
51477>>>                End_Object
51478>>>                
51478>>>                Object oSegments is a cWebGrid
51480>>>                    Set piColumnIndex       to 2
51481>>>                    Set piColumnSpan        to 5
51482>>>                    Set pbFillHeight        to True
51483>>>                    Set pbDataAware         to False
51484>>>                    Set pbOfflineEditing    to True
51485>>>                    Set pbAllowAppendRow    to False
51486>>>                    Set pbAllowInsertRow    to False
51487>>>                    Set pbAllowDeleteRow    to False
51488>>>                    
51488>>>                    Object oIdxBreakCol is a cWebColumnCheckbox
51490>>>                        Set psCaption to "Break"
51491>>>                        Set piWidth to 15
51492>>>                    End_Object
51493>>>                    
51493>>>                    Object oIdxDescCol is a cWebColumn
51495>>>                        Set psCaption to "Field name"
51496>>>                        Set piWidth to 100
51497>>>//                        Set pbEnabled to False
51497>>>                    End_Object
51498>>>                    
51498>>>                    Object oIdxTableCol is a cWebColumn
51500>>>                        Set pbRender to False
51501>>>                    End_Object
51502>>>                    
51502>>>                    Object oIdxFieldCol is a cWebColumn
51504>>>                        Set pbRender to False
51505>>>                    End_Object
51506>>>                    
51506>>>                    Object oIdxUCCol is a cWebColumn
51508>>>                        Set pbRender to False
51509>>>                    End_Object
51510>>>                    
51510>>>                    Object oIdxRevCol is a cWebColumn
51512>>>                        Set pbRender to False
51513>>>                    End_Object
51514>>>                    
51514>>>                    Procedure OnManualLoadData tWebRow[] ByRef aTheRows String ByRef sCurrentRowID
51517>>>                        Send LoadSegments (&aTheRows) (&sCurrentRowID)
51518>>>                    End_Procedure
51519>>>                    
51519>>>                    Procedure OnProcessDataSet tWebRow[] aData Integer eOp Integer iSelRowIndex
51522>>>                        If ((eOp = C_wqAssembleSave) or (eOp = C_wqAssembleRun)) ;                             Send AssembleQuery2 of ghoWebQry (&aData) eOp iSelRowIndex
51525>>>                        Else If (eOp = C_wqGetIndexInfo) Send IndexDataReceived of ghoWebQry (&aData) eOp iSelRowIndex
51529>>>                    End_Procedure
51530>>>                    
51530>>>                End_Object
51531>>>
51531>>>//                Object oWebSpacer1 is a cWebSpacer
51531>>>//                    Set piHeight to 10
51531>>>//                End_Object
51531>>>//                
51531>>>//                Object oSearchOrd is a cWebCombo
51531>>>//                    Set piColumnSpan  to 8
51531>>>//                    Set psLabel       to "Search order:"
51531>>>//                    Set peLabelAlign  to alignRight
51531>>>//                    Set piLabelOffset to 100
51531>>>//                    Set pbEnabled     to False
51531>>>//                    
51531>>>//                    Procedure OnFill
51531>>>//                        Integer i j iInds iSegs iFld
51531>>>//                        String  sDesc
51531>>>//                        Handle  hTab
51531>>>//                        Boolean bRNTab
51531>>>//                        
51531>>>//                        WebGet wphMainTable of ghoWebQry to hTab
51531>>>//                        If not hTab Procedure_Return
51531>>>//                        
51531>>>//                        Open hTab
51531>>>//                        
51531>>>//                        Get_Attribute DF_FILE_LAST_INDEX_NUMBER of hTab to iInds
51531>>>//                        Get_Attribute DF_FILE_RECNUM_TABLE      of hTab to bRNTab
51531>>>//                        If bRNTab Send AddComboItem 0 "Recnum"
51531>>>//                        
51531>>>//                        For i from 1 to iInds
51531>>>//                            Get_Attribute DF_INDEX_NUMBER_SEGMENTS of hTab i to iSegs
51531>>>//                            Move "" to sDesc
51531>>>//                            
51531>>>//                            For j from 1 to iSegs
51531>>>//                                Get_Attribute DF_INDEX_SEGMENT_FIELD of hTab i j    to iFld
51531>>>//                                If (j > 1) Move (sDesc + ", ")                      to sDesc
51531>>>//                                Move (sDesc + NiceFieldName(ghoWQF, hTab, iFld))    to sDesc
51531>>>//                            Loop
51531>>>//                            
51531>>>//                            If (Length(sDesc)) Send AddComboItem i sDesc
51531>>>//                        Loop
51531>>>//                        
51531>>>//                    End_Procedure  // OnFill
51531>>>//                    
51531>>>//                End_Object  // oSearchOrd
51531>>>                
51531>>>            End_Object
51532>>>            
51532>>>            Object oTextsPage is a cWebTabPage
51534>>>                Set psCaption to "Texts"
51535>>>                Set piColumnCount to 10
51536>>>                
51536>>>                Object oLineBreakNote is a cWebLabel
51538>>>                    Set piColumnSpan to 0
51539>>>                    Set psCaption to "(Note: To insert line-breaks in the texts, use Shift-Enter)"
51540>>>                    Set psTextColor to "blue"
51541>>>                    Set peAlign to alignCenter
51542>>>                End_Object
51543>>>                
51543>>>                Object oTextBefore is a cWebEdit
51545>>>                    Set piColumnSpan to 0
51546>>>                    Set psLabel to "Before report:"
51547>>>                    Set peLabelAlign to alignRight
51548>>>                    Set piLabelOffset to 90
51549>>>                    Set pbFillHeight to True
51550>>>                    Set piHeight to 50
51551>>>                End_Object
51552>>>                
51552>>>                Object oTextAfter is a cWebEdit
51554>>>                    Set piColumnSpan to 0
51555>>>                    Set psLabel to "After report:"
51556>>>                    Set peLabelAlign to alignRight
51557>>>                    Set piLabelOffset to 90
51558>>>                    Set pbFillHeight to True
51559>>>                    Set piHeight to 50
51560>>>                End_Object
51561>>>                
51561>>>            End_Object
51562>>>            
51562>>>            Object oOutputPage is a cWebTabPage
51564>>>                Set psCaption to "Output"
51565>>>                Set piColumnCount to 20
51566>>>
51566>>>                Object oFontCombo is a cWebCombo
51568>>>                    Set piColumnIndex to 0
51569>>>                    Set piColumnSpan to 9
51570>>>                    Set psLabel to "Font: "
51571>>>                    Set piLabelOffset to 110
51572>>>                    Set peLabelAlign to alignRight
51573>>>                    
51573>>>                    Procedure OnFill
51576>>>                        Send AddComboItem "Arial, Helvetica, sans-serif"                         "Arial"
51577>>>                        Send AddComboItem "'Arial Black', Gadget, sans-serif"                    "Arial Black"
51578>>>                        Send AddComboItem "'Courier New', Courier, monospace"                    "Courier New"
51579>>>                        Send AddComboItem "Impact, Charcoal, sans-serif"                         "Impact"
51580>>>                        Send AddComboItem "'Lucinda Console', Monaco, monospace"                 "Lucinda Console"
51581>>>                        Send AddComboItem "'Lucinda Sans Unicode', 'Lucinda Grande', sans-serif" "Lucinda Sans"
51582>>>                        Send AddComboItem "'Palatino Linotype', 'Book Antiqua', Palation, serif" "Palatino Linotype"
51583>>>                        Send AddComboItem "Tahoma, Geneva, sans-serif"                           "Tahoma"
51584>>>                        Send AddComboItem "'Times New Roman', Times, serif"                      "Times New Roman"
51585>>>                        Send AddComboItem "'Trebuchet MS', Helvetica, sans-serif"                "Trebuchet"
51586>>>                        Send AddComboItem "Verdana, Geneva, sans-serif"                          "Verdana"
51587>>>                        
51587>>>                        WebSet psValue to "Ariel, Helvetica, sans-serif"
51588>>>                    End_Procedure
51589>>>                    
51589>>>                End_Object
51590>>>
51590>>>                Object oFontSizeCombo is a cWebCombo
51592>>>                    Set piColumnIndex to 10
51593>>>                    Set piColumnSpan to 3
51594>>>                    Set pbShowLabel to False
51595>>>                    
51595>>>                    Procedure OnFill
51598>>>                        Send AddComboItem "xx-small" "xx-small"
51599>>>                        Send AddComboItem "x-small"  "x-small"
51600>>>                        Send AddComboItem "small"    "small"
51601>>>                        Send AddComboItem "medium"   "medium"
51602>>>                        Send AddComboItem "large"    "large"
51603>>>                        Send AddComboItem "x-large"  "x-large"
51604>>>                        Send AddComboItem "xx-large" "xx-large"
51605>>>                        
51605>>>                        WebSet psValue to "medium"
51606>>>                    End_Procedure
51607>>>                    
51607>>>                End_Object
51608>>>                
51608>>>                Object oIncSelections is a cWebCheckbox
51610>>>                    Set piColumnSpan to 0
51611>>>                    Set piColumnIndex to 3
51612>>>                    Set psCaption to "Include selection criteria in printed report"
51613>>>                End_Object
51614>>>
51614>>>                Object oTotalsOnly is a cWebCheckbox
51616>>>                    Set piColumnSpan to 0
51617>>>                    Set piColumnIndex to 3
51618>>>                    Set psCaption to "Print totals only"
51619>>>                End_Object
51620>>>                
51620>>>                Object oPrintCount is a cWebCheckbox
51622>>>                    Set piColumnSpan  to 0
51623>>>                    Set piColumnIndex to 3
51624>>>                    Set psCaption     to "Print record count"
51625>>>                    Set psValue       to True
51626>>>                End_Object
51627>>>                
51627>>>                Object oPrintGenLine is a cWebCheckbox
51629>>>                    Set piColumnSpan  to 7
51630>>>                    Set piColumnIndex to 3
51631>>>                    Set psCaption     to "Print generated date/time"
51632>>>                    Set psValue       to True
51633>>>                End_Object
51634>>>
51634>>>                Object oUseSQL is a cWebCheckbox
51636>>>                    Set piColumnSpan  to 5
51637>>>                    Set piColumnIndex to 10
51638>>>                    Set psCaption     to "Use SQL"
51639>>>                    Set psValue       to (pbUseSqlDefault(ghoWebQry))
51640>>>                End_Object
51641>>>                
51641>>>                Object oTextColour is a cWebForm
51643>>>                    Set piColumnIndex    to 0
51644>>>                    Set piColumnSpan     to 6
51645>>>                    Set psLabel          to "Text colour:"
51646>>>                    Set peLabelAlign     to alignRight
51647>>>                    Set pbPromptButton   to True
51648>>>                    Set pbServerOnPrompt to True
51649>>>                    Set psValue          to "black"
51650>>>                    Set piLabelOffset    to 110
51651>>>                    Set pbServerOnChange to True
51652>>>                    
51652>>>                    Procedure OnPrompt
51655>>>                        String sVal
51655>>>                        
51655>>>                        WebGet psValue to sVal
51656>>>                        Send ColourPopup of oWqColourPicker ghoWebQry sVal Self
51657>>>                    End_Procedure
51658>>>                    
51658>>>                    Procedure OnChange String sNewValue String sOldValue
51661>>>                        WebSet psBackgroundColor of oTextCol to sNewValue
51662>>>                    End_Procedure
51663>>>                    
51663>>>                End_Object
51664>>>
51664>>>                Object oTextCol is a cWebButton
51666>>>                    Set psCaption to " "
51667>>>                    Set pbShowBorder to False
51668>>>                    Set piColumnIndex to 6
51669>>>                    Set piColumnSpan  to 1
51670>>>                    Set psBackgroundColor to "black"
51671>>>                    
51671>>>                    Procedure OnClick
51674>>>                        Send OnPrompt of oTextColour
51675>>>                    End_Procedure  // OnClick
51676>>>                    
51676>>>                End_Object
51677>>>
51677>>>                Object oBGColour is a cWebForm
51679>>>                    Set piColumnIndex    to 9
51680>>>                    Set piColumnSpan     to 6
51681>>>                    Set psLabel          to "Background colour:"
51682>>>                    Set peLabelAlign     to alignRight
51683>>>                    Set pbPromptButton   to True
51684>>>                    Set pbServerOnPrompt to True
51685>>>                    Set psValue          to "white"
51686>>>                    Set pbServerOnChange to True
51687>>>                    
51687>>>                    Procedure OnPrompt
51690>>>                        String sVal
51690>>>                        
51690>>>                        WebGet psValue to sVal
51691>>>                        Send ColourPopup of oWqColourPicker ghoWebQry sVal Self
51692>>>                    End_Procedure
51693>>>                    
51693>>>                    Procedure OnChange String sNewValue String sOldValue
51696>>>                        WebSet psBackgroundColor of oBGCol to sNewValue
51697>>>                    End_Procedure
51698>>>                    
51698>>>                End_Object
51699>>>
51699>>>                Object oBGCol is a cWebButton
51701>>>                    Set psCaption to " "
51702>>>                    Set pbShowBorder to True
51703>>>                    Set piColumnIndex to 15
51704>>>                    Set piColumnSpan  to 1
51705>>>                    Set psBackgroundColor to "white"
51706>>>                    
51706>>>                    Procedure OnClick
51709>>>                        Send OnPrompt of oBGColour
51710>>>                    End_Procedure
51711>>>                    
51711>>>                End_Object
51712>>>
51712>>>                Object oAltRowHighlight is a cWebCheckbox
51714>>>                    Set piColumnIndex    to 3
51715>>>                    Set piColumnSpan     to 6
51716>>>                    Set psCaption        to "Use alternate row highlighting"
51717>>>                    Set pbServerOnChange to True
51718>>>                    Set psValue          to True
51719>>>                    
51719>>>                    Procedure OnChange
51722>>>                        Boolean bOn
51722>>>                        
51722>>>                        WebGet psValue to bOn
51723>>>                        WebSet pbEnabled of oHighlightColour to bOn
51724>>>                    End_Procedure
51725>>>                    
51725>>>                End_Object
51726>>>
51726>>>                Object oHighlightColour is a cWebForm
51728>>>                    Set piColumnIndex    to 9
51729>>>                    Set piColumnSpan     to 6
51730>>>                    Set psLabel          to "Highlight colour:"
51731>>>                    Set peLabelAlign     to alignRight
51732>>>                    Set pbPromptButton   to True
51733>>>                    Set pbServerOnPrompt to True
51734>>>                    Set psValue          to "#AAFFFF"
51735>>>                    Set pbServerOnChange to True
51736>>>                    
51736>>>                    Procedure OnPrompt
51739>>>                        String sVal
51739>>>                        
51739>>>                        WebGet psValue to sVal
51740>>>                        Send ColourPopup of oWqColourPicker ghoWebQry sVal Self
51741>>>                    End_Procedure
51742>>>                    
51742>>>                    Procedure OnChange String sNewValue String sOldValue
51745>>>                        WebSet psBackgroundColor of oHLCol to sNewValue
51746>>>                    End_Procedure
51747>>>                    
51747>>>                End_Object
51748>>>
51748>>>                Object oHLCol is a cWebButton
51750>>>                    Set psCaption to " "
51751>>>                    Set pbShowBorder to True
51752>>>                    Set piColumnIndex to 15
51753>>>                    Set piColumnSpan  to 1
51754>>>                    Set psBackgroundColor to "#AAFFFF"
51755>>>                    
51755>>>                    Procedure OnClick
51758>>>                        Send OnPrompt of oHighlightColour
51759>>>                    End_Procedure
51760>>>                    
51760>>>                End_Object
51761>>>                
51761>>>                Object oViewOutput is a cWebRadio
51763>>>                    Set piColumnIndex to 3
51764>>>                    Set piColumnSpan  to 6
51765>>>                    Set psCaption to "View output in browser"
51766>>>                    Set psRadioValue to C_wqViewOutput
51767>>>                    Set pbServerOnChange to True
51768>>>                    Set psGroupName to "Output"
51769>>>                    Send SetSelected
51770>>>                    
51770>>>                    Procedure OnChange String sNewValue String sOldValue
51773>>>                        Send ChangeOutput sNewValue
51774>>>                    End_Procedure
51775>>>                    
51775>>>                End_Object
51776>>>                
51776>>>                Object oDownloadOutput is a cWebRadio
51778>>>                    Set piColumnIndex to 9
51779>>>                    Set piColumnSpan  to 5
51780>>>                    Set psCaption to "Download output to file"
51781>>>                    Set psRadioValue to C_wqDownloadOutput
51782>>>                    Set psGroupName to "Output"
51783>>>                End_Object
51784>>>
51784>>>                Object oOutputLab is a cWebLabel
51786>>>                    Set piColumnIndex to 1
51787>>>                    Set piColumnSpan  to 4
51788>>>                    Set psCaption to "Output destination: "
51789>>>                End_Object
51790>>>
51790>>>                Object oOutModal is a cWebRadio
51792>>>                    Set piColumnIndex to 5
51793>>>                    Set piColumnSpan  to 4
51794>>>                    Set psCaption to "Pop-up window"
51795>>>                    Set psRadioValue to C_wqModalWin
51796>>>                    Set psGroupName to "Destination"
51797>>>                End_Object
51798>>>                
51798>>>                Object oOutTab is a cWebRadio
51800>>>                    Set piColumnIndex to 9
51801>>>                    Set piColumnSpan  to 4
51802>>>                    Set psCaption to "New browser tab"
51803>>>                    Set psRadioValue to C_wqNewTab
51804>>>                    Set psGroupName to "Destination"
51805>>>                End_Object
51806>>>                
51806>>>                Object oOutWin is a cWebRadio
51808>>>                    Set piColumnIndex to 13
51809>>>                    Set piColumnSpan  to 5
51810>>>                    Set psCaption to "New browser window"
51811>>>                    Set psRadioValue to C_wqNewWin
51812>>>                    Set psGroupName to "Destination"
51813>>>                End_Object
51814>>>
51814>>>                Object oNewWarning is a cWebLabel
51816>>>                    Set piColumnIndex to 9
51817>>>                    Set piColumnSpan to 0
51818>>>                    Set psCaption to "Note: a new browser tab or window may be blocked by your browser settings or popup blocker - you should adjust them accordingly"
51819>>>                    Set psTextColor to "blue"
51820>>>                End_Object
51821>>>                
51821>>>                Object oLabFormat is a cWebLabel
51823>>>                    Set piColumnIndex to 1
51824>>>                    Set piColumnSpan  to 4
51825>>>                    Set psCaption to "Download format:"
51826>>>                    Set pbRender to False
51827>>>                End_Object
51828>>>
51828>>>                Object oOutHTML is a cWebRadio
51830>>>                    Set piColumnIndex to 5
51831>>>                    Set piColumnSpan  to 3
51832>>>                    Set psCaption to "HTML"
51833>>>                    Set psRadioValue to C_wqOutputHtml
51834>>>                    Set psGroupName to "Format"
51835>>>                    Set pbRender to False
51836>>>                    Set pbServerOnChange to True
51837>>>                    
51837>>>                    Procedure OnChange String sNewValue String sOldValue
51840>>>                        Send ChangeFormat sNewValue
51841>>>                    End_Procedure
51842>>>                    
51842>>>                End_Object
51843>>>                
51843>>>                Object oOutText is a cWebRadio
51845>>>                    Set piColumnIndex to 8
51846>>>                    Set piColumnSpan  to 3
51847>>>                    Set psCaption to "Text"
51848>>>                    Set psRadioValue to C_wqOutputText
51849>>>                    Set psGroupName to "Format"
51850>>>                    Set pbRender to False
51851>>>                End_Object
51852>>>                
51852>>>                Object oOutCSV is a cWebRadio
51854>>>                    Set piColumnIndex to 11
51855>>>                    Set piColumnSpan  to 3
51856>>>                    Set psCaption to "CSV"
51857>>>                    Set psRadioValue to C_wqOutputCSV
51858>>>                    Set psGroupName to "Format"
51859>>>                    Set pbRender to False
51860>>>                End_Object
51861>>>                
51861>>>                Object oOutXML is a cWebRadio
51863>>>                    Set piColumnIndex to 14
51864>>>                    Set piColumnSpan  to 3
51865>>>                    Set psCaption to "XML"
51866>>>                    Set psRadioValue to C_wqOutputXML
51867>>>                    Set psGroupName to "Format"
51868>>>                    Set pbRender to False
51869>>>                End_Object
51870>>>
51870>>>                Object oColHeads is a cWebCheckbox
51872>>>                    Set piColumnIndex to 11
51873>>>                    Set piColumnSpan to 4
51874>>>                    Set psCaption to "Include column headers in CSV"
51875>>>                    Set pbRender to False
51876>>>                    Set pbEnabled to False
51877>>>                End_Object
51878>>>
51878>>>            End_Object
51879>>>
51879>>>        End_Object
51880>>>
51880>>>        Object oRunButton is a cWebButton
51882>>>            Set piColumnSpan to 2
51883>>>            Set piColumnIndex to 16
51884>>>            Set psCaption to "Run"
51885>>>            Set pbShowWaitDialog to True
51886>>>//            Set psWaitMessage to "Generating Report"
51886>>>            Set pbEnabled to False
51887>>>            
51887>>>            Procedure OnClick
51890>>>                Send AssembleQuery C_wqAssembleRun
51891>>>            End_Procedure
51892>>>            
51892>>>            Procedure OnLoad
51895>>>                Forward Send OnLoad
51897>>>                
51897>>>                Send SetActionMode (RefProc(OnClick)) scModeProgress "Processing report - please wait...."
51898>>>            End_Procedure
51899>>>            
51899>>>        End_Object
51900>>>
51900>>>        Object oCloseButton is a cWebButton
51902>>>            Set piColumnSpan to 2
51903>>>            Set piColumnIndex to 18
51904>>>            Set psCaption to "Close"
51905>>>        
51905>>>            Procedure OnClick
51908>>>                Send Hide
51909>>>            End_Procedure
51910>>>            
51910>>>        End_Object
51911>>>        
51911>>>    End_Object
51912>>>    
51912>>>End_Object
51913>
51913>    // This allows raw HTML output in reports, which permits interesting
51913>    // effects... but you may not want that.  It is false by default.
51913>    Set pbAllowRawOutput of oWebQuery to True
51914>    
51914>    // Fields (columns) can be excluded thus:
51914>    Send ExcludeField of ghoWebQry File_Field WebAppUser.Password
51915>    // Obviously we can't have the users seeing all the passwords!    
51915>    // The tables must be opened before such use, but WebAppUser will be
51915>    // opened by the WebApp itself.
51915>
51915>    // Tables can also be excluded (although this will break any relational
51915>    // chains which pass through them). Tables must be opened before these
51915>    // exclusions on them or their columns, otherwise errors will result.
51915> 
51915>    // The WebAppSession will automatically be open:
51915>    Send ExcludeTable of ghoWebQry WebAppSession.File_Number
51916>    // It is a VERY good idea to exclude this table since reading from it
51916>    // will cause a session timeout error!
51916>
51916>    // The OrderHea table needs to be opened before we can exclude it:
51916>    // Open OrderHea
51916>    // Send ExcludeTable of ghoWebQry OrderHea.File_Number
51916>    
51916>    // Setting pbUseSqlDefault will determine whether the "Use SQL" checkbox
51916>    // on the Output tab is checked by default.
51916>    // Set pbUseSqlDefault of oWebQuery to True
51916>End_Object
51917>
51917>Send StartWebApp of oWebApp
51918>
Summary
Memory Available: 2147483647
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 29589
Total Resources: 0
Total Commands : 51917
Total Windows  : 1
Total Pages    : 1
Static Data    : 662879
Message area   : 306192
Total Blocks   : 20952
